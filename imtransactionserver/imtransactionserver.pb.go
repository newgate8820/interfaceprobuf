// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imtransactionserver/imtransactionserver.proto

/*
Package imstransactionserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/imtransactionserver/imtransactionserver.proto

It has these top-level messages:

	UserPrivate
	DivideMultiSigReq
	DivideMultiSigRsp
	CheckRawTransactionDoneRsp
	GetAddressBalanceReq
	GetAddressBalanceRsp
	CheckRawTransactionDoneReq
	SendRawTransactionReq
	SendRawTransactionRsp
	GetRawTransactionFeeReq
	GetRawTransactionFeeRsp
	PubPrvKeyInfo
	AddressInfo
	CreateWalletAddressReq
	CreateWalletAddressRsp
	CreateBtcTypeMultiSigAddressReq
	CreateBtcTypeMultiSigAddressRsp
	CreateEthTypeMultiSigAddressReq
	CreateEthTypeMultiSigAddressRsp
	EncryPrvKeyInfo
	SendBtcTypeMultiSigTransactionReq
	SendEthTypeMultiSigTransactionReq
	SendMultiSigTransactionRsp
*/
package imstransactionserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 數字貨幣類型
type DigtialType int32

const (
	DigtialType_BTC  DigtialType = 0
	DigtialType_LTC  DigtialType = 1
	DigtialType_ETH  DigtialType = 2
	DigtialType_USDT DigtialType = 3
)

var DigtialType_name = map[int32]string{
	0: "BTC",
	1: "LTC",
	2: "ETH",
	3: "USDT",
}
var DigtialType_value = map[string]int32{
	"BTC":  0,
	"LTC":  1,
	"ETH":  2,
	"USDT": 3,
}

func (x DigtialType) String() string {
	return proto.EnumName(DigtialType_name, int32(x))
}
func (DigtialType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{0}
}

// 數字貨幣類型
type ErrorCode int32

const (
	ErrorCode_SUCCESS               ErrorCode = 0
	ErrorCode_FAILED                ErrorCode = 1
	ErrorCode_INSUFFICIENT          ErrorCode = 2
	ErrorCode_TRANSACTION_NOT_EXIST ErrorCode = 3
	ErrorCode_INSUFFICIENT_TRANSFEE ErrorCode = 4
	ErrorCode_INVALID_ADDRESS       ErrorCode = 5
)

var ErrorCode_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED",
	2: "INSUFFICIENT",
	3: "TRANSACTION_NOT_EXIST",
	4: "INSUFFICIENT_TRANSFEE",
	5: "INVALID_ADDRESS",
}
var ErrorCode_value = map[string]int32{
	"SUCCESS":               0,
	"FAILED":                1,
	"INSUFFICIENT":          2,
	"TRANSACTION_NOT_EXIST": 3,
	"INSUFFICIENT_TRANSFEE": 4,
	"INVALID_ADDRESS":       5,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorImtransactionserver, []int{1} }

type UserPrivate struct {
	Address   string `protobuf:"bytes,1,opt,name=Address,proto3" json:"Address,omitempty"`
	EncryPriv string `protobuf:"bytes,2,opt,name=EncryPriv,proto3" json:"EncryPriv,omitempty"`
}

func (m *UserPrivate) Reset()                    { *m = UserPrivate{} }
func (m *UserPrivate) String() string            { return proto.CompactTextString(m) }
func (*UserPrivate) ProtoMessage()               {}
func (*UserPrivate) Descriptor() ([]byte, []int) { return fileDescriptorImtransactionserver, []int{0} }

func (m *UserPrivate) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *UserPrivate) GetEncryPriv() string {
	if m != nil {
		return m.EncryPriv
	}
	return ""
}

// 获取此次交易手续费請求
type DivideMultiSigReq struct {
	DivideId        int32          `protobuf:"varint,1,opt,name=DivideId,proto3" json:"DivideId,omitempty"`
	CurrencyId      int32          `protobuf:"varint,2,opt,name=CurrencyId,proto3" json:"CurrencyId,omitempty"`
	FromAddress     string         `protobuf:"bytes,3,opt,name=FromAddress,proto3" json:"FromAddress,omitempty"`
	ToWalletType    int32          `protobuf:"varint,4,opt,name=ToWalletType,proto3" json:"ToWalletType,omitempty"`
	ToAddress       string         `protobuf:"bytes,5,opt,name=ToAddress,proto3" json:"ToAddress,omitempty"`
	Amount          string         `protobuf:"bytes,6,opt,name=Amount,proto3" json:"Amount,omitempty"`
	CreateTimestamp int32          `protobuf:"varint,7,opt,name=CreateTimestamp,proto3" json:"CreateTimestamp,omitempty"`
	Signs           []*UserPrivate `protobuf:"bytes,8,rep,name=Signs" json:"Signs,omitempty"`
	M               int32          `protobuf:"varint,9,opt,name=M,proto3" json:"M,omitempty"`
}

func (m *DivideMultiSigReq) Reset()         { *m = DivideMultiSigReq{} }
func (m *DivideMultiSigReq) String() string { return proto.CompactTextString(m) }
func (*DivideMultiSigReq) ProtoMessage()    {}
func (*DivideMultiSigReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{1}
}

func (m *DivideMultiSigReq) GetDivideId() int32 {
	if m != nil {
		return m.DivideId
	}
	return 0
}

func (m *DivideMultiSigReq) GetCurrencyId() int32 {
	if m != nil {
		return m.CurrencyId
	}
	return 0
}

func (m *DivideMultiSigReq) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *DivideMultiSigReq) GetToWalletType() int32 {
	if m != nil {
		return m.ToWalletType
	}
	return 0
}

func (m *DivideMultiSigReq) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

func (m *DivideMultiSigReq) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *DivideMultiSigReq) GetCreateTimestamp() int32 {
	if m != nil {
		return m.CreateTimestamp
	}
	return 0
}

func (m *DivideMultiSigReq) GetSigns() []*UserPrivate {
	if m != nil {
		return m.Signs
	}
	return nil
}

func (m *DivideMultiSigReq) GetM() int32 {
	if m != nil {
		return m.M
	}
	return 0
}

// 获取此次交易手续费返回
type DivideMultiSigRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	TxId    string    `protobuf:"bytes,2,opt,name=TxId,proto3" json:"TxId,omitempty"`
}

func (m *DivideMultiSigRsp) Reset()         { *m = DivideMultiSigRsp{} }
func (m *DivideMultiSigRsp) String() string { return proto.CompactTextString(m) }
func (*DivideMultiSigRsp) ProtoMessage()    {}
func (*DivideMultiSigRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{2}
}

func (m *DivideMultiSigRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *DivideMultiSigRsp) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type CheckRawTransactionDoneRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	IsDone  bool      `protobuf:"varint,2,opt,name=isDone,proto3" json:"isDone,omitempty"`
}

func (m *CheckRawTransactionDoneRsp) Reset()         { *m = CheckRawTransactionDoneRsp{} }
func (m *CheckRawTransactionDoneRsp) String() string { return proto.CompactTextString(m) }
func (*CheckRawTransactionDoneRsp) ProtoMessage()    {}
func (*CheckRawTransactionDoneRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{3}
}

func (m *CheckRawTransactionDoneRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *CheckRawTransactionDoneRsp) GetIsDone() bool {
	if m != nil {
		return m.IsDone
	}
	return false
}

// 获取地址余额
type GetAddressBalanceReq struct {
	DigType DigtialType `protobuf:"varint,1,opt,name=DigType,proto3,enum=imstransactionserver.DigtialType" json:"DigType,omitempty"`
	Address string      `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *GetAddressBalanceReq) Reset()         { *m = GetAddressBalanceReq{} }
func (m *GetAddressBalanceReq) String() string { return proto.CompactTextString(m) }
func (*GetAddressBalanceReq) ProtoMessage()    {}
func (*GetAddressBalanceReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{4}
}

func (m *GetAddressBalanceReq) GetDigType() DigtialType {
	if m != nil {
		return m.DigType
	}
	return DigtialType_BTC
}

func (m *GetAddressBalanceReq) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetAddressBalanceRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	Bal     string    `protobuf:"bytes,2,opt,name=bal,proto3" json:"bal,omitempty"`
}

func (m *GetAddressBalanceRsp) Reset()         { *m = GetAddressBalanceRsp{} }
func (m *GetAddressBalanceRsp) String() string { return proto.CompactTextString(m) }
func (*GetAddressBalanceRsp) ProtoMessage()    {}
func (*GetAddressBalanceRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{5}
}

func (m *GetAddressBalanceRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *GetAddressBalanceRsp) GetBal() string {
	if m != nil {
		return m.Bal
	}
	return ""
}

type CheckRawTransactionDoneReq struct {
	DigType DigtialType `protobuf:"varint,1,opt,name=DigType,proto3,enum=imstransactionserver.DigtialType" json:"DigType,omitempty"`
	Txid    string      `protobuf:"bytes,2,opt,name=txid,proto3" json:"txid,omitempty"`
}

func (m *CheckRawTransactionDoneReq) Reset()         { *m = CheckRawTransactionDoneReq{} }
func (m *CheckRawTransactionDoneReq) String() string { return proto.CompactTextString(m) }
func (*CheckRawTransactionDoneReq) ProtoMessage()    {}
func (*CheckRawTransactionDoneReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{6}
}

func (m *CheckRawTransactionDoneReq) GetDigType() DigtialType {
	if m != nil {
		return m.DigType
	}
	return DigtialType_BTC
}

func (m *CheckRawTransactionDoneReq) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

// 发送rawtransaction交易
type SendRawTransactionReq struct {
	DigType DigtialType `protobuf:"varint,1,opt,name=DigType,proto3,enum=imstransactionserver.DigtialType" json:"DigType,omitempty"`
	//    string FromAddress = 2; // 發送方地址
	//    string FromPrvKey = 3; // 加密的私鑰
	//    int32 fromUserId = 4; // 发送方的userId
	//    string ToAddress = 5; //转向的地址
	//    string Amount = 6; //交易余额  比如 BTC: 0.0001 BTC
	RawData string `protobuf:"bytes,2,opt,name=RawData,proto3" json:"RawData,omitempty"`
}

func (m *SendRawTransactionReq) Reset()         { *m = SendRawTransactionReq{} }
func (m *SendRawTransactionReq) String() string { return proto.CompactTextString(m) }
func (*SendRawTransactionReq) ProtoMessage()    {}
func (*SendRawTransactionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{7}
}

func (m *SendRawTransactionReq) GetDigType() DigtialType {
	if m != nil {
		return m.DigType
	}
	return DigtialType_BTC
}

func (m *SendRawTransactionReq) GetRawData() string {
	if m != nil {
		return m.RawData
	}
	return ""
}

// 发送rawtransaction交易
type SendRawTransactionRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	Txid    string    `protobuf:"bytes,2,opt,name=Txid,proto3" json:"Txid,omitempty"`
}

func (m *SendRawTransactionRsp) Reset()         { *m = SendRawTransactionRsp{} }
func (m *SendRawTransactionRsp) String() string { return proto.CompactTextString(m) }
func (*SendRawTransactionRsp) ProtoMessage()    {}
func (*SendRawTransactionRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{8}
}

func (m *SendRawTransactionRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *SendRawTransactionRsp) GetTxid() string {
	if m != nil {
		return m.Txid
	}
	return ""
}

// 获取此次交易手续费請求
type GetRawTransactionFeeReq struct {
	DigType     DigtialType `protobuf:"varint,1,opt,name=DigType,proto3,enum=imstransactionserver.DigtialType" json:"DigType,omitempty"`
	FromAddress string      `protobuf:"bytes,2,opt,name=FromAddress,proto3" json:"FromAddress,omitempty"`
	FromPrvKey  string      `protobuf:"bytes,3,opt,name=FromPrvKey,proto3" json:"FromPrvKey,omitempty"`
	FromUserId  int64       `protobuf:"varint,4,opt,name=fromUserId,proto3" json:"fromUserId,omitempty"`
	ToAddress   string      `protobuf:"bytes,5,opt,name=ToAddress,proto3" json:"ToAddress,omitempty"`
	Amount      string      `protobuf:"bytes,6,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *GetRawTransactionFeeReq) Reset()         { *m = GetRawTransactionFeeReq{} }
func (m *GetRawTransactionFeeReq) String() string { return proto.CompactTextString(m) }
func (*GetRawTransactionFeeReq) ProtoMessage()    {}
func (*GetRawTransactionFeeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{9}
}

func (m *GetRawTransactionFeeReq) GetDigType() DigtialType {
	if m != nil {
		return m.DigType
	}
	return DigtialType_BTC
}

func (m *GetRawTransactionFeeReq) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *GetRawTransactionFeeReq) GetFromPrvKey() string {
	if m != nil {
		return m.FromPrvKey
	}
	return ""
}

func (m *GetRawTransactionFeeReq) GetFromUserId() int64 {
	if m != nil {
		return m.FromUserId
	}
	return 0
}

func (m *GetRawTransactionFeeReq) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

func (m *GetRawTransactionFeeReq) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

// 获取此次交易手续费返回
type GetRawTransactionFeeRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	Fee     string    `protobuf:"bytes,2,opt,name=Fee,proto3" json:"Fee,omitempty"`
	Bal     string    `protobuf:"bytes,3,opt,name=Bal,proto3" json:"Bal,omitempty"`
	TxId    string    `protobuf:"bytes,4,opt,name=TxId,proto3" json:"TxId,omitempty"`
	RawData string    `protobuf:"bytes,5,opt,name=RawData,proto3" json:"RawData,omitempty"`
}

func (m *GetRawTransactionFeeRsp) Reset()         { *m = GetRawTransactionFeeRsp{} }
func (m *GetRawTransactionFeeRsp) String() string { return proto.CompactTextString(m) }
func (*GetRawTransactionFeeRsp) ProtoMessage()    {}
func (*GetRawTransactionFeeRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{10}
}

func (m *GetRawTransactionFeeRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *GetRawTransactionFeeRsp) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *GetRawTransactionFeeRsp) GetBal() string {
	if m != nil {
		return m.Bal
	}
	return ""
}

func (m *GetRawTransactionFeeRsp) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *GetRawTransactionFeeRsp) GetRawData() string {
	if m != nil {
		return m.RawData
	}
	return ""
}

// 公私鑰匙信息
type PubPrvKeyInfo struct {
	PubKey   string `protobuf:"bytes,1,opt,name=PubKey,proto3" json:"PubKey,omitempty"`
	PrvKey   string `protobuf:"bytes,2,opt,name=PrvKey,proto3" json:"PrvKey,omitempty"`
	Mnemonic string `protobuf:"bytes,3,opt,name=mnemonic,proto3" json:"mnemonic,omitempty"`
}

func (m *PubPrvKeyInfo) Reset()         { *m = PubPrvKeyInfo{} }
func (m *PubPrvKeyInfo) String() string { return proto.CompactTextString(m) }
func (*PubPrvKeyInfo) ProtoMessage()    {}
func (*PubPrvKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{11}
}

func (m *PubPrvKeyInfo) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

func (m *PubPrvKeyInfo) GetPrvKey() string {
	if m != nil {
		return m.PrvKey
	}
	return ""
}

func (m *PubPrvKeyInfo) GetMnemonic() string {
	if m != nil {
		return m.Mnemonic
	}
	return ""
}

// 地址信息
type AddressInfo struct {
	Address string         `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	PubPrv  *PubPrvKeyInfo `protobuf:"bytes,2,opt,name=pubPrv" json:"pubPrv,omitempty"`
}

func (m *AddressInfo) Reset()                    { *m = AddressInfo{} }
func (m *AddressInfo) String() string            { return proto.CompactTextString(m) }
func (*AddressInfo) ProtoMessage()               {}
func (*AddressInfo) Descriptor() ([]byte, []int) { return fileDescriptorImtransactionserver, []int{12} }

func (m *AddressInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AddressInfo) GetPubPrv() *PubPrvKeyInfo {
	if m != nil {
		return m.PubPrv
	}
	return nil
}

// 创建钱包单签地址 請求
type CreateWalletAddressReq struct {
	UserId     int64       `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Language   string      `protobuf:"bytes,2,opt,name=language,proto3" json:"language,omitempty"`
	DiatalType DigtialType `protobuf:"varint,3,opt,name=DiatalType,proto3,enum=imstransactionserver.DigtialType" json:"DiatalType,omitempty"`
}

func (m *CreateWalletAddressReq) Reset()         { *m = CreateWalletAddressReq{} }
func (m *CreateWalletAddressReq) String() string { return proto.CompactTextString(m) }
func (*CreateWalletAddressReq) ProtoMessage()    {}
func (*CreateWalletAddressReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{13}
}

func (m *CreateWalletAddressReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CreateWalletAddressReq) GetLanguage() string {
	if m != nil {
		return m.Language
	}
	return ""
}

func (m *CreateWalletAddressReq) GetDiatalType() DigtialType {
	if m != nil {
		return m.DiatalType
	}
	return DigtialType_BTC
}

// 创建钱包单签地址 返回
type CreateWalletAddressRsp struct {
	ErrCode     ErrorCode    `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	AddressInfo *AddressInfo `protobuf:"bytes,2,opt,name=addressInfo" json:"addressInfo,omitempty"`
}

func (m *CreateWalletAddressRsp) Reset()         { *m = CreateWalletAddressRsp{} }
func (m *CreateWalletAddressRsp) String() string { return proto.CompactTextString(m) }
func (*CreateWalletAddressRsp) ProtoMessage()    {}
func (*CreateWalletAddressRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{14}
}

func (m *CreateWalletAddressRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *CreateWalletAddressRsp) GetAddressInfo() *AddressInfo {
	if m != nil {
		return m.AddressInfo
	}
	return nil
}

// 创建btc类型的多签地址
type CreateBtcTypeMultiSigAddressReq struct {
	DigType    DigtialType `protobuf:"varint,1,opt,name=DigType,proto3,enum=imstransactionserver.DigtialType" json:"DigType,omitempty"`
	WalletType int32       `protobuf:"varint,2,opt,name=WalletType,proto3" json:"WalletType,omitempty"`
	M          int32       `protobuf:"varint,3,opt,name=M,proto3" json:"M,omitempty"`
	PubKeys    []string    `protobuf:"bytes,4,rep,name=PubKeys" json:"PubKeys,omitempty"`
}

func (m *CreateBtcTypeMultiSigAddressReq) Reset()         { *m = CreateBtcTypeMultiSigAddressReq{} }
func (m *CreateBtcTypeMultiSigAddressReq) String() string { return proto.CompactTextString(m) }
func (*CreateBtcTypeMultiSigAddressReq) ProtoMessage()    {}
func (*CreateBtcTypeMultiSigAddressReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{15}
}

func (m *CreateBtcTypeMultiSigAddressReq) GetDigType() DigtialType {
	if m != nil {
		return m.DigType
	}
	return DigtialType_BTC
}

func (m *CreateBtcTypeMultiSigAddressReq) GetWalletType() int32 {
	if m != nil {
		return m.WalletType
	}
	return 0
}

func (m *CreateBtcTypeMultiSigAddressReq) GetM() int32 {
	if m != nil {
		return m.M
	}
	return 0
}

func (m *CreateBtcTypeMultiSigAddressReq) GetPubKeys() []string {
	if m != nil {
		return m.PubKeys
	}
	return nil
}

// 创建btc类型的多签地址 返回
type CreateBtcTypeMultiSigAddressRsp struct {
	ErrCode      ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	Address      string    `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
	RedeemScript string    `protobuf:"bytes,3,opt,name=RedeemScript,proto3" json:"RedeemScript,omitempty"`
}

func (m *CreateBtcTypeMultiSigAddressRsp) Reset()         { *m = CreateBtcTypeMultiSigAddressRsp{} }
func (m *CreateBtcTypeMultiSigAddressRsp) String() string { return proto.CompactTextString(m) }
func (*CreateBtcTypeMultiSigAddressRsp) ProtoMessage()    {}
func (*CreateBtcTypeMultiSigAddressRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{16}
}

func (m *CreateBtcTypeMultiSigAddressRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *CreateBtcTypeMultiSigAddressRsp) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *CreateBtcTypeMultiSigAddressRsp) GetRedeemScript() string {
	if m != nil {
		return m.RedeemScript
	}
	return ""
}

// 创建eth类型的多签地址
type CreateEthTypeMultiSigAddressReq struct {
	Creator    string   `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Private    string   `protobuf:"bytes,2,opt,name=private,proto3" json:"private,omitempty"`
	M          int32    `protobuf:"varint,3,opt,name=M,proto3" json:"M,omitempty"`
	Owners     []string `protobuf:"bytes,4,rep,name=Owners" json:"Owners,omitempty"`
	DevideId   int32    `protobuf:"varint,5,opt,name=DevideId,proto3" json:"DevideId,omitempty"`
	CurrencyId int32    `protobuf:"varint,6,opt,name=CurrencyId,proto3" json:"CurrencyId,omitempty"`
	WalletType int32    `protobuf:"varint,7,opt,name=WalletType,proto3" json:"WalletType,omitempty"`
}

func (m *CreateEthTypeMultiSigAddressReq) Reset()         { *m = CreateEthTypeMultiSigAddressReq{} }
func (m *CreateEthTypeMultiSigAddressReq) String() string { return proto.CompactTextString(m) }
func (*CreateEthTypeMultiSigAddressReq) ProtoMessage()    {}
func (*CreateEthTypeMultiSigAddressReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{17}
}

func (m *CreateEthTypeMultiSigAddressReq) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *CreateEthTypeMultiSigAddressReq) GetPrivate() string {
	if m != nil {
		return m.Private
	}
	return ""
}

func (m *CreateEthTypeMultiSigAddressReq) GetM() int32 {
	if m != nil {
		return m.M
	}
	return 0
}

func (m *CreateEthTypeMultiSigAddressReq) GetOwners() []string {
	if m != nil {
		return m.Owners
	}
	return nil
}

func (m *CreateEthTypeMultiSigAddressReq) GetDevideId() int32 {
	if m != nil {
		return m.DevideId
	}
	return 0
}

func (m *CreateEthTypeMultiSigAddressReq) GetCurrencyId() int32 {
	if m != nil {
		return m.CurrencyId
	}
	return 0
}

func (m *CreateEthTypeMultiSigAddressReq) GetWalletType() int32 {
	if m != nil {
		return m.WalletType
	}
	return 0
}

// 创建eth类型的多签地址 返回
type CreateEthTypeMultiSigAddressRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	TxId    string    `protobuf:"bytes,2,opt,name=TxId,proto3" json:"TxId,omitempty"`
}

func (m *CreateEthTypeMultiSigAddressRsp) Reset()         { *m = CreateEthTypeMultiSigAddressRsp{} }
func (m *CreateEthTypeMultiSigAddressRsp) String() string { return proto.CompactTextString(m) }
func (*CreateEthTypeMultiSigAddressRsp) ProtoMessage()    {}
func (*CreateEthTypeMultiSigAddressRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{18}
}

func (m *CreateEthTypeMultiSigAddressRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *CreateEthTypeMultiSigAddressRsp) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

// 加密秘钥信息
type EncryPrvKeyInfo struct {
	EncryPrvKey string `protobuf:"bytes,1,opt,name=encryPrvKey,proto3" json:"encryPrvKey,omitempty"`
	UserId      int64  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Address     string `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *EncryPrvKeyInfo) Reset()         { *m = EncryPrvKeyInfo{} }
func (m *EncryPrvKeyInfo) String() string { return proto.CompactTextString(m) }
func (*EncryPrvKeyInfo) ProtoMessage()    {}
func (*EncryPrvKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{19}
}

func (m *EncryPrvKeyInfo) GetEncryPrvKey() string {
	if m != nil {
		return m.EncryPrvKey
	}
	return ""
}

func (m *EncryPrvKeyInfo) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *EncryPrvKeyInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// 发送btc类型的多签交易
type SendBtcTypeMultiSigTransactionReq struct {
	DigType      DigtialType        `protobuf:"varint,1,opt,name=DigType,proto3,enum=imstransactionserver.DigtialType" json:"DigType,omitempty"`
	FromAddr     string             `protobuf:"bytes,2,opt,name=FromAddr,proto3" json:"FromAddr,omitempty"`
	ToAddr       string             `protobuf:"bytes,3,opt,name=ToAddr,proto3" json:"ToAddr,omitempty"`
	Amount       string             `protobuf:"bytes,4,opt,name=Amount,proto3" json:"Amount,omitempty"`
	RedeemScript string             `protobuf:"bytes,5,opt,name=RedeemScript,proto3" json:"RedeemScript,omitempty"`
	PrvKeys      []*EncryPrvKeyInfo `protobuf:"bytes,6,rep,name=PrvKeys" json:"PrvKeys,omitempty"`
}

func (m *SendBtcTypeMultiSigTransactionReq) Reset()         { *m = SendBtcTypeMultiSigTransactionReq{} }
func (m *SendBtcTypeMultiSigTransactionReq) String() string { return proto.CompactTextString(m) }
func (*SendBtcTypeMultiSigTransactionReq) ProtoMessage()    {}
func (*SendBtcTypeMultiSigTransactionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{20}
}

func (m *SendBtcTypeMultiSigTransactionReq) GetDigType() DigtialType {
	if m != nil {
		return m.DigType
	}
	return DigtialType_BTC
}

func (m *SendBtcTypeMultiSigTransactionReq) GetFromAddr() string {
	if m != nil {
		return m.FromAddr
	}
	return ""
}

func (m *SendBtcTypeMultiSigTransactionReq) GetToAddr() string {
	if m != nil {
		return m.ToAddr
	}
	return ""
}

func (m *SendBtcTypeMultiSigTransactionReq) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SendBtcTypeMultiSigTransactionReq) GetRedeemScript() string {
	if m != nil {
		return m.RedeemScript
	}
	return ""
}

func (m *SendBtcTypeMultiSigTransactionReq) GetPrvKeys() []*EncryPrvKeyInfo {
	if m != nil {
		return m.PrvKeys
	}
	return nil
}

// 发送eth类型的多签交易
type SendEthTypeMultiSigTransactionReq struct {
	DigType  DigtialType        `protobuf:"varint,1,opt,name=DigType,proto3,enum=imstransactionserver.DigtialType" json:"DigType,omitempty"`
	ConAddr  string             `protobuf:"bytes,2,opt,name=ConAddr,proto3" json:"ConAddr,omitempty"`
	ToAddr   string             `protobuf:"bytes,3,opt,name=ToAddr,proto3" json:"ToAddr,omitempty"`
	Amount   string             `protobuf:"bytes,4,opt,name=Amount,proto3" json:"Amount,omitempty"`
	USDTAddr string             `protobuf:"bytes,5,opt,name=USDTAddr,proto3" json:"USDTAddr,omitempty"`
	PrvKeys  []*EncryPrvKeyInfo `protobuf:"bytes,6,rep,name=PrvKeys" json:"PrvKeys,omitempty"`
}

func (m *SendEthTypeMultiSigTransactionReq) Reset()         { *m = SendEthTypeMultiSigTransactionReq{} }
func (m *SendEthTypeMultiSigTransactionReq) String() string { return proto.CompactTextString(m) }
func (*SendEthTypeMultiSigTransactionReq) ProtoMessage()    {}
func (*SendEthTypeMultiSigTransactionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{21}
}

func (m *SendEthTypeMultiSigTransactionReq) GetDigType() DigtialType {
	if m != nil {
		return m.DigType
	}
	return DigtialType_BTC
}

func (m *SendEthTypeMultiSigTransactionReq) GetConAddr() string {
	if m != nil {
		return m.ConAddr
	}
	return ""
}

func (m *SendEthTypeMultiSigTransactionReq) GetToAddr() string {
	if m != nil {
		return m.ToAddr
	}
	return ""
}

func (m *SendEthTypeMultiSigTransactionReq) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SendEthTypeMultiSigTransactionReq) GetUSDTAddr() string {
	if m != nil {
		return m.USDTAddr
	}
	return ""
}

func (m *SendEthTypeMultiSigTransactionReq) GetPrvKeys() []*EncryPrvKeyInfo {
	if m != nil {
		return m.PrvKeys
	}
	return nil
}

// 发送交易
type SendMultiSigTransactionRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=errCode,proto3,enum=imstransactionserver.ErrorCode" json:"errCode,omitempty"`
	Txs     []string  `protobuf:"bytes,2,rep,name=Txs" json:"Txs,omitempty"`
}

func (m *SendMultiSigTransactionRsp) Reset()         { *m = SendMultiSigTransactionRsp{} }
func (m *SendMultiSigTransactionRsp) String() string { return proto.CompactTextString(m) }
func (*SendMultiSigTransactionRsp) ProtoMessage()    {}
func (*SendMultiSigTransactionRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImtransactionserver, []int{22}
}

func (m *SendMultiSigTransactionRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_SUCCESS
}

func (m *SendMultiSigTransactionRsp) GetTxs() []string {
	if m != nil {
		return m.Txs
	}
	return nil
}

func init() {
	proto.RegisterType((*UserPrivate)(nil), "imstransactionserver.UserPrivate")
	proto.RegisterType((*DivideMultiSigReq)(nil), "imstransactionserver.DivideMultiSigReq")
	proto.RegisterType((*DivideMultiSigRsp)(nil), "imstransactionserver.DivideMultiSigRsp")
	proto.RegisterType((*CheckRawTransactionDoneRsp)(nil), "imstransactionserver.CheckRawTransactionDoneRsp")
	proto.RegisterType((*GetAddressBalanceReq)(nil), "imstransactionserver.GetAddressBalanceReq")
	proto.RegisterType((*GetAddressBalanceRsp)(nil), "imstransactionserver.GetAddressBalanceRsp")
	proto.RegisterType((*CheckRawTransactionDoneReq)(nil), "imstransactionserver.CheckRawTransactionDoneReq")
	proto.RegisterType((*SendRawTransactionReq)(nil), "imstransactionserver.SendRawTransactionReq")
	proto.RegisterType((*SendRawTransactionRsp)(nil), "imstransactionserver.SendRawTransactionRsp")
	proto.RegisterType((*GetRawTransactionFeeReq)(nil), "imstransactionserver.GetRawTransactionFeeReq")
	proto.RegisterType((*GetRawTransactionFeeRsp)(nil), "imstransactionserver.GetRawTransactionFeeRsp")
	proto.RegisterType((*PubPrvKeyInfo)(nil), "imstransactionserver.PubPrvKeyInfo")
	proto.RegisterType((*AddressInfo)(nil), "imstransactionserver.AddressInfo")
	proto.RegisterType((*CreateWalletAddressReq)(nil), "imstransactionserver.CreateWalletAddressReq")
	proto.RegisterType((*CreateWalletAddressRsp)(nil), "imstransactionserver.CreateWalletAddressRsp")
	proto.RegisterType((*CreateBtcTypeMultiSigAddressReq)(nil), "imstransactionserver.CreateBtcTypeMultiSigAddressReq")
	proto.RegisterType((*CreateBtcTypeMultiSigAddressRsp)(nil), "imstransactionserver.CreateBtcTypeMultiSigAddressRsp")
	proto.RegisterType((*CreateEthTypeMultiSigAddressReq)(nil), "imstransactionserver.CreateEthTypeMultiSigAddressReq")
	proto.RegisterType((*CreateEthTypeMultiSigAddressRsp)(nil), "imstransactionserver.CreateEthTypeMultiSigAddressRsp")
	proto.RegisterType((*EncryPrvKeyInfo)(nil), "imstransactionserver.EncryPrvKeyInfo")
	proto.RegisterType((*SendBtcTypeMultiSigTransactionReq)(nil), "imstransactionserver.SendBtcTypeMultiSigTransactionReq")
	proto.RegisterType((*SendEthTypeMultiSigTransactionReq)(nil), "imstransactionserver.SendEthTypeMultiSigTransactionReq")
	proto.RegisterType((*SendMultiSigTransactionRsp)(nil), "imstransactionserver.SendMultiSigTransactionRsp")
	proto.RegisterEnum("imstransactionserver.DigtialType", DigtialType_name, DigtialType_value)
	proto.RegisterEnum("imstransactionserver.ErrorCode", ErrorCode_name, ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ServerService service

type ServerServiceClient interface {
	// 创建钱包单签地址
	CreateWalletAddress(ctx context.Context, in *CreateWalletAddressReq, opts ...grpc.CallOption) (*CreateWalletAddressRsp, error)
	// 获取此次交易手续费
	GetRawTransactionFee(ctx context.Context, in *GetRawTransactionFeeReq, opts ...grpc.CallOption) (*GetRawTransactionFeeRsp, error)
	// 發送 raw transaction
	SendRawTransaction(ctx context.Context, in *SendRawTransactionReq, opts ...grpc.CallOption) (*SendRawTransactionRsp, error)
	// 根据交易ID 查看是否到账
	CheckRawTransactionDone(ctx context.Context, in *CheckRawTransactionDoneReq, opts ...grpc.CallOption) (*CheckRawTransactionDoneRsp, error)
	// 获取地址余额
	GetAddressBalance(ctx context.Context, in *GetAddressBalanceReq, opts ...grpc.CallOption) (*GetAddressBalanceRsp, error)
	// 发送BTC/LTC类型的多签交易
	SendBtcTypeMultiSigTransaction(ctx context.Context, in *SendBtcTypeMultiSigTransactionReq, opts ...grpc.CallOption) (*SendMultiSigTransactionRsp, error)
	// 发送EHT/USDT类型的多签交易
	SendEthTypeMultiSigTransaction(ctx context.Context, in *SendEthTypeMultiSigTransactionReq, opts ...grpc.CallOption) (*SendMultiSigTransactionRsp, error)
	// 创建BTC/LTC类型的多签钱包地址
	CreateBtcTypeMultiSigWalletAddress(ctx context.Context, in *CreateBtcTypeMultiSigAddressReq, opts ...grpc.CallOption) (*CreateBtcTypeMultiSigAddressRsp, error)
	// 创建EHT/USDT类型的多签钱包地址
	CreateEthTypeMultiSigWalletAddress(ctx context.Context, in *CreateEthTypeMultiSigAddressReq, opts ...grpc.CallOption) (*CreateEthTypeMultiSigAddressRsp, error)
	DivideMultiSig(ctx context.Context, in *DivideMultiSigReq, opts ...grpc.CallOption) (*DivideMultiSigRsp, error)
}

type serverServiceClient struct {
	cc *grpc.ClientConn
}

func NewServerServiceClient(cc *grpc.ClientConn) ServerServiceClient {
	return &serverServiceClient{cc}
}

func (c *serverServiceClient) CreateWalletAddress(ctx context.Context, in *CreateWalletAddressReq, opts ...grpc.CallOption) (*CreateWalletAddressRsp, error) {
	out := new(CreateWalletAddressRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/CreateWalletAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) GetRawTransactionFee(ctx context.Context, in *GetRawTransactionFeeReq, opts ...grpc.CallOption) (*GetRawTransactionFeeRsp, error) {
	out := new(GetRawTransactionFeeRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/GetRawTransactionFee", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SendRawTransaction(ctx context.Context, in *SendRawTransactionReq, opts ...grpc.CallOption) (*SendRawTransactionRsp, error) {
	out := new(SendRawTransactionRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/SendRawTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) CheckRawTransactionDone(ctx context.Context, in *CheckRawTransactionDoneReq, opts ...grpc.CallOption) (*CheckRawTransactionDoneRsp, error) {
	out := new(CheckRawTransactionDoneRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/CheckRawTransactionDone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) GetAddressBalance(ctx context.Context, in *GetAddressBalanceReq, opts ...grpc.CallOption) (*GetAddressBalanceRsp, error) {
	out := new(GetAddressBalanceRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/GetAddressBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SendBtcTypeMultiSigTransaction(ctx context.Context, in *SendBtcTypeMultiSigTransactionReq, opts ...grpc.CallOption) (*SendMultiSigTransactionRsp, error) {
	out := new(SendMultiSigTransactionRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/SendBtcTypeMultiSigTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SendEthTypeMultiSigTransaction(ctx context.Context, in *SendEthTypeMultiSigTransactionReq, opts ...grpc.CallOption) (*SendMultiSigTransactionRsp, error) {
	out := new(SendMultiSigTransactionRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/SendEthTypeMultiSigTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) CreateBtcTypeMultiSigWalletAddress(ctx context.Context, in *CreateBtcTypeMultiSigAddressReq, opts ...grpc.CallOption) (*CreateBtcTypeMultiSigAddressRsp, error) {
	out := new(CreateBtcTypeMultiSigAddressRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/CreateBtcTypeMultiSigWalletAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) CreateEthTypeMultiSigWalletAddress(ctx context.Context, in *CreateEthTypeMultiSigAddressReq, opts ...grpc.CallOption) (*CreateEthTypeMultiSigAddressRsp, error) {
	out := new(CreateEthTypeMultiSigAddressRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/CreateEthTypeMultiSigWalletAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) DivideMultiSig(ctx context.Context, in *DivideMultiSigReq, opts ...grpc.CallOption) (*DivideMultiSigRsp, error) {
	out := new(DivideMultiSigRsp)
	err := grpc.Invoke(ctx, "/imstransactionserver.ServerService/DivideMultiSig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServerService service

type ServerServiceServer interface {
	// 创建钱包单签地址
	CreateWalletAddress(context.Context, *CreateWalletAddressReq) (*CreateWalletAddressRsp, error)
	// 获取此次交易手续费
	GetRawTransactionFee(context.Context, *GetRawTransactionFeeReq) (*GetRawTransactionFeeRsp, error)
	// 發送 raw transaction
	SendRawTransaction(context.Context, *SendRawTransactionReq) (*SendRawTransactionRsp, error)
	// 根据交易ID 查看是否到账
	CheckRawTransactionDone(context.Context, *CheckRawTransactionDoneReq) (*CheckRawTransactionDoneRsp, error)
	// 获取地址余额
	GetAddressBalance(context.Context, *GetAddressBalanceReq) (*GetAddressBalanceRsp, error)
	// 发送BTC/LTC类型的多签交易
	SendBtcTypeMultiSigTransaction(context.Context, *SendBtcTypeMultiSigTransactionReq) (*SendMultiSigTransactionRsp, error)
	// 发送EHT/USDT类型的多签交易
	SendEthTypeMultiSigTransaction(context.Context, *SendEthTypeMultiSigTransactionReq) (*SendMultiSigTransactionRsp, error)
	// 创建BTC/LTC类型的多签钱包地址
	CreateBtcTypeMultiSigWalletAddress(context.Context, *CreateBtcTypeMultiSigAddressReq) (*CreateBtcTypeMultiSigAddressRsp, error)
	// 创建EHT/USDT类型的多签钱包地址
	CreateEthTypeMultiSigWalletAddress(context.Context, *CreateEthTypeMultiSigAddressReq) (*CreateEthTypeMultiSigAddressRsp, error)
	DivideMultiSig(context.Context, *DivideMultiSigReq) (*DivideMultiSigRsp, error)
}

func RegisterServerServiceServer(s *grpc.Server, srv ServerServiceServer) {
	s.RegisterService(&_ServerService_serviceDesc, srv)
}

func _ServerService_CreateWalletAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWalletAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).CreateWalletAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/CreateWalletAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).CreateWalletAddress(ctx, req.(*CreateWalletAddressReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_GetRawTransactionFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRawTransactionFeeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetRawTransactionFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/GetRawTransactionFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetRawTransactionFee(ctx, req.(*GetRawTransactionFeeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SendRawTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRawTransactionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SendRawTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/SendRawTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SendRawTransaction(ctx, req.(*SendRawTransactionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_CheckRawTransactionDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRawTransactionDoneReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).CheckRawTransactionDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/CheckRawTransactionDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).CheckRawTransactionDone(ctx, req.(*CheckRawTransactionDoneReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_GetAddressBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressBalanceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetAddressBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/GetAddressBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetAddressBalance(ctx, req.(*GetAddressBalanceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SendBtcTypeMultiSigTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendBtcTypeMultiSigTransactionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SendBtcTypeMultiSigTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/SendBtcTypeMultiSigTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SendBtcTypeMultiSigTransaction(ctx, req.(*SendBtcTypeMultiSigTransactionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SendEthTypeMultiSigTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendEthTypeMultiSigTransactionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SendEthTypeMultiSigTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/SendEthTypeMultiSigTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SendEthTypeMultiSigTransaction(ctx, req.(*SendEthTypeMultiSigTransactionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_CreateBtcTypeMultiSigWalletAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBtcTypeMultiSigAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).CreateBtcTypeMultiSigWalletAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/CreateBtcTypeMultiSigWalletAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).CreateBtcTypeMultiSigWalletAddress(ctx, req.(*CreateBtcTypeMultiSigAddressReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_CreateEthTypeMultiSigWalletAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateEthTypeMultiSigAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).CreateEthTypeMultiSigWalletAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/CreateEthTypeMultiSigWalletAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).CreateEthTypeMultiSigWalletAddress(ctx, req.(*CreateEthTypeMultiSigAddressReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_DivideMultiSig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DivideMultiSigReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).DivideMultiSig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imstransactionserver.ServerService/DivideMultiSig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).DivideMultiSig(ctx, req.(*DivideMultiSigReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imstransactionserver.ServerService",
	HandlerType: (*ServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateWalletAddress",
			Handler:    _ServerService_CreateWalletAddress_Handler,
		},
		{
			MethodName: "GetRawTransactionFee",
			Handler:    _ServerService_GetRawTransactionFee_Handler,
		},
		{
			MethodName: "SendRawTransaction",
			Handler:    _ServerService_SendRawTransaction_Handler,
		},
		{
			MethodName: "CheckRawTransactionDone",
			Handler:    _ServerService_CheckRawTransactionDone_Handler,
		},
		{
			MethodName: "GetAddressBalance",
			Handler:    _ServerService_GetAddressBalance_Handler,
		},
		{
			MethodName: "SendBtcTypeMultiSigTransaction",
			Handler:    _ServerService_SendBtcTypeMultiSigTransaction_Handler,
		},
		{
			MethodName: "SendEthTypeMultiSigTransaction",
			Handler:    _ServerService_SendEthTypeMultiSigTransaction_Handler,
		},
		{
			MethodName: "CreateBtcTypeMultiSigWalletAddress",
			Handler:    _ServerService_CreateBtcTypeMultiSigWalletAddress_Handler,
		},
		{
			MethodName: "CreateEthTypeMultiSigWalletAddress",
			Handler:    _ServerService_CreateEthTypeMultiSigWalletAddress_Handler,
		},
		{
			MethodName: "DivideMultiSig",
			Handler:    _ServerService_DivideMultiSig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imtransactionserver/imtransactionserver.proto",
}

func (m *UserPrivate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPrivate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.EncryPriv) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.EncryPriv)))
		i += copy(dAtA[i:], m.EncryPriv)
	}
	return i, nil
}

func (m *DivideMultiSigReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DivideMultiSigReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DivideId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DivideId))
	}
	if m.CurrencyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.CurrencyId))
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	if m.ToWalletType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ToWalletType))
	}
	if len(m.ToAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.ToAddress)))
		i += copy(dAtA[i:], m.ToAddress)
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	if m.CreateTimestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.CreateTimestamp))
	}
	if len(m.Signs) > 0 {
		for _, msg := range m.Signs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintImtransactionserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.M != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.M))
	}
	return i, nil
}

func (m *DivideMultiSigRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DivideMultiSigRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.TxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.TxId)))
		i += copy(dAtA[i:], m.TxId)
	}
	return i, nil
}

func (m *CheckRawTransactionDoneRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRawTransactionDoneRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if m.IsDone {
		dAtA[i] = 0x10
		i++
		if m.IsDone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetAddressBalanceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAddressBalanceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DigType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DigType))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *GetAddressBalanceRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAddressBalanceRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Bal) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Bal)))
		i += copy(dAtA[i:], m.Bal)
	}
	return i, nil
}

func (m *CheckRawTransactionDoneReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRawTransactionDoneReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DigType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DigType))
	}
	if len(m.Txid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Txid)))
		i += copy(dAtA[i:], m.Txid)
	}
	return i, nil
}

func (m *SendRawTransactionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRawTransactionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DigType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DigType))
	}
	if len(m.RawData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.RawData)))
		i += copy(dAtA[i:], m.RawData)
	}
	return i, nil
}

func (m *SendRawTransactionRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRawTransactionRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Txid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Txid)))
		i += copy(dAtA[i:], m.Txid)
	}
	return i, nil
}

func (m *GetRawTransactionFeeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRawTransactionFeeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DigType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DigType))
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	if len(m.FromPrvKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.FromPrvKey)))
		i += copy(dAtA[i:], m.FromPrvKey)
	}
	if m.FromUserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.FromUserId))
	}
	if len(m.ToAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.ToAddress)))
		i += copy(dAtA[i:], m.ToAddress)
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	return i, nil
}

func (m *GetRawTransactionFeeRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRawTransactionFeeRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Fee) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Fee)))
		i += copy(dAtA[i:], m.Fee)
	}
	if len(m.Bal) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Bal)))
		i += copy(dAtA[i:], m.Bal)
	}
	if len(m.TxId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.TxId)))
		i += copy(dAtA[i:], m.TxId)
	}
	if len(m.RawData) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.RawData)))
		i += copy(dAtA[i:], m.RawData)
	}
	return i, nil
}

func (m *PubPrvKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PubPrvKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PubKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.PubKey)))
		i += copy(dAtA[i:], m.PubKey)
	}
	if len(m.PrvKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.PrvKey)))
		i += copy(dAtA[i:], m.PrvKey)
	}
	if len(m.Mnemonic) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Mnemonic)))
		i += copy(dAtA[i:], m.Mnemonic)
	}
	return i, nil
}

func (m *AddressInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddressInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.PubPrv != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.PubPrv.Size()))
		n1, err := m.PubPrv.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *CreateWalletAddressReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWalletAddressReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if m.DiatalType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DiatalType))
	}
	return i, nil
}

func (m *CreateWalletAddressRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWalletAddressRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if m.AddressInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.AddressInfo.Size()))
		n2, err := m.AddressInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *CreateBtcTypeMultiSigAddressReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBtcTypeMultiSigAddressReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DigType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DigType))
	}
	if m.WalletType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.WalletType))
	}
	if m.M != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.M))
	}
	if len(m.PubKeys) > 0 {
		for _, s := range m.PubKeys {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *CreateBtcTypeMultiSigAddressRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBtcTypeMultiSigAddressRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.RedeemScript) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.RedeemScript)))
		i += copy(dAtA[i:], m.RedeemScript)
	}
	return i, nil
}

func (m *CreateEthTypeMultiSigAddressReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateEthTypeMultiSigAddressReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Creator) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Creator)))
		i += copy(dAtA[i:], m.Creator)
	}
	if len(m.Private) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Private)))
		i += copy(dAtA[i:], m.Private)
	}
	if m.M != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.M))
	}
	if len(m.Owners) > 0 {
		for _, s := range m.Owners {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.DevideId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DevideId))
	}
	if m.CurrencyId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.CurrencyId))
	}
	if m.WalletType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.WalletType))
	}
	return i, nil
}

func (m *CreateEthTypeMultiSigAddressRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateEthTypeMultiSigAddressRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.TxId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.TxId)))
		i += copy(dAtA[i:], m.TxId)
	}
	return i, nil
}

func (m *EncryPrvKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryPrvKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EncryPrvKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.EncryPrvKey)))
		i += copy(dAtA[i:], m.EncryPrvKey)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *SendBtcTypeMultiSigTransactionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendBtcTypeMultiSigTransactionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DigType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DigType))
	}
	if len(m.FromAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.FromAddr)))
		i += copy(dAtA[i:], m.FromAddr)
	}
	if len(m.ToAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.ToAddr)))
		i += copy(dAtA[i:], m.ToAddr)
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	if len(m.RedeemScript) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.RedeemScript)))
		i += copy(dAtA[i:], m.RedeemScript)
	}
	if len(m.PrvKeys) > 0 {
		for _, msg := range m.PrvKeys {
			dAtA[i] = 0x32
			i++
			i = encodeVarintImtransactionserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SendEthTypeMultiSigTransactionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEthTypeMultiSigTransactionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DigType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.DigType))
	}
	if len(m.ConAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.ConAddr)))
		i += copy(dAtA[i:], m.ConAddr)
	}
	if len(m.ToAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.ToAddr)))
		i += copy(dAtA[i:], m.ToAddr)
	}
	if len(m.Amount) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.Amount)))
		i += copy(dAtA[i:], m.Amount)
	}
	if len(m.USDTAddr) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(len(m.USDTAddr)))
		i += copy(dAtA[i:], m.USDTAddr)
	}
	if len(m.PrvKeys) > 0 {
		for _, msg := range m.PrvKeys {
			dAtA[i] = 0x32
			i++
			i = encodeVarintImtransactionserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SendMultiSigTransactionRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMultiSigTransactionRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImtransactionserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Txs) > 0 {
		for _, s := range m.Txs {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func encodeVarintImtransactionserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserPrivate) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.EncryPriv)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *DivideMultiSigReq) Size() (n int) {
	var l int
	_ = l
	if m.DivideId != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DivideId))
	}
	if m.CurrencyId != 0 {
		n += 1 + sovImtransactionserver(uint64(m.CurrencyId))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if m.ToWalletType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ToWalletType))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if m.CreateTimestamp != 0 {
		n += 1 + sovImtransactionserver(uint64(m.CreateTimestamp))
	}
	if len(m.Signs) > 0 {
		for _, e := range m.Signs {
			l = e.Size()
			n += 1 + l + sovImtransactionserver(uint64(l))
		}
	}
	if m.M != 0 {
		n += 1 + sovImtransactionserver(uint64(m.M))
	}
	return n
}

func (m *DivideMultiSigRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *CheckRawTransactionDoneRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	if m.IsDone {
		n += 2
	}
	return n
}

func (m *GetAddressBalanceReq) Size() (n int) {
	var l int
	_ = l
	if m.DigType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DigType))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *GetAddressBalanceRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	l = len(m.Bal)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *CheckRawTransactionDoneReq) Size() (n int) {
	var l int
	_ = l
	if m.DigType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DigType))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *SendRawTransactionReq) Size() (n int) {
	var l int
	_ = l
	if m.DigType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DigType))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *SendRawTransactionRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *GetRawTransactionFeeReq) Size() (n int) {
	var l int
	_ = l
	if m.DigType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DigType))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.FromPrvKey)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if m.FromUserId != 0 {
		n += 1 + sovImtransactionserver(uint64(m.FromUserId))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *GetRawTransactionFeeRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.Bal)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.RawData)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *PubPrvKeyInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.PrvKey)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.Mnemonic)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *AddressInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if m.PubPrv != nil {
		l = m.PubPrv.Size()
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *CreateWalletAddressReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImtransactionserver(uint64(m.UserId))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if m.DiatalType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DiatalType))
	}
	return n
}

func (m *CreateWalletAddressRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	if m.AddressInfo != nil {
		l = m.AddressInfo.Size()
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *CreateBtcTypeMultiSigAddressReq) Size() (n int) {
	var l int
	_ = l
	if m.DigType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DigType))
	}
	if m.WalletType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.WalletType))
	}
	if m.M != 0 {
		n += 1 + sovImtransactionserver(uint64(m.M))
	}
	if len(m.PubKeys) > 0 {
		for _, s := range m.PubKeys {
			l = len(s)
			n += 1 + l + sovImtransactionserver(uint64(l))
		}
	}
	return n
}

func (m *CreateBtcTypeMultiSigAddressRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.RedeemScript)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *CreateEthTypeMultiSigAddressReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.Private)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if m.M != 0 {
		n += 1 + sovImtransactionserver(uint64(m.M))
	}
	if len(m.Owners) > 0 {
		for _, s := range m.Owners {
			l = len(s)
			n += 1 + l + sovImtransactionserver(uint64(l))
		}
	}
	if m.DevideId != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DevideId))
	}
	if m.CurrencyId != 0 {
		n += 1 + sovImtransactionserver(uint64(m.CurrencyId))
	}
	if m.WalletType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.WalletType))
	}
	return n
}

func (m *CreateEthTypeMultiSigAddressRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *EncryPrvKeyInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.EncryPrvKey)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImtransactionserver(uint64(m.UserId))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	return n
}

func (m *SendBtcTypeMultiSigTransactionReq) Size() (n int) {
	var l int
	_ = l
	if m.DigType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DigType))
	}
	l = len(m.FromAddr)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.ToAddr)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.RedeemScript)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if len(m.PrvKeys) > 0 {
		for _, e := range m.PrvKeys {
			l = e.Size()
			n += 1 + l + sovImtransactionserver(uint64(l))
		}
	}
	return n
}

func (m *SendEthTypeMultiSigTransactionReq) Size() (n int) {
	var l int
	_ = l
	if m.DigType != 0 {
		n += 1 + sovImtransactionserver(uint64(m.DigType))
	}
	l = len(m.ConAddr)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.ToAddr)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	l = len(m.USDTAddr)
	if l > 0 {
		n += 1 + l + sovImtransactionserver(uint64(l))
	}
	if len(m.PrvKeys) > 0 {
		for _, e := range m.PrvKeys {
			l = e.Size()
			n += 1 + l + sovImtransactionserver(uint64(l))
		}
	}
	return n
}

func (m *SendMultiSigTransactionRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImtransactionserver(uint64(m.ErrCode))
	}
	if len(m.Txs) > 0 {
		for _, s := range m.Txs {
			l = len(s)
			n += 1 + l + sovImtransactionserver(uint64(l))
		}
	}
	return n
}

func sovImtransactionserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImtransactionserver(x uint64) (n int) {
	return sovImtransactionserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserPrivate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPrivate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPrivate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryPriv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryPriv = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DivideMultiSigReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DivideMultiSigReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DivideMultiSigReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivideId", wireType)
			}
			m.DivideId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DivideId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyId", wireType)
			}
			m.CurrencyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToWalletType", wireType)
			}
			m.ToWalletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToWalletType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTimestamp", wireType)
			}
			m.CreateTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTimestamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signs = append(m.Signs, &UserPrivate{})
			if err := m.Signs[len(m.Signs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			m.M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.M |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DivideMultiSigRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DivideMultiSigRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DivideMultiSigRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckRawTransactionDoneRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRawTransactionDoneRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRawTransactionDoneRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDone = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAddressBalanceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAddressBalanceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAddressBalanceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigType", wireType)
			}
			m.DigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAddressBalanceRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAddressBalanceRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAddressBalanceRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckRawTransactionDoneReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRawTransactionDoneReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRawTransactionDoneReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigType", wireType)
			}
			m.DigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRawTransactionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRawTransactionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRawTransactionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigType", wireType)
			}
			m.DigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRawTransactionRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRawTransactionRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRawTransactionRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRawTransactionFeeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRawTransactionFeeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRawTransactionFeeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigType", wireType)
			}
			m.DigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPrvKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromPrvKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUserId", wireType)
			}
			m.FromUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRawTransactionFeeRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRawTransactionFeeRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRawTransactionFeeRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PubPrvKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PubPrvKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PubPrvKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrvKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrvKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mnemonic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mnemonic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddressInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddressInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddressInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubPrv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PubPrv == nil {
				m.PubPrv = &PubPrvKeyInfo{}
			}
			if err := m.PubPrv.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWalletAddressReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWalletAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWalletAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiatalType", wireType)
			}
			m.DiatalType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiatalType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWalletAddressRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWalletAddressRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWalletAddressRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddressInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AddressInfo == nil {
				m.AddressInfo = &AddressInfo{}
			}
			if err := m.AddressInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBtcTypeMultiSigAddressReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBtcTypeMultiSigAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBtcTypeMultiSigAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigType", wireType)
			}
			m.DigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletType", wireType)
			}
			m.WalletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			m.M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.M |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKeys = append(m.PubKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBtcTypeMultiSigAddressRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBtcTypeMultiSigAddressRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBtcTypeMultiSigAddressRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedeemScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedeemScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateEthTypeMultiSigAddressReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateEthTypeMultiSigAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateEthTypeMultiSigAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Private", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Private = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			m.M = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.M |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owners = append(m.Owners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DevideId", wireType)
			}
			m.DevideId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DevideId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyId", wireType)
			}
			m.CurrencyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrencyId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletType", wireType)
			}
			m.WalletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateEthTypeMultiSigAddressRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateEthTypeMultiSigAddressRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateEthTypeMultiSigAddressRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryPrvKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryPrvKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryPrvKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryPrvKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryPrvKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendBtcTypeMultiSigTransactionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendBtcTypeMultiSigTransactionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendBtcTypeMultiSigTransactionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigType", wireType)
			}
			m.DigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedeemScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RedeemScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrvKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrvKeys = append(m.PrvKeys, &EncryPrvKeyInfo{})
			if err := m.PrvKeys[len(m.PrvKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEthTypeMultiSigTransactionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEthTypeMultiSigTransactionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEthTypeMultiSigTransactionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DigType", wireType)
			}
			m.DigType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DigType |= (DigtialType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field USDTAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.USDTAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrvKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrvKeys = append(m.PrvKeys, &EncryPrvKeyInfo{})
			if err := m.PrvKeys[len(m.PrvKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMultiSigTransactionRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMultiSigTransactionRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMultiSigTransactionRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImtransactionserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImtransactionserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImtransactionserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImtransactionserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImtransactionserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImtransactionserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImtransactionserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImtransactionserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImtransactionserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImtransactionserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imtransactionserver/imtransactionserver.proto", fileDescriptorImtransactionserver)
}

var fileDescriptorImtransactionserver = []byte{
	// 1356 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x6e, 0xe3, 0xc4,
	0x17, 0x5f, 0xe7, 0xbb, 0x27, 0xdd, 0xdd, 0xec, 0xec, 0x6e, 0x37, 0x7f, 0xeb, 0xaf, 0x6c, 0xd7,
	0x08, 0xb1, 0x2a, 0xd0, 0x45, 0x45, 0x68, 0x85, 0xf6, 0x02, 0xa5, 0x4e, 0xb2, 0x58, 0xb4, 0x69,
	0x65, 0xbb, 0x80, 0xc4, 0x45, 0xe5, 0xd8, 0x93, 0x74, 0x44, 0x6c, 0x87, 0xb1, 0xd3, 0x8f, 0x2b,
	0xc4, 0x15, 0x57, 0x48, 0x80, 0xb8, 0x40, 0x3c, 0x00, 0x4f, 0xc1, 0x03, 0x70, 0xc9, 0x1d, 0xb7,
	0xa8, 0x0f, 0xc0, 0x33, 0xa0, 0x19, 0x8f, 0x53, 0x3b, 0xb1, 0xbb, 0x6d, 0xd3, 0x9b, 0x68, 0xce,
	0x99, 0x33, 0xe7, 0xe3, 0x37, 0x67, 0xce, 0x39, 0x0e, 0xe8, 0x23, 0x12, 0x8e, 0xad, 0xc1, 0xa6,
	0x7d, 0x64, 0x85, 0x01, 0xa6, 0xc7, 0x98, 0x6e, 0x12, 0xf7, 0x05, 0xf1, 0x42, 0x4c, 0x87, 0x96,
	0x8d, 0x27, 0xd4, 0x1f, 0x4c, 0x87, 0x2f, 0x88, 0x1b, 0x52, 0xcb, 0x0b, 0x2c, 0x3b, 0x24, 0xbe,
	0x17, 0x89, 0x65, 0xf1, 0x36, 0x27, 0xd4, 0x0f, 0x7d, 0xf4, 0x88, 0xb8, 0xc1, 0xc2, 0x9e, 0xd2,
	0x85, 0xfa, 0x41, 0x80, 0xe9, 0x3e, 0x25, 0xc7, 0x56, 0x88, 0x51, 0x13, 0xaa, 0x6d, 0xc7, 0xa1,
	0x38, 0x08, 0x9a, 0xd2, 0xba, 0xf4, 0x7c, 0x45, 0x8f, 0x49, 0xf4, 0x7f, 0x58, 0xe9, 0x7a, 0x36,
	0x3d, 0x63, 0x92, 0xcd, 0x02, 0xdf, 0xbb, 0x60, 0x28, 0x7f, 0x14, 0xe0, 0x41, 0x87, 0x1c, 0x13,
	0x07, 0xef, 0x4e, 0xc7, 0x21, 0x31, 0xc8, 0x48, 0xc7, 0xdf, 0x20, 0x19, 0x6a, 0x11, 0x53, 0x73,
	0xb8, 0xba, 0xb2, 0x3e, 0xa3, 0x51, 0x0b, 0x40, 0x9d, 0x52, 0x8a, 0x3d, 0xfb, 0x4c, 0x73, 0xb8,
	0xc2, 0xb2, 0x9e, 0xe0, 0xa0, 0x75, 0xa8, 0xf7, 0xa8, 0xef, 0xc6, 0xde, 0x14, 0xb9, 0xc5, 0x24,
	0x0b, 0x29, 0xb0, 0x6a, 0xfa, 0x5f, 0x58, 0xe3, 0x31, 0x0e, 0xcd, 0xb3, 0x09, 0x6e, 0x96, 0xb8,
	0x8e, 0x14, 0x8f, 0x79, 0x6d, 0xfa, 0xb1, 0x8e, 0x72, 0xe4, 0xf5, 0x8c, 0x81, 0xd6, 0xa0, 0xd2,
	0x76, 0xfd, 0xa9, 0x17, 0x36, 0x2b, 0x7c, 0x4b, 0x50, 0xe8, 0x39, 0xdc, 0x57, 0x29, 0xb6, 0x42,
	0x6c, 0x12, 0x17, 0x07, 0xa1, 0xe5, 0x4e, 0x9a, 0x55, 0xae, 0x7c, 0x9e, 0x8d, 0x5e, 0x42, 0xd9,
	0x20, 0x23, 0x2f, 0x68, 0xd6, 0xd6, 0x8b, 0xcf, 0xeb, 0x5b, 0xcf, 0x36, 0xb3, 0x40, 0xde, 0x4c,
	0x20, 0xac, 0x47, 0xf2, 0x68, 0x15, 0xa4, 0xdd, 0xe6, 0x0a, 0x57, 0x2a, 0xed, 0x2a, 0x83, 0x05,
	0xf4, 0x82, 0x09, 0xfa, 0x18, 0xaa, 0x98, 0x52, 0xd5, 0x77, 0x30, 0x07, 0xef, 0xde, 0xd6, 0xd3,
	0x6c, 0xed, 0x5d, 0x4a, 0x7d, 0x2e, 0xa6, 0xc7, 0xf2, 0x08, 0x41, 0xc9, 0x3c, 0x15, 0xb0, 0xae,
	0xe8, 0x7c, 0xad, 0xf8, 0x20, 0xab, 0x47, 0xd8, 0xfe, 0x5a, 0xb7, 0x4e, 0xcc, 0x0b, 0x1d, 0x1d,
	0xdf, 0xc3, 0x4b, 0x1a, 0x5b, 0x83, 0x0a, 0x09, 0x98, 0x1e, 0x6e, 0xae, 0xa6, 0x0b, 0x4a, 0x71,
	0xe1, 0xd1, 0x6b, 0x1c, 0x0a, 0xac, 0xb7, 0xad, 0xb1, 0xe5, 0xd9, 0x98, 0x65, 0xc5, 0x2b, 0xa8,
	0x76, 0xc8, 0x88, 0x5f, 0x59, 0x64, 0x2a, 0x07, 0xb5, 0x0e, 0x19, 0x85, 0xc4, 0x1a, 0x33, 0x41,
	0x3d, 0x3e, 0xc1, 0x12, 0xd4, 0x12, 0xd7, 0x19, 0x05, 0x17, 0x93, 0x8a, 0x9d, 0x65, 0x6e, 0xb9,
	0xc8, 0x1a, 0x50, 0x1c, 0x58, 0x63, 0x61, 0x88, 0x2d, 0x15, 0x37, 0x1f, 0xc4, 0x65, 0x23, 0x43,
	0x50, 0x0a, 0x4f, 0xc9, 0xec, 0xce, 0xd8, 0x5a, 0xf1, 0xe0, 0xb1, 0x81, 0x3d, 0x27, 0x6d, 0xed,
	0x36, 0x30, 0xd4, 0xad, 0x93, 0x8e, 0x15, 0x5a, 0x31, 0x86, 0x82, 0x54, 0x86, 0x99, 0xf6, 0x6e,
	0x21, 0x17, 0x49, 0x22, 0x17, 0x89, 0xa3, 0xfc, 0x2b, 0xc1, 0x93, 0xd7, 0x38, 0x4c, 0xdb, 0xe9,
	0xe1, 0xe5, 0x41, 0x9c, 0xab, 0x1a, 0x85, 0xc5, 0xaa, 0xd1, 0x02, 0x60, 0xe4, 0x3e, 0x3d, 0xfe,
	0x0c, 0x9f, 0x89, 0xb2, 0x92, 0xe0, 0xb0, 0xfd, 0x21, 0xf5, 0x5d, 0xf6, 0x64, 0x35, 0x87, 0xd7,
	0x94, 0xa2, 0x9e, 0xe0, 0xdc, 0xac, 0xa2, 0x28, 0xbf, 0xe7, 0x05, 0xbc, 0x74, 0x82, 0xf6, 0x30,
	0x8e, 0x13, 0xb4, 0x87, 0x39, 0x67, 0xdb, 0x1a, 0x8b, 0xb8, 0xd8, 0x72, 0x56, 0x0b, 0x4a, 0x17,
	0xb5, 0x20, 0x99, 0x01, 0xe5, 0x74, 0x06, 0x7c, 0x05, 0x77, 0xf7, 0xa7, 0x83, 0x08, 0x0b, 0xcd,
	0x1b, 0xfa, 0x2c, 0xa2, 0xfd, 0xe9, 0x80, 0x61, 0x15, 0x35, 0x04, 0x41, 0x71, 0x7e, 0x84, 0x61,
	0x41, 0xf0, 0x23, 0xfc, 0x64, 0xa8, 0xb9, 0x1e, 0x76, 0x7d, 0x8f, 0xd8, 0xc2, 0x8b, 0x19, 0xad,
	0x38, 0x50, 0x17, 0x40, 0x71, 0xd5, 0x89, 0xb7, 0x2c, 0xa5, 0xde, 0x32, 0x7a, 0x05, 0x95, 0x09,
	0xf7, 0x82, 0x2b, 0xaf, 0x6f, 0xbd, 0x95, 0x8d, 0x48, 0xca, 0x53, 0x5d, 0x1c, 0x51, 0x7e, 0x94,
	0x60, 0x2d, 0xaa, 0xd3, 0x51, 0x23, 0x10, 0x26, 0x59, 0x6e, 0x3d, 0x81, 0xea, 0x34, 0xc0, 0xf4,
	0x90, 0x44, 0xfd, 0xa8, 0xa8, 0x57, 0xa6, 0xd1, 0xad, 0xca, 0x50, 0x1b, 0x5b, 0xde, 0x68, 0x6a,
	0x8d, 0x62, 0x34, 0x67, 0x34, 0x6a, 0x03, 0x74, 0x88, 0x15, 0x46, 0xa9, 0xc6, 0x63, 0xba, 0x52,
	0x4e, 0x26, 0x0e, 0x29, 0xbf, 0xe6, 0xb8, 0xb4, 0xdc, 0xed, 0xab, 0x50, 0xb7, 0x2e, 0xe0, 0x14,
	0x50, 0xe5, 0x78, 0x96, 0xc0, 0x5d, 0x4f, 0x9e, 0x62, 0x99, 0xf9, 0x34, 0x72, 0x6d, 0x3b, 0xb4,
	0x99, 0xb3, 0x71, 0x0b, 0x4a, 0xc0, 0xb6, 0xd4, 0x93, 0x6c, 0x01, 0x24, 0x9a, 0xb4, 0x68, 0xf4,
	0x89, 0x16, 0xcd, 0x3b, 0x61, 0x51, 0x74, 0x42, 0x96, 0x13, 0x51, 0x82, 0x05, 0xcd, 0xd2, 0x7a,
	0x91, 0xe5, 0x84, 0x20, 0x95, 0xdf, 0xde, 0xe4, 0xe8, 0x72, 0x60, 0x26, 0x26, 0x9f, 0x42, 0x7a,
	0xf2, 0x51, 0x60, 0x55, 0xc7, 0x0e, 0xc6, 0xae, 0x61, 0x53, 0x32, 0x09, 0x45, 0x56, 0xa7, 0x78,
	0xca, 0xdf, 0x33, 0xe7, 0xba, 0xe1, 0x51, 0x0e, 0x8a, 0x4d, 0xa8, 0xda, 0x4c, 0xc4, 0xa7, 0x71,
	0xba, 0x0b, 0x92, 0xed, 0x4c, 0xa2, 0xf1, 0x20, 0xb6, 0x2d, 0xc8, 0x39, 0x70, 0xd6, 0xa0, 0xb2,
	0x77, 0xe2, 0x61, 0x1a, 0x63, 0x23, 0x28, 0x3e, 0x67, 0x61, 0x31, 0x67, 0x95, 0xc5, 0x9c, 0x85,
	0x33, 0xe7, 0xac, 0xca, 0xc2, 0x9c, 0x95, 0xbe, 0x9e, 0xea, 0xfc, 0xf5, 0x28, 0x93, 0x37, 0x04,
	0x76, 0xfb, 0x83, 0xca, 0x10, 0xee, 0x8b, 0xc1, 0x72, 0x56, 0x84, 0xd6, 0xa1, 0x8e, 0x2f, 0x58,
	0x02, 0xbe, 0x24, 0x2b, 0xf9, 0xb2, 0x0b, 0xa9, 0x97, 0x9d, 0x28, 0x32, 0xc5, 0xf4, 0xc0, 0xf0,
	0x53, 0x01, 0x9e, 0xb1, 0x6e, 0x37, 0x97, 0x4e, 0xb7, 0xd9, 0x69, 0x65, 0xa8, 0xc5, 0xbd, 0x27,
	0x2e, 0x2b, 0x31, 0xcd, 0x2e, 0x33, 0xea, 0x1b, 0xc2, 0x2f, 0x41, 0x25, 0x5a, 0x48, 0x29, 0x35,
	0x94, 0xce, 0xa7, 0x61, 0x79, 0x31, 0x0d, 0xd1, 0x27, 0x50, 0x8d, 0xf0, 0x08, 0x9a, 0x15, 0x3e,
	0x90, 0xbe, 0x9d, 0x73, 0x13, 0x69, 0x7c, 0xf5, 0xf8, 0x94, 0xf2, 0xbd, 0xc0, 0x64, 0xee, 0xb2,
	0x6f, 0x79, 0xfa, 0x50, 0x7d, 0x2f, 0x01, 0x49, 0x4c, 0x5e, 0x1b, 0x11, 0x19, 0x6a, 0x07, 0x46,
	0xc7, 0xe4, 0x27, 0x22, 0x34, 0x66, 0xf4, 0xf2, 0x48, 0x10, 0x90, 0x19, 0x10, 0x59, 0x08, 0x2c,
	0xdd, 0xb3, 0xcd, 0x53, 0x56, 0x64, 0xd8, 0x0b, 0x66, 0xcb, 0x8d, 0x2d, 0xa8, 0x27, 0x90, 0x42,
	0x55, 0x28, 0x6e, 0x9b, 0x6a, 0xe3, 0x0e, 0x5b, 0xec, 0x98, 0x6a, 0x43, 0x62, 0x8b, 0xae, 0xf9,
	0x69, 0xa3, 0x80, 0x6a, 0x50, 0x62, 0x11, 0x36, 0x8a, 0x1b, 0xdf, 0x49, 0xb0, 0x32, 0x53, 0x8e,
	0xea, 0x50, 0x35, 0x0e, 0x54, 0xb5, 0x6b, 0x18, 0x8d, 0x3b, 0x08, 0xa0, 0xd2, 0x6b, 0x6b, 0x3b,
	0xdd, 0x4e, 0x43, 0x42, 0x0d, 0x58, 0xd5, 0xfa, 0xc6, 0x41, 0xaf, 0xa7, 0xa9, 0x5a, 0xb7, 0x6f,
	0x36, 0x0a, 0xe8, 0x7f, 0xf0, 0xd8, 0xd4, 0xdb, 0x7d, 0xa3, 0xad, 0x9a, 0xda, 0x5e, 0xff, 0xb0,
	0xbf, 0x67, 0x1e, 0x76, 0xbf, 0xd4, 0x0c, 0xb3, 0x51, 0x64, 0x5b, 0x49, 0xe1, 0x43, 0x2e, 0xd7,
	0xeb, 0x76, 0x1b, 0x25, 0xf4, 0x10, 0xee, 0x6b, 0xfd, 0xcf, 0xdb, 0x3b, 0x5a, 0xe7, 0xb0, 0xdd,
	0xe9, 0xe8, 0xcc, 0x50, 0x79, 0xeb, 0x67, 0x80, 0xbb, 0x06, 0x8f, 0x93, 0xfd, 0x12, 0x1b, 0xa3,
	0x00, 0x1e, 0x66, 0xb4, 0x39, 0xf4, 0x5e, 0x36, 0x38, 0xd9, 0x4d, 0x5a, 0xbe, 0x86, 0x74, 0x30,
	0x51, 0xee, 0xa0, 0x63, 0x3e, 0xf8, 0x2f, 0x8c, 0x56, 0xe8, 0xfd, 0x6c, 0x3d, 0x39, 0x73, 0xa7,
	0x7c, 0x1d, 0x71, 0x6e, 0x77, 0x02, 0x68, 0x71, 0x58, 0x46, 0xef, 0x66, 0xab, 0xc9, 0x1c, 0xe3,
	0xe5, 0xab, 0x0b, 0x73, 0x8b, 0xdf, 0xc2, 0x93, 0x9c, 0xaf, 0x0f, 0xf4, 0x41, 0x0e, 0x68, 0xb9,
	0x1f, 0x2b, 0xf2, 0x35, 0x4f, 0x70, 0x07, 0x5c, 0x78, 0xb0, 0xf0, 0x8d, 0x85, 0x36, 0x72, 0x81,
	0x5b, 0xf8, 0xf6, 0x93, 0xaf, 0x2c, 0xcb, 0xcd, 0xfd, 0x20, 0x41, 0xeb, 0xf2, 0x0a, 0x8d, 0x5e,
	0xe6, 0x23, 0x78, 0x69, 0x5d, 0xcf, 0x0b, 0x3f, 0xff, 0xcd, 0x27, 0xfc, 0xc9, 0xaf, 0x8e, 0x97,
	0xf9, 0x73, 0x69, 0x4d, 0xbd, 0x91, 0x3f, 0xbf, 0x48, 0xa0, 0x64, 0x8e, 0x44, 0xe9, 0xe7, 0xf7,
	0xd1, 0x65, 0x0f, 0x2a, 0x77, 0xea, 0x93, 0x6f, 0x72, 0x6c, 0xce, 0xad, 0xb9, 0x90, 0xaf, 0xe1,
	0x56, 0xee, 0x18, 0x25, 0xdf, 0xe4, 0x18, 0x77, 0xcb, 0x81, 0x7b, 0xe9, 0x3f, 0x59, 0xd0, 0x3b,
	0x79, 0x6d, 0x6b, 0xee, 0x8f, 0x2c, 0xf9, 0x6a, 0x82, 0xcc, 0xca, 0xf6, 0xea, 0x9f, 0xe7, 0x2d,
	0xe9, 0xaf, 0xf3, 0x96, 0xf4, 0xcf, 0x79, 0x4b, 0x1a, 0x54, 0xf8, 0x7f, 0x6f, 0x1f, 0xfe, 0x17,
	0x00, 0x00, 0xff, 0xff, 0xaf, 0xf3, 0x7a, 0xec, 0xd1, 0x13, 0x00, 0x00,
}
