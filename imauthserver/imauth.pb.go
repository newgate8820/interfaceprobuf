// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imauthserver/imauth.proto

/*
Package imauthserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/imauthserver/imauth.proto

It has these top-level messages:

	AuthMTPReply
	Context
	AuthMTPRequest
	AccountMTPRequest
	AccountMTPReply
	PasswordReq
	VirtualPhoneNumberInfo
	ExtraContext
	ExtraReply
	RobotSignUpRequest
	RobotSignUpReply
	UserPasswordRequest
	UserPasswordReply
*/
package imauthserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type RobotSignUpReply_ResultCode int32

const (
	RobotSignUpReply_Success             RobotSignUpReply_ResultCode = 0
	RobotSignUpReply_InternalError       RobotSignUpReply_ResultCode = 1
	RobotSignUpReply_PhoneNumberInvalid  RobotSignUpReply_ResultCode = 2
	RobotSignUpReply_PhoneNumberOccupied RobotSignUpReply_ResultCode = 3
	RobotSignUpReply_CaptchaExpired      RobotSignUpReply_ResultCode = 4
	RobotSignUpReply_CaptchaInvalid      RobotSignUpReply_ResultCode = 5
	RobotSignUpReply_FloodWait           RobotSignUpReply_ResultCode = 6
	RobotSignUpReply_SignUpRobotBlocked  RobotSignUpReply_ResultCode = 7
)

var RobotSignUpReply_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
	2: "PhoneNumberInvalid",
	3: "PhoneNumberOccupied",
	4: "CaptchaExpired",
	5: "CaptchaInvalid",
	6: "FloodWait",
	7: "SignUpRobotBlocked",
}
var RobotSignUpReply_ResultCode_value = map[string]int32{
	"Success":             0,
	"InternalError":       1,
	"PhoneNumberInvalid":  2,
	"PhoneNumberOccupied": 3,
	"CaptchaExpired":      4,
	"CaptchaInvalid":      5,
	"FloodWait":           6,
	"SignUpRobotBlocked":  7,
}

func (x RobotSignUpReply_ResultCode) String() string {
	return proto.EnumName(RobotSignUpReply_ResultCode_name, int32(x))
}
func (RobotSignUpReply_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImauth, []int{10, 0}
}

type UserPasswordReply_Code int32

const (
	UserPasswordReply_Success  UserPasswordReply_Code = 0
	UserPasswordReply_NotFound UserPasswordReply_Code = 1
)

var UserPasswordReply_Code_name = map[int32]string{
	0: "Success",
	1: "NotFound",
}
var UserPasswordReply_Code_value = map[string]int32{
	"Success":  0,
	"NotFound": 1,
}

func (x UserPasswordReply_Code) String() string {
	return proto.EnumName(UserPasswordReply_Code_name, int32(x))
}
func (UserPasswordReply_Code) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImauth, []int{12, 0}
}

type AuthMTPReply struct {
	RpcResult []byte      `protobuf:"bytes,1,opt,name=rpc_result,json=rpcResult,proto3" json:"rpc_result,omitempty"`
	Extra     *ExtraReply `protobuf:"bytes,2,opt,name=extra" json:"extra,omitempty"`
}

func (m *AuthMTPReply) Reset()                    { *m = AuthMTPReply{} }
func (m *AuthMTPReply) String() string            { return proto.CompactTextString(m) }
func (*AuthMTPReply) ProtoMessage()               {}
func (*AuthMTPReply) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{0} }

func (m *AuthMTPReply) GetRpcResult() []byte {
	if m != nil {
		return m.RpcResult
	}
	return nil
}

func (m *AuthMTPReply) GetExtra() *ExtraReply {
	if m != nil {
		return m.Extra
	}
	return nil
}

type Context struct {
	UserId       int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId    int64         `protobuf:"varint,2,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	ReqMessageId int64         `protobuf:"varint,3,opt,name=req_message_id,json=reqMessageId,proto3" json:"req_message_id,omitempty"`
	Layer        int64         `protobuf:"varint,4,opt,name=layer,proto3" json:"layer,omitempty"`
	Extra        *ExtraContext `protobuf:"bytes,5,opt,name=extra" json:"extra,omitempty"`
	Crc32        uint32        `protobuf:"varint,6,opt,name=crc32,proto3" json:"crc32,omitempty"`
}

func (m *Context) Reset()                    { *m = Context{} }
func (m *Context) String() string            { return proto.CompactTextString(m) }
func (*Context) ProtoMessage()               {}
func (*Context) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{1} }

func (m *Context) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Context) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *Context) GetReqMessageId() int64 {
	if m != nil {
		return m.ReqMessageId
	}
	return 0
}

func (m *Context) GetLayer() int64 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *Context) GetExtra() *ExtraContext {
	if m != nil {
		return m.Extra
	}
	return nil
}

func (m *Context) GetCrc32() uint32 {
	if m != nil {
		return m.Crc32
	}
	return 0
}

type AuthMTPRequest struct {
	Ctx           *Context      `protobuf:"bytes,1,opt,name=ctx" json:"ctx,omitempty"`
	MessageObjBin []byte        `protobuf:"bytes,2,opt,name=message_obj_bin,json=messageObjBin,proto3" json:"message_obj_bin,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *AuthMTPRequest) Reset()                    { *m = AuthMTPRequest{} }
func (m *AuthMTPRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthMTPRequest) ProtoMessage()               {}
func (*AuthMTPRequest) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{2} }

func (m *AuthMTPRequest) GetCtx() *Context {
	if m != nil {
		return m.Ctx
	}
	return nil
}

func (m *AuthMTPRequest) GetMessageObjBin() []byte {
	if m != nil {
		return m.MessageObjBin
	}
	return nil
}

func (m *AuthMTPRequest) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type AccountMTPRequest struct {
	Ctx           *Context      `protobuf:"bytes,1,opt,name=ctx" json:"ctx,omitempty"`
	MessageObjBin []byte        `protobuf:"bytes,2,opt,name=message_obj_bin,json=messageObjBin,proto3" json:"message_obj_bin,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *AccountMTPRequest) Reset()                    { *m = AccountMTPRequest{} }
func (m *AccountMTPRequest) String() string            { return proto.CompactTextString(m) }
func (*AccountMTPRequest) ProtoMessage()               {}
func (*AccountMTPRequest) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{3} }

func (m *AccountMTPRequest) GetCtx() *Context {
	if m != nil {
		return m.Ctx
	}
	return nil
}

func (m *AccountMTPRequest) GetMessageObjBin() []byte {
	if m != nil {
		return m.MessageObjBin
	}
	return nil
}

func (m *AccountMTPRequest) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type AccountMTPReply struct {
	RpcResult []byte `protobuf:"bytes,1,opt,name=rpc_result,json=rpcResult,proto3" json:"rpc_result,omitempty"`
}

func (m *AccountMTPReply) Reset()                    { *m = AccountMTPReply{} }
func (m *AccountMTPReply) String() string            { return proto.CompactTextString(m) }
func (*AccountMTPReply) ProtoMessage()               {}
func (*AccountMTPReply) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{4} }

func (m *AccountMTPReply) GetRpcResult() []byte {
	if m != nil {
		return m.RpcResult
	}
	return nil
}

type PasswordReq struct {
	UserId      int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId       int64  `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Flags       int32  `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`
	CurrPwdHash []byte `protobuf:"bytes,4,opt,name=curr_pwd_hash,json=currPwdHash,proto3" json:"curr_pwd_hash,omitempty"`
	NewPwdHash  []byte `protobuf:"bytes,5,opt,name=new_pwd_hash,json=newPwdHash,proto3" json:"new_pwd_hash,omitempty"`
	Salt        []byte `protobuf:"bytes,6,opt,name=salt,proto3" json:"salt,omitempty"`
	Hint        string `protobuf:"bytes,7,opt,name=hint,proto3" json:"hint,omitempty"`
	Email       string `protobuf:"bytes,8,opt,name=email,proto3" json:"email,omitempty"`
	ReqType     int32  `protobuf:"varint,9,opt,name=req_type,json=reqType,proto3" json:"req_type,omitempty"`
}

func (m *PasswordReq) Reset()                    { *m = PasswordReq{} }
func (m *PasswordReq) String() string            { return proto.CompactTextString(m) }
func (*PasswordReq) ProtoMessage()               {}
func (*PasswordReq) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{5} }

func (m *PasswordReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PasswordReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *PasswordReq) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PasswordReq) GetCurrPwdHash() []byte {
	if m != nil {
		return m.CurrPwdHash
	}
	return nil
}

func (m *PasswordReq) GetNewPwdHash() []byte {
	if m != nil {
		return m.NewPwdHash
	}
	return nil
}

func (m *PasswordReq) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *PasswordReq) GetHint() string {
	if m != nil {
		return m.Hint
	}
	return ""
}

func (m *PasswordReq) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *PasswordReq) GetReqType() int32 {
	if m != nil {
		return m.ReqType
	}
	return 0
}

type VirtualPhoneNumberInfo struct {
	VirtualPhone     string `protobuf:"bytes,1,opt,name=virtual_phone,json=virtualPhone,proto3" json:"virtual_phone,omitempty"`
	RealPhone        string `protobuf:"bytes,2,opt,name=real_phone,json=realPhone,proto3" json:"real_phone,omitempty"`
	Activated        uint32 `protobuf:"varint,3,opt,name=activated,proto3" json:"activated,omitempty"`
	BindTime         int64  `protobuf:"varint,4,opt,name=bind_time,json=bindTime,proto3" json:"bind_time,omitempty"`
	ActivateTime     int64  `protobuf:"varint,5,opt,name=activate_time,json=activateTime,proto3" json:"activate_time,omitempty"`
	ActivateAdminId  int32  `protobuf:"varint,6,opt,name=activate_admin_id,json=activateAdminId,proto3" json:"activate_admin_id,omitempty"`
	BindAdminId      int32  `protobuf:"varint,7,opt,name=bind_admin_id,json=bindAdminId,proto3" json:"bind_admin_id,omitempty"`
	OwnerId          int32  `protobuf:"varint,8,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	InitialPhoneCode string `protobuf:"bytes,9,opt,name=initial_phone_code,json=initialPhoneCode,proto3" json:"initial_phone_code,omitempty"`
}

func (m *VirtualPhoneNumberInfo) Reset()                    { *m = VirtualPhoneNumberInfo{} }
func (m *VirtualPhoneNumberInfo) String() string            { return proto.CompactTextString(m) }
func (*VirtualPhoneNumberInfo) ProtoMessage()               {}
func (*VirtualPhoneNumberInfo) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{6} }

func (m *VirtualPhoneNumberInfo) GetVirtualPhone() string {
	if m != nil {
		return m.VirtualPhone
	}
	return ""
}

func (m *VirtualPhoneNumberInfo) GetRealPhone() string {
	if m != nil {
		return m.RealPhone
	}
	return ""
}

func (m *VirtualPhoneNumberInfo) GetActivated() uint32 {
	if m != nil {
		return m.Activated
	}
	return 0
}

func (m *VirtualPhoneNumberInfo) GetBindTime() int64 {
	if m != nil {
		return m.BindTime
	}
	return 0
}

func (m *VirtualPhoneNumberInfo) GetActivateTime() int64 {
	if m != nil {
		return m.ActivateTime
	}
	return 0
}

func (m *VirtualPhoneNumberInfo) GetActivateAdminId() int32 {
	if m != nil {
		return m.ActivateAdminId
	}
	return 0
}

func (m *VirtualPhoneNumberInfo) GetBindAdminId() int32 {
	if m != nil {
		return m.BindAdminId
	}
	return 0
}

func (m *VirtualPhoneNumberInfo) GetOwnerId() int32 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *VirtualPhoneNumberInfo) GetInitialPhoneCode() string {
	if m != nil {
		return m.InitialPhoneCode
	}
	return ""
}

type ExtraContext struct {
	DeviceModel   string `protobuf:"bytes,1,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	ClientAddress string `protobuf:"bytes,2,opt,name=client_address,json=clientAddress,proto3" json:"client_address,omitempty"`
}

func (m *ExtraContext) Reset()                    { *m = ExtraContext{} }
func (m *ExtraContext) String() string            { return proto.CompactTextString(m) }
func (*ExtraContext) ProtoMessage()               {}
func (*ExtraContext) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{7} }

func (m *ExtraContext) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *ExtraContext) GetClientAddress() string {
	if m != nil {
		return m.ClientAddress
	}
	return ""
}

type ExtraReply struct {
	SigninOk                  bool   `protobuf:"varint,1,opt,name=signin_ok,json=signinOk,proto3" json:"signin_ok,omitempty"`
	UserId                    int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PhoneNumber               string `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	GroupId                   int32  `protobuf:"varint,4,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	PasswordNeeded            bool   `protobuf:"varint,5,opt,name=password_needed,json=passwordNeeded,proto3" json:"password_needed,omitempty"`
	LogOutOk                  bool   `protobuf:"varint,6,opt,name=log_out_ok,json=logOutOk,proto3" json:"log_out_ok,omitempty"`
	RequestPasswordRecoveryOk bool   `protobuf:"varint,7,opt,name=request_password_recovery_ok,json=requestPasswordRecoveryOk,proto3" json:"request_password_recovery_ok,omitempty"`
}

func (m *ExtraReply) Reset()                    { *m = ExtraReply{} }
func (m *ExtraReply) String() string            { return proto.CompactTextString(m) }
func (*ExtraReply) ProtoMessage()               {}
func (*ExtraReply) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{8} }

func (m *ExtraReply) GetSigninOk() bool {
	if m != nil {
		return m.SigninOk
	}
	return false
}

func (m *ExtraReply) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ExtraReply) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *ExtraReply) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ExtraReply) GetPasswordNeeded() bool {
	if m != nil {
		return m.PasswordNeeded
	}
	return false
}

func (m *ExtraReply) GetLogOutOk() bool {
	if m != nil {
		return m.LogOutOk
	}
	return false
}

func (m *ExtraReply) GetRequestPasswordRecoveryOk() bool {
	if m != nil {
		return m.RequestPasswordRecoveryOk
	}
	return false
}

type RobotSignUpRequest struct {
	PhoneNumber    string        `protobuf:"bytes,1,opt,name=PhoneNumber,proto3" json:"PhoneNumber,omitempty"`
	PhoneCodeHash  string        `protobuf:"bytes,2,opt,name=PhoneCodeHash,proto3" json:"PhoneCodeHash,omitempty"`
	PhoneCode      string        `protobuf:"bytes,3,opt,name=PhoneCode,proto3" json:"PhoneCode,omitempty"`
	KeyId          int64         `protobuf:"varint,5,opt,name=keyId,proto3" json:"keyId,omitempty"`
	FirstName      string        `protobuf:"bytes,6,opt,name=FirstName,proto3" json:"FirstName,omitempty"`
	LastName       string        `protobuf:"bytes,7,opt,name=LastName,proto3" json:"LastName,omitempty"`
	IsBot          bool          `protobuf:"varint,8,opt,name=is_bot,json=isBot,proto3" json:"is_bot,omitempty"`
	BotInfoVersion int32         `protobuf:"varint,9,opt,name=bot_info_version,json=botInfoVersion,proto3" json:"bot_info_version,omitempty"`
	BotChatHistory bool          `protobuf:"varint,10,opt,name=bot_chat_history,json=botChatHistory,proto3" json:"bot_chat_history,omitempty"`
	BotNoChats     bool          `protobuf:"varint,11,opt,name=bot_no_chats,json=botNoChats,proto3" json:"bot_no_chats,omitempty"`
	DcId           int32         `protobuf:"varint,12,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	Debug          *pbcomm.Debug `protobuf:"bytes,13,opt,name=debug" json:"debug,omitempty"`
	CountryCode    string        `protobuf:"bytes,14,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	LocalPhone     string        `protobuf:"bytes,15,opt,name=local_phone,json=localPhone,proto3" json:"local_phone,omitempty"`
}

func (m *RobotSignUpRequest) Reset()                    { *m = RobotSignUpRequest{} }
func (m *RobotSignUpRequest) String() string            { return proto.CompactTextString(m) }
func (*RobotSignUpRequest) ProtoMessage()               {}
func (*RobotSignUpRequest) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{9} }

func (m *RobotSignUpRequest) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *RobotSignUpRequest) GetPhoneCodeHash() string {
	if m != nil {
		return m.PhoneCodeHash
	}
	return ""
}

func (m *RobotSignUpRequest) GetPhoneCode() string {
	if m != nil {
		return m.PhoneCode
	}
	return ""
}

func (m *RobotSignUpRequest) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *RobotSignUpRequest) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *RobotSignUpRequest) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *RobotSignUpRequest) GetIsBot() bool {
	if m != nil {
		return m.IsBot
	}
	return false
}

func (m *RobotSignUpRequest) GetBotInfoVersion() int32 {
	if m != nil {
		return m.BotInfoVersion
	}
	return 0
}

func (m *RobotSignUpRequest) GetBotChatHistory() bool {
	if m != nil {
		return m.BotChatHistory
	}
	return false
}

func (m *RobotSignUpRequest) GetBotNoChats() bool {
	if m != nil {
		return m.BotNoChats
	}
	return false
}

func (m *RobotSignUpRequest) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *RobotSignUpRequest) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *RobotSignUpRequest) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *RobotSignUpRequest) GetLocalPhone() string {
	if m != nil {
		return m.LocalPhone
	}
	return ""
}

type RobotSignUpReply struct {
	Code     RobotSignUpReply_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imauthserver.RobotSignUpReply_ResultCode" json:"code,omitempty"`
	UserInfo []byte                      `protobuf:"bytes,2,opt,name=user_info,json=userInfo,proto3" json:"user_info,omitempty"`
}

func (m *RobotSignUpReply) Reset()                    { *m = RobotSignUpReply{} }
func (m *RobotSignUpReply) String() string            { return proto.CompactTextString(m) }
func (*RobotSignUpReply) ProtoMessage()               {}
func (*RobotSignUpReply) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{10} }

func (m *RobotSignUpReply) GetCode() RobotSignUpReply_ResultCode {
	if m != nil {
		return m.Code
	}
	return RobotSignUpReply_Success
}

func (m *RobotSignUpReply) GetUserInfo() []byte {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

type UserPasswordRequest struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *UserPasswordRequest) Reset()                    { *m = UserPasswordRequest{} }
func (m *UserPasswordRequest) String() string            { return proto.CompactTextString(m) }
func (*UserPasswordRequest) ProtoMessage()               {}
func (*UserPasswordRequest) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{11} }

func (m *UserPasswordRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UserPasswordReply struct {
	PasswordHash []byte                 `protobuf:"bytes,1,opt,name=password_hash,json=passwordHash,proto3" json:"password_hash,omitempty"`
	Hint         string                 `protobuf:"bytes,2,opt,name=hint,proto3" json:"hint,omitempty"`
	Email        string                 `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	Status       int32                  `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
	Code         UserPasswordReply_Code `protobuf:"varint,5,opt,name=code,proto3,enum=imauthserver.UserPasswordReply_Code" json:"code,omitempty"`
}

func (m *UserPasswordReply) Reset()                    { *m = UserPasswordReply{} }
func (m *UserPasswordReply) String() string            { return proto.CompactTextString(m) }
func (*UserPasswordReply) ProtoMessage()               {}
func (*UserPasswordReply) Descriptor() ([]byte, []int) { return fileDescriptorImauth, []int{12} }

func (m *UserPasswordReply) GetPasswordHash() []byte {
	if m != nil {
		return m.PasswordHash
	}
	return nil
}

func (m *UserPasswordReply) GetHint() string {
	if m != nil {
		return m.Hint
	}
	return ""
}

func (m *UserPasswordReply) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *UserPasswordReply) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *UserPasswordReply) GetCode() UserPasswordReply_Code {
	if m != nil {
		return m.Code
	}
	return UserPasswordReply_Success
}

func init() {
	proto.RegisterType((*AuthMTPReply)(nil), "imauthserver.AuthMTPReply")
	proto.RegisterType((*Context)(nil), "imauthserver.Context")
	proto.RegisterType((*AuthMTPRequest)(nil), "imauthserver.AuthMTPRequest")
	proto.RegisterType((*AccountMTPRequest)(nil), "imauthserver.AccountMTPRequest")
	proto.RegisterType((*AccountMTPReply)(nil), "imauthserver.AccountMTPReply")
	proto.RegisterType((*PasswordReq)(nil), "imauthserver.PasswordReq")
	proto.RegisterType((*VirtualPhoneNumberInfo)(nil), "imauthserver.VirtualPhoneNumberInfo")
	proto.RegisterType((*ExtraContext)(nil), "imauthserver.ExtraContext")
	proto.RegisterType((*ExtraReply)(nil), "imauthserver.ExtraReply")
	proto.RegisterType((*RobotSignUpRequest)(nil), "imauthserver.RobotSignUpRequest")
	proto.RegisterType((*RobotSignUpReply)(nil), "imauthserver.RobotSignUpReply")
	proto.RegisterType((*UserPasswordRequest)(nil), "imauthserver.UserPasswordRequest")
	proto.RegisterType((*UserPasswordReply)(nil), "imauthserver.UserPasswordReply")
	proto.RegisterEnum("imauthserver.RobotSignUpReply_ResultCode", RobotSignUpReply_ResultCode_name, RobotSignUpReply_ResultCode_value)
	proto.RegisterEnum("imauthserver.UserPasswordReply_Code", UserPasswordReply_Code_name, UserPasswordReply_Code_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AuthServer service

type AuthServerClient interface {
	CheckPhone(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	SendCode(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	SignUp(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	SignIn(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	LogOut(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	ResetAuthorizations(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	SendInvites(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	ExportAuthorization(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	ImportAuthorization(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	BindTempAuthKey(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	ImportBotAuthorization(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	CheckPassword(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	RequestPasswordRecovery(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	RecoverPassword(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	ResendCode(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	CancelCode(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	DropTempAuthKey(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error)
	// internal rpc
	RobotSignUp(ctx context.Context, in *RobotSignUpRequest, opts ...grpc.CallOption) (*RobotSignUpReply, error)
}

type authServerClient struct {
	cc *grpc.ClientConn
}

func NewAuthServerClient(cc *grpc.ClientConn) AuthServerClient {
	return &authServerClient{cc}
}

func (c *authServerClient) CheckPhone(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/CheckPhone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) SendCode(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/SendCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) SignUp(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/SignUp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) SignIn(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/SignIn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) LogOut(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/LogOut", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) ResetAuthorizations(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/ResetAuthorizations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) SendInvites(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/SendInvites", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) ExportAuthorization(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/ExportAuthorization", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) ImportAuthorization(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/ImportAuthorization", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) BindTempAuthKey(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/BindTempAuthKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) ImportBotAuthorization(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/ImportBotAuthorization", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) CheckPassword(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/CheckPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) RequestPasswordRecovery(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/RequestPasswordRecovery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) RecoverPassword(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/RecoverPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) ResendCode(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/ResendCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) CancelCode(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/CancelCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) DropTempAuthKey(ctx context.Context, in *AuthMTPRequest, opts ...grpc.CallOption) (*AuthMTPReply, error) {
	out := new(AuthMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/DropTempAuthKey", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServerClient) RobotSignUp(ctx context.Context, in *RobotSignUpRequest, opts ...grpc.CallOption) (*RobotSignUpReply, error) {
	out := new(RobotSignUpReply)
	err := grpc.Invoke(ctx, "/imauthserver.AuthServer/RobotSignUp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AuthServer service

type AuthServerServer interface {
	CheckPhone(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	SendCode(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	SignUp(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	SignIn(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	LogOut(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	ResetAuthorizations(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	SendInvites(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	ExportAuthorization(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	ImportAuthorization(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	BindTempAuthKey(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	ImportBotAuthorization(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	CheckPassword(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	RequestPasswordRecovery(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	RecoverPassword(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	ResendCode(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	CancelCode(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	DropTempAuthKey(context.Context, *AuthMTPRequest) (*AuthMTPReply, error)
	// internal rpc
	RobotSignUp(context.Context, *RobotSignUpRequest) (*RobotSignUpReply, error)
}

func RegisterAuthServerServer(s *grpc.Server, srv AuthServerServer) {
	s.RegisterService(&_AuthServer_serviceDesc, srv)
}

func _AuthServer_CheckPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).CheckPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/CheckPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).CheckPhone(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_SendCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).SendCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/SendCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).SendCode(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_SignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).SignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/SignUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).SignUp(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_SignIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).SignIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/SignIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).SignIn(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_LogOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).LogOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/LogOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).LogOut(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_ResetAuthorizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).ResetAuthorizations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/ResetAuthorizations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).ResetAuthorizations(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_SendInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).SendInvites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/SendInvites",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).SendInvites(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_ExportAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).ExportAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/ExportAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).ExportAuthorization(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_ImportAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).ImportAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/ImportAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).ImportAuthorization(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_BindTempAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).BindTempAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/BindTempAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).BindTempAuthKey(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_ImportBotAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).ImportBotAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/ImportBotAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).ImportBotAuthorization(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_CheckPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).CheckPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/CheckPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).CheckPassword(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_RequestPasswordRecovery_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).RequestPasswordRecovery(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/RequestPasswordRecovery",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).RequestPasswordRecovery(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_RecoverPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).RecoverPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/RecoverPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).RecoverPassword(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_ResendCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).ResendCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/ResendCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).ResendCode(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_CancelCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).CancelCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/CancelCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).CancelCode(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_DropTempAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).DropTempAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/DropTempAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).DropTempAuthKey(ctx, req.(*AuthMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthServer_RobotSignUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RobotSignUpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServerServer).RobotSignUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AuthServer/RobotSignUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServerServer).RobotSignUp(ctx, req.(*RobotSignUpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imauthserver.AuthServer",
	HandlerType: (*AuthServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckPhone",
			Handler:    _AuthServer_CheckPhone_Handler,
		},
		{
			MethodName: "SendCode",
			Handler:    _AuthServer_SendCode_Handler,
		},
		{
			MethodName: "SignUp",
			Handler:    _AuthServer_SignUp_Handler,
		},
		{
			MethodName: "SignIn",
			Handler:    _AuthServer_SignIn_Handler,
		},
		{
			MethodName: "LogOut",
			Handler:    _AuthServer_LogOut_Handler,
		},
		{
			MethodName: "ResetAuthorizations",
			Handler:    _AuthServer_ResetAuthorizations_Handler,
		},
		{
			MethodName: "SendInvites",
			Handler:    _AuthServer_SendInvites_Handler,
		},
		{
			MethodName: "ExportAuthorization",
			Handler:    _AuthServer_ExportAuthorization_Handler,
		},
		{
			MethodName: "ImportAuthorization",
			Handler:    _AuthServer_ImportAuthorization_Handler,
		},
		{
			MethodName: "BindTempAuthKey",
			Handler:    _AuthServer_BindTempAuthKey_Handler,
		},
		{
			MethodName: "ImportBotAuthorization",
			Handler:    _AuthServer_ImportBotAuthorization_Handler,
		},
		{
			MethodName: "CheckPassword",
			Handler:    _AuthServer_CheckPassword_Handler,
		},
		{
			MethodName: "RequestPasswordRecovery",
			Handler:    _AuthServer_RequestPasswordRecovery_Handler,
		},
		{
			MethodName: "RecoverPassword",
			Handler:    _AuthServer_RecoverPassword_Handler,
		},
		{
			MethodName: "ResendCode",
			Handler:    _AuthServer_ResendCode_Handler,
		},
		{
			MethodName: "CancelCode",
			Handler:    _AuthServer_CancelCode_Handler,
		},
		{
			MethodName: "DropTempAuthKey",
			Handler:    _AuthServer_DropTempAuthKey_Handler,
		},
		{
			MethodName: "RobotSignUp",
			Handler:    _AuthServer_RobotSignUp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imauthserver/imauth.proto",
}

// Client API for AccountServer service

type AccountServerClient interface {
	GetPassword(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error)
	GetPasswordSettings(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error)
	UpdatePasswordSettings(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error)
	SendUpdatePasswordSettingsCode(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error)
	PTAccountUpdatePasswordSettings(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error)
	ResetAuthroization(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error)
	GetAuthorizations(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error)
	// internal rpc
	UserPassword(ctx context.Context, in *UserPasswordRequest, opts ...grpc.CallOption) (*UserPasswordReply, error)
}

type accountServerClient struct {
	cc *grpc.ClientConn
}

func NewAccountServerClient(cc *grpc.ClientConn) AccountServerClient {
	return &accountServerClient{cc}
}

func (c *accountServerClient) GetPassword(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error) {
	out := new(AccountMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/GetPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServerClient) GetPasswordSettings(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error) {
	out := new(AccountMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/GetPasswordSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServerClient) UpdatePasswordSettings(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error) {
	out := new(AccountMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/UpdatePasswordSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServerClient) SendUpdatePasswordSettingsCode(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error) {
	out := new(AccountMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/SendUpdatePasswordSettingsCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServerClient) PTAccountUpdatePasswordSettings(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error) {
	out := new(AccountMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/PTAccountUpdatePasswordSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServerClient) ResetAuthroization(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error) {
	out := new(AccountMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/ResetAuthroization", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServerClient) GetAuthorizations(ctx context.Context, in *AccountMTPRequest, opts ...grpc.CallOption) (*AccountMTPReply, error) {
	out := new(AccountMTPReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/GetAuthorizations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountServerClient) UserPassword(ctx context.Context, in *UserPasswordRequest, opts ...grpc.CallOption) (*UserPasswordReply, error) {
	out := new(UserPasswordReply)
	err := grpc.Invoke(ctx, "/imauthserver.AccountServer/UserPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AccountServer service

type AccountServerServer interface {
	GetPassword(context.Context, *AccountMTPRequest) (*AccountMTPReply, error)
	GetPasswordSettings(context.Context, *AccountMTPRequest) (*AccountMTPReply, error)
	UpdatePasswordSettings(context.Context, *AccountMTPRequest) (*AccountMTPReply, error)
	SendUpdatePasswordSettingsCode(context.Context, *AccountMTPRequest) (*AccountMTPReply, error)
	PTAccountUpdatePasswordSettings(context.Context, *AccountMTPRequest) (*AccountMTPReply, error)
	ResetAuthroization(context.Context, *AccountMTPRequest) (*AccountMTPReply, error)
	GetAuthorizations(context.Context, *AccountMTPRequest) (*AccountMTPReply, error)
	// internal rpc
	UserPassword(context.Context, *UserPasswordRequest) (*UserPasswordReply, error)
}

func RegisterAccountServerServer(s *grpc.Server, srv AccountServerServer) {
	s.RegisterService(&_AccountServer_serviceDesc, srv)
}

func _AccountServer_GetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).GetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/GetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).GetPassword(ctx, req.(*AccountMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountServer_GetPasswordSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).GetPasswordSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/GetPasswordSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).GetPasswordSettings(ctx, req.(*AccountMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountServer_UpdatePasswordSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).UpdatePasswordSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/UpdatePasswordSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).UpdatePasswordSettings(ctx, req.(*AccountMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountServer_SendUpdatePasswordSettingsCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).SendUpdatePasswordSettingsCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/SendUpdatePasswordSettingsCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).SendUpdatePasswordSettingsCode(ctx, req.(*AccountMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountServer_PTAccountUpdatePasswordSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).PTAccountUpdatePasswordSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/PTAccountUpdatePasswordSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).PTAccountUpdatePasswordSettings(ctx, req.(*AccountMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountServer_ResetAuthroization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).ResetAuthroization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/ResetAuthroization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).ResetAuthroization(ctx, req.(*AccountMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountServer_GetAuthorizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountMTPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).GetAuthorizations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/GetAuthorizations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).GetAuthorizations(ctx, req.(*AccountMTPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AccountServer_UserPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPasswordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountServerServer).UserPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imauthserver.AccountServer/UserPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountServerServer).UserPassword(ctx, req.(*UserPasswordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccountServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imauthserver.AccountServer",
	HandlerType: (*AccountServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPassword",
			Handler:    _AccountServer_GetPassword_Handler,
		},
		{
			MethodName: "GetPasswordSettings",
			Handler:    _AccountServer_GetPasswordSettings_Handler,
		},
		{
			MethodName: "UpdatePasswordSettings",
			Handler:    _AccountServer_UpdatePasswordSettings_Handler,
		},
		{
			MethodName: "SendUpdatePasswordSettingsCode",
			Handler:    _AccountServer_SendUpdatePasswordSettingsCode_Handler,
		},
		{
			MethodName: "PTAccountUpdatePasswordSettings",
			Handler:    _AccountServer_PTAccountUpdatePasswordSettings_Handler,
		},
		{
			MethodName: "ResetAuthroization",
			Handler:    _AccountServer_ResetAuthroization_Handler,
		},
		{
			MethodName: "GetAuthorizations",
			Handler:    _AccountServer_GetAuthorizations_Handler,
		},
		{
			MethodName: "UserPassword",
			Handler:    _AccountServer_UserPassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imauthserver/imauth.proto",
}

func (m *AuthMTPReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthMTPReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RpcResult) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.RpcResult)))
		i += copy(dAtA[i:], m.RpcResult)
	}
	if m.Extra != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Extra.Size()))
		n1, err := m.Extra.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Context) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Context) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.ReqMessageId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.ReqMessageId))
	}
	if m.Layer != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Layer))
	}
	if m.Extra != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Extra.Size()))
		n2, err := m.Extra.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Crc32 != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Crc32))
	}
	return i, nil
}

func (m *AuthMTPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthMTPRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ctx != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Ctx.Size()))
		n3, err := m.Ctx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.MessageObjBin) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.MessageObjBin)))
		i += copy(dAtA[i:], m.MessageObjBin)
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Debug.Size()))
		n4, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *AccountMTPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMTPRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ctx != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Ctx.Size()))
		n5, err := m.Ctx.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.MessageObjBin) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.MessageObjBin)))
		i += copy(dAtA[i:], m.MessageObjBin)
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Debug.Size()))
		n6, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *AccountMTPReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountMTPReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RpcResult) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.RpcResult)))
		i += copy(dAtA[i:], m.RpcResult)
	}
	return i, nil
}

func (m *PasswordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PasswordReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.KeyId))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Flags))
	}
	if len(m.CurrPwdHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.CurrPwdHash)))
		i += copy(dAtA[i:], m.CurrPwdHash)
	}
	if len(m.NewPwdHash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.NewPwdHash)))
		i += copy(dAtA[i:], m.NewPwdHash)
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if len(m.Hint) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.Hint)))
		i += copy(dAtA[i:], m.Hint)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.ReqType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.ReqType))
	}
	return i, nil
}

func (m *VirtualPhoneNumberInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VirtualPhoneNumberInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VirtualPhone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.VirtualPhone)))
		i += copy(dAtA[i:], m.VirtualPhone)
	}
	if len(m.RealPhone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.RealPhone)))
		i += copy(dAtA[i:], m.RealPhone)
	}
	if m.Activated != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Activated))
	}
	if m.BindTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.BindTime))
	}
	if m.ActivateTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.ActivateTime))
	}
	if m.ActivateAdminId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.ActivateAdminId))
	}
	if m.BindAdminId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.BindAdminId))
	}
	if m.OwnerId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.OwnerId))
	}
	if len(m.InitialPhoneCode) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.InitialPhoneCode)))
		i += copy(dAtA[i:], m.InitialPhoneCode)
	}
	return i, nil
}

func (m *ExtraContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraContext) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.ClientAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.ClientAddress)))
		i += copy(dAtA[i:], m.ClientAddress)
	}
	return i, nil
}

func (m *ExtraReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtraReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SigninOk {
		dAtA[i] = 0x8
		i++
		if m.SigninOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.UserId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.GroupId))
	}
	if m.PasswordNeeded {
		dAtA[i] = 0x28
		i++
		if m.PasswordNeeded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LogOutOk {
		dAtA[i] = 0x30
		i++
		if m.LogOutOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RequestPasswordRecoveryOk {
		dAtA[i] = 0x38
		i++
		if m.RequestPasswordRecoveryOk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RobotSignUpRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RobotSignUpRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.PhoneCodeHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.PhoneCodeHash)))
		i += copy(dAtA[i:], m.PhoneCodeHash)
	}
	if len(m.PhoneCode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.PhoneCode)))
		i += copy(dAtA[i:], m.PhoneCode)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.KeyId))
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.IsBot {
		dAtA[i] = 0x40
		i++
		if m.IsBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BotInfoVersion != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		dAtA[i] = 0x50
		i++
		if m.BotChatHistory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BotNoChats {
		dAtA[i] = 0x58
		i++
		if m.BotNoChats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DcId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.DcId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Debug.Size()))
		n7, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.CountryCode) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.CountryCode)))
		i += copy(dAtA[i:], m.CountryCode)
	}
	if len(m.LocalPhone) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.LocalPhone)))
		i += copy(dAtA[i:], m.LocalPhone)
	}
	return i, nil
}

func (m *RobotSignUpReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RobotSignUpReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Code))
	}
	if len(m.UserInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.UserInfo)))
		i += copy(dAtA[i:], m.UserInfo)
	}
	return i, nil
}

func (m *UserPasswordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPasswordRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *UserPasswordReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPasswordReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PasswordHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.PasswordHash)))
		i += copy(dAtA[i:], m.PasswordHash)
	}
	if len(m.Hint) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.Hint)))
		i += copy(dAtA[i:], m.Hint)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImauth(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Status))
	}
	if m.Code != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImauth(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func encodeVarintImauth(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthMTPReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.RpcResult)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.Extra != nil {
		l = m.Extra.Size()
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *Context) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImauth(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovImauth(uint64(m.AuthKeyId))
	}
	if m.ReqMessageId != 0 {
		n += 1 + sovImauth(uint64(m.ReqMessageId))
	}
	if m.Layer != 0 {
		n += 1 + sovImauth(uint64(m.Layer))
	}
	if m.Extra != nil {
		l = m.Extra.Size()
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.Crc32 != 0 {
		n += 1 + sovImauth(uint64(m.Crc32))
	}
	return n
}

func (m *AuthMTPRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ctx != nil {
		l = m.Ctx.Size()
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.MessageObjBin)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *AccountMTPRequest) Size() (n int) {
	var l int
	_ = l
	if m.Ctx != nil {
		l = m.Ctx.Size()
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.MessageObjBin)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *AccountMTPReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.RpcResult)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *PasswordReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImauth(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImauth(uint64(m.KeyId))
	}
	if m.Flags != 0 {
		n += 1 + sovImauth(uint64(m.Flags))
	}
	l = len(m.CurrPwdHash)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.NewPwdHash)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.Hint)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.ReqType != 0 {
		n += 1 + sovImauth(uint64(m.ReqType))
	}
	return n
}

func (m *VirtualPhoneNumberInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.VirtualPhone)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.RealPhone)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.Activated != 0 {
		n += 1 + sovImauth(uint64(m.Activated))
	}
	if m.BindTime != 0 {
		n += 1 + sovImauth(uint64(m.BindTime))
	}
	if m.ActivateTime != 0 {
		n += 1 + sovImauth(uint64(m.ActivateTime))
	}
	if m.ActivateAdminId != 0 {
		n += 1 + sovImauth(uint64(m.ActivateAdminId))
	}
	if m.BindAdminId != 0 {
		n += 1 + sovImauth(uint64(m.BindAdminId))
	}
	if m.OwnerId != 0 {
		n += 1 + sovImauth(uint64(m.OwnerId))
	}
	l = len(m.InitialPhoneCode)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *ExtraContext) Size() (n int) {
	var l int
	_ = l
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.ClientAddress)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *ExtraReply) Size() (n int) {
	var l int
	_ = l
	if m.SigninOk {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovImauth(uint64(m.UserId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovImauth(uint64(m.GroupId))
	}
	if m.PasswordNeeded {
		n += 2
	}
	if m.LogOutOk {
		n += 2
	}
	if m.RequestPasswordRecoveryOk {
		n += 2
	}
	return n
}

func (m *RobotSignUpRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.PhoneCodeHash)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.PhoneCode)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovImauth(uint64(m.KeyId))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.IsBot {
		n += 2
	}
	if m.BotInfoVersion != 0 {
		n += 1 + sovImauth(uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		n += 2
	}
	if m.BotNoChats {
		n += 2
	}
	if m.DcId != 0 {
		n += 1 + sovImauth(uint64(m.DcId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.LocalPhone)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *RobotSignUpReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImauth(uint64(m.Code))
	}
	l = len(m.UserInfo)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	return n
}

func (m *UserPasswordRequest) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImauth(uint64(m.UserId))
	}
	return n
}

func (m *UserPasswordReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.PasswordHash)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.Hint)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovImauth(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovImauth(uint64(m.Status))
	}
	if m.Code != 0 {
		n += 1 + sovImauth(uint64(m.Code))
	}
	return n
}

func sovImauth(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImauth(x uint64) (n int) {
	return sovImauth(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthMTPReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthMTPReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthMTPReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcResult", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcResult = append(m.RpcResult[:0], dAtA[iNdEx:postIndex]...)
			if m.RpcResult == nil {
				m.RpcResult = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extra == nil {
				m.Extra = &ExtraReply{}
			}
			if err := m.Extra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Context) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Context: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Context: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMessageId", wireType)
			}
			m.ReqMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extra == nil {
				m.Extra = &ExtraContext{}
			}
			if err := m.Extra.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32", wireType)
			}
			m.Crc32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthMTPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthMTPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthMTPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ctx == nil {
				m.Ctx = &Context{}
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageObjBin = append(m.MessageObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageObjBin == nil {
				m.MessageObjBin = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMTPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMTPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMTPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ctx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ctx == nil {
				m.Ctx = &Context{}
			}
			if err := m.Ctx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageObjBin = append(m.MessageObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageObjBin == nil {
				m.MessageObjBin = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountMTPReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountMTPReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountMTPReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcResult", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcResult = append(m.RpcResult[:0], dAtA[iNdEx:postIndex]...)
			if m.RpcResult == nil {
				m.RpcResult = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrPwdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrPwdHash = append(m.CurrPwdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CurrPwdHash == nil {
				m.CurrPwdHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPwdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPwdHash = append(m.NewPwdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.NewPwdHash == nil {
				m.NewPwdHash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = append(m.Salt[:0], dAtA[iNdEx:postIndex]...)
			if m.Salt == nil {
				m.Salt = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqType", wireType)
			}
			m.ReqType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VirtualPhoneNumberInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VirtualPhoneNumberInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VirtualPhoneNumberInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RealPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RealPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activated", wireType)
			}
			m.Activated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Activated |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindTime", wireType)
			}
			m.BindTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivateTime", wireType)
			}
			m.ActivateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivateAdminId", wireType)
			}
			m.ActivateAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivateAdminId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindAdminId", wireType)
			}
			m.BindAdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindAdminId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialPhoneCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialPhoneCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtraReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtraReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtraReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigninOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SigninOk = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordNeeded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PasswordNeeded = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogOutOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LogOutOk = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPasswordRecoveryOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequestPasswordRecoveryOk = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RobotSignUpRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RobotSignUpRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RobotSignUpRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneCodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBot = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotInfoVersion", wireType)
			}
			m.BotInfoVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotInfoVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotChatHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotChatHistory = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotNoChats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotNoChats = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RobotSignUpReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RobotSignUpReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RobotSignUpReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (RobotSignUpReply_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserInfo = append(m.UserInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.UserInfo == nil {
				m.UserInfo = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPasswordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPasswordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPasswordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPasswordReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPasswordReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPasswordReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PasswordHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PasswordHash = append(m.PasswordHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PasswordHash == nil {
				m.PasswordHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImauth
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (UserPasswordReply_Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImauth(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImauth
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImauth(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImauth
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImauth
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImauth
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImauth
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImauth(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImauth = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImauth   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imauthserver/imauth.proto", fileDescriptorImauth)
}

var fileDescriptorImauth = []byte{
	// 1611 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0xdb, 0x6e, 0x23, 0x49,
	0x19, 0xa6, 0x9d, 0xf8, 0xf4, 0x77, 0xdb, 0x71, 0x2a, 0xbb, 0x19, 0x4f, 0xc8, 0xe6, 0xe0, 0x19,
	0xd8, 0x80, 0x90, 0x77, 0x95, 0xbd, 0xd9, 0x1b, 0x40, 0x49, 0x26, 0x99, 0xb5, 0x66, 0x13, 0x47,
	0x9d, 0x64, 0xd9, 0x1b, 0xd4, 0x74, 0x77, 0x55, 0xec, 0x1a, 0xb7, 0xab, 0x3a, 0xd5, 0xd5, 0x4e,
	0xcc, 0x03, 0x20, 0x78, 0x08, 0xde, 0x80, 0xe7, 0x40, 0x5c, 0x22, 0xa1, 0x11, 0x77, 0x08, 0xcd,
	0x23, 0xf0, 0x04, 0xa8, 0xaa, 0xba, 0x7d, 0x98, 0x49, 0x66, 0x10, 0x0e, 0xe2, 0x6a, 0x52, 0x5f,
	0x7d, 0xfd, 0xd5, 0x5f, 0xff, 0xb1, 0x3c, 0xf0, 0x8b, 0x1e, 0x95, 0x91, 0x1f, 0xb4, 0xc3, 0xbe,
	0x2f, 0x13, 0x22, 0x46, 0x44, 0xb4, 0xe9, 0xf0, 0x0b, 0xca, 0x24, 0x11, 0xd7, 0x7e, 0x48, 0x62,
	0xc1, 0x83, 0xf4, 0xfa, 0x0b, 0x3a, 0xf4, 0x53, 0xd9, 0x37, 0xfb, 0xd9, 0xa2, 0x1d, 0x0b, 0x2e,
	0x39, 0x72, 0x66, 0xb7, 0x36, 0xbe, 0xfe, 0x8f, 0xd4, 0xe2, 0x20, 0xe4, 0xc3, 0x61, 0xf6, 0x8f,
	0xd1, 0x69, 0xfd, 0x1a, 0x9c, 0x83, 0x54, 0xf6, 0x4f, 0x2f, 0xcf, 0x5d, 0x12, 0x47, 0x63, 0xf4,
	0x19, 0x80, 0x88, 0x43, 0x4f, 0x90, 0x24, 0x8d, 0x64, 0xd3, 0xda, 0xb1, 0xf6, 0x1c, 0xb7, 0x2a,
	0xe2, 0xd0, 0xd5, 0x00, 0x6a, 0x43, 0x91, 0xdc, 0x49, 0xe1, 0x37, 0x0b, 0x3b, 0xd6, 0x9e, 0xbd,
	0xdf, 0x6c, 0xcf, 0x9a, 0xd1, 0x3e, 0x56, 0x5b, 0x5a, 0xc7, 0x35, 0xb4, 0xd6, 0x9f, 0x2d, 0x28,
	0x1f, 0x71, 0x26, 0xc9, 0x9d, 0x44, 0x4f, 0xa0, 0x9c, 0x26, 0x44, 0x78, 0x14, 0x6b, 0xdd, 0xa2,
	0x5b, 0x52, 0xcb, 0x0e, 0x46, 0x5b, 0x60, 0x2b, 0x11, 0x6f, 0x40, 0xc6, 0x6a, 0x53, 0x49, 0x2f,
	0xb9, 0x55, 0x05, 0xbd, 0x22, 0xe3, 0x0e, 0x46, 0xcf, 0xa1, 0x2e, 0xc8, 0x8d, 0x37, 0x24, 0x49,
	0xe2, 0xf7, 0x88, 0xa2, 0x2c, 0x69, 0x8a, 0x23, 0xc8, 0xcd, 0xa9, 0x01, 0x3b, 0x18, 0x7d, 0x02,
	0xc5, 0xc8, 0x1f, 0x13, 0xd1, 0x5c, 0xd6, 0x9b, 0x66, 0x81, 0xbe, 0xcc, 0x0d, 0x2e, 0x6a, 0x83,
	0x37, 0xee, 0x31, 0x38, 0xb3, 0x2f, 0x33, 0x59, 0xe9, 0x84, 0x22, 0xfc, 0x6a, 0xbf, 0x59, 0xda,
	0xb1, 0xf6, 0x6a, 0xae, 0x59, 0xb4, 0x7e, 0x67, 0x41, 0x7d, 0xe2, 0xa8, 0x9b, 0x94, 0x24, 0x12,
	0x7d, 0x0e, 0x4b, 0xa1, 0xbc, 0xd3, 0x77, 0xb1, 0xf7, 0x3f, 0x9d, 0x17, 0xce, 0x35, 0x15, 0x03,
	0xfd, 0x18, 0x56, 0x72, 0xdb, 0x79, 0xf0, 0xda, 0x0b, 0x28, 0xd3, 0x77, 0x74, 0xdc, 0x5a, 0x06,
	0x77, 0x83, 0xd7, 0x87, 0x94, 0xa1, 0x67, 0x50, 0xc4, 0x24, 0x48, 0x7b, 0xfa, 0x7a, 0xf6, 0x7e,
	0xad, 0x9d, 0x45, 0xea, 0x85, 0x02, 0x5d, 0xb3, 0xd7, 0xfa, 0x83, 0x05, 0xab, 0x07, 0x61, 0xc8,
	0x53, 0x26, 0xff, 0xef, 0xb6, 0x7c, 0x09, 0x2b, 0xb3, 0xa6, 0x7c, 0x3c, 0x7f, 0x5a, 0xff, 0xb2,
	0xc0, 0x3e, 0xf7, 0x93, 0xe4, 0x96, 0x0b, 0xec, 0x92, 0x9b, 0x87, 0x73, 0xe2, 0x53, 0x28, 0xcd,
	0xa5, 0x43, 0x71, 0xa0, 0x53, 0xe1, 0x13, 0x28, 0x5e, 0x47, 0x7e, 0x2f, 0xd1, 0x66, 0x15, 0x5d,
	0xb3, 0x40, 0x2d, 0xa8, 0x85, 0xa9, 0x10, 0x5e, 0x7c, 0x8b, 0xbd, 0xbe, 0x9f, 0xf4, 0x75, 0x0a,
	0x38, 0xae, 0xad, 0xc0, 0xf3, 0x5b, 0xfc, 0x8d, 0x9f, 0xf4, 0xd1, 0x0e, 0x38, 0x8c, 0xdc, 0x4e,
	0x29, 0x45, 0x4d, 0x01, 0x46, 0x6e, 0x73, 0x06, 0x82, 0xe5, 0xc4, 0x8f, 0xa4, 0x8e, 0xbb, 0xe3,
	0xea, 0xbf, 0x15, 0xd6, 0xa7, 0x4c, 0x36, 0xcb, 0x3b, 0xd6, 0x5e, 0xd5, 0xd5, 0x7f, 0x2b, 0x1b,
	0xc8, 0xd0, 0xa7, 0x51, 0xb3, 0xa2, 0x41, 0xb3, 0x40, 0x4f, 0xa1, 0xa2, 0x92, 0x54, 0x8e, 0x63,
	0xd2, 0xac, 0x6a, 0xe3, 0xca, 0x82, 0xdc, 0x5c, 0x8e, 0x63, 0xd2, 0x7a, 0x53, 0x80, 0xf5, 0xef,
	0xa8, 0x90, 0xa9, 0x1f, 0x9d, 0xf7, 0x39, 0x23, 0x67, 0xe9, 0x30, 0x20, 0xa2, 0xc3, 0xae, 0x39,
	0x7a, 0x06, 0xb5, 0x91, 0xd9, 0xf1, 0x62, 0xb5, 0xa5, 0xbd, 0x50, 0x75, 0x9d, 0xd1, 0x0c, 0x5d,
	0xfb, 0x94, 0x4c, 0x18, 0x05, 0xcd, 0xa8, 0x2a, 0xc4, 0x6c, 0x6f, 0x42, 0xd5, 0x0f, 0x25, 0x1d,
	0xf9, 0x92, 0x98, 0xca, 0xa8, 0xb9, 0x53, 0x00, 0xfd, 0x10, 0xaa, 0x01, 0x65, 0xd8, 0x93, 0x74,
	0x48, 0xb2, 0xd2, 0xa8, 0x28, 0xe0, 0x92, 0x0e, 0x89, 0x3a, 0x3e, 0x67, 0x1a, 0x42, 0xd1, 0x14,
	0x56, 0x0e, 0x6a, 0xd2, 0x4f, 0x61, 0x75, 0x42, 0xf2, 0xf1, 0x90, 0x32, 0x15, 0x95, 0x92, 0xbe,
	0xe2, 0x4a, 0xbe, 0x71, 0xa0, 0xf0, 0x0e, 0x56, 0x91, 0xd0, 0xa7, 0x4d, 0x78, 0x65, 0xcd, 0xb3,
	0x15, 0x98, 0x73, 0x9e, 0x42, 0x85, 0xdf, 0x32, 0x13, 0xf4, 0x8a, 0xf1, 0x94, 0x5e, 0x77, 0x30,
	0xfa, 0x19, 0x20, 0xca, 0xa8, 0xa4, 0xf9, 0x65, 0xbd, 0x90, 0x63, 0xe3, 0xce, 0xaa, 0xdb, 0xc8,
	0x76, 0xf4, 0xa5, 0x8f, 0x38, 0x26, 0xad, 0xef, 0xc1, 0x99, 0x2d, 0x60, 0xb4, 0x0b, 0x0e, 0x26,
	0x23, 0x1a, 0x12, 0x6f, 0xc8, 0x31, 0x89, 0x32, 0x5f, 0xda, 0x06, 0x3b, 0x55, 0x10, 0xfa, 0x11,
	0xd4, 0xc3, 0x88, 0x12, 0x26, 0x3d, 0x1f, 0x63, 0x41, 0x92, 0x24, 0x73, 0x67, 0xcd, 0xa0, 0x07,
	0x06, 0x6c, 0xfd, 0xbe, 0x00, 0x30, 0x6d, 0x66, 0xca, 0x87, 0x09, 0xed, 0x31, 0xca, 0x3c, 0x3e,
	0xd0, 0xaa, 0x15, 0xb7, 0x62, 0x80, 0xee, 0x60, 0x36, 0x85, 0x0b, 0x73, 0x29, 0xbc, 0x0b, 0x8e,
	0xb9, 0x04, 0xd3, 0xf1, 0xd6, 0xa1, 0xa9, 0xba, 0x76, 0x3c, 0x4d, 0x01, 0xe5, 0x8a, 0x9e, 0xe0,
	0x69, 0xac, 0x3e, 0x5e, 0x36, 0xae, 0xd0, 0xeb, 0x0e, 0x46, 0x9f, 0xc3, 0x4a, 0x9c, 0x15, 0x8a,
	0xc7, 0x08, 0xc1, 0x04, 0xeb, 0xe0, 0x54, 0xdc, 0x7a, 0x0e, 0x9f, 0x69, 0x14, 0x6d, 0x02, 0x44,
	0xbc, 0xe7, 0xf1, 0x54, 0x2a, 0xeb, 0x4a, 0xc6, 0xba, 0x88, 0xf7, 0xba, 0xa9, 0xec, 0x0e, 0xd0,
	0x2f, 0x61, 0x53, 0x98, 0x1e, 0xe1, 0x4d, 0xe4, 0x04, 0x09, 0xf9, 0x88, 0x88, 0xb1, 0xe2, 0x97,
	0x35, 0xff, 0x69, 0xc6, 0x99, 0x96, 0xa6, 0x61, 0x74, 0x07, 0xad, 0x37, 0x4b, 0x80, 0x5c, 0x1e,
	0x70, 0x79, 0x41, 0x7b, 0xec, 0x2a, 0xce, 0x1b, 0xce, 0x0e, 0xd8, 0x33, 0xb9, 0x9c, 0xbb, 0x7a,
	0x06, 0x42, 0xcf, 0xa1, 0x36, 0x09, 0x95, 0xaa, 0xaf, 0xdc, 0xd3, 0x73, 0xa0, 0x4a, 0xde, 0x09,
	0x90, 0x79, 0x68, 0x0a, 0xa8, 0x52, 0xd3, 0x75, 0x9f, 0xe5, 0x65, 0xd6, 0x04, 0x36, 0xa1, 0x7a,
	0x42, 0x45, 0x22, 0xcf, 0xfc, 0x21, 0xd1, 0x17, 0xae, 0xba, 0x53, 0x00, 0x6d, 0x40, 0xe5, 0x5b,
	0x3f, 0xdb, 0x34, 0x65, 0x3b, 0x59, 0xab, 0xae, 0x42, 0x13, 0x2f, 0xe0, 0x52, 0x27, 0x5e, 0xc5,
	0x2d, 0xd2, 0xe4, 0x90, 0x4b, 0xb4, 0x07, 0x8d, 0x80, 0x4b, 0x8f, 0xb2, 0x6b, 0xee, 0x8d, 0x88,
	0x48, 0x28, 0x67, 0x59, 0x0d, 0xd7, 0x03, 0x2e, 0x55, 0xa1, 0x7e, 0x67, 0xd0, 0x9c, 0xa9, 0xe6,
	0xac, 0xd7, 0xa7, 0x89, 0xe4, 0x62, 0xdc, 0x04, 0x13, 0x96, 0x80, 0xcb, 0xa3, 0xbe, 0x2f, 0xbf,
	0x31, 0xa8, 0xea, 0x37, 0x8a, 0xc9, 0xb8, 0x26, 0x27, 0x4d, 0x5b, 0xb3, 0x20, 0xe0, 0xf2, 0x8c,
	0x2b, 0x5e, 0x82, 0xd6, 0xa0, 0x88, 0x43, 0x15, 0x79, 0x47, 0x1f, 0xb5, 0x8c, 0xc3, 0x0e, 0x9e,
	0xf6, 0xdd, 0xda, 0xc3, 0x7d, 0x57, 0x65, 0x96, 0xee, 0xba, 0x62, 0x6c, 0x0a, 0xa4, 0x6e, 0xbc,
	0x9f, 0x61, 0xda, 0x73, 0xdb, 0x60, 0x47, 0x3c, 0x9c, 0x34, 0x8d, 0x15, 0xcd, 0x00, 0x0d, 0x69,
	0xf7, 0xb6, 0xfe, 0x58, 0x80, 0xc6, 0x5c, 0x5c, 0x55, 0xa2, 0xff, 0x1c, 0x96, 0xb5, 0xa0, 0x0a,
	0x67, 0x7d, 0xff, 0x27, 0xf3, 0x73, 0xe4, 0x5d, 0x76, 0xdb, 0xf4, 0x74, 0x75, 0x9c, 0xab, 0x3f,
	0x53, 0x75, 0x62, 0x4a, 0x81, 0x5d, 0xf3, 0x6c, 0xac, 0x54, 0x74, 0x31, 0xb0, 0x6b, 0xde, 0xfa,
	0x93, 0x05, 0x30, 0xfd, 0x02, 0xd9, 0x50, 0xbe, 0x48, 0xc3, 0x90, 0x24, 0x49, 0xe3, 0x07, 0x68,
	0x15, 0x6a, 0x1d, 0xf5, 0x58, 0x61, 0x7e, 0x74, 0x2c, 0x04, 0x17, 0x0d, 0x0b, 0xad, 0x03, 0x9a,
	0x6b, 0x96, 0x23, 0x3f, 0xa2, 0xb8, 0x51, 0x40, 0x4f, 0x60, 0x6d, 0x06, 0xef, 0x86, 0x61, 0x1a,
	0x53, 0x82, 0x1b, 0x4b, 0x08, 0x41, 0xfd, 0xc8, 0x8f, 0x65, 0xd8, 0xf7, 0x8f, 0xef, 0x62, 0x2a,
	0x08, 0x6e, 0x2c, 0xcf, 0x60, 0xb9, 0x40, 0x11, 0xd5, 0xa0, 0x7a, 0x12, 0x71, 0x8e, 0x7f, 0xe5,
	0x53, 0xd9, 0x28, 0xa9, 0x73, 0xb2, 0x3b, 0xa9, 0xeb, 0x1d, 0x46, 0x3c, 0x1c, 0x10, 0xdc, 0x28,
	0xb7, 0xda, 0xb0, 0x76, 0x95, 0x10, 0x31, 0x33, 0xac, 0x74, 0xde, 0x3f, 0x34, 0xb0, 0x5a, 0x7f,
	0xb7, 0x60, 0x75, 0xfe, 0x03, 0xe5, 0xd0, 0x67, 0x50, 0x9b, 0x94, 0x9d, 0x1e, 0x3b, 0x66, 0x22,
	0x3a, 0x39, 0x98, 0x0f, 0x1e, 0x3d, 0x64, 0x0a, 0xf7, 0x0d, 0x99, 0xa5, 0xd9, 0x21, 0xb3, 0x0e,
	0xa5, 0x44, 0xfa, 0x32, 0x4d, 0xb2, 0x6e, 0x91, 0xad, 0xd0, 0xd7, 0x59, 0xdc, 0x8a, 0x3a, 0x6e,
	0xcf, 0xe7, 0xe3, 0xf6, 0x9e, 0x55, 0xed, 0x69, 0xc8, 0x5a, 0xbb, 0xb0, 0xfc, 0x7e, 0x38, 0x1c,
	0xa8, 0x9c, 0x71, 0x79, 0xc2, 0x53, 0x86, 0x1b, 0xd6, 0xfe, 0x3f, 0x00, 0x40, 0x3d, 0x7d, 0x2e,
	0xb4, 0x1c, 0x3a, 0x01, 0x38, 0xea, 0x93, 0x70, 0x90, 0x0d, 0x9f, 0xf9, 0xb3, 0xe6, 0x9f, 0x48,
	0x1b, 0x1b, 0x0f, 0xec, 0x2a, 0xd7, 0xbc, 0x80, 0xca, 0x05, 0x61, 0x58, 0x9f, 0xfe, 0xdf, 0xab,
	0x1c, 0x42, 0xc9, 0x84, 0x6f, 0x71, 0x8d, 0x0e, 0x5b, 0x4c, 0xe3, 0x5b, 0xdd, 0x73, 0x17, 0xd0,
	0xe8, 0xc2, 0x9a, 0x4b, 0x12, 0x22, 0x15, 0xc8, 0x05, 0xfd, 0xad, 0x2f, 0x29, 0x67, 0xc9, 0x02,
	0x82, 0x2f, 0xc1, 0x56, 0x2e, 0xee, 0xb0, 0x11, 0x95, 0x24, 0x59, 0xcc, 0xb2, 0xe3, 0xbb, 0x98,
	0x8b, 0x79, 0xd3, 0x16, 0x13, 0xec, 0x0c, 0x1f, 0x53, 0xf0, 0x15, 0xac, 0x1c, 0xaa, 0x57, 0x0d,
	0x19, 0xc6, 0x07, 0xe6, 0x87, 0xc3, 0x02, 0x62, 0x2e, 0xac, 0x1b, 0xeb, 0x0e, 0xf9, 0xa3, 0x19,
	0xd8, 0x81, 0x9a, 0x29, 0x9b, 0xac, 0x12, 0x17, 0x90, 0xba, 0x80, 0x27, 0xee, 0xfd, 0xf3, 0x7a,
	0x31, 0x07, 0x66, 0x2a, 0x8f, 0x60, 0xe1, 0x89, 0x6e, 0xf5, 0x8b, 0x57, 0xb7, 0xea, 0x35, 0x3e,
	0x0b, 0x49, 0xb4, 0xa0, 0xce, 0x2b, 0x58, 0x79, 0x21, 0x78, 0xfc, 0x38, 0xd9, 0xd1, 0x05, 0x7b,
	0x66, 0x14, 0xa2, 0x9d, 0x0f, 0x4c, 0x49, 0x23, 0xb6, 0xf5, 0xe1, 0x39, 0xba, 0xff, 0xb7, 0x22,
	0xd4, 0xb2, 0xdf, 0x51, 0x59, 0x8f, 0x3d, 0x05, 0xfb, 0x25, 0x99, 0x44, 0x17, 0x6d, 0xbf, 0x63,
	0xcd, 0xbb, 0x3f, 0xff, 0x36, 0x3e, 0x7b, 0x98, 0xa0, 0x2c, 0xbe, 0x82, 0xb5, 0x19, 0xb9, 0x0b,
	0x22, 0x25, 0x65, 0xbd, 0x64, 0x61, 0xd9, 0xef, 0x61, 0xfd, 0x2a, 0xc6, 0xbe, 0x24, 0x8f, 0xae,
	0xfc, 0x1b, 0xd8, 0x52, 0x8d, 0xeb, 0x7e, 0x75, 0xf3, 0xbe, 0x59, 0xf0, 0x04, 0x1f, 0xb6, 0xcf,
	0x2f, 0x33, 0xf0, 0x7f, 0x74, 0x89, 0x4b, 0x40, 0x93, 0x76, 0x2e, 0x78, 0xde, 0x41, 0x16, 0x55,
	0xbd, 0x80, 0xd5, 0x97, 0xef, 0x8d, 0x88, 0x45, 0x45, 0x5d, 0x70, 0x66, 0x5f, 0x09, 0x68, 0xf7,
	0x43, 0x2f, 0x08, 0xa3, 0xb8, 0xfd, 0x91, 0x47, 0xc6, 0xa1, 0xf3, 0x97, 0xb7, 0x5b, 0xd6, 0x5f,
	0xdf, 0x6e, 0x59, 0xff, 0x7c, 0xbb, 0x65, 0x05, 0x25, 0xfd, 0xdf, 0x4d, 0x5f, 0xfd, 0x3b, 0x00,
	0x00, 0xff, 0xff, 0xa1, 0xa1, 0x37, 0xd4, 0xf8, 0x12, 0x00, 0x00,
}
