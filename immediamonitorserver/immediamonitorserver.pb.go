// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/immediamonitorserver/immediamonitorserver.proto

/*
Package immediamonitorserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/immediamonitorserver/immediamonitorserver.proto

It has these top-level messages:

	MediaInfo
	UserMsg
	MediaMonitorInfoSaveReq
	MediaMonitorInfoSaveResp
*/
package immediamonitorserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 结果码定义
type ERpcResultCode int32

const (
	ERpcResultCode_RRC_OK                  ERpcResultCode = 0
	ERpcResultCode_RRC_FILE_NOT_EXISITS    ERpcResultCode = 1
	ERpcResultCode_RRC_SYSTEM_EXCEPTION    ERpcResultCode = 2
	ERpcResultCode_RRC_PARAMETER_EXCEPTION ERpcResultCode = 3
	ERpcResultCode_RRC_LOGIC_EXCEPTION     ERpcResultCode = 4
	ERpcResultCode_RRC_DATA_EXCEPTION      ERpcResultCode = 5
	ERpcResultCode_RRC_NO_ACCESS_RIGHTS    ERpcResultCode = 6
	ERpcResultCode_RRC_DB_EXCEPTION        ERpcResultCode = 7
	ERpcResultCode_RRC_UNKNOWN             ERpcResultCode = 65535
)

var ERpcResultCode_name = map[int32]string{
	0:     "RRC_OK",
	1:     "RRC_FILE_NOT_EXISITS",
	2:     "RRC_SYSTEM_EXCEPTION",
	3:     "RRC_PARAMETER_EXCEPTION",
	4:     "RRC_LOGIC_EXCEPTION",
	5:     "RRC_DATA_EXCEPTION",
	6:     "RRC_NO_ACCESS_RIGHTS",
	7:     "RRC_DB_EXCEPTION",
	65535: "RRC_UNKNOWN",
}
var ERpcResultCode_value = map[string]int32{
	"RRC_OK":                  0,
	"RRC_FILE_NOT_EXISITS":    1,
	"RRC_SYSTEM_EXCEPTION":    2,
	"RRC_PARAMETER_EXCEPTION": 3,
	"RRC_LOGIC_EXCEPTION":     4,
	"RRC_DATA_EXCEPTION":      5,
	"RRC_NO_ACCESS_RIGHTS":    6,
	"RRC_DB_EXCEPTION":        7,
	"RRC_UNKNOWN":             65535,
}

func (x ERpcResultCode) String() string {
	return proto.EnumName(ERpcResultCode_name, int32(x))
}
func (ERpcResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImmediamonitorserver, []int{0}
}

// ----------------------------------------------------
// 媒体文件信息
type MediaInfo struct {
	Fid      uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	FileName string `protobuf:"bytes,2,opt,name=fileName,proto3" json:"fileName,omitempty"`
	FileSize uint32 `protobuf:"varint,3,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
}

func (m *MediaInfo) Reset()                    { *m = MediaInfo{} }
func (m *MediaInfo) String() string            { return proto.CompactTextString(m) }
func (*MediaInfo) ProtoMessage()               {}
func (*MediaInfo) Descriptor() ([]byte, []int) { return fileDescriptorImmediamonitorserver, []int{0} }

func (m *MediaInfo) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MediaInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *MediaInfo) GetFileSize() uint32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// 来源信息
type UserMsg struct {
	UserId      int32 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId      int32 `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithIdType  int32 `protobuf:"varint,3,opt,name=WithIdType,proto3" json:"WithIdType,omitempty"`
	MessageType int32 `protobuf:"varint,4,opt,name=MessageType,proto3" json:"MessageType,omitempty"`
	MsgId       int32 `protobuf:"varint,5,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	ToId        int32 `protobuf:"varint,6,opt,name=ToId,proto3" json:"ToId,omitempty"`
	FromId      int32 `protobuf:"varint,7,opt,name=FromId,proto3" json:"FromId,omitempty"`
}

func (m *UserMsg) Reset()                    { *m = UserMsg{} }
func (m *UserMsg) String() string            { return proto.CompactTextString(m) }
func (*UserMsg) ProtoMessage()               {}
func (*UserMsg) Descriptor() ([]byte, []int) { return fileDescriptorImmediamonitorserver, []int{1} }

func (m *UserMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserMsg) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *UserMsg) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *UserMsg) GetMessageType() int32 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMsg) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *UserMsg) GetToId() int32 {
	if m != nil {
		return m.ToId
	}
	return 0
}

func (m *UserMsg) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

// 媒体监督所需相关信息存储请求
type MediaMonitorInfoSaveReq struct {
	FileInfo *MediaInfo `protobuf:"bytes,1,opt,name=file_info,json=fileInfo" json:"file_info,omitempty"`
	UserMsg  *UserMsg   `protobuf:"bytes,2,opt,name=user_msg,json=userMsg" json:"user_msg,omitempty"`
}

func (m *MediaMonitorInfoSaveReq) Reset()         { *m = MediaMonitorInfoSaveReq{} }
func (m *MediaMonitorInfoSaveReq) String() string { return proto.CompactTextString(m) }
func (*MediaMonitorInfoSaveReq) ProtoMessage()    {}
func (*MediaMonitorInfoSaveReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImmediamonitorserver, []int{2}
}

func (m *MediaMonitorInfoSaveReq) GetFileInfo() *MediaInfo {
	if m != nil {
		return m.FileInfo
	}
	return nil
}

func (m *MediaMonitorInfoSaveReq) GetUserMsg() *UserMsg {
	if m != nil {
		return m.UserMsg
	}
	return nil
}

// 媒体监督所需相关信息存储响应
type MediaMonitorInfoSaveResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=immediamonitorserver.ERpcResultCode" json:"result,omitempty"`
}

func (m *MediaMonitorInfoSaveResp) Reset()         { *m = MediaMonitorInfoSaveResp{} }
func (m *MediaMonitorInfoSaveResp) String() string { return proto.CompactTextString(m) }
func (*MediaMonitorInfoSaveResp) ProtoMessage()    {}
func (*MediaMonitorInfoSaveResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImmediamonitorserver, []int{3}
}

func (m *MediaMonitorInfoSaveResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func init() {
	proto.RegisterType((*MediaInfo)(nil), "immediamonitorserver.MediaInfo")
	proto.RegisterType((*UserMsg)(nil), "immediamonitorserver.UserMsg")
	proto.RegisterType((*MediaMonitorInfoSaveReq)(nil), "immediamonitorserver.MediaMonitorInfoSaveReq")
	proto.RegisterType((*MediaMonitorInfoSaveResp)(nil), "immediamonitorserver.MediaMonitorInfoSaveResp")
	proto.RegisterEnum("immediamonitorserver.ERpcResultCode", ERpcResultCode_name, ERpcResultCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MediaMonitorService service

type MediaMonitorServiceClient interface {
	// MediaMonitorInfoSave 媒体监督所需相关信息存储
	MediaMonitorInfoSave(ctx context.Context, in *MediaMonitorInfoSaveReq, opts ...grpc.CallOption) (*MediaMonitorInfoSaveResp, error)
}

type mediaMonitorServiceClient struct {
	cc *grpc.ClientConn
}

func NewMediaMonitorServiceClient(cc *grpc.ClientConn) MediaMonitorServiceClient {
	return &mediaMonitorServiceClient{cc}
}

func (c *mediaMonitorServiceClient) MediaMonitorInfoSave(ctx context.Context, in *MediaMonitorInfoSaveReq, opts ...grpc.CallOption) (*MediaMonitorInfoSaveResp, error) {
	out := new(MediaMonitorInfoSaveResp)
	err := grpc.Invoke(ctx, "/immediamonitorserver.MediaMonitorService/MediaMonitorInfoSave", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MediaMonitorService service

type MediaMonitorServiceServer interface {
	// MediaMonitorInfoSave 媒体监督所需相关信息存储
	MediaMonitorInfoSave(context.Context, *MediaMonitorInfoSaveReq) (*MediaMonitorInfoSaveResp, error)
}

func RegisterMediaMonitorServiceServer(s *grpc.Server, srv MediaMonitorServiceServer) {
	s.RegisterService(&_MediaMonitorService_serviceDesc, srv)
}

func _MediaMonitorService_MediaMonitorInfoSave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MediaMonitorInfoSaveReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaMonitorServiceServer).MediaMonitorInfoSave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/immediamonitorserver.MediaMonitorService/MediaMonitorInfoSave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaMonitorServiceServer).MediaMonitorInfoSave(ctx, req.(*MediaMonitorInfoSaveReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _MediaMonitorService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "immediamonitorserver.MediaMonitorService",
	HandlerType: (*MediaMonitorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MediaMonitorInfoSave",
			Handler:    _MediaMonitorService_MediaMonitorInfoSave_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/immediamonitorserver/immediamonitorserver.proto",
}

func (m *MediaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.Fid))
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.FileSize))
	}
	return i, nil
}

func (m *UserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.WithIdType))
	}
	if m.MessageType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.MessageType))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.MsgId))
	}
	if m.ToId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.ToId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.FromId))
	}
	return i, nil
}

func (m *MediaMonitorInfoSaveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaMonitorInfoSaveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.FileInfo.Size()))
		n1, err := m.FileInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.UserMsg != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.UserMsg.Size()))
		n2, err := m.UserMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *MediaMonitorInfoSaveResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MediaMonitorInfoSaveResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImmediamonitorserver(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func encodeVarintImmediamonitorserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MediaInfo) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.Fid))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovImmediamonitorserver(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.FileSize))
	}
	return n
}

func (m *UserMsg) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.WithIdType))
	}
	if m.MessageType != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.MessageType))
	}
	if m.MsgId != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.MsgId))
	}
	if m.ToId != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.ToId))
	}
	if m.FromId != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.FromId))
	}
	return n
}

func (m *MediaMonitorInfoSaveReq) Size() (n int) {
	var l int
	_ = l
	if m.FileInfo != nil {
		l = m.FileInfo.Size()
		n += 1 + l + sovImmediamonitorserver(uint64(l))
	}
	if m.UserMsg != nil {
		l = m.UserMsg.Size()
		n += 1 + l + sovImmediamonitorserver(uint64(l))
	}
	return n
}

func (m *MediaMonitorInfoSaveResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovImmediamonitorserver(uint64(m.Result))
	}
	return n
}

func sovImmediamonitorserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImmediamonitorserver(x uint64) (n int) {
	return sovImmediamonitorserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MediaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImmediamonitorserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImmediamonitorserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImmediamonitorserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImmediamonitorserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImmediamonitorserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToId", wireType)
			}
			m.ToId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImmediamonitorserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImmediamonitorserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaMonitorInfoSaveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImmediamonitorserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaMonitorInfoSaveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaMonitorInfoSaveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImmediamonitorserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileInfo == nil {
				m.FileInfo = &MediaInfo{}
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImmediamonitorserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMsg == nil {
				m.UserMsg = &UserMsg{}
			}
			if err := m.UserMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImmediamonitorserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImmediamonitorserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MediaMonitorInfoSaveResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImmediamonitorserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MediaMonitorInfoSaveResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MediaMonitorInfoSaveResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImmediamonitorserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImmediamonitorserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImmediamonitorserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImmediamonitorserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImmediamonitorserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImmediamonitorserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImmediamonitorserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImmediamonitorserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImmediamonitorserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImmediamonitorserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/immediamonitorserver/immediamonitorserver.proto", fileDescriptorImmediamonitorserver)
}

var fileDescriptorImmediamonitorserver = []byte{
	// 550 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0xdf, 0x6e, 0x93, 0x50,
	0x18, 0xdf, 0x59, 0x0b, 0xdd, 0xbe, 0xea, 0x82, 0x67, 0xcd, 0x46, 0x66, 0xac, 0x4d, 0xe3, 0xc5,
	0x62, 0x62, 0x97, 0xd4, 0x1b, 0x2f, 0x76, 0xd3, 0x21, 0x9b, 0x27, 0x1b, 0xb0, 0x1c, 0x58, 0x36,
	0xaf, 0x08, 0x2b, 0x87, 0xee, 0x24, 0xa3, 0x20, 0xd0, 0x1a, 0x7d, 0x08, 0x13, 0x1f, 0xc8, 0x7b,
	0x2f, 0x7d, 0x04, 0xed, 0x8b, 0xcc, 0x9c, 0x43, 0xdb, 0x60, 0x24, 0x26, 0xde, 0xfd, 0xfe, 0x9d,
	0x8f, 0xef, 0xfc, 0x00, 0xf0, 0x26, 0xbc, 0xb8, 0x0f, 0x6e, 0x07, 0xe3, 0xbb, 0xa0, 0xc8, 0x59,
	0x36, 0x67, 0xd9, 0x80, 0xc7, 0x47, 0x7c, 0x5a, 0xb0, 0x2c, 0x0a, 0xc6, 0x2c, 0xcd, 0x92, 0xdb,
	0x59, 0x74, 0xc4, 0xe3, 0x98, 0x85, 0x3c, 0x88, 0x93, 0x29, 0x2f, 0x92, 0xac, 0xcc, 0xd5, 0x8a,
	0x83, 0x34, 0x4b, 0x8a, 0x04, 0x77, 0xea, 0xbc, 0xfe, 0x15, 0x6c, 0x5b, 0x42, 0x25, 0xd3, 0x28,
	0xc1, 0x1a, 0x34, 0x22, 0x1e, 0xea, 0xa8, 0x87, 0x0e, 0x9b, 0x54, 0x40, 0x7c, 0x00, 0x5b, 0x11,
	0xbf, 0x67, 0x76, 0x10, 0x33, 0x7d, 0xb3, 0x87, 0x0e, 0xb7, 0xe9, 0x9a, 0xaf, 0x3c, 0x97, 0x7f,
	0x66, 0x7a, 0xa3, 0x87, 0x0e, 0x1f, 0xd3, 0x35, 0xef, 0x7f, 0x43, 0xd0, 0xba, 0xca, 0x59, 0x66,
	0xe5, 0x13, 0xbc, 0x07, 0xaa, 0x80, 0xa4, 0x1c, 0xac, 0xd0, 0x25, 0x13, 0xfa, 0x35, 0x2f, 0xee,
	0x48, 0x28, 0x27, 0x2b, 0x74, 0xc9, 0x70, 0x17, 0xa0, 0x44, 0xde, 0xa7, 0xb4, 0x9c, 0xac, 0xd0,
	0x8a, 0x82, 0x7b, 0xd0, 0xb6, 0x58, 0x9e, 0x07, 0x13, 0x26, 0x03, 0x4d, 0x19, 0xa8, 0x4a, 0xb8,
	0x03, 0x8a, 0x95, 0x4f, 0x48, 0xa8, 0x2b, 0xd2, 0x2b, 0x09, 0xc6, 0xd0, 0xf4, 0x12, 0x12, 0xea,
	0xaa, 0x14, 0x25, 0x16, 0x3b, 0x9c, 0x66, 0x49, 0x4c, 0x42, 0xbd, 0x55, 0xee, 0x50, 0xb2, 0xfe,
	0x57, 0x04, 0xfb, 0xb2, 0x17, 0xab, 0x6c, 0x4b, 0xd4, 0xe3, 0x06, 0x73, 0x46, 0xd9, 0x07, 0x7c,
	0x0c, 0xdb, 0xe2, 0x9e, 0x3e, 0x9f, 0x46, 0x89, 0xbc, 0x52, 0x7b, 0xf8, 0x7c, 0x50, 0x5b, 0xfc,
	0xba, 0xd9, 0xb2, 0x19, 0xd9, 0xf1, 0x1b, 0xd8, 0x9a, 0xe5, 0x2c, 0xf3, 0xe3, 0x7c, 0x22, 0xef,
	0xdd, 0x1e, 0x3e, 0xab, 0x3f, 0xbc, 0xac, 0x8f, 0xb6, 0x66, 0x25, 0xe8, 0xdf, 0x80, 0x5e, 0xbf,
	0x52, 0x9e, 0xe2, 0x63, 0x50, 0x33, 0x96, 0xcf, 0xee, 0x0b, 0xb9, 0xd0, 0xce, 0xf0, 0x45, 0xfd,
	0x4c, 0x93, 0xa6, 0x63, 0x2a, 0x73, 0x46, 0x12, 0x32, 0xba, 0x3c, 0xf3, 0xf2, 0x17, 0x82, 0x9d,
	0x3f, 0x2d, 0x0c, 0xa0, 0x52, 0x6a, 0xf8, 0xce, 0xb9, 0xb6, 0x81, 0x75, 0xe8, 0x08, 0x7c, 0x4a,
	0x2e, 0x4c, 0xdf, 0x76, 0x3c, 0xdf, 0xbc, 0x21, 0x2e, 0xf1, 0x5c, 0x0d, 0xad, 0x1c, 0xf7, 0xbd,
	0xeb, 0x99, 0x96, 0x6f, 0xde, 0x18, 0xe6, 0xa5, 0x47, 0x1c, 0x5b, 0xdb, 0xc4, 0x4f, 0x61, 0x5f,
	0x38, 0x97, 0x23, 0x3a, 0xb2, 0x4c, 0xcf, 0xa4, 0x15, 0xb3, 0x81, 0xf7, 0x61, 0x57, 0x98, 0x17,
	0xce, 0x19, 0x31, 0x2a, 0x46, 0x13, 0xef, 0x01, 0x16, 0xc6, 0xdb, 0x91, 0x37, 0xaa, 0xe8, 0xca,
	0xea, 0x39, 0xb6, 0xe3, 0x8f, 0x0c, 0xc3, 0x74, 0x5d, 0x9f, 0x92, 0xb3, 0x77, 0x9e, 0xab, 0xa9,
	0xb8, 0x03, 0x9a, 0x3c, 0x71, 0x52, 0xc9, 0xb7, 0xf0, 0x13, 0x68, 0x0b, 0xf5, 0xca, 0x3e, 0xb7,
	0x9d, 0x6b, 0x5b, 0x7b, 0x78, 0x68, 0x0c, 0xbf, 0x20, 0xd8, 0xad, 0xd6, 0xe7, 0xb2, 0x6c, 0xce,
	0xc7, 0x0c, 0x7f, 0x84, 0x4e, 0x5d, 0xab, 0xf8, 0xd5, 0x3f, 0x5e, 0xe9, 0xdf, 0x1f, 0xc5, 0xc1,
	0xe0, 0x7f, 0xe2, 0x79, 0xda, 0xdf, 0x38, 0x79, 0xf4, 0x7d, 0xd1, 0x45, 0x3f, 0x16, 0x5d, 0xf4,
	0x73, 0xd1, 0x45, 0xb7, 0xaa, 0xfc, 0x49, 0x5f, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x20, 0x75,
	0x82, 0x5a, 0xfc, 0x03, 0x00, 0x00,
}
