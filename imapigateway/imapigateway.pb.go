// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imapigateway/imapigateway.proto

package imapigateway

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import storageservice "gitlab.chatserver.im/interfaceprobuf/storageservice"
import storageservice1 "gitlab.chatserver.im/interfaceprobuf/storageservice"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GroupLiveReplyCode int32

const (
	GroupLiveReplyCode_Successfuly GroupLiveReplyCode = 0
	GroupLiveReplyCode_UserUnknown GroupLiveReplyCode = 90001
	GroupLiveReplyCode_ChanUnknown GroupLiveReplyCode = 90002
	GroupLiveReplyCode_LiveUnknown GroupLiveReplyCode = 90003
	GroupLiveReplyCode_LiveOnGoing GroupLiveReplyCode = 90004
	GroupLiveReplyCode_HaveNoPower GroupLiveReplyCode = 90005
	GroupLiveReplyCode_IllegalArgs GroupLiveReplyCode = 90006
	GroupLiveReplyCode_InternalErr GroupLiveReplyCode = 90007
)

var GroupLiveReplyCode_name = map[int32]string{
	0:     "Successfuly",
	90001: "UserUnknown",
	90002: "ChanUnknown",
	90003: "LiveUnknown",
	90004: "LiveOnGoing",
	90005: "HaveNoPower",
	90006: "IllegalArgs",
	90007: "InternalErr",
}
var GroupLiveReplyCode_value = map[string]int32{
	"Successfuly": 0,
	"UserUnknown": 90001,
	"ChanUnknown": 90002,
	"LiveUnknown": 90003,
	"LiveOnGoing": 90004,
	"HaveNoPower": 90005,
	"IllegalArgs": 90006,
	"InternalErr": 90007,
}

func (x GroupLiveReplyCode) String() string {
	return proto.EnumName(GroupLiveReplyCode_name, int32(x))
}
func (GroupLiveReplyCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{0}
}

// ChatType 聊天类型
type ChatType int32

const (
	ChatType_ChatTypeZero ChatType = 0
	ChatType_PeerUser     ChatType = 1
	ChatType_PeerChat     ChatType = 2
	ChatType_ChannelChat  ChatType = 3
)

var ChatType_name = map[int32]string{
	0: "ChatTypeZero",
	1: "PeerUser",
	2: "PeerChat",
	3: "ChannelChat",
}
var ChatType_value = map[string]int32{
	"ChatTypeZero": 0,
	"PeerUser":     1,
	"PeerChat":     2,
	"ChannelChat":  3,
}

func (x ChatType) String() string {
	return proto.EnumName(ChatType_name, int32(x))
}
func (ChatType) EnumDescriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{1} }

// 消息来源ID定义
type MsgFromID int32

const (
	MsgFromID_MFI_UNKNOWN       MsgFromID = 0
	MsgFromID_MFI_IM            MsgFromID = 1
	MsgFromID_MFI_Integral_Mall MsgFromID = 2
	MsgFromID_MFI_GameApi       MsgFromID = 3
)

var MsgFromID_name = map[int32]string{
	0: "MFI_UNKNOWN",
	1: "MFI_IM",
	2: "MFI_Integral_Mall",
	3: "MFI_GameApi",
}
var MsgFromID_value = map[string]int32{
	"MFI_UNKNOWN":       0,
	"MFI_IM":            1,
	"MFI_Integral_Mall": 2,
	"MFI_GameApi":       3,
}

func (x MsgFromID) String() string {
	return proto.EnumName(MsgFromID_name, int32(x))
}
func (MsgFromID) EnumDescriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{2} }

// ###################################  avthumb.pb.go  #############################
// StatusCode 状态码
type StatusCode int32

const (
	StatusCode_StatusCodeOK   StatusCode = 0
	StatusCode_StatusCodeFail StatusCode = 1
)

var StatusCode_name = map[int32]string{
	0: "StatusCodeOK",
	1: "StatusCodeFail",
}
var StatusCode_value = map[string]int32{
	"StatusCodeOK":   0,
	"StatusCodeFail": 1,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}
func (StatusCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{3} }

type ErrorCode int32

const (
	ErrorCode_ErrorCodeOk           ErrorCode = 0
	ErrorCode_ErrorCodeUserNotExist ErrorCode = 10001
)

var ErrorCode_name = map[int32]string{
	0:     "ErrorCodeOk",
	10001: "ErrorCodeUserNotExist",
}
var ErrorCode_value = map[string]int32{
	"ErrorCodeOk":           0,
	"ErrorCodeUserNotExist": 10001,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{4} }

type CheckIsMuteContactResult_ResultCode int32

const (
	CheckIsMuteContactResult_Success       CheckIsMuteContactResult_ResultCode = 0
	CheckIsMuteContactResult_InternalError CheckIsMuteContactResult_ResultCode = 1
)

var CheckIsMuteContactResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var CheckIsMuteContactResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x CheckIsMuteContactResult_ResultCode) String() string {
	return proto.EnumName(CheckIsMuteContactResult_ResultCode_name, int32(x))
}
func (CheckIsMuteContactResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{46, 0}
}

type AuthSignUpResult_ResultCode int32

const (
	AuthSignUpResult_Success             AuthSignUpResult_ResultCode = 0
	AuthSignUpResult_InternalError       AuthSignUpResult_ResultCode = 1
	AuthSignUpResult_PhoneNumberInvalid  AuthSignUpResult_ResultCode = 2
	AuthSignUpResult_PhoneNumberOccupied AuthSignUpResult_ResultCode = 3
	AuthSignUpResult_CaptchaExpired      AuthSignUpResult_ResultCode = 4
	AuthSignUpResult_CaptchaInvalid      AuthSignUpResult_ResultCode = 5
	AuthSignUpResult_FloodWait           AuthSignUpResult_ResultCode = 6
	AuthSignUpResult_SignUpRobotBlocked  AuthSignUpResult_ResultCode = 7
)

var AuthSignUpResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
	2: "PhoneNumberInvalid",
	3: "PhoneNumberOccupied",
	4: "CaptchaExpired",
	5: "CaptchaInvalid",
	6: "FloodWait",
	7: "SignUpRobotBlocked",
}
var AuthSignUpResult_ResultCode_value = map[string]int32{
	"Success":             0,
	"InternalError":       1,
	"PhoneNumberInvalid":  2,
	"PhoneNumberOccupied": 3,
	"CaptchaExpired":      4,
	"CaptchaInvalid":      5,
	"FloodWait":           6,
	"SignUpRobotBlocked":  7,
}

func (x AuthSignUpResult_ResultCode) String() string {
	return proto.EnumName(AuthSignUpResult_ResultCode_name, int32(x))
}
func (AuthSignUpResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{211, 0}
}

type GetGroupUserIdsReq struct {
	ChanId int32 `protobuf:"varint,1,opt,name=chanId,proto3" json:"chanId,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	Offset int32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Length int32 `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *GetGroupUserIdsReq) Reset()                    { *m = GetGroupUserIdsReq{} }
func (m *GetGroupUserIdsReq) String() string            { return proto.CompactTextString(m) }
func (*GetGroupUserIdsReq) ProtoMessage()               {}
func (*GetGroupUserIdsReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{0} }

func (m *GetGroupUserIdsReq) GetChanId() int32 {
	if m != nil {
		return m.ChanId
	}
	return 0
}

func (m *GetGroupUserIdsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetGroupUserIdsReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GetGroupUserIdsReq) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

type GetGroupUserIdsRsp struct {
	RetNo GroupLiveReplyCode `protobuf:"varint,1,opt,name=RetNo,proto3,enum=imapigateway.GroupLiveReplyCode" json:"RetNo,omitempty"`
	Total int32              `protobuf:"varint,2,opt,name=Total,proto3" json:"Total,omitempty"`
	Count int32              `protobuf:"varint,3,opt,name=Count,proto3" json:"Count,omitempty"`
	Users []int32            `protobuf:"varint,4,rep,packed,name=Users" json:"Users,omitempty"`
}

func (m *GetGroupUserIdsRsp) Reset()                    { *m = GetGroupUserIdsRsp{} }
func (m *GetGroupUserIdsRsp) String() string            { return proto.CompactTextString(m) }
func (*GetGroupUserIdsRsp) ProtoMessage()               {}
func (*GetGroupUserIdsRsp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{1} }

func (m *GetGroupUserIdsRsp) GetRetNo() GroupLiveReplyCode {
	if m != nil {
		return m.RetNo
	}
	return GroupLiveReplyCode_Successfuly
}

func (m *GetGroupUserIdsRsp) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *GetGroupUserIdsRsp) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetGroupUserIdsRsp) GetUsers() []int32 {
	if m != nil {
		return m.Users
	}
	return nil
}

// @ added by qingsong at 2020.12.01 for live start
// rpc GroupLiveStart(LiveStartReq) returns (LiveStarRsp) {}
// 开播请求
type LiveStartReq struct {
	BeginAt  int32  `protobuf:"varint,1,opt,name=BeginAt,proto3" json:"BeginAt,omitempty"`
	GroupId  int32  `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	LiveStat int32  `protobuf:"varint,3,opt,name=LiveStat,proto3" json:"LiveStat,omitempty"`
	LiveType int32  `protobuf:"varint,4,opt,name=LiveType,proto3" json:"LiveType,omitempty"`
	LiveUser int32  `protobuf:"varint,5,opt,name=LiveUser,proto3" json:"LiveUser,omitempty"`
	LiveRoom int32  `protobuf:"varint,6,opt,name=LiveRoom,proto3" json:"LiveRoom,omitempty"`
	LivePkId int64  `protobuf:"varint,7,opt,name=LivePkId,proto3" json:"LivePkId,omitempty"`
	LiveFlag string `protobuf:"bytes,8,opt,name=LiveFlag,proto3" json:"LiveFlag,omitempty"`
	LiveName string `protobuf:"bytes,9,opt,name=LiveName,proto3" json:"LiveName,omitempty"`
	LiveIcon string `protobuf:"bytes,10,opt,name=LiveIcon,proto3" json:"LiveIcon,omitempty"`
}

func (m *LiveStartReq) Reset()                    { *m = LiveStartReq{} }
func (m *LiveStartReq) String() string            { return proto.CompactTextString(m) }
func (*LiveStartReq) ProtoMessage()               {}
func (*LiveStartReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{2} }

func (m *LiveStartReq) GetBeginAt() int32 {
	if m != nil {
		return m.BeginAt
	}
	return 0
}

func (m *LiveStartReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *LiveStartReq) GetLiveStat() int32 {
	if m != nil {
		return m.LiveStat
	}
	return 0
}

func (m *LiveStartReq) GetLiveType() int32 {
	if m != nil {
		return m.LiveType
	}
	return 0
}

func (m *LiveStartReq) GetLiveUser() int32 {
	if m != nil {
		return m.LiveUser
	}
	return 0
}

func (m *LiveStartReq) GetLiveRoom() int32 {
	if m != nil {
		return m.LiveRoom
	}
	return 0
}

func (m *LiveStartReq) GetLivePkId() int64 {
	if m != nil {
		return m.LivePkId
	}
	return 0
}

func (m *LiveStartReq) GetLiveFlag() string {
	if m != nil {
		return m.LiveFlag
	}
	return ""
}

func (m *LiveStartReq) GetLiveName() string {
	if m != nil {
		return m.LiveName
	}
	return ""
}

func (m *LiveStartReq) GetLiveIcon() string {
	if m != nil {
		return m.LiveIcon
	}
	return ""
}

// 开播返回
type LiveStartRsp struct {
	ReplyCode GroupLiveReplyCode `protobuf:"varint,1,opt,name=ReplyCode,proto3,enum=imapigateway.GroupLiveReplyCode" json:"ReplyCode,omitempty"`
	InviteUrl string             `protobuf:"bytes,2,opt,name=InviteUrl,proto3" json:"InviteUrl,omitempty"`
}

func (m *LiveStartRsp) Reset()                    { *m = LiveStartRsp{} }
func (m *LiveStartRsp) String() string            { return proto.CompactTextString(m) }
func (*LiveStartRsp) ProtoMessage()               {}
func (*LiveStartRsp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{3} }

func (m *LiveStartRsp) GetReplyCode() GroupLiveReplyCode {
	if m != nil {
		return m.ReplyCode
	}
	return GroupLiveReplyCode_Successfuly
}

func (m *LiveStartRsp) GetInviteUrl() string {
	if m != nil {
		return m.InviteUrl
	}
	return ""
}

// @ added by qingsong at 2020.12.01 for live stop
// rpc GroupLiveStop(LiveStopReq) returns (LiveStopRsp) {}
// 停播请求
type LiveStopReq struct {
	GroupId  int32  `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	LiveUser int32  `protobuf:"varint,2,opt,name=LiveUser,proto3" json:"LiveUser,omitempty"`
	LiveStat int32  `protobuf:"varint,3,opt,name=LiveStat,proto3" json:"LiveStat,omitempty"`
	LiveCode string `protobuf:"bytes,4,opt,name=LiveCode,proto3" json:"LiveCode,omitempty"`
}

func (m *LiveStopReq) Reset()                    { *m = LiveStopReq{} }
func (m *LiveStopReq) String() string            { return proto.CompactTextString(m) }
func (*LiveStopReq) ProtoMessage()               {}
func (*LiveStopReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{4} }

func (m *LiveStopReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *LiveStopReq) GetLiveUser() int32 {
	if m != nil {
		return m.LiveUser
	}
	return 0
}

func (m *LiveStopReq) GetLiveStat() int32 {
	if m != nil {
		return m.LiveStat
	}
	return 0
}

func (m *LiveStopReq) GetLiveCode() string {
	if m != nil {
		return m.LiveCode
	}
	return ""
}

// 停播应答
type LiveStopRsp struct {
	RetCode GroupLiveReplyCode `protobuf:"varint,1,opt,name=RetCode,proto3,enum=imapigateway.GroupLiveReplyCode" json:"RetCode,omitempty"`
	Invited int32              `protobuf:"varint,2,opt,name=Invited,proto3" json:"Invited,omitempty"`
}

func (m *LiveStopRsp) Reset()                    { *m = LiveStopRsp{} }
func (m *LiveStopRsp) String() string            { return proto.CompactTextString(m) }
func (*LiveStopRsp) ProtoMessage()               {}
func (*LiveStopRsp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{5} }

func (m *LiveStopRsp) GetRetCode() GroupLiveReplyCode {
	if m != nil {
		return m.RetCode
	}
	return GroupLiveReplyCode_Successfuly
}

func (m *LiveStopRsp) GetInvited() int32 {
	if m != nil {
		return m.Invited
	}
	return 0
}

// @ added by qingsong at 2020.12.01 for live user invite link
// 获取主播邀请链接
type GetLiveInviteUrlReq struct {
	BeginAt  int32 `protobuf:"varint,1,opt,name=BeginAt,proto3" json:"BeginAt,omitempty"`
	GroupId  int32 `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	LiveUser int32 `protobuf:"varint,3,opt,name=LiveUser,proto3" json:"LiveUser,omitempty"`
}

func (m *GetLiveInviteUrlReq) Reset()                    { *m = GetLiveInviteUrlReq{} }
func (m *GetLiveInviteUrlReq) String() string            { return proto.CompactTextString(m) }
func (*GetLiveInviteUrlReq) ProtoMessage()               {}
func (*GetLiveInviteUrlReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{6} }

func (m *GetLiveInviteUrlReq) GetBeginAt() int32 {
	if m != nil {
		return m.BeginAt
	}
	return 0
}

func (m *GetLiveInviteUrlReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GetLiveInviteUrlReq) GetLiveUser() int32 {
	if m != nil {
		return m.LiveUser
	}
	return 0
}

type GetLiveInviteUrlRsp struct {
	ReplyCode GroupLiveReplyCode `protobuf:"varint,1,opt,name=ReplyCode,proto3,enum=imapigateway.GroupLiveReplyCode" json:"ReplyCode,omitempty"`
	InviteUrl string             `protobuf:"bytes,2,opt,name=InviteUrl,proto3" json:"InviteUrl,omitempty"`
}

func (m *GetLiveInviteUrlRsp) Reset()                    { *m = GetLiveInviteUrlRsp{} }
func (m *GetLiveInviteUrlRsp) String() string            { return proto.CompactTextString(m) }
func (*GetLiveInviteUrlRsp) ProtoMessage()               {}
func (*GetLiveInviteUrlRsp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{7} }

func (m *GetLiveInviteUrlRsp) GetReplyCode() GroupLiveReplyCode {
	if m != nil {
		return m.ReplyCode
	}
	return GroupLiveReplyCode_Successfuly
}

func (m *GetLiveInviteUrlRsp) GetInviteUrl() string {
	if m != nil {
		return m.InviteUrl
	}
	return ""
}

// rpc EditLiveInfo(EditLiveInfoReq) returns (EditLiveInfoRsp) {}
// 编辑请求
type EditLiveInfoReq struct {
	BeginAt  int32  `protobuf:"varint,1,opt,name=BeginAt,proto3" json:"BeginAt,omitempty"`
	GroupId  int32  `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	LiveStat int32  `protobuf:"varint,3,opt,name=LiveStat,proto3" json:"LiveStat,omitempty"`
	LiveType int32  `protobuf:"varint,4,opt,name=LiveType,proto3" json:"LiveType,omitempty"`
	LiveUser int32  `protobuf:"varint,5,opt,name=LiveUser,proto3" json:"LiveUser,omitempty"`
	LiveRoom int32  `protobuf:"varint,6,opt,name=LiveRoom,proto3" json:"LiveRoom,omitempty"`
	LiveFlag string `protobuf:"bytes,7,opt,name=LiveFlag,proto3" json:"LiveFlag,omitempty"`
	LiveName string `protobuf:"bytes,8,opt,name=LiveName,proto3" json:"LiveName,omitempty"`
	LiveIcon string `protobuf:"bytes,9,opt,name=LiveIcon,proto3" json:"LiveIcon,omitempty"`
}

func (m *EditLiveInfoReq) Reset()                    { *m = EditLiveInfoReq{} }
func (m *EditLiveInfoReq) String() string            { return proto.CompactTextString(m) }
func (*EditLiveInfoReq) ProtoMessage()               {}
func (*EditLiveInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{8} }

func (m *EditLiveInfoReq) GetBeginAt() int32 {
	if m != nil {
		return m.BeginAt
	}
	return 0
}

func (m *EditLiveInfoReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *EditLiveInfoReq) GetLiveStat() int32 {
	if m != nil {
		return m.LiveStat
	}
	return 0
}

func (m *EditLiveInfoReq) GetLiveType() int32 {
	if m != nil {
		return m.LiveType
	}
	return 0
}

func (m *EditLiveInfoReq) GetLiveUser() int32 {
	if m != nil {
		return m.LiveUser
	}
	return 0
}

func (m *EditLiveInfoReq) GetLiveRoom() int32 {
	if m != nil {
		return m.LiveRoom
	}
	return 0
}

func (m *EditLiveInfoReq) GetLiveFlag() string {
	if m != nil {
		return m.LiveFlag
	}
	return ""
}

func (m *EditLiveInfoReq) GetLiveName() string {
	if m != nil {
		return m.LiveName
	}
	return ""
}

func (m *EditLiveInfoReq) GetLiveIcon() string {
	if m != nil {
		return m.LiveIcon
	}
	return ""
}

type EditLiveInfoRsp struct {
	ReplyCode GroupLiveReplyCode `protobuf:"varint,1,opt,name=ReplyCode,proto3,enum=imapigateway.GroupLiveReplyCode" json:"ReplyCode,omitempty"`
	ReplyData string             `protobuf:"bytes,2,opt,name=ReplyData,proto3" json:"ReplyData,omitempty"`
}

func (m *EditLiveInfoRsp) Reset()                    { *m = EditLiveInfoRsp{} }
func (m *EditLiveInfoRsp) String() string            { return proto.CompactTextString(m) }
func (*EditLiveInfoRsp) ProtoMessage()               {}
func (*EditLiveInfoRsp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{9} }

func (m *EditLiveInfoRsp) GetReplyCode() GroupLiveReplyCode {
	if m != nil {
		return m.ReplyCode
	}
	return GroupLiveReplyCode_Successfuly
}

func (m *EditLiveInfoRsp) GetReplyData() string {
	if m != nil {
		return m.ReplyData
	}
	return ""
}

// @ brief : group live rights check.
// rpc GroupLiveCheck(GroupLiveCheckReq)returns(GroupLiveCheckRsp){}
type GroupLiveCheckReq struct {
	GroupId  int32 `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	LiveUser int32 `protobuf:"varint,2,opt,name=LiveUser,proto3" json:"LiveUser,omitempty"`
}

func (m *GroupLiveCheckReq) Reset()                    { *m = GroupLiveCheckReq{} }
func (m *GroupLiveCheckReq) String() string            { return proto.CompactTextString(m) }
func (*GroupLiveCheckReq) ProtoMessage()               {}
func (*GroupLiveCheckReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{10} }

func (m *GroupLiveCheckReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GroupLiveCheckReq) GetLiveUser() int32 {
	if m != nil {
		return m.LiveUser
	}
	return 0
}

type GroupLiveCheckRsp struct {
	ReplyCode GroupLiveReplyCode `protobuf:"varint,1,opt,name=ReplyCode,proto3,enum=imapigateway.GroupLiveReplyCode" json:"ReplyCode,omitempty"`
	ReplyData string             `protobuf:"bytes,2,opt,name=ReplyData,proto3" json:"ReplyData,omitempty"`
}

func (m *GroupLiveCheckRsp) Reset()                    { *m = GroupLiveCheckRsp{} }
func (m *GroupLiveCheckRsp) String() string            { return proto.CompactTextString(m) }
func (*GroupLiveCheckRsp) ProtoMessage()               {}
func (*GroupLiveCheckRsp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{11} }

func (m *GroupLiveCheckRsp) GetReplyCode() GroupLiveReplyCode {
	if m != nil {
		return m.ReplyCode
	}
	return GroupLiveReplyCode_Successfuly
}

func (m *GroupLiveCheckRsp) GetReplyData() string {
	if m != nil {
		return m.ReplyData
	}
	return ""
}

// @ brief : get live invite user count.
// rpc GetLiveInviteCnt(GetLiveInviteCntReq) returns (GetLiveInviteCntRsp) {}
type GetLiveInviteCntReq struct {
	GroupId  int32 `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	LiveUser int32 `protobuf:"varint,2,opt,name=LiveUser,proto3" json:"LiveUser,omitempty"`
}

func (m *GetLiveInviteCntReq) Reset()         { *m = GetLiveInviteCntReq{} }
func (m *GetLiveInviteCntReq) String() string { return proto.CompactTextString(m) }
func (*GetLiveInviteCntReq) ProtoMessage()    {}
func (*GetLiveInviteCntReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{12}
}

func (m *GetLiveInviteCntReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GetLiveInviteCntReq) GetLiveUser() int32 {
	if m != nil {
		return m.LiveUser
	}
	return 0
}

type GetLiveInviteCntRsp struct {
	RetCode GroupLiveReplyCode `protobuf:"varint,1,opt,name=RetCode,proto3,enum=imapigateway.GroupLiveReplyCode" json:"RetCode,omitempty"`
	Invited int32              `protobuf:"varint,2,opt,name=Invited,proto3" json:"Invited,omitempty"`
}

func (m *GetLiveInviteCntRsp) Reset()         { *m = GetLiveInviteCntRsp{} }
func (m *GetLiveInviteCntRsp) String() string { return proto.CompactTextString(m) }
func (*GetLiveInviteCntRsp) ProtoMessage()    {}
func (*GetLiveInviteCntRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{13}
}

func (m *GetLiveInviteCntRsp) GetRetCode() GroupLiveReplyCode {
	if m != nil {
		return m.RetCode
	}
	return GroupLiveReplyCode_Successfuly
}

func (m *GetLiveInviteCntRsp) GetInvited() int32 {
	if m != nil {
		return m.Invited
	}
	return 0
}

// rpc CheckUserInGroup(CheckUserInGroupReq) returns (CheckUserInGroupRsp)
type CheckUserInGroupReq struct {
	GroupId int32 `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	UserId  int32 `protobuf:"varint,2,opt,name=UserId,proto3" json:"UserId,omitempty"`
}

func (m *CheckUserInGroupReq) Reset()         { *m = CheckUserInGroupReq{} }
func (m *CheckUserInGroupReq) String() string { return proto.CompactTextString(m) }
func (*CheckUserInGroupReq) ProtoMessage()    {}
func (*CheckUserInGroupReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{14}
}

func (m *CheckUserInGroupReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *CheckUserInGroupReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type CheckUserInGroupRsp struct {
	InGroup bool `protobuf:"varint,1,opt,name=InGroup,proto3" json:"InGroup,omitempty"`
}

func (m *CheckUserInGroupRsp) Reset()         { *m = CheckUserInGroupRsp{} }
func (m *CheckUserInGroupRsp) String() string { return proto.CompactTextString(m) }
func (*CheckUserInGroupRsp) ProtoMessage()    {}
func (*CheckUserInGroupRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{15}
}

func (m *CheckUserInGroupRsp) GetInGroup() bool {
	if m != nil {
		return m.InGroup
	}
	return false
}

// 直播推送请求
type LivePushReq struct {
	UserIds []int32 `protobuf:"varint,1,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
	SelfId  int32   `protobuf:"varint,2,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
	Text    string  `protobuf:"bytes,3,opt,name=text,proto3" json:"text,omitempty"`
	Type    int32   `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *LivePushReq) Reset()                    { *m = LivePushReq{} }
func (m *LivePushReq) String() string            { return proto.CompactTextString(m) }
func (*LivePushReq) ProtoMessage()               {}
func (*LivePushReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{16} }

func (m *LivePushReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *LivePushReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *LivePushReq) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *LivePushReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type LivePushResult struct {
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *LivePushResult) Reset()                    { *m = LivePushResult{} }
func (m *LivePushResult) String() string            { return proto.CompactTextString(m) }
func (*LivePushResult) ProtoMessage()               {}
func (*LivePushResult) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{17} }

func (m *LivePushResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// 踢人
type ReqKickFromChannel struct {
	ChannelId int32  `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Kicker    int32  `protobuf:"varint,2,opt,name=kicker,proto3" json:"kicker,omitempty"`
	Kickee    int32  `protobuf:"varint,3,opt,name=kickee,proto3" json:"kickee,omitempty"`
	IsBotUser bool   `protobuf:"varint,4,opt,name=is_bot_user,json=isBotUser,proto3" json:"is_bot_user,omitempty"`
	IsKicked  bool   `protobuf:"varint,5,opt,name=is_kicked,json=isKicked,proto3" json:"is_kicked,omitempty"`
	KickedId  int32  `protobuf:"varint,6,opt,name=Kicked_id,json=KickedId,proto3" json:"Kicked_id,omitempty"`
	FromKeyid int64  `protobuf:"varint,7,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *Debug `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqKickFromChannel) Reset()                    { *m = ReqKickFromChannel{} }
func (m *ReqKickFromChannel) String() string            { return proto.CompactTextString(m) }
func (*ReqKickFromChannel) ProtoMessage()               {}
func (*ReqKickFromChannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{18} }

func (m *ReqKickFromChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqKickFromChannel) GetKicker() int32 {
	if m != nil {
		return m.Kicker
	}
	return 0
}

func (m *ReqKickFromChannel) GetKickee() int32 {
	if m != nil {
		return m.Kickee
	}
	return 0
}

func (m *ReqKickFromChannel) GetIsBotUser() bool {
	if m != nil {
		return m.IsBotUser
	}
	return false
}

func (m *ReqKickFromChannel) GetIsKicked() bool {
	if m != nil {
		return m.IsKicked
	}
	return false
}

func (m *ReqKickFromChannel) GetKickedId() int32 {
	if m != nil {
		return m.KickedId
	}
	return 0
}

func (m *ReqKickFromChannel) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqKickFromChannel) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type CheckUserNameReq struct {
	UserId   int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	UserName string `protobuf:"bytes,2,opt,name=userName,proto3" json:"userName,omitempty"`
	Debug    *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *CheckUserNameReq) Reset()                    { *m = CheckUserNameReq{} }
func (m *CheckUserNameReq) String() string            { return proto.CompactTextString(m) }
func (*CheckUserNameReq) ProtoMessage()               {}
func (*CheckUserNameReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{19} }

func (m *CheckUserNameReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CheckUserNameReq) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *CheckUserNameReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type CheckUserNameResp struct {
	Occpuy    bool   `protobuf:"varint,1,opt,name=occpuy,proto3" json:"occpuy,omitempty"`
	ErrorCode uint32 `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMsg  string `protobuf:"bytes,3,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
}

func (m *CheckUserNameResp) Reset()                    { *m = CheckUserNameResp{} }
func (m *CheckUserNameResp) String() string            { return proto.CompactTextString(m) }
func (*CheckUserNameResp) ProtoMessage()               {}
func (*CheckUserNameResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{20} }

func (m *CheckUserNameResp) GetOccpuy() bool {
	if m != nil {
		return m.Occpuy
	}
	return false
}

func (m *CheckUserNameResp) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *CheckUserNameResp) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

// 发送短信
type ReqSendCodeMsg struct {
	Userid     int32  `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	AccessHash int64  `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Keyid      uint64 `protobuf:"varint,3,opt,name=keyid,proto3" json:"keyid,omitempty"`
	Code       string `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	Debug      *Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqSendCodeMsg) Reset()                    { *m = ReqSendCodeMsg{} }
func (m *ReqSendCodeMsg) String() string            { return proto.CompactTextString(m) }
func (*ReqSendCodeMsg) ProtoMessage()               {}
func (*ReqSendCodeMsg) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{21} }

func (m *ReqSendCodeMsg) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *ReqSendCodeMsg) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqSendCodeMsg) GetKeyid() uint64 {
	if m != nil {
		return m.Keyid
	}
	return 0
}

func (m *ReqSendCodeMsg) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *ReqSendCodeMsg) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 禁言单个用户
type ChannelBannedRights struct {
	Flags        int32 `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	ViewMessages bool  `protobuf:"varint,2,opt,name=view_messages,json=viewMessages,proto3" json:"view_messages,omitempty"`
	SendMessages bool  `protobuf:"varint,3,opt,name=send_messages,json=sendMessages,proto3" json:"send_messages,omitempty"`
	SendMedia    bool  `protobuf:"varint,4,opt,name=send_media,json=sendMedia,proto3" json:"send_media,omitempty"`
	SendStickers bool  `protobuf:"varint,5,opt,name=send_stickers,json=sendStickers,proto3" json:"send_stickers,omitempty"`
	SendGifs     bool  `protobuf:"varint,6,opt,name=send_gifs,json=sendGifs,proto3" json:"send_gifs,omitempty"`
	SendGames    bool  `protobuf:"varint,7,opt,name=send_games,json=sendGames,proto3" json:"send_games,omitempty"`
	SendInline   bool  `protobuf:"varint,8,opt,name=send_inline,json=sendInline,proto3" json:"send_inline,omitempty"`
	EmbedLinks   bool  `protobuf:"varint,9,opt,name=embed_links,json=embedLinks,proto3" json:"embed_links,omitempty"`
	UntilDate    int32 `protobuf:"varint,10,opt,name=until_date,json=untilDate,proto3" json:"until_date,omitempty"`
	// @ add by Qingsong at 2019-11-14 for ban member rights.
	InviteUser      bool `protobuf:"varint,11,opt,name=invite_user,json=inviteUser,proto3" json:"invite_user,omitempty"`
	PinMessage      bool `protobuf:"varint,12,opt,name=pin_message,json=pinMessage,proto3" json:"pin_message,omitempty"`
	ChangeGroupInfo bool `protobuf:"varint,13,opt,name=change_group_info,json=changeGroupInfo,proto3" json:"change_group_info,omitempty"`
	SendPolls       bool `protobuf:"varint,14,opt,name=send_polls,json=sendPolls,proto3" json:"send_polls,omitempty"`
}

func (m *ChannelBannedRights) Reset()         { *m = ChannelBannedRights{} }
func (m *ChannelBannedRights) String() string { return proto.CompactTextString(m) }
func (*ChannelBannedRights) ProtoMessage()    {}
func (*ChannelBannedRights) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{22}
}

func (m *ChannelBannedRights) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ChannelBannedRights) GetViewMessages() bool {
	if m != nil {
		return m.ViewMessages
	}
	return false
}

func (m *ChannelBannedRights) GetSendMessages() bool {
	if m != nil {
		return m.SendMessages
	}
	return false
}

func (m *ChannelBannedRights) GetSendMedia() bool {
	if m != nil {
		return m.SendMedia
	}
	return false
}

func (m *ChannelBannedRights) GetSendStickers() bool {
	if m != nil {
		return m.SendStickers
	}
	return false
}

func (m *ChannelBannedRights) GetSendGifs() bool {
	if m != nil {
		return m.SendGifs
	}
	return false
}

func (m *ChannelBannedRights) GetSendGames() bool {
	if m != nil {
		return m.SendGames
	}
	return false
}

func (m *ChannelBannedRights) GetSendInline() bool {
	if m != nil {
		return m.SendInline
	}
	return false
}

func (m *ChannelBannedRights) GetEmbedLinks() bool {
	if m != nil {
		return m.EmbedLinks
	}
	return false
}

func (m *ChannelBannedRights) GetUntilDate() int32 {
	if m != nil {
		return m.UntilDate
	}
	return 0
}

func (m *ChannelBannedRights) GetInviteUser() bool {
	if m != nil {
		return m.InviteUser
	}
	return false
}

func (m *ChannelBannedRights) GetPinMessage() bool {
	if m != nil {
		return m.PinMessage
	}
	return false
}

func (m *ChannelBannedRights) GetChangeGroupInfo() bool {
	if m != nil {
		return m.ChangeGroupInfo
	}
	return false
}

func (m *ChannelBannedRights) GetSendPolls() bool {
	if m != nil {
		return m.SendPolls
	}
	return false
}

type ReqEditBanChannelUser struct {
	FromId              int32                `protobuf:"varint,1,opt,name=fromId,proto3" json:"fromId,omitempty"`
	FromKeyId           int64                `protobuf:"varint,2,opt,name=fromKeyId,proto3" json:"fromKeyId,omitempty"`
	ChannelId           int32                `protobuf:"varint,3,opt,name=channelId,proto3" json:"channelId,omitempty"`
	BannedUserId        int32                `protobuf:"varint,4,opt,name=bannedUserId,proto3" json:"bannedUserId,omitempty"`
	AccessHash          int64                `protobuf:"varint,5,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	UtilDate            int32                `protobuf:"varint,6,opt,name=util_date,json=utilDate,proto3" json:"util_date,omitempty"`
	ChannelBannedRights *ChannelBannedRights `protobuf:"bytes,7,opt,name=channelBannedRights" json:"channelBannedRights,omitempty"`
	Debug               *Debug               `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqEditBanChannelUser) Reset()         { *m = ReqEditBanChannelUser{} }
func (m *ReqEditBanChannelUser) String() string { return proto.CompactTextString(m) }
func (*ReqEditBanChannelUser) ProtoMessage()    {}
func (*ReqEditBanChannelUser) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{23}
}

func (m *ReqEditBanChannelUser) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetBannedUserId() int32 {
	if m != nil {
		return m.BannedUserId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetUtilDate() int32 {
	if m != nil {
		return m.UtilDate
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetChannelBannedRights() *ChannelBannedRights {
	if m != nil {
		return m.ChannelBannedRights
	}
	return nil
}

func (m *ReqEditBanChannelUser) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 超级群全体禁言
type ReqEditEveryoneQuiet struct {
	UserId    int32  `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	ChannelId int32  `protobuf:"varint,2,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	Quiet     bool   `protobuf:"varint,3,opt,name=quiet,proto3" json:"quiet,omitempty"`
	Debug     *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqEditEveryoneQuiet) Reset()         { *m = ReqEditEveryoneQuiet{} }
func (m *ReqEditEveryoneQuiet) String() string { return proto.CompactTextString(m) }
func (*ReqEditEveryoneQuiet) ProtoMessage()    {}
func (*ReqEditEveryoneQuiet) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{24}
}

func (m *ReqEditEveryoneQuiet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqEditEveryoneQuiet) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqEditEveryoneQuiet) GetQuiet() bool {
	if m != nil {
		return m.Quiet
	}
	return false
}

func (m *ReqEditEveryoneQuiet) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 获取群用户信息
type GetChannelUserInfoReq struct {
	ChannelId  int32  `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	FromId     int32  `protobuf:"varint,2,opt,name=fromId,proto3" json:"fromId,omitempty"`
	UserId     int32  `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
	AccessHash int64  `protobuf:"varint,4,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	Debug      *Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetChannelUserInfoReq) Reset()         { *m = GetChannelUserInfoReq{} }
func (m *GetChannelUserInfoReq) String() string { return proto.CompactTextString(m) }
func (*GetChannelUserInfoReq) ProtoMessage()    {}
func (*GetChannelUserInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{25}
}

func (m *GetChannelUserInfoReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelUserInfoReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *GetChannelUserInfoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetChannelUserInfoReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GetChannelUserInfoReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type GetChannelUserInfoResp struct {
	Reply      []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode  int32  `protobuf:"varint,2,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
	ChannelId  int32  `protobuf:"varint,3,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	AccessHash int64  `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	FromId     int32  `protobuf:"varint,5,opt,name=FromId,proto3" json:"FromId,omitempty"`
}

func (m *GetChannelUserInfoResp) Reset()         { *m = GetChannelUserInfoResp{} }
func (m *GetChannelUserInfoResp) String() string { return proto.CompactTextString(m) }
func (*GetChannelUserInfoResp) ProtoMessage()    {}
func (*GetChannelUserInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{26}
}

func (m *GetChannelUserInfoResp) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *GetChannelUserInfoResp) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *GetChannelUserInfoResp) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelUserInfoResp) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GetChannelUserInfoResp) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

// 检测是否是对方是否是自己的联系人
type CheckIsSelfContactReq struct {
	SelfId int32  `protobuf:"varint,1,opt,name=selfId,proto3" json:"selfId,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	Debug  *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *CheckIsSelfContactReq) Reset()         { *m = CheckIsSelfContactReq{} }
func (m *CheckIsSelfContactReq) String() string { return proto.CompactTextString(m) }
func (*CheckIsSelfContactReq) ProtoMessage()    {}
func (*CheckIsSelfContactReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{27}
}

func (m *CheckIsSelfContactReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *CheckIsSelfContactReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CheckIsSelfContactReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 检测是否是自己是否是对方的联系人的返回结果
type CheckIsSelfContactResult struct {
	IsSelfContact bool      `protobuf:"varint,1,opt,name=IsSelfContact,proto3" json:"IsSelfContact,omitempty"`
	Errorcode     ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *CheckIsSelfContactResult) Reset()         { *m = CheckIsSelfContactResult{} }
func (m *CheckIsSelfContactResult) String() string { return proto.CompactTextString(m) }
func (*CheckIsSelfContactResult) ProtoMessage()    {}
func (*CheckIsSelfContactResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{28}
}

func (m *CheckIsSelfContactResult) GetIsSelfContact() bool {
	if m != nil {
		return m.IsSelfContact
	}
	return false
}

func (m *CheckIsSelfContactResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 朋友圈关注接口
type MomentFollowReq struct {
	UserId   int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FollowId int64 `protobuf:"varint,2,opt,name=follow_id,json=followId,proto3" json:"follow_id,omitempty"`
	IsFollow int32 `protobuf:"varint,3,opt,name=is_follow,json=isFollow,proto3" json:"is_follow,omitempty"`
}

func (m *MomentFollowReq) Reset()                    { *m = MomentFollowReq{} }
func (m *MomentFollowReq) String() string            { return proto.CompactTextString(m) }
func (*MomentFollowReq) ProtoMessage()               {}
func (*MomentFollowReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{29} }

func (m *MomentFollowReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MomentFollowReq) GetFollowId() int64 {
	if m != nil {
		return m.FollowId
	}
	return 0
}

func (m *MomentFollowReq) GetIsFollow() int32 {
	if m != nil {
		return m.IsFollow
	}
	return 0
}

// 朋友圈关注接口
type MomentFollowResp struct {
	ErrorCode int32 `protobuf:"varint,1,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
}

func (m *MomentFollowResp) Reset()                    { *m = MomentFollowResp{} }
func (m *MomentFollowResp) String() string            { return proto.CompactTextString(m) }
func (*MomentFollowResp) ProtoMessage()               {}
func (*MomentFollowResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{30} }

func (m *MomentFollowResp) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type MomentData struct {
	ForumId    int64  `protobuf:"varint,1,opt,name=forum_id,json=forumId,proto3" json:"forum_id,omitempty"`
	ForumType  int64  `protobuf:"varint,2,opt,name=forum_type,json=forumType,proto3" json:"forum_type,omitempty"`
	ForumImage string `protobuf:"bytes,3,opt,name=forum_image,json=forumImage,proto3" json:"forum_image,omitempty"`
	ForumText  string `protobuf:"bytes,4,opt,name=forum_text,json=forumText,proto3" json:"forum_text,omitempty"`
	WithId     int32  `protobuf:"varint,5,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	MsgId      int64  `protobuf:"varint,6,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	MsgContent string `protobuf:"bytes,7,opt,name=msg_content,json=msgContent,proto3" json:"msg_content,omitempty"`
	IsFollowed int64  `protobuf:"varint,8,opt,name=is_followed,json=isFollowed,proto3" json:"is_followed,omitempty"`
}

func (m *MomentData) Reset()                    { *m = MomentData{} }
func (m *MomentData) String() string            { return proto.CompactTextString(m) }
func (*MomentData) ProtoMessage()               {}
func (*MomentData) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{31} }

func (m *MomentData) GetForumId() int64 {
	if m != nil {
		return m.ForumId
	}
	return 0
}

func (m *MomentData) GetForumType() int64 {
	if m != nil {
		return m.ForumType
	}
	return 0
}

func (m *MomentData) GetForumImage() string {
	if m != nil {
		return m.ForumImage
	}
	return ""
}

func (m *MomentData) GetForumText() string {
	if m != nil {
		return m.ForumText
	}
	return ""
}

func (m *MomentData) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *MomentData) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *MomentData) GetMsgContent() string {
	if m != nil {
		return m.MsgContent
	}
	return ""
}

func (m *MomentData) GetIsFollowed() int64 {
	if m != nil {
		return m.IsFollowed
	}
	return 0
}

type SysNotifyData struct {
	MsgTitle      string      `protobuf:"bytes,1,opt,name=msg_title,json=msgTitle,proto3" json:"msg_title,omitempty"`
	MsgTime       int64       `protobuf:"varint,2,opt,name=msg_time,json=msgTime,proto3" json:"msg_time,omitempty"`
	MsgUrl        string      `protobuf:"bytes,3,opt,name=msg_url,json=msgUrl,proto3" json:"msg_url,omitempty"`
	MsgButtonText string      `protobuf:"bytes,4,opt,name=msg_button_text,json=msgButtonText,proto3" json:"msg_button_text,omitempty"`
	InteractMsg   *MomentData `protobuf:"bytes,5,opt,name=interact_msg,json=interactMsg" json:"interact_msg,omitempty"`
	IsPush        bool        `protobuf:"varint,6,opt,name=is_push,json=isPush,proto3" json:"is_push,omitempty"`
}

func (m *SysNotifyData) Reset()                    { *m = SysNotifyData{} }
func (m *SysNotifyData) String() string            { return proto.CompactTextString(m) }
func (*SysNotifyData) ProtoMessage()               {}
func (*SysNotifyData) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{32} }

func (m *SysNotifyData) GetMsgTitle() string {
	if m != nil {
		return m.MsgTitle
	}
	return ""
}

func (m *SysNotifyData) GetMsgTime() int64 {
	if m != nil {
		return m.MsgTime
	}
	return 0
}

func (m *SysNotifyData) GetMsgUrl() string {
	if m != nil {
		return m.MsgUrl
	}
	return ""
}

func (m *SysNotifyData) GetMsgButtonText() string {
	if m != nil {
		return m.MsgButtonText
	}
	return ""
}

func (m *SysNotifyData) GetInteractMsg() *MomentData {
	if m != nil {
		return m.InteractMsg
	}
	return nil
}

func (m *SysNotifyData) GetIsPush() bool {
	if m != nil {
		return m.IsPush
	}
	return false
}

type NotifyMedia struct {
	Seq         int64  `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Fid         string `protobuf:"bytes,2,opt,name=fid,proto3" json:"fid,omitempty"`
	ContentType string `protobuf:"bytes,3,opt,name=content_type,json=contentType,proto3" json:"content_type,omitempty"`
	PartNum     int64  `protobuf:"varint,4,opt,name=part_num,json=partNum,proto3" json:"part_num,omitempty"`
	FileName    string `protobuf:"bytes,5,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	Md5         string `protobuf:"bytes,6,opt,name=md5,proto3" json:"md5,omitempty"`
	Width       int32  `protobuf:"varint,7,opt,name=width,proto3" json:"width,omitempty"`
	Height      int32  `protobuf:"varint,8,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *NotifyMedia) Reset()                    { *m = NotifyMedia{} }
func (m *NotifyMedia) String() string            { return proto.CompactTextString(m) }
func (*NotifyMedia) ProtoMessage()               {}
func (*NotifyMedia) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{33} }

func (m *NotifyMedia) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *NotifyMedia) GetFid() string {
	if m != nil {
		return m.Fid
	}
	return ""
}

func (m *NotifyMedia) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *NotifyMedia) GetPartNum() int64 {
	if m != nil {
		return m.PartNum
	}
	return 0
}

func (m *NotifyMedia) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *NotifyMedia) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *NotifyMedia) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *NotifyMedia) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type NotifyText struct {
	Seq  int64  `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *NotifyText) Reset()                    { *m = NotifyText{} }
func (m *NotifyText) String() string            { return proto.CompactTextString(m) }
func (*NotifyText) ProtoMessage()               {}
func (*NotifyText) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{34} }

func (m *NotifyText) GetSeq() int64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *NotifyText) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type SendMediaSysNotifyReq struct {
	SourceCode   int32          `protobuf:"varint,1,opt,name=source_code,json=sourceCode,proto3" json:"source_code,omitempty"`
	BusinessCode int32          `protobuf:"varint,2,opt,name=business_code,json=businessCode,proto3" json:"business_code,omitempty"`
	NotifyMedias []*NotifyMedia `protobuf:"bytes,3,rep,name=notify_medias,json=notifyMedias" json:"notify_medias,omitempty"`
	NotifyTexts  []*NotifyText  `protobuf:"bytes,4,rep,name=notify_texts,json=notifyTexts" json:"notify_texts,omitempty"`
	Users        []int32        `protobuf:"varint,5,rep,packed,name=users" json:"users,omitempty"`
	Data         *SysNotifyData `protobuf:"bytes,6,opt,name=data" json:"data,omitempty"`
	FromId       int32          `protobuf:"varint,7,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	MsgId        string         `protobuf:"bytes,8,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
}

func (m *SendMediaSysNotifyReq) Reset()         { *m = SendMediaSysNotifyReq{} }
func (m *SendMediaSysNotifyReq) String() string { return proto.CompactTextString(m) }
func (*SendMediaSysNotifyReq) ProtoMessage()    {}
func (*SendMediaSysNotifyReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{35}
}

func (m *SendMediaSysNotifyReq) GetSourceCode() int32 {
	if m != nil {
		return m.SourceCode
	}
	return 0
}

func (m *SendMediaSysNotifyReq) GetBusinessCode() int32 {
	if m != nil {
		return m.BusinessCode
	}
	return 0
}

func (m *SendMediaSysNotifyReq) GetNotifyMedias() []*NotifyMedia {
	if m != nil {
		return m.NotifyMedias
	}
	return nil
}

func (m *SendMediaSysNotifyReq) GetNotifyTexts() []*NotifyText {
	if m != nil {
		return m.NotifyTexts
	}
	return nil
}

func (m *SendMediaSysNotifyReq) GetUsers() []int32 {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *SendMediaSysNotifyReq) GetData() *SysNotifyData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SendMediaSysNotifyReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *SendMediaSysNotifyReq) GetMsgId() string {
	if m != nil {
		return m.MsgId
	}
	return ""
}

type FailUser struct {
	User int32  `protobuf:"varint,1,opt,name=user,proto3" json:"user,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *FailUser) Reset()                    { *m = FailUser{} }
func (m *FailUser) String() string            { return proto.CompactTextString(m) }
func (*FailUser) ProtoMessage()               {}
func (*FailUser) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{36} }

func (m *FailUser) GetUser() int32 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *FailUser) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type SucceedUser struct {
	User int32  `protobuf:"varint,1,opt,name=user,proto3" json:"user,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *SucceedUser) Reset()                    { *m = SucceedUser{} }
func (m *SucceedUser) String() string            { return proto.CompactTextString(m) }
func (*SucceedUser) ProtoMessage()               {}
func (*SucceedUser) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{37} }

func (m *SucceedUser) GetUser() int32 {
	if m != nil {
		return m.User
	}
	return 0
}

func (m *SucceedUser) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type SendMediaSysNotifyResult struct {
	ErrorCode    uint32         `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMsg     string         `protobuf:"bytes,2,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
	FailUsers    []*FailUser    `protobuf:"bytes,3,rep,name=failUsers" json:"failUsers,omitempty"`
	SucceedUsers []*SucceedUser `protobuf:"bytes,4,rep,name=SucceedUsers" json:"SucceedUsers,omitempty"`
}

func (m *SendMediaSysNotifyResult) Reset()         { *m = SendMediaSysNotifyResult{} }
func (m *SendMediaSysNotifyResult) String() string { return proto.CompactTextString(m) }
func (*SendMediaSysNotifyResult) ProtoMessage()    {}
func (*SendMediaSysNotifyResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{38}
}

func (m *SendMediaSysNotifyResult) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *SendMediaSysNotifyResult) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *SendMediaSysNotifyResult) GetFailUsers() []*FailUser {
	if m != nil {
		return m.FailUsers
	}
	return nil
}

func (m *SendMediaSysNotifyResult) GetSucceedUsers() []*SucceedUser {
	if m != nil {
		return m.SucceedUsers
	}
	return nil
}

type SearchUserByNicknameReq struct {
	Nickname string  `protobuf:"bytes,1,opt,name=nickname,proto3" json:"nickname,omitempty"`
	UserIds  []int32 `protobuf:"varint,2,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
	Offset   int32   `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit    int32   `protobuf:"varint,4,opt,name=limit,proto3" json:"limit,omitempty"`
	SelfId   int32   `protobuf:"varint,5,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
}

func (m *SearchUserByNicknameReq) Reset()         { *m = SearchUserByNicknameReq{} }
func (m *SearchUserByNicknameReq) String() string { return proto.CompactTextString(m) }
func (*SearchUserByNicknameReq) ProtoMessage()    {}
func (*SearchUserByNicknameReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{39}
}

func (m *SearchUserByNicknameReq) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

func (m *SearchUserByNicknameReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *SearchUserByNicknameReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SearchUserByNicknameReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchUserByNicknameReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

type SearchUserByNicknameResult struct {
	UserInfos []*UserInfo `protobuf:"bytes,1,rep,name=user_infos,json=userInfos" json:"user_infos,omitempty"`
	Errorcode ReErrCode   `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *SearchUserByNicknameResult) Reset()         { *m = SearchUserByNicknameResult{} }
func (m *SearchUserByNicknameResult) String() string { return proto.CompactTextString(m) }
func (*SearchUserByNicknameResult) ProtoMessage()    {}
func (*SearchUserByNicknameResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{40}
}

func (m *SearchUserByNicknameResult) GetUserInfos() []*UserInfo {
	if m != nil {
		return m.UserInfos
	}
	return nil
}

func (m *SearchUserByNicknameResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

type Entity struct {
	Type   int32  `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Offset int32  `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Length int32  `protobuf:"varint,3,opt,name=length,proto3" json:"length,omitempty"`
	UserId uint32 `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Url    string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{41} }

func (m *Entity) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Entity) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Entity) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *Entity) GetUserId() uint32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Entity) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type MomentNotifyData struct {
	SourceCode   int32     `protobuf:"varint,1,opt,name=source_code,json=sourceCode,proto3" json:"source_code,omitempty"`
	BusinessCode int32     `protobuf:"varint,2,opt,name=business_code,json=businessCode,proto3" json:"business_code,omitempty"`
	ToId         int32     `protobuf:"varint,3,opt,name=to_id,json=toId,proto3" json:"to_id,omitempty"`
	WithId       int32     `protobuf:"varint,4,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	ForumId      int64     `protobuf:"varint,5,opt,name=forum_id,json=forumId,proto3" json:"forum_id,omitempty"`
	ForumType    int64     `protobuf:"varint,6,opt,name=forum_type,json=forumType,proto3" json:"forum_type,omitempty"`
	ForumImage   string    `protobuf:"bytes,7,opt,name=forum_image,json=forumImage,proto3" json:"forum_image,omitempty"`
	ForumText    string    `protobuf:"bytes,8,opt,name=forum_text,json=forumText,proto3" json:"forum_text,omitempty"`
	MsgId        int64     `protobuf:"varint,9,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	MsgContent   string    `protobuf:"bytes,10,opt,name=msg_content,json=msgContent,proto3" json:"msg_content,omitempty"`
	IsFollowed   int64     `protobuf:"varint,11,opt,name=is_followed,json=isFollowed,proto3" json:"is_followed,omitempty"`
	MsgTime      int64     `protobuf:"varint,12,opt,name=msg_time,json=msgTime,proto3" json:"msg_time,omitempty"`
	Entites      []*Entity `protobuf:"bytes,13,rep,name=entites" json:"entites,omitempty"`
}

func (m *MomentNotifyData) Reset()                    { *m = MomentNotifyData{} }
func (m *MomentNotifyData) String() string            { return proto.CompactTextString(m) }
func (*MomentNotifyData) ProtoMessage()               {}
func (*MomentNotifyData) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{42} }

func (m *MomentNotifyData) GetSourceCode() int32 {
	if m != nil {
		return m.SourceCode
	}
	return 0
}

func (m *MomentNotifyData) GetBusinessCode() int32 {
	if m != nil {
		return m.BusinessCode
	}
	return 0
}

func (m *MomentNotifyData) GetToId() int32 {
	if m != nil {
		return m.ToId
	}
	return 0
}

func (m *MomentNotifyData) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *MomentNotifyData) GetForumId() int64 {
	if m != nil {
		return m.ForumId
	}
	return 0
}

func (m *MomentNotifyData) GetForumType() int64 {
	if m != nil {
		return m.ForumType
	}
	return 0
}

func (m *MomentNotifyData) GetForumImage() string {
	if m != nil {
		return m.ForumImage
	}
	return ""
}

func (m *MomentNotifyData) GetForumText() string {
	if m != nil {
		return m.ForumText
	}
	return ""
}

func (m *MomentNotifyData) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *MomentNotifyData) GetMsgContent() string {
	if m != nil {
		return m.MsgContent
	}
	return ""
}

func (m *MomentNotifyData) GetIsFollowed() int64 {
	if m != nil {
		return m.IsFollowed
	}
	return 0
}

func (m *MomentNotifyData) GetMsgTime() int64 {
	if m != nil {
		return m.MsgTime
	}
	return 0
}

func (m *MomentNotifyData) GetEntites() []*Entity {
	if m != nil {
		return m.Entites
	}
	return nil
}

type MomentNotifyReq struct {
	MomentNotifyData []*MomentNotifyData `protobuf:"bytes,1,rep,name=moment_notify_data,json=momentNotifyData" json:"moment_notify_data,omitempty"`
}

func (m *MomentNotifyReq) Reset()                    { *m = MomentNotifyReq{} }
func (m *MomentNotifyReq) String() string            { return proto.CompactTextString(m) }
func (*MomentNotifyReq) ProtoMessage()               {}
func (*MomentNotifyReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{43} }

func (m *MomentNotifyReq) GetMomentNotifyData() []*MomentNotifyData {
	if m != nil {
		return m.MomentNotifyData
	}
	return nil
}

type MomentNotifyResult struct {
	ErrorCode uint32 `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMsg  string `protobuf:"bytes,2,opt,name=error_msg,json=errorMsg,proto3" json:"error_msg,omitempty"`
}

func (m *MomentNotifyResult) Reset()                    { *m = MomentNotifyResult{} }
func (m *MomentNotifyResult) String() string            { return proto.CompactTextString(m) }
func (*MomentNotifyResult) ProtoMessage()               {}
func (*MomentNotifyResult) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{44} }

func (m *MomentNotifyResult) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *MomentNotifyResult) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

// 根据用户Id来获取用户信息selfId 代表自己的Id userId 代表需要获取的用户的Id
type CheckIsMuteContactReq struct {
	SelfId int32 `protobuf:"varint,1,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *CheckIsMuteContactReq) Reset()         { *m = CheckIsMuteContactReq{} }
func (m *CheckIsMuteContactReq) String() string { return proto.CompactTextString(m) }
func (*CheckIsMuteContactReq) ProtoMessage()    {}
func (*CheckIsMuteContactReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{45}
}

func (m *CheckIsMuteContactReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *CheckIsMuteContactReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type CheckIsMuteContactResult struct {
	ErrorCode CheckIsMuteContactResult_ResultCode `protobuf:"varint,1,opt,name=ErrorCode,proto3,enum=imapigateway.CheckIsMuteContactResult_ResultCode" json:"ErrorCode,omitempty"`
	Result    bool                                `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *CheckIsMuteContactResult) Reset()         { *m = CheckIsMuteContactResult{} }
func (m *CheckIsMuteContactResult) String() string { return proto.CompactTextString(m) }
func (*CheckIsMuteContactResult) ProtoMessage()    {}
func (*CheckIsMuteContactResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{46}
}

func (m *CheckIsMuteContactResult) GetErrorCode() CheckIsMuteContactResult_ResultCode {
	if m != nil {
		return m.ErrorCode
	}
	return CheckIsMuteContactResult_Success
}

func (m *CheckIsMuteContactResult) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// 联系人的基本信息
type ContactInfo struct {
	UserId          int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ContactId       int32  `protobuf:"varint,2,opt,name=contact_id,json=contactId,proto3" json:"contact_id,omitempty"`
	FirstName       string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName        string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	IsSelfContacted bool   `protobuf:"varint,5,opt,name=is_self_contacted,json=isSelfContacted,proto3" json:"is_self_contacted,omitempty"`
	SelfIsContacted bool   `protobuf:"varint,6,opt,name=self_is_contacted,json=selfIsContacted,proto3" json:"self_is_contacted,omitempty"`
	StarMark        bool   `protobuf:"varint,7,opt,name=star_mark,json=starMark,proto3" json:"star_mark,omitempty"`
	HasPhone        bool   `protobuf:"varint,8,opt,name=has_phone,json=hasPhone,proto3" json:"has_phone,omitempty"`
	GroupId         int32  `protobuf:"varint,9,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	About           string `protobuf:"bytes,10,opt,name=about,proto3" json:"about,omitempty"`
}

func (m *ContactInfo) Reset()                    { *m = ContactInfo{} }
func (m *ContactInfo) String() string            { return proto.CompactTextString(m) }
func (*ContactInfo) ProtoMessage()               {}
func (*ContactInfo) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{47} }

func (m *ContactInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ContactInfo) GetContactId() int32 {
	if m != nil {
		return m.ContactId
	}
	return 0
}

func (m *ContactInfo) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *ContactInfo) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *ContactInfo) GetIsSelfContacted() bool {
	if m != nil {
		return m.IsSelfContacted
	}
	return false
}

func (m *ContactInfo) GetSelfIsContacted() bool {
	if m != nil {
		return m.SelfIsContacted
	}
	return false
}

func (m *ContactInfo) GetStarMark() bool {
	if m != nil {
		return m.StarMark
	}
	return false
}

func (m *ContactInfo) GetHasPhone() bool {
	if m != nil {
		return m.HasPhone
	}
	return false
}

func (m *ContactInfo) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ContactInfo) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

// 获取用户联系人列表的请求
type ContatsGetContactsReq struct {
	UserId      int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	KeyId       int64  `protobuf:"varint,2,opt,name=keyId,proto3" json:"keyId,omitempty"`
	Contacthash string `protobuf:"bytes,3,opt,name=contacthash,proto3" json:"contacthash,omitempty"`
	Debug       *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ContatsGetContactsReq) Reset()         { *m = ContatsGetContactsReq{} }
func (m *ContatsGetContactsReq) String() string { return proto.CompactTextString(m) }
func (*ContatsGetContactsReq) ProtoMessage()    {}
func (*ContatsGetContactsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{48}
}

func (m *ContatsGetContactsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ContatsGetContactsReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *ContatsGetContactsReq) GetContacthash() string {
	if m != nil {
		return m.Contacthash
	}
	return ""
}

func (m *ContatsGetContactsReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 用户联系人列表获取的返回
type ContatsGetContactsResult struct {
	ContactArr  []*ContactInfo `protobuf:"bytes,1,rep,name=contactArr" json:"contactArr,omitempty"`
	UserInfoArr []*UserInfo    `protobuf:"bytes,2,rep,name=userInfoArr" json:"userInfoArr,omitempty"`
	Errorcode   ReErrCode      `protobuf:"varint,3,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *ContatsGetContactsResult) Reset()         { *m = ContatsGetContactsResult{} }
func (m *ContatsGetContactsResult) String() string { return proto.CompactTextString(m) }
func (*ContatsGetContactsResult) ProtoMessage()    {}
func (*ContatsGetContactsResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{49}
}

func (m *ContatsGetContactsResult) GetContactArr() []*ContactInfo {
	if m != nil {
		return m.ContactArr
	}
	return nil
}

func (m *ContatsGetContactsResult) GetUserInfoArr() []*UserInfo {
	if m != nil {
		return m.UserInfoArr
	}
	return nil
}

func (m *ContatsGetContactsResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

type MomentState struct {
	UserId []int32 `protobuf:"varint,1,rep,packed,name=userId" json:"userId,omitempty"`
	Type   int32   `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *MomentState) Reset()                    { *m = MomentState{} }
func (m *MomentState) String() string            { return proto.CompactTextString(m) }
func (*MomentState) ProtoMessage()               {}
func (*MomentState) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{50} }

func (m *MomentState) GetUserId() []int32 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *MomentState) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type ReqUpdateMoments struct {
	MomentStates []*MomentState `protobuf:"bytes,1,rep,name=momentStates" json:"momentStates,omitempty"`
	SelfId       int32          `protobuf:"varint,2,opt,name=selfId,proto3" json:"selfId,omitempty"`
}

func (m *ReqUpdateMoments) Reset()                    { *m = ReqUpdateMoments{} }
func (m *ReqUpdateMoments) String() string            { return proto.CompactTextString(m) }
func (*ReqUpdateMoments) ProtoMessage()               {}
func (*ReqUpdateMoments) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{51} }

func (m *ReqUpdateMoments) GetMomentStates() []*MomentState {
	if m != nil {
		return m.MomentStates
	}
	return nil
}

func (m *ReqUpdateMoments) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

type ResUpdateMoments struct {
	Code int32  `protobuf:"varint,1,opt,name=code,proto3" json:"code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ResUpdateMoments) Reset()                    { *m = ResUpdateMoments{} }
func (m *ResUpdateMoments) String() string            { return proto.CompactTextString(m) }
func (*ResUpdateMoments) ProtoMessage()               {}
func (*ResUpdateMoments) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{52} }

func (m *ResUpdateMoments) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ResUpdateMoments) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// 积分业务通用协议请求
type ReqIntegralUniversalBusiness struct {
	Ip         string    `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	ImUserId   int32     `protobuf:"varint,2,opt,name=imUserId,proto3" json:"imUserId,omitempty"`
	ImKeyId    uint64    `protobuf:"varint,3,opt,name=imKeyId,proto3" json:"imKeyId,omitempty"`
	BusinessId int32     `protobuf:"varint,4,opt,name=businessId,proto3" json:"businessId,omitempty"`
	FromId     MsgFromID `protobuf:"varint,5,opt,name=fromId,proto3,enum=imapigateway.MsgFromID" json:"fromId,omitempty"`
	Data       []byte    `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ReqIntegralUniversalBusiness) Reset()         { *m = ReqIntegralUniversalBusiness{} }
func (m *ReqIntegralUniversalBusiness) String() string { return proto.CompactTextString(m) }
func (*ReqIntegralUniversalBusiness) ProtoMessage()    {}
func (*ReqIntegralUniversalBusiness) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{53}
}

func (m *ReqIntegralUniversalBusiness) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ReqIntegralUniversalBusiness) GetImUserId() int32 {
	if m != nil {
		return m.ImUserId
	}
	return 0
}

func (m *ReqIntegralUniversalBusiness) GetImKeyId() uint64 {
	if m != nil {
		return m.ImKeyId
	}
	return 0
}

func (m *ReqIntegralUniversalBusiness) GetBusinessId() int32 {
	if m != nil {
		return m.BusinessId
	}
	return 0
}

func (m *ReqIntegralUniversalBusiness) GetFromId() MsgFromID {
	if m != nil {
		return m.FromId
	}
	return MsgFromID_MFI_UNKNOWN
}

func (m *ReqIntegralUniversalBusiness) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 积分业务通用协议响应
type ReplyIntegralUniversalBusiness struct {
	Data string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ReplyIntegralUniversalBusiness) Reset()         { *m = ReplyIntegralUniversalBusiness{} }
func (m *ReplyIntegralUniversalBusiness) String() string { return proto.CompactTextString(m) }
func (*ReplyIntegralUniversalBusiness) ProtoMessage()    {}
func (*ReplyIntegralUniversalBusiness) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{54}
}

func (m *ReplyIntegralUniversalBusiness) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// 游戏规则获取借口
type OtherTransReq struct {
	UserId      int32  `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	KeyId       int64  `protobuf:"varint,2,opt,name=KeyId,proto3" json:"KeyId,omitempty"`
	IpAddr      string `protobuf:"bytes,3,opt,name=IpAddr,proto3" json:"IpAddr,omitempty"`
	ReqMessagId int64  `protobuf:"varint,4,opt,name=ReqMessagId,proto3" json:"ReqMessagId,omitempty"`
	ReqBytes    []byte `protobuf:"bytes,5,opt,name=ReqBytes,proto3" json:"ReqBytes,omitempty"`
}

func (m *OtherTransReq) Reset()                    { *m = OtherTransReq{} }
func (m *OtherTransReq) String() string            { return proto.CompactTextString(m) }
func (*OtherTransReq) ProtoMessage()               {}
func (*OtherTransReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{55} }

func (m *OtherTransReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *OtherTransReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *OtherTransReq) GetIpAddr() string {
	if m != nil {
		return m.IpAddr
	}
	return ""
}

func (m *OtherTransReq) GetReqMessagId() int64 {
	if m != nil {
		return m.ReqMessagId
	}
	return 0
}

func (m *OtherTransReq) GetReqBytes() []byte {
	if m != nil {
		return m.ReqBytes
	}
	return nil
}

// 游戏规则响应
type OtherTransResp struct {
	RespBytes []byte `protobuf:"bytes,1,opt,name=RespBytes,proto3" json:"RespBytes,omitempty"`
}

func (m *OtherTransResp) Reset()                    { *m = OtherTransResp{} }
func (m *OtherTransResp) String() string            { return proto.CompactTextString(m) }
func (*OtherTransResp) ProtoMessage()               {}
func (*OtherTransResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{56} }

func (m *OtherTransResp) GetRespBytes() []byte {
	if m != nil {
		return m.RespBytes
	}
	return nil
}

// 设置用户性别和生日
type SetUserDetailReq struct {
	UserId    int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Flags     int32  `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	FirstName string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	Photo     string `protobuf:"bytes,4,opt,name=photo,proto3" json:"photo,omitempty"`
	Sex       int32  `protobuf:"varint,5,opt,name=sex,proto3" json:"sex,omitempty"`
	Birthday  int32  `protobuf:"varint,6,opt,name=birthday,proto3" json:"birthday,omitempty"`
	Extend    string `protobuf:"bytes,7,opt,name=extend,proto3" json:"extend,omitempty"`
}

func (m *SetUserDetailReq) Reset()                    { *m = SetUserDetailReq{} }
func (m *SetUserDetailReq) String() string            { return proto.CompactTextString(m) }
func (*SetUserDetailReq) ProtoMessage()               {}
func (*SetUserDetailReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{57} }

func (m *SetUserDetailReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetUserDetailReq) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SetUserDetailReq) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *SetUserDetailReq) GetPhoto() string {
	if m != nil {
		return m.Photo
	}
	return ""
}

func (m *SetUserDetailReq) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *SetUserDetailReq) GetBirthday() int32 {
	if m != nil {
		return m.Birthday
	}
	return 0
}

func (m *SetUserDetailReq) GetExtend() string {
	if m != nil {
		return m.Extend
	}
	return ""
}

// 设置用户性别和生日响应
type SetUserDetailResult struct {
	Successful bool `protobuf:"varint,1,opt,name=successful,proto3" json:"successful,omitempty"`
}

func (m *SetUserDetailResult) Reset()         { *m = SetUserDetailResult{} }
func (m *SetUserDetailResult) String() string { return proto.CompactTextString(m) }
func (*SetUserDetailResult) ProtoMessage()    {}
func (*SetUserDetailResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{58}
}

func (m *SetUserDetailResult) GetSuccessful() bool {
	if m != nil {
		return m.Successful
	}
	return false
}

// 根据用户userName来获取用户基本信息
type GetUserByUsernameReq struct {
	SelfId   int32  `protobuf:"varint,1,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
}

func (m *GetUserByUsernameReq) Reset()         { *m = GetUserByUsernameReq{} }
func (m *GetUserByUsernameReq) String() string { return proto.CompactTextString(m) }
func (*GetUserByUsernameReq) ProtoMessage()    {}
func (*GetUserByUsernameReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{59}
}

func (m *GetUserByUsernameReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *GetUserByUsernameReq) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

// 获取用户基本信息的返回结果
type GetUserInfoResult struct {
	Uinfo     *UserInfo `protobuf:"bytes,1,opt,name=Uinfo" json:"Uinfo,omitempty"`
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *GetUserInfoResult) Reset()                    { *m = GetUserInfoResult{} }
func (m *GetUserInfoResult) String() string            { return proto.CompactTextString(m) }
func (*GetUserInfoResult) ProtoMessage()               {}
func (*GetUserInfoResult) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{60} }

func (m *GetUserInfoResult) GetUinfo() *UserInfo {
	if m != nil {
		return m.Uinfo
	}
	return nil
}

func (m *GetUserInfoResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// ####################################　红包游戏　######################################
// 发送红包游戏请求
type SendGameRedReq struct {
	FromKeyId int64  `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    uint32 `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte `protobuf:"bytes,3,opt,name=Req,proto3" json:"Req,omitempty"`
	RdpRsp    []byte `protobuf:"bytes,4,opt,name=RdpRsp,proto3" json:"RdpRsp,omitempty"`
}

func (m *SendGameRedReq) Reset()                    { *m = SendGameRedReq{} }
func (m *SendGameRedReq) String() string            { return proto.CompactTextString(m) }
func (*SendGameRedReq) ProtoMessage()               {}
func (*SendGameRedReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{61} }

func (m *SendGameRedReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *SendGameRedReq) GetFromId() uint32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *SendGameRedReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *SendGameRedReq) GetRdpRsp() []byte {
	if m != nil {
		return m.RdpRsp
	}
	return nil
}

// 查询红包游戏请求
type QryGameRdpReq struct {
	FromKeyId int64  `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    uint32 `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte `protobuf:"bytes,4,opt,name=Req,proto3" json:"Req,omitempty"`
}

func (m *QryGameRdpReq) Reset()                    { *m = QryGameRdpReq{} }
func (m *QryGameRdpReq) String() string            { return proto.CompactTextString(m) }
func (*QryGameRdpReq) ProtoMessage()               {}
func (*QryGameRdpReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{62} }

func (m *QryGameRdpReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *QryGameRdpReq) GetFromId() uint32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *QryGameRdpReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

// 领取红包游戏请求
type RcvGameRedReq struct {
	FromKeyId int64  `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    uint32 `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte `protobuf:"bytes,3,opt,name=Req,proto3" json:"Req,omitempty"`
	RdpRsp    []byte `protobuf:"bytes,4,opt,name=RdpRsp,proto3" json:"RdpRsp,omitempty"`
}

func (m *RcvGameRedReq) Reset()                    { *m = RcvGameRedReq{} }
func (m *RcvGameRedReq) String() string            { return proto.CompactTextString(m) }
func (*RcvGameRedReq) ProtoMessage()               {}
func (*RcvGameRedReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{63} }

func (m *RcvGameRedReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *RcvGameRedReq) GetFromId() uint32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *RcvGameRedReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *RcvGameRedReq) GetRdpRsp() []byte {
	if m != nil {
		return m.RdpRsp
	}
	return nil
}

// 红包游戏响应
type GameRedResp struct {
	Result []byte `protobuf:"bytes,1,opt,name=Result,proto3" json:"Result,omitempty"`
	Code   int32  `protobuf:"varint,2,opt,name=Code,proto3" json:"Code,omitempty"`
	Msg    string `protobuf:"bytes,3,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (m *GameRedResp) Reset()                    { *m = GameRedResp{} }
func (m *GameRedResp) String() string            { return proto.CompactTextString(m) }
func (*GameRedResp) ProtoMessage()               {}
func (*GameRedResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{64} }

func (m *GameRedResp) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GameRedResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GameRedResp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

// ################################# 红包相关协议转发　###############################
// 发送红包请求
type SendRDPReq struct {
	Debug        *Debug `protobuf:"bytes,1,opt,name=Debug" json:"Debug,omitempty"`
	ReqMessageId int64  `protobuf:"varint,2,opt,name=req_messageId,json=reqMessageId,proto3" json:"req_messageId,omitempty"`
	ReqBytes     []byte `protobuf:"bytes,3,opt,name=ReqBytes,proto3" json:"ReqBytes,omitempty"`
	RedMessageId int32  `protobuf:"varint,4,opt,name=red_messageId,json=redMessageId,proto3" json:"red_messageId,omitempty"`
	RedChanelId  int32  `protobuf:"varint,5,opt,name=red_chanelId,json=redChanelId,proto3" json:"red_chanelId,omitempty"`
}

func (m *SendRDPReq) Reset()                    { *m = SendRDPReq{} }
func (m *SendRDPReq) String() string            { return proto.CompactTextString(m) }
func (*SendRDPReq) ProtoMessage()               {}
func (*SendRDPReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{65} }

func (m *SendRDPReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SendRDPReq) GetReqMessageId() int64 {
	if m != nil {
		return m.ReqMessageId
	}
	return 0
}

func (m *SendRDPReq) GetReqBytes() []byte {
	if m != nil {
		return m.ReqBytes
	}
	return nil
}

func (m *SendRDPReq) GetRedMessageId() int32 {
	if m != nil {
		return m.RedMessageId
	}
	return 0
}

func (m *SendRDPReq) GetRedChanelId() int32 {
	if m != nil {
		return m.RedChanelId
	}
	return 0
}

// 发送红包/转账返回
type SendRDPResp struct {
	RespBytes []byte `protobuf:"bytes,1,opt,name=RespBytes,proto3" json:"RespBytes,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *SendRDPResp) Reset()                    { *m = SendRDPResp{} }
func (m *SendRDPResp) String() string            { return proto.CompactTextString(m) }
func (*SendRDPResp) ProtoMessage()               {}
func (*SendRDPResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{66} }

func (m *SendRDPResp) GetRespBytes() []byte {
	if m != nil {
		return m.RespBytes
	}
	return nil
}

func (m *SendRDPResp) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 查看红包/转账请求
type CheckRDPReq struct {
	Debug        *Debug `protobuf:"bytes,1,opt,name=Debug" json:"Debug,omitempty"`
	ReqMessageId int64  `protobuf:"varint,2,opt,name=req_messageId,json=reqMessageId,proto3" json:"req_messageId,omitempty"`
	ReqBytes     []byte `protobuf:"bytes,3,opt,name=ReqBytes,proto3" json:"ReqBytes,omitempty"`
}

func (m *CheckRDPReq) Reset()                    { *m = CheckRDPReq{} }
func (m *CheckRDPReq) String() string            { return proto.CompactTextString(m) }
func (*CheckRDPReq) ProtoMessage()               {}
func (*CheckRDPReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{67} }

func (m *CheckRDPReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *CheckRDPReq) GetReqMessageId() int64 {
	if m != nil {
		return m.ReqMessageId
	}
	return 0
}

func (m *CheckRDPReq) GetReqBytes() []byte {
	if m != nil {
		return m.ReqBytes
	}
	return nil
}

// 查看红包/转账返回
type CheckRDPResp struct {
	RespBytes []byte `protobuf:"bytes,1,opt,name=RespBytes,proto3" json:"RespBytes,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *CheckRDPResp) Reset()                    { *m = CheckRDPResp{} }
func (m *CheckRDPResp) String() string            { return proto.CompactTextString(m) }
func (*CheckRDPResp) ProtoMessage()               {}
func (*CheckRDPResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{68} }

func (m *CheckRDPResp) GetRespBytes() []byte {
	if m != nil {
		return m.RespBytes
	}
	return nil
}

func (m *CheckRDPResp) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 接收红包/转账请求
type ReceiveRDPReq struct {
	Debug        *Debug `protobuf:"bytes,1,opt,name=Debug" json:"Debug,omitempty"`
	ReqMessageId int64  `protobuf:"varint,2,opt,name=req_messageId,json=reqMessageId,proto3" json:"req_messageId,omitempty"`
	ReqBytes     []byte `protobuf:"bytes,3,opt,name=ReqBytes,proto3" json:"ReqBytes,omitempty"`
}

func (m *ReceiveRDPReq) Reset()                    { *m = ReceiveRDPReq{} }
func (m *ReceiveRDPReq) String() string            { return proto.CompactTextString(m) }
func (*ReceiveRDPReq) ProtoMessage()               {}
func (*ReceiveRDPReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{69} }

func (m *ReceiveRDPReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *ReceiveRDPReq) GetReqMessageId() int64 {
	if m != nil {
		return m.ReqMessageId
	}
	return 0
}

func (m *ReceiveRDPReq) GetReqBytes() []byte {
	if m != nil {
		return m.ReqBytes
	}
	return nil
}

// 接收红包/转账返回
type ReceiveRDPResp struct {
	RespBytes []byte `protobuf:"bytes,1,opt,name=RespBytes,proto3" json:"RespBytes,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReceiveRDPResp) Reset()                    { *m = ReceiveRDPResp{} }
func (m *ReceiveRDPResp) String() string            { return proto.CompactTextString(m) }
func (*ReceiveRDPResp) ProtoMessage()               {}
func (*ReceiveRDPResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{70} }

func (m *ReceiveRDPResp) GetRespBytes() []byte {
	if m != nil {
		return m.RespBytes
	}
	return nil
}

func (m *ReceiveRDPResp) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// ################################ 编辑超级群群说明信息 editAbout ######################
// 返回参数
type ReplyEditChannelAbout struct {
	Succeed   bool  `protobuf:"varint,1,opt,name=succeed,proto3" json:"succeed,omitempty"`
	ErrorCode int32 `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyEditChannelAbout) Reset()         { *m = ReplyEditChannelAbout{} }
func (m *ReplyEditChannelAbout) String() string { return proto.CompactTextString(m) }
func (*ReplyEditChannelAbout) ProtoMessage()    {}
func (*ReplyEditChannelAbout) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{71}
}

func (m *ReplyEditChannelAbout) GetSucceed() bool {
	if m != nil {
		return m.Succeed
	}
	return false
}

func (m *ReplyEditChannelAbout) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// ack to the title editing
type ReplyEditChannelTitle struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyEditChannelTitle) Reset()         { *m = ReplyEditChannelTitle{} }
func (m *ReplyEditChannelTitle) String() string { return proto.CompactTextString(m) }
func (*ReplyEditChannelTitle) ProtoMessage()    {}
func (*ReplyEditChannelTitle) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{72}
}

func (m *ReplyEditChannelTitle) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyEditChannelTitle) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 机器人基础信息更改
type BotUpdateInfo struct {
	UserId         int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	BotInfoVersion int32  `protobuf:"varint,2,opt,name=bot_info_version,json=botInfoVersion,proto3" json:"bot_info_version,omitempty"`
	BotChatHistory bool   `protobuf:"varint,3,opt,name=bot_chat_history,json=botChatHistory,proto3" json:"bot_chat_history,omitempty"`
	BotNoChat      bool   `protobuf:"varint,4,opt,name=bot_no_chat,json=botNoChat,proto3" json:"bot_no_chat,omitempty"`
	Debug          *Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *BotUpdateInfo) Reset()                    { *m = BotUpdateInfo{} }
func (m *BotUpdateInfo) String() string            { return proto.CompactTextString(m) }
func (*BotUpdateInfo) ProtoMessage()               {}
func (*BotUpdateInfo) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{73} }

func (m *BotUpdateInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BotUpdateInfo) GetBotInfoVersion() int32 {
	if m != nil {
		return m.BotInfoVersion
	}
	return 0
}

func (m *BotUpdateInfo) GetBotChatHistory() bool {
	if m != nil {
		return m.BotChatHistory
	}
	return false
}

func (m *BotUpdateInfo) GetBotNoChat() bool {
	if m != nil {
		return m.BotNoChat
	}
	return false
}

func (m *BotUpdateInfo) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 机器人更改信息的返回结果
type BotUpdateInfoResult struct {
	Errorcode ReErrCode `protobuf:"varint,1,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *BotUpdateInfoResult) Reset()         { *m = BotUpdateInfoResult{} }
func (m *BotUpdateInfoResult) String() string { return proto.CompactTextString(m) }
func (*BotUpdateInfoResult) ProtoMessage()    {}
func (*BotUpdateInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{74}
}

func (m *BotUpdateInfoResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 返回参数
type ReplyUpdatePinnedChannelMessage struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyUpdatePinnedChannelMessage) Reset()         { *m = ReplyUpdatePinnedChannelMessage{} }
func (m *ReplyUpdatePinnedChannelMessage) String() string { return proto.CompactTextString(m) }
func (*ReplyUpdatePinnedChannelMessage) ProtoMessage()    {}
func (*ReplyUpdatePinnedChannelMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{75}
}

func (m *ReplyUpdatePinnedChannelMessage) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyUpdatePinnedChannelMessage) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 推出超级群返回
type ReplyLeaveChannel struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyLeaveChannel) Reset()                    { *m = ReplyLeaveChannel{} }
func (m *ReplyLeaveChannel) String() string            { return proto.CompactTextString(m) }
func (*ReplyLeaveChannel) ProtoMessage()               {}
func (*ReplyLeaveChannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{76} }

func (m *ReplyLeaveChannel) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyLeaveChannel) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type ReqGetAllChats struct {
	Fromid int32  `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Debug  *Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetAllChats) Reset()                    { *m = ReqGetAllChats{} }
func (m *ReqGetAllChats) String() string            { return proto.CompactTextString(m) }
func (*ReqGetAllChats) ProtoMessage()               {}
func (*ReqGetAllChats) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{77} }

func (m *ReqGetAllChats) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqGetAllChats) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetAllChats struct {
	Chats []int32 `protobuf:"varint,1,rep,packed,name=chats" json:"chats,omitempty"`
	Error int32   `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyGetAllChats) Reset()                    { *m = ReplyGetAllChats{} }
func (m *ReplyGetAllChats) String() string            { return proto.CompactTextString(m) }
func (*ReplyGetAllChats) ProtoMessage()               {}
func (*ReplyGetAllChats) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{78} }

func (m *ReplyGetAllChats) GetChats() []int32 {
	if m != nil {
		return m.Chats
	}
	return nil
}

func (m *ReplyGetAllChats) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// #####################超级群get diff###################
type ReqGetchannelDifference struct {
	FromId      int32  `protobuf:"varint,1,opt,name=fromId,proto3" json:"fromId,omitempty"`
	FromKeyId   int64  `protobuf:"varint,2,opt,name=fromKeyId,proto3" json:"fromKeyId,omitempty"`
	Flags       int32  `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`
	Force       bool   `protobuf:"varint,4,opt,name=force,proto3" json:"force,omitempty"`
	ChannelId   int32  `protobuf:"varint,5,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Pts         int32  `protobuf:"varint,6,opt,name=pts,proto3" json:"pts,omitempty"`
	Limit       int32  `protobuf:"varint,7,opt,name=limit,proto3" json:"limit,omitempty"`
	Range_MinId int32  `protobuf:"varint,8,opt,name=range_MinId,json=rangeMinId,proto3" json:"range_MinId,omitempty"`
	Range_MaxId int32  `protobuf:"varint,9,opt,name=range_MaxId,json=rangeMaxId,proto3" json:"range_MaxId,omitempty"`
	Device      int32  `protobuf:"varint,10,opt,name=device,proto3" json:"device,omitempty"`
	Debug       *Debug `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetchannelDifference) Reset()         { *m = ReqGetchannelDifference{} }
func (m *ReqGetchannelDifference) String() string { return proto.CompactTextString(m) }
func (*ReqGetchannelDifference) ProtoMessage()    {}
func (*ReqGetchannelDifference) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{79}
}

func (m *ReqGetchannelDifference) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqGetchannelDifference) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *ReqGetchannelDifference) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ReqGetchannelDifference) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *ReqGetchannelDifference) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqGetchannelDifference) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *ReqGetchannelDifference) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqGetchannelDifference) GetRange_MinId() int32 {
	if m != nil {
		return m.Range_MinId
	}
	return 0
}

func (m *ReqGetchannelDifference) GetRange_MaxId() int32 {
	if m != nil {
		return m.Range_MaxId
	}
	return 0
}

func (m *ReqGetchannelDifference) GetDevice() int32 {
	if m != nil {
		return m.Device
	}
	return 0
}

func (m *ReqGetchannelDifference) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyChannelDiffCommon struct {
	Difference []byte `protobuf:"bytes,1,opt,name=difference,proto3" json:"difference,omitempty"`
	ErrorCode  int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyChannelDiffCommon) Reset()         { *m = ReplyChannelDiffCommon{} }
func (m *ReplyChannelDiffCommon) String() string { return proto.CompactTextString(m) }
func (*ReplyChannelDiffCommon) ProtoMessage()    {}
func (*ReplyChannelDiffCommon) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{80}
}

func (m *ReplyChannelDiffCommon) GetDifference() []byte {
	if m != nil {
		return m.Difference
	}
	return nil
}

func (m *ReplyChannelDiffCommon) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 获取fullchannel
type ReqFullchannel struct {
	FromId     int32  `protobuf:"varint,1,opt,name=fromId,proto3" json:"fromId,omitempty"`
	ChannelId  int32  `protobuf:"varint,2,opt,name=channelId,proto3" json:"channelId,omitempty"`
	AccessHash int64  `protobuf:"varint,3,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	Debug      *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqFullchannel) Reset()                    { *m = ReqFullchannel{} }
func (m *ReqFullchannel) String() string            { return proto.CompactTextString(m) }
func (*ReqFullchannel) ProtoMessage()               {}
func (*ReqFullchannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{81} }

func (m *ReqFullchannel) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqFullchannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqFullchannel) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqFullchannel) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 返回fullchannel
type ReplyFullChannel struct {
	Updates   []byte `protobuf:"bytes,1,opt,name=Updates,proto3" json:"Updates,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyFullChannel) Reset()                    { *m = ReplyFullChannel{} }
func (m *ReplyFullChannel) String() string            { return proto.CompactTextString(m) }
func (*ReplyFullChannel) ProtoMessage()               {}
func (*ReplyFullChannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{82} }

func (m *ReplyFullChannel) GetUpdates() []byte {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *ReplyFullChannel) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// ############################# 删除消息 ####################
type ReqDeleteMessages struct {
	Fromid    int32   `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	FromKeyid uint64  `protobuf:"varint,2,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Flags     int32   `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`
	Revoke    bool    `protobuf:"varint,4,opt,name=revoke,proto3" json:"revoke,omitempty"`
	Id        []int32 `protobuf:"varint,5,rep,packed,name=id" json:"id,omitempty"`
	Channelid int32   `protobuf:"varint,6,opt,name=channelid,proto3" json:"channelid,omitempty"`
	Debug     *Debug  `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqDeleteMessages) Reset()                    { *m = ReqDeleteMessages{} }
func (m *ReqDeleteMessages) String() string            { return proto.CompactTextString(m) }
func (*ReqDeleteMessages) ProtoMessage()               {}
func (*ReqDeleteMessages) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{83} }

func (m *ReqDeleteMessages) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqDeleteMessages) GetFromKeyid() uint64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqDeleteMessages) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ReqDeleteMessages) GetRevoke() bool {
	if m != nil {
		return m.Revoke
	}
	return false
}

func (m *ReqDeleteMessages) GetId() []int32 {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ReqDeleteMessages) GetChannelid() int32 {
	if m != nil {
		return m.Channelid
	}
	return 0
}

func (m *ReqDeleteMessages) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyDeleteMessages struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyDeleteMessages) Reset()         { *m = ReplyDeleteMessages{} }
func (m *ReplyDeleteMessages) String() string { return proto.CompactTextString(m) }
func (*ReplyDeleteMessages) ProtoMessage()    {}
func (*ReplyDeleteMessages) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{84}
}

func (m *ReplyDeleteMessages) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyDeleteMessages) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 注册指定用户的请求
type RegisterUserInfoReq struct {
	UserId         int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AccessHash     int64  `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	PhoneNumber    string `protobuf:"bytes,3,opt,name=PhoneNumber,proto3" json:"PhoneNumber,omitempty"`
	FirstName      string `protobuf:"bytes,4,opt,name=FirstName,proto3" json:"FirstName,omitempty"`
	LastName       string `protobuf:"bytes,5,opt,name=LastName,proto3" json:"LastName,omitempty"`
	IsBot          bool   `protobuf:"varint,6,opt,name=is_bot,json=isBot,proto3" json:"is_bot,omitempty"`
	BotInfoVersion int32  `protobuf:"varint,7,opt,name=bot_info_version,json=botInfoVersion,proto3" json:"bot_info_version,omitempty"`
	BotChatHistory bool   `protobuf:"varint,8,opt,name=bot_chat_history,json=botChatHistory,proto3" json:"bot_chat_history,omitempty"`
	BotNoChats     bool   `protobuf:"varint,9,opt,name=bot_no_chats,json=botNoChats,proto3" json:"bot_no_chats,omitempty"`
	CountryCode    string `protobuf:"bytes,10,opt,name=CountryCode,proto3" json:"CountryCode,omitempty"`
	LocalPhone     string `protobuf:"bytes,11,opt,name=LocalPhone,proto3" json:"LocalPhone,omitempty"`
	Dc             int32  `protobuf:"varint,12,opt,name=dc,proto3" json:"dc,omitempty"`
	GroupNow       int32  `protobuf:"varint,13,opt,name=GroupNow,proto3" json:"GroupNow,omitempty"`
	Debug          *Debug `protobuf:"bytes,14,opt,name=debug" json:"debug,omitempty"`
	Sex            int32  `protobuf:"varint,15,opt,name=Sex,proto3" json:"Sex,omitempty"`
	Birthday       int32  `protobuf:"varint,16,opt,name=birthday,proto3" json:"birthday,omitempty"`
}

func (m *RegisterUserInfoReq) Reset()         { *m = RegisterUserInfoReq{} }
func (m *RegisterUserInfoReq) String() string { return proto.CompactTextString(m) }
func (*RegisterUserInfoReq) ProtoMessage()    {}
func (*RegisterUserInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{85}
}

func (m *RegisterUserInfoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *RegisterUserInfoReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *RegisterUserInfoReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *RegisterUserInfoReq) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *RegisterUserInfoReq) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *RegisterUserInfoReq) GetIsBot() bool {
	if m != nil {
		return m.IsBot
	}
	return false
}

func (m *RegisterUserInfoReq) GetBotInfoVersion() int32 {
	if m != nil {
		return m.BotInfoVersion
	}
	return 0
}

func (m *RegisterUserInfoReq) GetBotChatHistory() bool {
	if m != nil {
		return m.BotChatHistory
	}
	return false
}

func (m *RegisterUserInfoReq) GetBotNoChats() bool {
	if m != nil {
		return m.BotNoChats
	}
	return false
}

func (m *RegisterUserInfoReq) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *RegisterUserInfoReq) GetLocalPhone() string {
	if m != nil {
		return m.LocalPhone
	}
	return ""
}

func (m *RegisterUserInfoReq) GetDc() int32 {
	if m != nil {
		return m.Dc
	}
	return 0
}

func (m *RegisterUserInfoReq) GetGroupNow() int32 {
	if m != nil {
		return m.GroupNow
	}
	return 0
}

func (m *RegisterUserInfoReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *RegisterUserInfoReq) GetSex() int32 {
	if m != nil {
		return m.Sex
	}
	return 0
}

func (m *RegisterUserInfoReq) GetBirthday() int32 {
	if m != nil {
		return m.Birthday
	}
	return 0
}

// 获取fullchannel
type ReqGetFullChannel struct {
	FromId     int32  `protobuf:"varint,1,opt,name=fromId,proto3" json:"fromId,omitempty"`
	ChannelId  int32  `protobuf:"varint,2,opt,name=channelId,proto3" json:"channelId,omitempty"`
	AccessHash int64  `protobuf:"varint,3,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	Debug      *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetFullChannel) Reset()                    { *m = ReqGetFullChannel{} }
func (m *ReqGetFullChannel) String() string            { return proto.CompactTextString(m) }
func (*ReqGetFullChannel) ProtoMessage()               {}
func (*ReqGetFullChannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{86} }

func (m *ReqGetFullChannel) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqGetFullChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqGetFullChannel) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqGetFullChannel) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 获取participants
type ReqGetParticipants struct {
	OffSet    int32  `protobuf:"varint,1,opt,name=offSet,proto3" json:"offSet,omitempty"`
	Limit     int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	PartiType int32  `protobuf:"varint,3,opt,name=partiType,proto3" json:"partiType,omitempty"`
	ChannelId int32  `protobuf:"varint,4,opt,name=channelId,proto3" json:"channelId,omitempty"`
	FromId    int32  `protobuf:"varint,5,opt,name=fromId,proto3" json:"fromId,omitempty"`
	Q         string `protobuf:"bytes,6,opt,name=q,proto3" json:"q,omitempty"`
	Hash      int32  `protobuf:"varint,7,opt,name=Hash,proto3" json:"Hash,omitempty"`
	Debug     *Debug `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetParticipants) Reset()                    { *m = ReqGetParticipants{} }
func (m *ReqGetParticipants) String() string            { return proto.CompactTextString(m) }
func (*ReqGetParticipants) ProtoMessage()               {}
func (*ReqGetParticipants) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{87} }

func (m *ReqGetParticipants) GetOffSet() int32 {
	if m != nil {
		return m.OffSet
	}
	return 0
}

func (m *ReqGetParticipants) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqGetParticipants) GetPartiType() int32 {
	if m != nil {
		return m.PartiType
	}
	return 0
}

func (m *ReqGetParticipants) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqGetParticipants) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqGetParticipants) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

func (m *ReqGetParticipants) GetHash() int32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *ReqGetParticipants) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 请求参数
type ReqUpdatePinnedChannelMessage struct {
	FromId int32 `protobuf:"varint,1,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	Flags  int32 `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Silent bool  `protobuf:"varint,3,opt,name=silent,proto3" json:"silent,omitempty"`
	//    InputChannel channel = 4;
	ChannelId int32  `protobuf:"varint,4,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Id        int32  `protobuf:"varint,5,opt,name=id,proto3" json:"id,omitempty"`
	FromKeyid int64  `protobuf:"varint,6,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *Debug `protobuf:"bytes,7,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqUpdatePinnedChannelMessage) Reset()         { *m = ReqUpdatePinnedChannelMessage{} }
func (m *ReqUpdatePinnedChannelMessage) String() string { return proto.CompactTextString(m) }
func (*ReqUpdatePinnedChannelMessage) ProtoMessage()    {}
func (*ReqUpdatePinnedChannelMessage) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{88}
}

func (m *ReqUpdatePinnedChannelMessage) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqUpdatePinnedChannelMessage) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ReqUpdatePinnedChannelMessage) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *ReqUpdatePinnedChannelMessage) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqUpdatePinnedChannelMessage) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ReqUpdatePinnedChannelMessage) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqUpdatePinnedChannelMessage) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 请求参数
type ReqEditChannelAbout struct {
	FromId     int32  `protobuf:"varint,1,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	FromKeyId  int64  `protobuf:"varint,2,opt,name=fromKeyId,proto3" json:"fromKeyId,omitempty"`
	ChannelId  int32  `protobuf:"varint,3,opt,name=channelId,proto3" json:"channelId,omitempty"`
	About      string `protobuf:"bytes,4,opt,name=about,proto3" json:"about,omitempty"`
	AccessHash int64  `protobuf:"varint,5,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	Debug      *Debug `protobuf:"bytes,6,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqEditChannelAbout) Reset()         { *m = ReqEditChannelAbout{} }
func (m *ReqEditChannelAbout) String() string { return proto.CompactTextString(m) }
func (*ReqEditChannelAbout) ProtoMessage()    {}
func (*ReqEditChannelAbout) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{89}
}

func (m *ReqEditChannelAbout) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqEditChannelAbout) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *ReqEditChannelAbout) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqEditChannelAbout) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *ReqEditChannelAbout) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqEditChannelAbout) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// edit title
type ReqEditChannelTitle struct {
	ChannelId int32  `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Title     string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	UserId    int32  `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
	FromKeyid int64  `protobuf:"varint,4,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqEditChannelTitle) Reset()         { *m = ReqEditChannelTitle{} }
func (m *ReqEditChannelTitle) String() string { return proto.CompactTextString(m) }
func (*ReqEditChannelTitle) ProtoMessage()    {}
func (*ReqEditChannelTitle) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{90}
}

func (m *ReqEditChannelTitle) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqEditChannelTitle) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ReqEditChannelTitle) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqEditChannelTitle) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqEditChannelTitle) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyChannelData struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
	ChannelId int32  `protobuf:"varint,4,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	FromId    int32  `protobuf:"varint,5,opt,name=FromId,proto3" json:"FromId,omitempty"`
}

func (m *ReplyChannelData) Reset()                    { *m = ReplyChannelData{} }
func (m *ReplyChannelData) String() string            { return proto.CompactTextString(m) }
func (*ReplyChannelData) ProtoMessage()               {}
func (*ReplyChannelData) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{91} }

func (m *ReplyChannelData) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyChannelData) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ReplyChannelData) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReplyChannelData) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

type ReqDelManualBlockList struct {
	UnBlockUser *BlockUser `protobuf:"bytes,1,opt,name=UnBlockUser" json:"UnBlockUser,omitempty"`
	BotId       int32      `protobuf:"varint,2,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	Debug       *Debug     `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqDelManualBlockList) Reset()         { *m = ReqDelManualBlockList{} }
func (m *ReqDelManualBlockList) String() string { return proto.CompactTextString(m) }
func (*ReqDelManualBlockList) ProtoMessage()    {}
func (*ReqDelManualBlockList) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{92}
}

func (m *ReqDelManualBlockList) GetUnBlockUser() *BlockUser {
	if m != nil {
		return m.UnBlockUser
	}
	return nil
}

func (m *ReqDelManualBlockList) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

func (m *ReqDelManualBlockList) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqSetManualBlockList struct {
	BlockUser *BlockUser `protobuf:"bytes,1,opt,name=BlockUser" json:"BlockUser,omitempty"`
	BotId     int32      `protobuf:"varint,2,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	Debug     *Debug     `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqSetManualBlockList) Reset()         { *m = ReqSetManualBlockList{} }
func (m *ReqSetManualBlockList) String() string { return proto.CompactTextString(m) }
func (*ReqSetManualBlockList) ProtoMessage()    {}
func (*ReqSetManualBlockList) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{93}
}

func (m *ReqSetManualBlockList) GetBlockUser() *BlockUser {
	if m != nil {
		return m.BlockUser
	}
	return nil
}

func (m *ReqSetManualBlockList) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

func (m *ReqSetManualBlockList) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 禁言某用戶
type BlockUser struct {
	UserId    int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	BlockTime int64 `protobuf:"varint,2,opt,name=blockTime,proto3" json:"blockTime,omitempty"`
	GroupId   int64 `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
}

func (m *BlockUser) Reset()                    { *m = BlockUser{} }
func (m *BlockUser) String() string            { return proto.CompactTextString(m) }
func (*BlockUser) ProtoMessage()               {}
func (*BlockUser) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{94} }

func (m *BlockUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BlockUser) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *BlockUser) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type ManualBlockReplyData struct {
	ReplyData []byte `protobuf:"bytes,1,opt,name=replyData,proto3" json:"replyData,omitempty"`
	Reply     bool   `protobuf:"varint,2,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,3,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
}

func (m *ManualBlockReplyData) Reset()         { *m = ManualBlockReplyData{} }
func (m *ManualBlockReplyData) String() string { return proto.CompactTextString(m) }
func (*ManualBlockReplyData) ProtoMessage()    {}
func (*ManualBlockReplyData) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{95}
}

func (m *ManualBlockReplyData) GetReplyData() []byte {
	if m != nil {
		return m.ReplyData
	}
	return nil
}

func (m *ManualBlockReplyData) GetReply() bool {
	if m != nil {
		return m.Reply
	}
	return false
}

func (m *ManualBlockReplyData) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 存储sticker 集合概要 Documents请求
type StoreShopStickerSetDocumentsReq struct {
	Id        int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Documents []int32 `protobuf:"varint,2,rep,packed,name=documents" json:"documents,omitempty"`
	Debug     *Debug  `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *StoreShopStickerSetDocumentsReq) Reset()         { *m = StoreShopStickerSetDocumentsReq{} }
func (m *StoreShopStickerSetDocumentsReq) String() string { return proto.CompactTextString(m) }
func (*StoreShopStickerSetDocumentsReq) ProtoMessage()    {}
func (*StoreShopStickerSetDocumentsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{96}
}

func (m *StoreShopStickerSetDocumentsReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StoreShopStickerSetDocumentsReq) GetDocuments() []int32 {
	if m != nil {
		return m.Documents
	}
	return nil
}

func (m *StoreShopStickerSetDocumentsReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 存储sticker 集合概要 Documents返回结果
type StoreShopStickerSetDocumentsResult struct {
	Errorcode ReErrCode `protobuf:"varint,1,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *StoreShopStickerSetDocumentsResult) Reset()         { *m = StoreShopStickerSetDocumentsResult{} }
func (m *StoreShopStickerSetDocumentsResult) String() string { return proto.CompactTextString(m) }
func (*StoreShopStickerSetDocumentsResult) ProtoMessage()    {}
func (*StoreShopStickerSetDocumentsResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{97}
}

func (m *StoreShopStickerSetDocumentsResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 结构体AuthorStickerSet
type AuthorStickerSet struct {
	UserId       int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	StickersetId int64  `protobuf:"varint,2,opt,name=stickerset_id,json=stickersetId,proto3" json:"stickerset_id,omitempty"`
	ShortName    string `protobuf:"bytes,3,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	Archived     bool   `protobuf:"varint,4,opt,name=archived,proto3" json:"archived,omitempty"`
	Installed    bool   `protobuf:"varint,5,opt,name=installed,proto3" json:"installed,omitempty"`
	Disabled     bool   `protobuf:"varint,6,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Ordered      int32  `protobuf:"varint,7,opt,name=ordered,proto3" json:"ordered,omitempty"`
	Created      int32  `protobuf:"varint,8,opt,name=created,proto3" json:"created,omitempty"`
	Updated      int32  `protobuf:"varint,9,opt,name=updated,proto3" json:"updated,omitempty"`
}

func (m *AuthorStickerSet) Reset()                    { *m = AuthorStickerSet{} }
func (m *AuthorStickerSet) String() string            { return proto.CompactTextString(m) }
func (*AuthorStickerSet) ProtoMessage()               {}
func (*AuthorStickerSet) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{98} }

func (m *AuthorStickerSet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AuthorStickerSet) GetStickersetId() int64 {
	if m != nil {
		return m.StickersetId
	}
	return 0
}

func (m *AuthorStickerSet) GetShortName() string {
	if m != nil {
		return m.ShortName
	}
	return ""
}

func (m *AuthorStickerSet) GetArchived() bool {
	if m != nil {
		return m.Archived
	}
	return false
}

func (m *AuthorStickerSet) GetInstalled() bool {
	if m != nil {
		return m.Installed
	}
	return false
}

func (m *AuthorStickerSet) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *AuthorStickerSet) GetOrdered() int32 {
	if m != nil {
		return m.Ordered
	}
	return 0
}

func (m *AuthorStickerSet) GetCreated() int32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *AuthorStickerSet) GetUpdated() int32 {
	if m != nil {
		return m.Updated
	}
	return 0
}

// 获取作者所有sticker
type GetAuthorAllStickerSetReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetAuthorAllStickerSetReq) Reset()         { *m = GetAuthorAllStickerSetReq{} }
func (m *GetAuthorAllStickerSetReq) String() string { return proto.CompactTextString(m) }
func (*GetAuthorAllStickerSetReq) ProtoMessage()    {}
func (*GetAuthorAllStickerSetReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{99}
}

func (m *GetAuthorAllStickerSetReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// 获取作者所有sticker返回
type GetAuthorAllStickerSetResult struct {
	ErrorCode ReErrCode           `protobuf:"varint,1,opt,name=ErrorCode,proto3,enum=imapigateway.ReErrCode" json:"ErrorCode,omitempty"`
	Sets      []*AuthorStickerSet `protobuf:"bytes,2,rep,name=sets" json:"sets,omitempty"`
}

func (m *GetAuthorAllStickerSetResult) Reset()         { *m = GetAuthorAllStickerSetResult{} }
func (m *GetAuthorAllStickerSetResult) String() string { return proto.CompactTextString(m) }
func (*GetAuthorAllStickerSetResult) ProtoMessage()    {}
func (*GetAuthorAllStickerSetResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{100}
}

func (m *GetAuthorAllStickerSetResult) GetErrorCode() ReErrCode {
	if m != nil {
		return m.ErrorCode
	}
	return ReErrCode_Success
}

func (m *GetAuthorAllStickerSetResult) GetSets() []*AuthorStickerSet {
	if m != nil {
		return m.Sets
	}
	return nil
}

// 删除单个sticker
type DeleteStickerPackDocumentReq struct {
	Id           int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StickersetId int64 `protobuf:"varint,2,opt,name=stickerset_id,json=stickersetId,proto3" json:"stickerset_id,omitempty"`
}

func (m *DeleteStickerPackDocumentReq) Reset()         { *m = DeleteStickerPackDocumentReq{} }
func (m *DeleteStickerPackDocumentReq) String() string { return proto.CompactTextString(m) }
func (*DeleteStickerPackDocumentReq) ProtoMessage()    {}
func (*DeleteStickerPackDocumentReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{101}
}

func (m *DeleteStickerPackDocumentReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DeleteStickerPackDocumentReq) GetStickersetId() int64 {
	if m != nil {
		return m.StickersetId
	}
	return 0
}

// 删除单个sticker返回
type DeleteStickerPackDocumentResult struct {
	Errorcode ReErrCode `protobuf:"varint,1,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *DeleteStickerPackDocumentResult) Reset()         { *m = DeleteStickerPackDocumentResult{} }
func (m *DeleteStickerPackDocumentResult) String() string { return proto.CompactTextString(m) }
func (*DeleteStickerPackDocumentResult) ProtoMessage()    {}
func (*DeleteStickerPackDocumentResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{102}
}

func (m *DeleteStickerPackDocumentResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 获取指定的sticker集合的请求
type GetStickerSetInfoReq struct {
	Id        int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ShortName string `protobuf:"bytes,2,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	IsId      bool   `protobuf:"varint,3,opt,name=is_id,json=isId,proto3" json:"is_id,omitempty"`
	Debug     *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetStickerSetInfoReq) Reset()         { *m = GetStickerSetInfoReq{} }
func (m *GetStickerSetInfoReq) String() string { return proto.CompactTextString(m) }
func (*GetStickerSetInfoReq) ProtoMessage()    {}
func (*GetStickerSetInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{103}
}

func (m *GetStickerSetInfoReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetStickerSetInfoReq) GetShortName() string {
	if m != nil {
		return m.ShortName
	}
	return ""
}

func (m *GetStickerSetInfoReq) GetIsId() bool {
	if m != nil {
		return m.IsId
	}
	return false
}

func (m *GetStickerSetInfoReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// sticker set 的基础信息
type StickerSetInfo struct {
	Id         int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash int64   `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Free       bool    `protobuf:"varint,3,opt,name=free,proto3" json:"free,omitempty"`
	Official   bool    `protobuf:"varint,4,opt,name=official,proto3" json:"official,omitempty"`
	Masks      bool    `protobuf:"varint,5,opt,name=masks,proto3" json:"masks,omitempty"`
	Title      string  `protobuf:"bytes,6,opt,name=title,proto3" json:"title,omitempty"`
	ShortName  string  `protobuf:"bytes,7,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	Count      int32   `protobuf:"varint,8,opt,name=count,proto3" json:"count,omitempty"`
	Hash       int64   `protobuf:"varint,9,opt,name=hash,proto3" json:"hash,omitempty"`
	Emoticon   string  `protobuf:"bytes,10,opt,name=emoticon,proto3" json:"emoticon,omitempty"`
	Documents  []int32 `protobuf:"varint,11,rep,packed,name=documents" json:"documents,omitempty"`
}

func (m *StickerSetInfo) Reset()                    { *m = StickerSetInfo{} }
func (m *StickerSetInfo) String() string            { return proto.CompactTextString(m) }
func (*StickerSetInfo) ProtoMessage()               {}
func (*StickerSetInfo) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{104} }

func (m *StickerSetInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StickerSetInfo) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *StickerSetInfo) GetFree() bool {
	if m != nil {
		return m.Free
	}
	return false
}

func (m *StickerSetInfo) GetOfficial() bool {
	if m != nil {
		return m.Official
	}
	return false
}

func (m *StickerSetInfo) GetMasks() bool {
	if m != nil {
		return m.Masks
	}
	return false
}

func (m *StickerSetInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *StickerSetInfo) GetShortName() string {
	if m != nil {
		return m.ShortName
	}
	return ""
}

func (m *StickerSetInfo) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *StickerSetInfo) GetHash() int64 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *StickerSetInfo) GetEmoticon() string {
	if m != nil {
		return m.Emoticon
	}
	return ""
}

func (m *StickerSetInfo) GetDocuments() []int32 {
	if m != nil {
		return m.Documents
	}
	return nil
}

// //获取指定的sticker集合的返回
type GetStickerSetInfoResult struct {
	StickerSetInfo *StickerSetInfo `protobuf:"bytes,1,opt,name=stickerSetInfo" json:"stickerSetInfo,omitempty"`
	Errorcode      ReErrCode       `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *GetStickerSetInfoResult) Reset()         { *m = GetStickerSetInfoResult{} }
func (m *GetStickerSetInfoResult) String() string { return proto.CompactTextString(m) }
func (*GetStickerSetInfoResult) ProtoMessage()    {}
func (*GetStickerSetInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{105}
}

func (m *GetStickerSetInfoResult) GetStickerSetInfo() *StickerSetInfo {
	if m != nil {
		return m.StickerSetInfo
	}
	return nil
}

func (m *GetStickerSetInfoResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 删除sticker商城的请求
type DeleteStickerSetReq struct {
	StickerId int32  `protobuf:"varint,1,opt,name=stickerId,proto3" json:"stickerId,omitempty"`
	Debug     *Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
	UserId    int32  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *DeleteStickerSetReq) Reset()         { *m = DeleteStickerSetReq{} }
func (m *DeleteStickerSetReq) String() string { return proto.CompactTextString(m) }
func (*DeleteStickerSetReq) ProtoMessage()    {}
func (*DeleteStickerSetReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{106}
}

func (m *DeleteStickerSetReq) GetStickerId() int32 {
	if m != nil {
		return m.StickerId
	}
	return 0
}

func (m *DeleteStickerSetReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *DeleteStickerSetReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// 删除sticker商城的返回
type DeleteStickerSetResult struct {
	Errorcode ReErrCode `protobuf:"varint,1,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *DeleteStickerSetResult) Reset()         { *m = DeleteStickerSetResult{} }
func (m *DeleteStickerSetResult) String() string { return proto.CompactTextString(m) }
func (*DeleteStickerSetResult) ProtoMessage()    {}
func (*DeleteStickerSetResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{107}
}

func (m *DeleteStickerSetResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 用户安装sticker集合的请求
type StoreUserStickerSetReq struct {
	UserId       int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	StickersetId int32  `protobuf:"varint,2,opt,name=stickerset_id,json=stickersetId,proto3" json:"stickerset_id,omitempty"`
	Installed    bool   `protobuf:"varint,3,opt,name=installed,proto3" json:"installed,omitempty"`
	Disabled     bool   `protobuf:"varint,4,opt,name=disabled,proto3" json:"disabled,omitempty"`
	Order        int32  `protobuf:"varint,5,opt,name=order,proto3" json:"order,omitempty"`
	Archived     bool   `protobuf:"varint,6,opt,name=archived,proto3" json:"archived,omitempty"`
	Debug        *Debug `protobuf:"bytes,7,opt,name=debug" json:"debug,omitempty"`
}

func (m *StoreUserStickerSetReq) Reset()         { *m = StoreUserStickerSetReq{} }
func (m *StoreUserStickerSetReq) String() string { return proto.CompactTextString(m) }
func (*StoreUserStickerSetReq) ProtoMessage()    {}
func (*StoreUserStickerSetReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{108}
}

func (m *StoreUserStickerSetReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *StoreUserStickerSetReq) GetStickersetId() int32 {
	if m != nil {
		return m.StickersetId
	}
	return 0
}

func (m *StoreUserStickerSetReq) GetInstalled() bool {
	if m != nil {
		return m.Installed
	}
	return false
}

func (m *StoreUserStickerSetReq) GetDisabled() bool {
	if m != nil {
		return m.Disabled
	}
	return false
}

func (m *StoreUserStickerSetReq) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *StoreUserStickerSetReq) GetArchived() bool {
	if m != nil {
		return m.Archived
	}
	return false
}

func (m *StoreUserStickerSetReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 用户安装sticker集合的返回
type StoreUserStickerSetResult struct {
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *StoreUserStickerSetResult) Reset()         { *m = StoreUserStickerSetResult{} }
func (m *StoreUserStickerSetResult) String() string { return proto.CompactTextString(m) }
func (*StoreUserStickerSetResult) ProtoMessage()    {}
func (*StoreUserStickerSetResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{109}
}

func (m *StoreUserStickerSetResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 存储sticker文档的请求
type StoreStickerPackDcReq struct {
	Stickpackbase *StickerPackDocumentBase `protobuf:"bytes,1,opt,name=stickpackbase" json:"stickpackbase,omitempty"`
	Debug         *Debug                   `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *StoreStickerPackDcReq) Reset()         { *m = StoreStickerPackDcReq{} }
func (m *StoreStickerPackDcReq) String() string { return proto.CompactTextString(m) }
func (*StoreStickerPackDcReq) ProtoMessage()    {}
func (*StoreStickerPackDcReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{110}
}

func (m *StoreStickerPackDcReq) GetStickpackbase() *StickerPackDocumentBase {
	if m != nil {
		return m.Stickpackbase
	}
	return nil
}

func (m *StoreStickerPackDcReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 存储sticker文档的返回
type StoreStickerPackDcResult struct {
	Id        int32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *StoreStickerPackDcResult) Reset()         { *m = StoreStickerPackDcResult{} }
func (m *StoreStickerPackDcResult) String() string { return proto.CompactTextString(m) }
func (*StoreStickerPackDcResult) ProtoMessage()    {}
func (*StoreStickerPackDcResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{111}
}

func (m *StoreStickerPackDcResult) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StoreStickerPackDcResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 存储sticker 集合概要的请求参数
type StoreShopStickerSetReq struct {
	AccessHash int64   `protobuf:"varint,1,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Free       bool    `protobuf:"varint,2,opt,name=free,proto3" json:"free,omitempty"`
	Official   bool    `protobuf:"varint,3,opt,name=official,proto3" json:"official,omitempty"`
	Masks      bool    `protobuf:"varint,4,opt,name=masks,proto3" json:"masks,omitempty"`
	Title      string  `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	ShortName  string  `protobuf:"bytes,6,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	Count      int32   `protobuf:"varint,7,opt,name=count,proto3" json:"count,omitempty"`
	Hash       int64   `protobuf:"varint,8,opt,name=hash,proto3" json:"hash,omitempty"`
	Emoticon   string  `protobuf:"bytes,9,opt,name=emoticon,proto3" json:"emoticon,omitempty"`
	Documents  []int32 `protobuf:"varint,10,rep,packed,name=documents" json:"documents,omitempty"`
	Debug      *Debug  `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
	UserId     int32   `protobuf:"varint,12,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *StoreShopStickerSetReq) Reset()         { *m = StoreShopStickerSetReq{} }
func (m *StoreShopStickerSetReq) String() string { return proto.CompactTextString(m) }
func (*StoreShopStickerSetReq) ProtoMessage()    {}
func (*StoreShopStickerSetReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{112}
}

func (m *StoreShopStickerSetReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *StoreShopStickerSetReq) GetFree() bool {
	if m != nil {
		return m.Free
	}
	return false
}

func (m *StoreShopStickerSetReq) GetOfficial() bool {
	if m != nil {
		return m.Official
	}
	return false
}

func (m *StoreShopStickerSetReq) GetMasks() bool {
	if m != nil {
		return m.Masks
	}
	return false
}

func (m *StoreShopStickerSetReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *StoreShopStickerSetReq) GetShortName() string {
	if m != nil {
		return m.ShortName
	}
	return ""
}

func (m *StoreShopStickerSetReq) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *StoreShopStickerSetReq) GetHash() int64 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *StoreShopStickerSetReq) GetEmoticon() string {
	if m != nil {
		return m.Emoticon
	}
	return ""
}

func (m *StoreShopStickerSetReq) GetDocuments() []int32 {
	if m != nil {
		return m.Documents
	}
	return nil
}

func (m *StoreShopStickerSetReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *StoreShopStickerSetReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// 存储sticker 集合概要的返回
type StoreShopStickerSetResult struct {
	Id        int32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *StoreShopStickerSetResult) Reset()         { *m = StoreShopStickerSetResult{} }
func (m *StoreShopStickerSetResult) String() string { return proto.CompactTextString(m) }
func (*StoreShopStickerSetResult) ProtoMessage()    {}
func (*StoreShopStickerSetResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{113}
}

func (m *StoreShopStickerSetResult) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StoreShopStickerSetResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// ResizeRequest 重设图片大小请求
type ResizeRequest struct {
	Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Width  uint32 `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height uint32 `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *ResizeRequest) Reset()                    { *m = ResizeRequest{} }
func (m *ResizeRequest) String() string            { return proto.CompactTextString(m) }
func (*ResizeRequest) ProtoMessage()               {}
func (*ResizeRequest) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{114} }

func (m *ResizeRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResizeRequest) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ResizeRequest) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

// ResizeReply 重设图片大小响应
type ResizeReply struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=imapigateway.StatusCode" json:"status,omitempty"`
	Data   []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ResizeReply) Reset()                    { *m = ResizeReply{} }
func (m *ResizeReply) String() string            { return proto.CompactTextString(m) }
func (*ResizeReply) ProtoMessage()               {}
func (*ResizeReply) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{115} }

func (m *ResizeReply) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_StatusCodeOK
}

func (m *ResizeReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ConstraintRequest 约束图片大小请求
type ConstraintRequest struct {
	Data       []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	MaxSize    uint32 `protobuf:"varint,2,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
	OutputWebp bool   `protobuf:"varint,3,opt,name=output_webp,json=outputWebp,proto3" json:"output_webp,omitempty"`
}

func (m *ConstraintRequest) Reset()                    { *m = ConstraintRequest{} }
func (m *ConstraintRequest) String() string            { return proto.CompactTextString(m) }
func (*ConstraintRequest) ProtoMessage()               {}
func (*ConstraintRequest) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{116} }

func (m *ConstraintRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ConstraintRequest) GetMaxSize() uint32 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

func (m *ConstraintRequest) GetOutputWebp() bool {
	if m != nil {
		return m.OutputWebp
	}
	return false
}

// ConstraintReply 约束图片大小响应
type ConstraintReply struct {
	Status       StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=imapigateway.StatusCode" json:"status,omitempty"`
	Data         []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	Width        uint32     `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	Height       uint32     `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	OriginWidth  uint32     `protobuf:"varint,5,opt,name=origin_width,json=originWidth,proto3" json:"origin_width,omitempty"`
	OriginHeight uint32     `protobuf:"varint,6,opt,name=origin_height,json=originHeight,proto3" json:"origin_height,omitempty"`
}

func (m *ConstraintReply) Reset()                    { *m = ConstraintReply{} }
func (m *ConstraintReply) String() string            { return proto.CompactTextString(m) }
func (*ConstraintReply) ProtoMessage()               {}
func (*ConstraintReply) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{117} }

func (m *ConstraintReply) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_StatusCodeOK
}

func (m *ConstraintReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ConstraintReply) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ConstraintReply) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ConstraintReply) GetOriginWidth() uint32 {
	if m != nil {
		return m.OriginWidth
	}
	return 0
}

func (m *ConstraintReply) GetOriginHeight() uint32 {
	if m != nil {
		return m.OriginHeight
	}
	return 0
}

// CompressImageRequest 压缩图片请求
type CompressImageRequest struct {
	Data    []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Quality uint32 `protobuf:"varint,2,opt,name=quality,proto3" json:"quality,omitempty"`
}

func (m *CompressImageRequest) Reset()         { *m = CompressImageRequest{} }
func (m *CompressImageRequest) String() string { return proto.CompactTextString(m) }
func (*CompressImageRequest) ProtoMessage()    {}
func (*CompressImageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{118}
}

func (m *CompressImageRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *CompressImageRequest) GetQuality() uint32 {
	if m != nil {
		return m.Quality
	}
	return 0
}

// CompressImageReply 压缩图片响应
type CompressImageReply struct {
	Status StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=imapigateway.StatusCode" json:"status,omitempty"`
	Data   []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *CompressImageReply) Reset()         { *m = CompressImageReply{} }
func (m *CompressImageReply) String() string { return proto.CompactTextString(m) }
func (*CompressImageReply) ProtoMessage()    {}
func (*CompressImageReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{119}
}

func (m *CompressImageReply) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_StatusCodeOK
}

func (m *CompressImageReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// VideoPreviewRequest 获取视频预览请求
type VideoPreviewRequest struct {
	Data    []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	MaxSize uint32 `protobuf:"varint,2,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
}

func (m *VideoPreviewRequest) Reset()         { *m = VideoPreviewRequest{} }
func (m *VideoPreviewRequest) String() string { return proto.CompactTextString(m) }
func (*VideoPreviewRequest) ProtoMessage()    {}
func (*VideoPreviewRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{120}
}

func (m *VideoPreviewRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *VideoPreviewRequest) GetMaxSize() uint32 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

// VideoPreviewReply 获取视频预览响应
type VideoPreviewReply struct {
	Status   StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=imapigateway.StatusCode" json:"status,omitempty"`
	Duration uint32     `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	Preview  []byte     `protobuf:"bytes,3,opt,name=preview,proto3" json:"preview,omitempty"`
	Width    uint32     `protobuf:"varint,4,opt,name=width,proto3" json:"width,omitempty"`
	Height   uint32     `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *VideoPreviewReply) Reset()                    { *m = VideoPreviewReply{} }
func (m *VideoPreviewReply) String() string            { return proto.CompactTextString(m) }
func (*VideoPreviewReply) ProtoMessage()               {}
func (*VideoPreviewReply) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{121} }

func (m *VideoPreviewReply) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_StatusCodeOK
}

func (m *VideoPreviewReply) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *VideoPreviewReply) GetPreview() []byte {
	if m != nil {
		return m.Preview
	}
	return nil
}

func (m *VideoPreviewReply) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *VideoPreviewReply) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

// AudioPreviewRequest 获取音频预览请求
type AudioPreviewRequest struct {
	Data    []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	MaxSize uint32 `protobuf:"varint,2,opt,name=max_size,json=maxSize,proto3" json:"max_size,omitempty"`
}

func (m *AudioPreviewRequest) Reset()         { *m = AudioPreviewRequest{} }
func (m *AudioPreviewRequest) String() string { return proto.CompactTextString(m) }
func (*AudioPreviewRequest) ProtoMessage()    {}
func (*AudioPreviewRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{122}
}

func (m *AudioPreviewRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AudioPreviewRequest) GetMaxSize() uint32 {
	if m != nil {
		return m.MaxSize
	}
	return 0
}

// AudioPreviewReply 获取音频预览响应
type AudioPreviewReply struct {
	Status   StatusCode `protobuf:"varint,1,opt,name=status,proto3,enum=imapigateway.StatusCode" json:"status,omitempty"`
	Duration uint32     `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	Cover    []byte     `protobuf:"bytes,3,opt,name=cover,proto3" json:"cover,omitempty"`
	Title    string     `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	Artist   string     `protobuf:"bytes,5,opt,name=artist,proto3" json:"artist,omitempty"`
	Width    uint32     `protobuf:"varint,6,opt,name=width,proto3" json:"width,omitempty"`
	Height   uint32     `protobuf:"varint,7,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *AudioPreviewReply) Reset()                    { *m = AudioPreviewReply{} }
func (m *AudioPreviewReply) String() string            { return proto.CompactTextString(m) }
func (*AudioPreviewReply) ProtoMessage()               {}
func (*AudioPreviewReply) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{123} }

func (m *AudioPreviewReply) GetStatus() StatusCode {
	if m != nil {
		return m.Status
	}
	return StatusCode_StatusCodeOK
}

func (m *AudioPreviewReply) GetDuration() uint32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *AudioPreviewReply) GetCover() []byte {
	if m != nil {
		return m.Cover
	}
	return nil
}

func (m *AudioPreviewReply) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *AudioPreviewReply) GetArtist() string {
	if m != nil {
		return m.Artist
	}
	return ""
}

func (m *AudioPreviewReply) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *AudioPreviewReply) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

// ###################################  pbmessageserver.pb.go  #############################
// 获取participants
type ReqParticipants struct {
	OffSet    int32  `protobuf:"varint,1,opt,name=offSet,proto3" json:"offSet,omitempty"`
	Limit     int32  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	PartiType int32  `protobuf:"varint,3,opt,name=partiType,proto3" json:"partiType,omitempty"`
	ChannelId int32  `protobuf:"varint,4,opt,name=channelId,proto3" json:"channelId,omitempty"`
	FromId    int32  `protobuf:"varint,5,opt,name=fromId,proto3" json:"fromId,omitempty"`
	Q         string `protobuf:"bytes,6,opt,name=q,proto3" json:"q,omitempty"`
	Hash      int32  `protobuf:"varint,7,opt,name=Hash,proto3" json:"Hash,omitempty"`
	Debug     *Debug `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqParticipants) Reset()                    { *m = ReqParticipants{} }
func (m *ReqParticipants) String() string            { return proto.CompactTextString(m) }
func (*ReqParticipants) ProtoMessage()               {}
func (*ReqParticipants) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{124} }

func (m *ReqParticipants) GetOffSet() int32 {
	if m != nil {
		return m.OffSet
	}
	return 0
}

func (m *ReqParticipants) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqParticipants) GetPartiType() int32 {
	if m != nil {
		return m.PartiType
	}
	return 0
}

func (m *ReqParticipants) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqParticipants) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqParticipants) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

func (m *ReqParticipants) GetHash() int32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *ReqParticipants) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 返回participants
type ReplyParticipants struct {
	Updates   []byte `protobuf:"bytes,1,opt,name=Updates,proto3" json:"Updates,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyParticipants) Reset()                    { *m = ReplyParticipants{} }
func (m *ReplyParticipants) String() string            { return proto.CompactTextString(m) }
func (*ReplyParticipants) ProtoMessage()               {}
func (*ReplyParticipants) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{125} }

func (m *ReplyParticipants) GetUpdates() []byte {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *ReplyParticipants) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type ReqCreateChat struct {
	Chatid    int32   `protobuf:"varint,1,opt,name=chatid,proto3" json:"chatid,omitempty"`
	Title     string  `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Creator   int32   `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	Users     []int32 `protobuf:"varint,4,rep,packed,name=users" json:"users,omitempty"`
	FromKeyid uint64  `protobuf:"varint,5,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *Debug  `protobuf:"bytes,6,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqCreateChat) Reset()                    { *m = ReqCreateChat{} }
func (m *ReqCreateChat) String() string            { return proto.CompactTextString(m) }
func (*ReqCreateChat) ProtoMessage()               {}
func (*ReqCreateChat) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{126} }

func (m *ReqCreateChat) GetChatid() int32 {
	if m != nil {
		return m.Chatid
	}
	return 0
}

func (m *ReqCreateChat) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ReqCreateChat) GetCreator() int32 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *ReqCreateChat) GetUsers() []int32 {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *ReqCreateChat) GetFromKeyid() uint64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqCreateChat) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyCreateChat struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,5,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyCreateChat) Reset()                    { *m = ReplyCreateChat{} }
func (m *ReplyCreateChat) String() string            { return proto.CompactTextString(m) }
func (*ReplyCreateChat) ProtoMessage()               {}
func (*ReplyCreateChat) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{127} }

func (m *ReplyCreateChat) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyCreateChat) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

type ReqMigrateChat struct {
	Fromid int32 `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Chatid int32 `protobuf:"varint,2,opt,name=chatid,proto3" json:"chatid,omitempty"`
	//    int32 channelid = 3; //升级后的超级群ID
	//    string title = 4; // 群标题
	//    repeated int32 members = 5; //现有用户
	//    string Phone = 6; //电话
	Fromkeyid uint64 `protobuf:"varint,3,opt,name=fromkeyid,proto3" json:"fromkeyid,omitempty"`
	//    bool isBroadCast = 8; //超级群还是频道
	Debug *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqMigrateChat) Reset()                    { *m = ReqMigrateChat{} }
func (m *ReqMigrateChat) String() string            { return proto.CompactTextString(m) }
func (*ReqMigrateChat) ProtoMessage()               {}
func (*ReqMigrateChat) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{128} }

func (m *ReqMigrateChat) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqMigrateChat) GetChatid() int32 {
	if m != nil {
		return m.Chatid
	}
	return 0
}

func (m *ReqMigrateChat) GetFromkeyid() uint64 {
	if m != nil {
		return m.Fromkeyid
	}
	return 0
}

func (m *ReqMigrateChat) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyMigrateChat struct {
	//    int32 msgid = 1; // 消息id
	//    int64 randomid = 2; // 消息随机id
	//    int32 date = 3; // 消息时间
	//    int32 pts = 4; // 消息pts
	//    int32 channelmsgid = 5; //频道的消息ID
	//    int32 channelpts = 6; //频道的PTS
	Result []byte `protobuf:"bytes,7,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,8,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyMigrateChat) Reset()                    { *m = ReplyMigrateChat{} }
func (m *ReplyMigrateChat) String() string            { return proto.CompactTextString(m) }
func (*ReplyMigrateChat) ProtoMessage()               {}
func (*ReplyMigrateChat) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{129} }

func (m *ReplyMigrateChat) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyMigrateChat) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 邀请用户进入超级群
type ReqJoinChannel struct {
	ChannelId  int32  `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	UserId     int32  `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
	FromKeyid  int64  `protobuf:"varint,5,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	AccessHash int64  `protobuf:"varint,6,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	ByLink     bool   `protobuf:"varint,7,opt,name=byLink,proto3" json:"byLink,omitempty"`
	Invitor    int32  `protobuf:"varint,8,opt,name=invitor,proto3" json:"invitor,omitempty"`
	InviteType int32  `protobuf:"varint,9,opt,name=invite_type,json=inviteType,proto3" json:"invite_type,omitempty"`
	Debug      *Debug `protobuf:"bytes,10,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqJoinChannel) Reset()                    { *m = ReqJoinChannel{} }
func (m *ReqJoinChannel) String() string            { return proto.CompactTextString(m) }
func (*ReqJoinChannel) ProtoMessage()               {}
func (*ReqJoinChannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{130} }

func (m *ReqJoinChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqJoinChannel) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqJoinChannel) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqJoinChannel) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqJoinChannel) GetByLink() bool {
	if m != nil {
		return m.ByLink
	}
	return false
}

func (m *ReqJoinChannel) GetInvitor() int32 {
	if m != nil {
		return m.Invitor
	}
	return 0
}

func (m *ReqJoinChannel) GetInviteType() int32 {
	if m != nil {
		return m.InviteType
	}
	return 0
}

func (m *ReqJoinChannel) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 邀请操作的ACK
type ReplyJoinChannel struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyJoinChannel) Reset()                    { *m = ReplyJoinChannel{} }
func (m *ReplyJoinChannel) String() string            { return proto.CompactTextString(m) }
func (*ReplyJoinChannel) ProtoMessage()               {}
func (*ReplyJoinChannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{131} }

func (m *ReplyJoinChannel) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyJoinChannel) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 转移群主
type ReqChangeGroupAndChannelCrator struct {
	GroupId    int32 `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	FromId     int32 `protobuf:"varint,2,opt,name=fromId,proto3" json:"fromId,omitempty"`
	OperatorId int32 `protobuf:"varint,3,opt,name=OperatorId,proto3" json:"OperatorId,omitempty"`
	IsChat     bool  `protobuf:"varint,4,opt,name=IsChat,proto3" json:"IsChat,omitempty"`
}

func (m *ReqChangeGroupAndChannelCrator) Reset()         { *m = ReqChangeGroupAndChannelCrator{} }
func (m *ReqChangeGroupAndChannelCrator) String() string { return proto.CompactTextString(m) }
func (*ReqChangeGroupAndChannelCrator) ProtoMessage()    {}
func (*ReqChangeGroupAndChannelCrator) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{132}
}

func (m *ReqChangeGroupAndChannelCrator) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ReqChangeGroupAndChannelCrator) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqChangeGroupAndChannelCrator) GetOperatorId() int32 {
	if m != nil {
		return m.OperatorId
	}
	return 0
}

func (m *ReqChangeGroupAndChannelCrator) GetIsChat() bool {
	if m != nil {
		return m.IsChat
	}
	return false
}

// 回复转移群主
type ReplyChangeGroupAndChannelCrator struct {
	Valid     bool  `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	ErrorCode int32 `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyChangeGroupAndChannelCrator) Reset()         { *m = ReplyChangeGroupAndChannelCrator{} }
func (m *ReplyChangeGroupAndChannelCrator) String() string { return proto.CompactTextString(m) }
func (*ReplyChangeGroupAndChannelCrator) ProtoMessage()    {}
func (*ReplyChangeGroupAndChannelCrator) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{133}
}

func (m *ReplyChangeGroupAndChannelCrator) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *ReplyChangeGroupAndChannelCrator) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 机器人调用接口
type ReqBotCallMessageMedia struct {
	FromBotId int32  `protobuf:"varint,1,opt,name=fromBotId,proto3" json:"fromBotId,omitempty"`
	MsgTxt    string `protobuf:"bytes,2,opt,name=MsgTxt,proto3" json:"MsgTxt,omitempty"`
	Request   []byte `protobuf:"bytes,3,opt,name=request,proto3" json:"request,omitempty"`
	Layer     int32  `protobuf:"varint,4,opt,name=layer,proto3" json:"layer,omitempty"`
	Debug     *Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqBotCallMessageMedia) Reset()         { *m = ReqBotCallMessageMedia{} }
func (m *ReqBotCallMessageMedia) String() string { return proto.CompactTextString(m) }
func (*ReqBotCallMessageMedia) ProtoMessage()    {}
func (*ReqBotCallMessageMedia) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{134}
}

func (m *ReqBotCallMessageMedia) GetFromBotId() int32 {
	if m != nil {
		return m.FromBotId
	}
	return 0
}

func (m *ReqBotCallMessageMedia) GetMsgTxt() string {
	if m != nil {
		return m.MsgTxt
	}
	return ""
}

func (m *ReqBotCallMessageMedia) GetRequest() []byte {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ReqBotCallMessageMedia) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *ReqBotCallMessageMedia) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 获取dialog接口
type RequestDialog struct {
	Userid     int32  `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Flags      int32  `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	OffsetDate int32  `protobuf:"varint,3,opt,name=offset_date,json=offsetDate,proto3" json:"offset_date,omitempty"`
	OffsetId   int32  `protobuf:"varint,4,opt,name=offset_id,json=offsetId,proto3" json:"offset_id,omitempty"`
	OffsetPeer []byte `protobuf:"bytes,5,opt,name=offset_peer,json=offsetPeer,proto3" json:"offset_peer,omitempty"`
	Limit      int32  `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	Debug      *Debug `protobuf:"bytes,7,opt,name=debug" json:"debug,omitempty"`
}

func (m *RequestDialog) Reset()                    { *m = RequestDialog{} }
func (m *RequestDialog) String() string            { return proto.CompactTextString(m) }
func (*RequestDialog) ProtoMessage()               {}
func (*RequestDialog) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{135} }

func (m *RequestDialog) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *RequestDialog) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *RequestDialog) GetOffsetDate() int32 {
	if m != nil {
		return m.OffsetDate
	}
	return 0
}

func (m *RequestDialog) GetOffsetId() int32 {
	if m != nil {
		return m.OffsetId
	}
	return 0
}

func (m *RequestDialog) GetOffsetPeer() []byte {
	if m != nil {
		return m.OffsetPeer
	}
	return nil
}

func (m *RequestDialog) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RequestDialog) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 返回dialog
type ReplyDialog struct {
	//    repeated DialogSlice dialog = 1;
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyDialog) Reset()                    { *m = ReplyDialog{} }
func (m *ReplyDialog) String() string            { return proto.CompactTextString(m) }
func (*ReplyDialog) ProtoMessage()               {}
func (*ReplyDialog) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{136} }

func (m *ReplyDialog) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyDialog) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 用户分数
type UserScore struct {
	Userid int32 `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Score  int32 `protobuf:"varint,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *UserScore) Reset()                    { *m = UserScore{} }
func (m *UserScore) String() string            { return proto.CompactTextString(m) }
func (*UserScore) ProtoMessage()               {}
func (*UserScore) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{137} }

func (m *UserScore) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *UserScore) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

// 调用设置分数
type ReqSetGameScore struct {
	Userid             int32        `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Scores             []*UserScore `protobuf:"bytes,2,rep,name=scores" json:"scores,omitempty"`
	Force              bool         `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	DisableEditMessage bool         `protobuf:"varint,4,opt,name=disable_edit_message,json=disableEditMessage,proto3" json:"disable_edit_message,omitempty"`
	ChatId             int32        `protobuf:"varint,5,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	ChatType           int32        `protobuf:"varint,6,opt,name=chat_type,json=chatType,proto3" json:"chat_type,omitempty"`
	MessageId          int32        `protobuf:"varint,7,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	InlineMessageId    string       `protobuf:"bytes,8,opt,name=inline_message_id,json=inlineMessageId,proto3" json:"inline_message_id,omitempty"`
	Botid              int32        `protobuf:"varint,9,opt,name=botid,proto3" json:"botid,omitempty"`
	Debug              *Debug       `protobuf:"bytes,10,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqSetGameScore) Reset()                    { *m = ReqSetGameScore{} }
func (m *ReqSetGameScore) String() string            { return proto.CompactTextString(m) }
func (*ReqSetGameScore) ProtoMessage()               {}
func (*ReqSetGameScore) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{138} }

func (m *ReqSetGameScore) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *ReqSetGameScore) GetScores() []*UserScore {
	if m != nil {
		return m.Scores
	}
	return nil
}

func (m *ReqSetGameScore) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *ReqSetGameScore) GetDisableEditMessage() bool {
	if m != nil {
		return m.DisableEditMessage
	}
	return false
}

func (m *ReqSetGameScore) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ReqSetGameScore) GetChatType() int32 {
	if m != nil {
		return m.ChatType
	}
	return 0
}

func (m *ReqSetGameScore) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *ReqSetGameScore) GetInlineMessageId() string {
	if m != nil {
		return m.InlineMessageId
	}
	return ""
}

func (m *ReqSetGameScore) GetBotid() int32 {
	if m != nil {
		return m.Botid
	}
	return 0
}

func (m *ReqSetGameScore) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 设置分数返回
type ReplySetGameScore struct {
	Succeed   bool   `protobuf:"varint,1,opt,name=succeed,proto3" json:"succeed,omitempty"`
	Error     string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	Errorcode int32  `protobuf:"varint,3,opt,name=errorcode,proto3" json:"errorcode,omitempty"`
}

func (m *ReplySetGameScore) Reset()                    { *m = ReplySetGameScore{} }
func (m *ReplySetGameScore) String() string            { return proto.CompactTextString(m) }
func (*ReplySetGameScore) ProtoMessage()               {}
func (*ReplySetGameScore) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{139} }

func (m *ReplySetGameScore) GetSucceed() bool {
	if m != nil {
		return m.Succeed
	}
	return false
}

func (m *ReplySetGameScore) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ReplySetGameScore) GetErrorcode() int32 {
	if m != nil {
		return m.Errorcode
	}
	return 0
}

type ReplyBanChannelUser struct {
	Updates   []byte `protobuf:"bytes,1,opt,name=Updates,proto3" json:"Updates,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyBanChannelUser) Reset()         { *m = ReplyBanChannelUser{} }
func (m *ReplyBanChannelUser) String() string { return proto.CompactTextString(m) }
func (*ReplyBanChannelUser) ProtoMessage()    {}
func (*ReplyBanChannelUser) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{140}
}

func (m *ReplyBanChannelUser) GetUpdates() []byte {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *ReplyBanChannelUser) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type ReqBanChannelUser struct {
	FromId              int32                `protobuf:"varint,1,opt,name=fromId,proto3" json:"fromId,omitempty"`
	FromKeyId           int64                `protobuf:"varint,2,opt,name=fromKeyId,proto3" json:"fromKeyId,omitempty"`
	ChannelId           int32                `protobuf:"varint,3,opt,name=channelId,proto3" json:"channelId,omitempty"`
	BannedUserId        int32                `protobuf:"varint,4,opt,name=bannedUserId,proto3" json:"bannedUserId,omitempty"`
	AccessHash          int64                `protobuf:"varint,5,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	UtilDate            int32                `protobuf:"varint,6,opt,name=util_date,json=utilDate,proto3" json:"util_date,omitempty"`
	ChannelBannedRights *ChannelBannedRights `protobuf:"bytes,7,opt,name=channelBannedRights" json:"channelBannedRights,omitempty"`
	Debug               *Debug               `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqBanChannelUser) Reset()                    { *m = ReqBanChannelUser{} }
func (m *ReqBanChannelUser) String() string            { return proto.CompactTextString(m) }
func (*ReqBanChannelUser) ProtoMessage()               {}
func (*ReqBanChannelUser) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{141} }

func (m *ReqBanChannelUser) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqBanChannelUser) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *ReqBanChannelUser) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqBanChannelUser) GetBannedUserId() int32 {
	if m != nil {
		return m.BannedUserId
	}
	return 0
}

func (m *ReqBanChannelUser) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqBanChannelUser) GetUtilDate() int32 {
	if m != nil {
		return m.UtilDate
	}
	return 0
}

func (m *ReqBanChannelUser) GetChannelBannedRights() *ChannelBannedRights {
	if m != nil {
		return m.ChannelBannedRights
	}
	return nil
}

func (m *ReqBanChannelUser) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 请求给定channel
type ReqGetChannels struct {
	ChannelIds []int32 `protobuf:"varint,1,rep,packed,name=channelIds" json:"channelIds,omitempty"`
	FromId     int32   `protobuf:"varint,2,opt,name=fromId,proto3" json:"fromId,omitempty"`
	Debug      *Debug  `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetChannels) Reset()                    { *m = ReqGetChannels{} }
func (m *ReqGetChannels) String() string            { return proto.CompactTextString(m) }
func (*ReqGetChannels) ProtoMessage()               {}
func (*ReqGetChannels) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{142} }

func (m *ReqGetChannels) GetChannelIds() []int32 {
	if m != nil {
		return m.ChannelIds
	}
	return nil
}

func (m *ReqGetChannels) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqGetChannels) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 返回get channles
type ReplyGetChannels struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyGetChannels) Reset()                    { *m = ReplyGetChannels{} }
func (m *ReplyGetChannels) String() string            { return proto.CompactTextString(m) }
func (*ReplyGetChannels) ProtoMessage()               {}
func (*ReplyGetChannels) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{143} }

func (m *ReplyGetChannels) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyGetChannels) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type ReqDeleteChatUser struct {
	Fromid    int32  `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Chatid    int32  `protobuf:"varint,2,opt,name=chatid,proto3" json:"chatid,omitempty"`
	Userid    int32  `protobuf:"varint,3,opt,name=userid,proto3" json:"userid,omitempty"`
	FromKeyid uint64 `protobuf:"varint,4,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *Debug `protobuf:"bytes,6,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqDeleteChatUser) Reset()                    { *m = ReqDeleteChatUser{} }
func (m *ReqDeleteChatUser) String() string            { return proto.CompactTextString(m) }
func (*ReqDeleteChatUser) ProtoMessage()               {}
func (*ReqDeleteChatUser) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{144} }

func (m *ReqDeleteChatUser) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqDeleteChatUser) GetChatid() int32 {
	if m != nil {
		return m.Chatid
	}
	return 0
}

func (m *ReqDeleteChatUser) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *ReqDeleteChatUser) GetFromKeyid() uint64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqDeleteChatUser) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyDeleteChatUser struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyDeleteChatUser) Reset()         { *m = ReplyDeleteChatUser{} }
func (m *ReplyDeleteChatUser) String() string { return proto.CompactTextString(m) }
func (*ReplyDeleteChatUser) ProtoMessage()    {}
func (*ReplyDeleteChatUser) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{145}
}

func (m *ReplyDeleteChatUser) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyDeleteChatUser) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

type ChannelInactiveUser struct {
	Id      int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Time    int32  `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	TimeStr string `protobuf:"bytes,4,opt,name=timeStr,proto3" json:"timeStr,omitempty"`
}

func (m *ChannelInactiveUser) Reset()         { *m = ChannelInactiveUser{} }
func (m *ChannelInactiveUser) String() string { return proto.CompactTextString(m) }
func (*ChannelInactiveUser) ProtoMessage()    {}
func (*ChannelInactiveUser) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{146}
}

func (m *ChannelInactiveUser) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChannelInactiveUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChannelInactiveUser) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ChannelInactiveUser) GetTimeStr() string {
	if m != nil {
		return m.TimeStr
	}
	return ""
}

type GetChannelInactiveUsersReq struct {
	ChannelId int32 `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Limit     int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Userid    int32 `protobuf:"varint,3,opt,name=userid,proto3" json:"userid,omitempty"`
}

func (m *GetChannelInactiveUsersReq) Reset()         { *m = GetChannelInactiveUsersReq{} }
func (m *GetChannelInactiveUsersReq) String() string { return proto.CompactTextString(m) }
func (*GetChannelInactiveUsersReq) ProtoMessage()    {}
func (*GetChannelInactiveUsersReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{147}
}

func (m *GetChannelInactiveUsersReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelInactiveUsersReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetChannelInactiveUsersReq) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

type GetChannelInactiveUsersResult struct {
	Users   []*ChannelInactiveUser `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	Count   int32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Errcode int32                  `protobuf:"varint,3,opt,name=errcode,proto3" json:"errcode,omitempty"`
}

func (m *GetChannelInactiveUsersResult) Reset()         { *m = GetChannelInactiveUsersResult{} }
func (m *GetChannelInactiveUsersResult) String() string { return proto.CompactTextString(m) }
func (*GetChannelInactiveUsersResult) ProtoMessage()    {}
func (*GetChannelInactiveUsersResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{148}
}

func (m *GetChannelInactiveUsersResult) GetUsers() []*ChannelInactiveUser {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GetChannelInactiveUsersResult) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetChannelInactiveUsersResult) GetErrcode() int32 {
	if m != nil {
		return m.Errcode
	}
	return 0
}

// 机器人调用接口-Inline
type ReqBotInlineCall struct {
	Debug     *Debug `protobuf:"bytes,1,opt,name=debug" json:"debug,omitempty"`
	UserId    int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	BotId     int32  `protobuf:"varint,3,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	MessageId uint64 `protobuf:"varint,4,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	KeyId     uint64 `protobuf:"varint,5,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	SessionId uint64 `protobuf:"varint,6,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Data      []byte `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
	Id        string `protobuf:"bytes,8,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ReqBotInlineCall) Reset()                    { *m = ReqBotInlineCall{} }
func (m *ReqBotInlineCall) String() string            { return proto.CompactTextString(m) }
func (*ReqBotInlineCall) ProtoMessage()               {}
func (*ReqBotInlineCall) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{149} }

func (m *ReqBotInlineCall) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *ReqBotInlineCall) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqBotInlineCall) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

func (m *ReqBotInlineCall) GetMessageId() uint64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *ReqBotInlineCall) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *ReqBotInlineCall) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *ReqBotInlineCall) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ReqBotInlineCall) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// 机器人返回接口-Inline
type ReplyBotInlineCall struct {
	ErrCode    int32       `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3" json:"err_code,omitempty"`
	Message    string      `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Inlinecall *InlineCall `protobuf:"bytes,3,opt,name=inlinecall" json:"inlinecall,omitempty"`
}

func (m *ReplyBotInlineCall) Reset()         { *m = ReplyBotInlineCall{} }
func (m *ReplyBotInlineCall) String() string { return proto.CompactTextString(m) }
func (*ReplyBotInlineCall) ProtoMessage()    {}
func (*ReplyBotInlineCall) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{150}
}

func (m *ReplyBotInlineCall) GetErrCode() int32 {
	if m != nil {
		return m.ErrCode
	}
	return 0
}

func (m *ReplyBotInlineCall) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ReplyBotInlineCall) GetInlinecall() *InlineCall {
	if m != nil {
		return m.Inlinecall
	}
	return nil
}

type InlineCall struct {
	MsgId    int32 `protobuf:"varint,1,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	FromId   int32 `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	ChatId   int32 `protobuf:"varint,3,opt,name=ChatId,proto3" json:"ChatId,omitempty"`
	ChatType int32 `protobuf:"varint,4,opt,name=ChatType,proto3" json:"ChatType,omitempty"`
	BotId    int32 `protobuf:"varint,5,opt,name=BotId,proto3" json:"BotId,omitempty"`
}

func (m *InlineCall) Reset()                    { *m = InlineCall{} }
func (m *InlineCall) String() string            { return proto.CompactTextString(m) }
func (*InlineCall) ProtoMessage()               {}
func (*InlineCall) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{151} }

func (m *InlineCall) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *InlineCall) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *InlineCall) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *InlineCall) GetChatType() int32 {
	if m != nil {
		return m.ChatType
	}
	return 0
}

func (m *InlineCall) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

// 发送给对方所有端
type ReqSendUserMsg struct {
	Fromid    int32  `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	FromKeyId int64  `protobuf:"varint,2,opt,name=fromKeyId,proto3" json:"fromKeyId,omitempty"`
	Toid      int32  `protobuf:"varint,3,opt,name=toid,proto3" json:"toid,omitempty"`
	Data      []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Debug     *Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqSendUserMsg) Reset()                    { *m = ReqSendUserMsg{} }
func (m *ReqSendUserMsg) String() string            { return proto.CompactTextString(m) }
func (*ReqSendUserMsg) ProtoMessage()               {}
func (*ReqSendUserMsg) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{152} }

func (m *ReqSendUserMsg) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqSendUserMsg) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *ReqSendUserMsg) GetToid() int32 {
	if m != nil {
		return m.Toid
	}
	return 0
}

func (m *ReqSendUserMsg) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ReqSendUserMsg) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 置顶对话框返回
type ReplyBool struct {
	Result bool  `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32 `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyBool) Reset()                    { *m = ReplyBool{} }
func (m *ReplyBool) String() string            { return proto.CompactTextString(m) }
func (*ReplyBool) ProtoMessage()               {}
func (*ReplyBool) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{153} }

func (m *ReplyBool) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ReplyBool) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 机器人调用接口
type ReqBotCall struct {
	FrombotId int32  `protobuf:"varint,1,opt,name=frombotId,proto3" json:"frombotId,omitempty"`
	Request   []byte `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	Layer     int32  `protobuf:"varint,3,opt,name=layer,proto3" json:"layer,omitempty"`
	Debug     *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqBotCall) Reset()                    { *m = ReqBotCall{} }
func (m *ReqBotCall) String() string            { return proto.CompactTextString(m) }
func (*ReqBotCall) ProtoMessage()               {}
func (*ReqBotCall) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{154} }

func (m *ReqBotCall) GetFrombotId() int32 {
	if m != nil {
		return m.FrombotId
	}
	return 0
}

func (m *ReqBotCall) GetRequest() []byte {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *ReqBotCall) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *ReqBotCall) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 机器人返回接口
type ReplyBotCall struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyBotCall) Reset()                    { *m = ReplyBotCall{} }
func (m *ReplyBotCall) String() string            { return proto.CompactTextString(m) }
func (*ReplyBotCall) ProtoMessage()               {}
func (*ReplyBotCall) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{155} }

func (m *ReplyBotCall) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyBotCall) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

type ReqGetMessageByUserIdUuid struct {
	UserId int32  `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Uuid   int64  `protobuf:"varint,2,opt,name=Uuid,proto3" json:"Uuid,omitempty"`
	Debug  *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetMessageByUserIdUuid) Reset()         { *m = ReqGetMessageByUserIdUuid{} }
func (m *ReqGetMessageByUserIdUuid) String() string { return proto.CompactTextString(m) }
func (*ReqGetMessageByUserIdUuid) ProtoMessage()    {}
func (*ReqGetMessageByUserIdUuid) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{156}
}

func (m *ReqGetMessageByUserIdUuid) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetMessageByUserIdUuid) GetUuid() int64 {
	if m != nil {
		return m.Uuid
	}
	return 0
}

func (m *ReqGetMessageByUserIdUuid) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetMessageByUserIdUuid struct {
	UserMessage *UserMsg `protobuf:"bytes,1,opt,name=UserMessage" json:"UserMessage,omitempty"`
	ErrorCode   int32    `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyGetMessageByUserIdUuid) Reset()         { *m = ReplyGetMessageByUserIdUuid{} }
func (m *ReplyGetMessageByUserIdUuid) String() string { return proto.CompactTextString(m) }
func (*ReplyGetMessageByUserIdUuid) ProtoMessage()    {}
func (*ReplyGetMessageByUserIdUuid) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{157}
}

func (m *ReplyGetMessageByUserIdUuid) GetUserMessage() *UserMsg {
	if m != nil {
		return m.UserMessage
	}
	return nil
}

func (m *ReplyGetMessageByUserIdUuid) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type ReqGetChannelMessageByChannelIdMsgId struct {
	ChannelId int32  `protobuf:"varint,1,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	MsgId     int32  `protobuf:"varint,2,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	Debug     *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetChannelMessageByChannelIdMsgId) Reset()         { *m = ReqGetChannelMessageByChannelIdMsgId{} }
func (m *ReqGetChannelMessageByChannelIdMsgId) String() string { return proto.CompactTextString(m) }
func (*ReqGetChannelMessageByChannelIdMsgId) ProtoMessage()    {}
func (*ReqGetChannelMessageByChannelIdMsgId) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{158}
}

func (m *ReqGetChannelMessageByChannelIdMsgId) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqGetChannelMessageByChannelIdMsgId) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqGetChannelMessageByChannelIdMsgId) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetChannelMessageByChannelIdMsgId struct {
	UserMessage *UserMsg `protobuf:"bytes,1,opt,name=UserMessage" json:"UserMessage,omitempty"`
	ErrorCode   int32    `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyGetChannelMessageByChannelIdMsgId) Reset() {
	*m = ReplyGetChannelMessageByChannelIdMsgId{}
}
func (m *ReplyGetChannelMessageByChannelIdMsgId) String() string { return proto.CompactTextString(m) }
func (*ReplyGetChannelMessageByChannelIdMsgId) ProtoMessage()    {}
func (*ReplyGetChannelMessageByChannelIdMsgId) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{159}
}

func (m *ReplyGetChannelMessageByChannelIdMsgId) GetUserMessage() *UserMsg {
	if m != nil {
		return m.UserMessage
	}
	return nil
}

func (m *ReplyGetChannelMessageByChannelIdMsgId) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type ReqGetMessageByUserIdMsgId struct {
	UserId int32  `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	MsgId  int32  `protobuf:"varint,2,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	Debug  *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetMessageByUserIdMsgId) Reset()         { *m = ReqGetMessageByUserIdMsgId{} }
func (m *ReqGetMessageByUserIdMsgId) String() string { return proto.CompactTextString(m) }
func (*ReqGetMessageByUserIdMsgId) ProtoMessage()    {}
func (*ReqGetMessageByUserIdMsgId) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{160}
}

func (m *ReqGetMessageByUserIdMsgId) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetMessageByUserIdMsgId) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqGetMessageByUserIdMsgId) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetMessageByUserIdMsgId struct {
	UserMessage *UserMsg `protobuf:"bytes,1,opt,name=UserMessage" json:"UserMessage,omitempty"`
	ErrorCode   int32    `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyGetMessageByUserIdMsgId) Reset()         { *m = ReplyGetMessageByUserIdMsgId{} }
func (m *ReplyGetMessageByUserIdMsgId) String() string { return proto.CompactTextString(m) }
func (*ReplyGetMessageByUserIdMsgId) ProtoMessage()    {}
func (*ReplyGetMessageByUserIdMsgId) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{161}
}

func (m *ReplyGetMessageByUserIdMsgId) GetUserMessage() *UserMsg {
	if m != nil {
		return m.UserMessage
	}
	return nil
}

func (m *ReplyGetMessageByUserIdMsgId) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// ###################################  storage_proto.pb.go  #############################
// 网关上传文件描述信息请求
type MsgFileDescReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Data       []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgFileDescReq) Reset()                    { *m = MsgFileDescReq{} }
func (m *MsgFileDescReq) String() string            { return proto.CompactTextString(m) }
func (*MsgFileDescReq) ProtoMessage()               {}
func (*MsgFileDescReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{162} }

func (m *MsgFileDescReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgFileDescReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgFileDescReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 网关上传文件描述信息响应
type MsgFileDescResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=imapigateway.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgFileDescResp) Reset()                    { *m = MsgFileDescResp{} }
func (m *MsgFileDescResp) String() string            { return proto.CompactTextString(m) }
func (*MsgFileDescResp) ProtoMessage()               {}
func (*MsgFileDescResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{163} }

func (m *MsgFileDescResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 服务上传下载限制请求
type MsgServiceLimitReq struct {
	Reserved uint32 `protobuf:"varint,1,opt,name=reserved,proto3" json:"reserved,omitempty"`
}

func (m *MsgServiceLimitReq) Reset()         { *m = MsgServiceLimitReq{} }
func (m *MsgServiceLimitReq) String() string { return proto.CompactTextString(m) }
func (*MsgServiceLimitReq) ProtoMessage()    {}
func (*MsgServiceLimitReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{164}
}

func (m *MsgServiceLimitReq) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

// 服务上传下载限制响应(单位：Byte)
type MsgServiceLimitResp struct {
	Usfsl  uint32 `protobuf:"varint,1,opt,name=usfsl,proto3" json:"usfsl,omitempty"`
	Ubfssl uint32 `protobuf:"varint,2,opt,name=ubfssl,proto3" json:"ubfssl,omitempty"`
	Dssl   uint32 `protobuf:"varint,3,opt,name=dssl,proto3" json:"dssl,omitempty"`
}

func (m *MsgServiceLimitResp) Reset()         { *m = MsgServiceLimitResp{} }
func (m *MsgServiceLimitResp) String() string { return proto.CompactTextString(m) }
func (*MsgServiceLimitResp) ProtoMessage()    {}
func (*MsgServiceLimitResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{165}
}

func (m *MsgServiceLimitResp) GetUsfsl() uint32 {
	if m != nil {
		return m.Usfsl
	}
	return 0
}

func (m *MsgServiceLimitResp) GetUbfssl() uint32 {
	if m != nil {
		return m.Ubfssl
	}
	return 0
}

func (m *MsgServiceLimitResp) GetDssl() uint32 {
	if m != nil {
		return m.Dssl
	}
	return 0
}

// 网关取Fid请求
type MsgGetFidReq struct {
	Keyid     uint64 `protobuf:"varint,1,opt,name=keyid,proto3" json:"keyid,omitempty"`
	Fileid    int64  `protobuf:"varint,2,opt,name=fileid,proto3" json:"fileid,omitempty"`
	FileType  uint32 `protobuf:"varint,3,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"`
	Md5       string `protobuf:"bytes,4,opt,name=md5,proto3" json:"md5,omitempty"`
	PartTotal uint32 `protobuf:"varint,5,opt,name=part_total,json=partTotal,proto3" json:"part_total,omitempty"`
}

func (m *MsgGetFidReq) Reset()                    { *m = MsgGetFidReq{} }
func (m *MsgGetFidReq) String() string            { return proto.CompactTextString(m) }
func (*MsgGetFidReq) ProtoMessage()               {}
func (*MsgGetFidReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{166} }

func (m *MsgGetFidReq) GetKeyid() uint64 {
	if m != nil {
		return m.Keyid
	}
	return 0
}

func (m *MsgGetFidReq) GetFileid() int64 {
	if m != nil {
		return m.Fileid
	}
	return 0
}

func (m *MsgGetFidReq) GetFileType() uint32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *MsgGetFidReq) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *MsgGetFidReq) GetPartTotal() uint32 {
	if m != nil {
		return m.PartTotal
	}
	return 0
}

// 网关取Fid响应
type MsgGetFidResp struct {
	Fid        uint64         `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64         `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	FileSize   uint64         `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Result     ERpcResultCode `protobuf:"varint,4,opt,name=result,proto3,enum=imapigateway.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgGetFidResp) Reset()                    { *m = MsgGetFidResp{} }
func (m *MsgGetFidResp) String() string            { return proto.CompactTextString(m) }
func (*MsgGetFidResp) ProtoMessage()               {}
func (*MsgGetFidResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{167} }

func (m *MsgGetFidResp) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgGetFidResp) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgGetFidResp) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *MsgGetFidResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 网关上传文件请求
type MsgFilePartsReq struct {
	Keyid     uint64 `protobuf:"varint,1,opt,name=keyid,proto3" json:"keyid,omitempty"`
	Fileid    int64  `protobuf:"varint,2,opt,name=fileid,proto3" json:"fileid,omitempty"`
	PartId    uint32 `protobuf:"varint,3,opt,name=part_id,json=partId,proto3" json:"part_id,omitempty"`
	FileType  uint32 `protobuf:"varint,4,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"`
	PartTotal uint32 `protobuf:"varint,5,opt,name=part_total,json=partTotal,proto3" json:"part_total,omitempty"`
	Data      []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgFilePartsReq) Reset()                    { *m = MsgFilePartsReq{} }
func (m *MsgFilePartsReq) String() string            { return proto.CompactTextString(m) }
func (*MsgFilePartsReq) ProtoMessage()               {}
func (*MsgFilePartsReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{168} }

func (m *MsgFilePartsReq) GetKeyid() uint64 {
	if m != nil {
		return m.Keyid
	}
	return 0
}

func (m *MsgFilePartsReq) GetFileid() int64 {
	if m != nil {
		return m.Fileid
	}
	return 0
}

func (m *MsgFilePartsReq) GetPartId() uint32 {
	if m != nil {
		return m.PartId
	}
	return 0
}

func (m *MsgFilePartsReq) GetFileType() uint32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *MsgFilePartsReq) GetPartTotal() uint32 {
	if m != nil {
		return m.PartTotal
	}
	return 0
}

func (m *MsgFilePartsReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 网关上传文件响应
type MsgFilePartsResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=imapigateway.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgFilePartsResp) Reset()                    { *m = MsgFilePartsResp{} }
func (m *MsgFilePartsResp) String() string            { return proto.CompactTextString(m) }
func (*MsgFilePartsResp) ProtoMessage()               {}
func (*MsgFilePartsResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{169} }

func (m *MsgFilePartsResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 上传文件请求
type MsgUploadFileReq struct {
	Para1 *storageservice1.UploadReqPara1 `protobuf:"bytes,1,opt,name=para1" json:"para1,omitempty"`
	Para2 *storageservice1.UploadReqPara2 `protobuf:"bytes,2,opt,name=para2" json:"para2,omitempty"`
	Data  []byte                          `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgUploadFileReq) Reset()                    { *m = MsgUploadFileReq{} }
func (m *MsgUploadFileReq) String() string            { return proto.CompactTextString(m) }
func (*MsgUploadFileReq) ProtoMessage()               {}
func (*MsgUploadFileReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{170} }

func (m *MsgUploadFileReq) GetPara1() *storageservice1.UploadReqPara1 {
	if m != nil {
		return m.Para1
	}
	return nil
}

func (m *MsgUploadFileReq) GetPara2() *storageservice1.UploadReqPara2 {
	if m != nil {
		return m.Para2
	}
	return nil
}

func (m *MsgUploadFileReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 上传文件响应
type MsgUploadFileResp struct {
	Result     ERpcResultCode                      `protobuf:"varint,1,opt,name=result,proto3,enum=imapigateway.ERpcResultCode" json:"result,omitempty"`
	Para1      *storageservice1.FileUploadRespPara `protobuf:"bytes,2,opt,name=para1" json:"para1,omitempty"`
	Para2      *storageservice.FidPara             `protobuf:"bytes,3,opt,name=para2" json:"para2,omitempty"`
	AccessHash uint64                              `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgUploadFileResp) Reset()                    { *m = MsgUploadFileResp{} }
func (m *MsgUploadFileResp) String() string            { return proto.CompactTextString(m) }
func (*MsgUploadFileResp) ProtoMessage()               {}
func (*MsgUploadFileResp) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{171} }

func (m *MsgUploadFileResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func (m *MsgUploadFileResp) GetPara1() *storageservice1.FileUploadRespPara {
	if m != nil {
		return m.Para1
	}
	return nil
}

func (m *MsgUploadFileResp) GetPara2() *storageservice.FidPara {
	if m != nil {
		return m.Para2
	}
	return nil
}

func (m *MsgUploadFileResp) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 下载文件请求
type MsgDownloadFileReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Offset     uint32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Length     uint32 `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *MsgDownloadFileReq) Reset()         { *m = MsgDownloadFileReq{} }
func (m *MsgDownloadFileReq) String() string { return proto.CompactTextString(m) }
func (*MsgDownloadFileReq) ProtoMessage()    {}
func (*MsgDownloadFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{172}
}

func (m *MsgDownloadFileReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgDownloadFileReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgDownloadFileReq) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MsgDownloadFileReq) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

// 下载文件响应参数1
type DownloadFileRespPara1 struct {
	Fid      uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	Offset   uint32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	FileName string `protobuf:"bytes,3,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (m *DownloadFileRespPara1) Reset()         { *m = DownloadFileRespPara1{} }
func (m *DownloadFileRespPara1) String() string { return proto.CompactTextString(m) }
func (*DownloadFileRespPara1) ProtoMessage()    {}
func (*DownloadFileRespPara1) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{173}
}

func (m *DownloadFileRespPara1) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *DownloadFileRespPara1) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *DownloadFileRespPara1) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

// 下载文件响应参数2
type DownloadFileRespPara2 struct {
	Length uint32 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	Data   []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DownloadFileRespPara2) Reset()         { *m = DownloadFileRespPara2{} }
func (m *DownloadFileRespPara2) String() string { return proto.CompactTextString(m) }
func (*DownloadFileRespPara2) ProtoMessage()    {}
func (*DownloadFileRespPara2) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{174}
}

func (m *DownloadFileRespPara2) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DownloadFileRespPara2) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 下载文件响应
type MsgDownloadFileResp struct {
	Result ERpcResultCode         `protobuf:"varint,1,opt,name=result,proto3,enum=imapigateway.ERpcResultCode" json:"result,omitempty"`
	Para1  *DownloadFileRespPara1 `protobuf:"bytes,2,opt,name=para1" json:"para1,omitempty"`
	Para2  *DownloadFileRespPara2 `protobuf:"bytes,3,opt,name=para2" json:"para2,omitempty"`
}

func (m *MsgDownloadFileResp) Reset()         { *m = MsgDownloadFileResp{} }
func (m *MsgDownloadFileResp) String() string { return proto.CompactTextString(m) }
func (*MsgDownloadFileResp) ProtoMessage()    {}
func (*MsgDownloadFileResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{175}
}

func (m *MsgDownloadFileResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func (m *MsgDownloadFileResp) GetPara1() *DownloadFileRespPara1 {
	if m != nil {
		return m.Para1
	}
	return nil
}

func (m *MsgDownloadFileResp) GetPara2() *DownloadFileRespPara2 {
	if m != nil {
		return m.Para2
	}
	return nil
}

// 查询对象信息请求
type MsgQueryObjInfoReq struct {
	Fid uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
}

func (m *MsgQueryObjInfoReq) Reset()         { *m = MsgQueryObjInfoReq{} }
func (m *MsgQueryObjInfoReq) String() string { return proto.CompactTextString(m) }
func (*MsgQueryObjInfoReq) ProtoMessage()    {}
func (*MsgQueryObjInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{176}
}

func (m *MsgQueryObjInfoReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

// 查询对象信息响应参数
type QueryObjInfoRespPara struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Size_      uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	AccessHash uint64 `protobuf:"varint,3,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *QueryObjInfoRespPara) Reset()         { *m = QueryObjInfoRespPara{} }
func (m *QueryObjInfoRespPara) String() string { return proto.CompactTextString(m) }
func (*QueryObjInfoRespPara) ProtoMessage()    {}
func (*QueryObjInfoRespPara) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{177}
}

func (m *QueryObjInfoRespPara) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryObjInfoRespPara) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *QueryObjInfoRespPara) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 查询对象信息响应
type MsgQueryObjInfoResp struct {
	Para   *QueryObjInfoRespPara `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Result ERpcResultCode        `protobuf:"varint,2,opt,name=result,proto3,enum=imapigateway.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgQueryObjInfoResp) Reset()         { *m = MsgQueryObjInfoResp{} }
func (m *MsgQueryObjInfoResp) String() string { return proto.CompactTextString(m) }
func (*MsgQueryObjInfoResp) ProtoMessage()    {}
func (*MsgQueryObjInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{178}
}

func (m *MsgQueryObjInfoResp) GetPara() *QueryObjInfoRespPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgQueryObjInfoResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 网关获取文件描述信息请求
type MsgGetFileDescReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgGetFileDescReq) Reset()                    { *m = MsgGetFileDescReq{} }
func (m *MsgGetFileDescReq) String() string            { return proto.CompactTextString(m) }
func (*MsgGetFileDescReq) ProtoMessage()               {}
func (*MsgGetFileDescReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{179} }

func (m *MsgGetFileDescReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgGetFileDescReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 网关获取文件描述信息响应
type MsgGetFileDescResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=imapigateway.ERpcResultCode" json:"result,omitempty"`
	Data   []byte         `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgGetFileDescResp) Reset()         { *m = MsgGetFileDescResp{} }
func (m *MsgGetFileDescResp) String() string { return proto.CompactTextString(m) }
func (*MsgGetFileDescResp) ProtoMessage()    {}
func (*MsgGetFileDescResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{180}
}

func (m *MsgGetFileDescResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func (m *MsgGetFileDescResp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ###################################  channelservice.pb.go  #############################
// 获取channel信息  不带user信息
type GetChannelInfoReq struct {
	ChannelId  int32  `protobuf:"varint,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	AccessHash int64  `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Dlog       *Debug `protobuf:"bytes,3,opt,name=Dlog" json:"Dlog,omitempty"`
}

func (m *GetChannelInfoReq) Reset()                    { *m = GetChannelInfoReq{} }
func (m *GetChannelInfoReq) String() string            { return proto.CompactTextString(m) }
func (*GetChannelInfoReq) ProtoMessage()               {}
func (*GetChannelInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{181} }

func (m *GetChannelInfoReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelInfoReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GetChannelInfoReq) GetDlog() *Debug {
	if m != nil {
		return m.Dlog
	}
	return nil
}

// 群基础信息
type GetChannelInfoResp struct {
	BaseInfo   *ChannelInfoBase `protobuf:"bytes,1,opt,name=baseInfo" json:"baseInfo,omitempty"`
	Resultcode ChatResultCode   `protobuf:"varint,2,opt,name=resultcode,proto3,enum=imapigateway.ChatResultCode" json:"resultcode,omitempty"`
}

func (m *GetChannelInfoResp) Reset()         { *m = GetChannelInfoResp{} }
func (m *GetChannelInfoResp) String() string { return proto.CompactTextString(m) }
func (*GetChannelInfoResp) ProtoMessage()    {}
func (*GetChannelInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{182}
}

func (m *GetChannelInfoResp) GetBaseInfo() *ChannelInfoBase {
	if m != nil {
		return m.BaseInfo
	}
	return nil
}

func (m *GetChannelInfoResp) GetResultcode() ChatResultCode {
	if m != nil {
		return m.Resultcode
	}
	return ChatResultCode_Chat_RPC_OK
}

// ###################################  botserver.pb.go  #############################
type ReqGetAdminGroups struct {
	UserID int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	// int32 PeerFilter = 2; // 2：只要普通群 4：只要超级群 8：只要频道 （可相互组合 ex: 2|4|8 暂时不支持单聊)
	Debug *Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetAdminGroups) Reset()                    { *m = ReqGetAdminGroups{} }
func (m *ReqGetAdminGroups) String() string            { return proto.CompactTextString(m) }
func (*ReqGetAdminGroups) ProtoMessage()               {}
func (*ReqGetAdminGroups) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{183} }

func (m *ReqGetAdminGroups) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ReqGetAdminGroups) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqGetGroups struct {
	UserID     int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	PeerFilter int32 `protobuf:"varint,2,opt,name=PeerFilter,proto3" json:"PeerFilter,omitempty"`
}

func (m *ReqGetGroups) Reset()                    { *m = ReqGetGroups{} }
func (m *ReqGetGroups) String() string            { return proto.CompactTextString(m) }
func (*ReqGetGroups) ProtoMessage()               {}
func (*ReqGetGroups) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{184} }

func (m *ReqGetGroups) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ReqGetGroups) GetPeerFilter() int32 {
	if m != nil {
		return m.PeerFilter
	}
	return 0
}

type Peer struct {
	PeerID   int32  `protobuf:"varint,1,opt,name=PeerID,proto3" json:"PeerID,omitempty"`
	PeerName string `protobuf:"bytes,2,opt,name=PeerName,proto3" json:"PeerName,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{185} }

func (m *Peer) GetPeerID() int32 {
	if m != nil {
		return m.PeerID
	}
	return 0
}

func (m *Peer) GetPeerName() string {
	if m != nil {
		return m.PeerName
	}
	return ""
}

type ReplyGetGroups struct {
	Groups      []*Peer `protobuf:"bytes,1,rep,name=Groups" json:"Groups,omitempty"`
	SuperGroups []*Peer `protobuf:"bytes,2,rep,name=SuperGroups" json:"SuperGroups,omitempty"`
	Channels    []*Peer `protobuf:"bytes,3,rep,name=Channels" json:"Channels,omitempty"`
}

func (m *ReplyGetGroups) Reset()                    { *m = ReplyGetGroups{} }
func (m *ReplyGetGroups) String() string            { return proto.CompactTextString(m) }
func (*ReplyGetGroups) ProtoMessage()               {}
func (*ReplyGetGroups) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{186} }

func (m *ReplyGetGroups) GetGroups() []*Peer {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *ReplyGetGroups) GetSuperGroups() []*Peer {
	if m != nil {
		return m.SuperGroups
	}
	return nil
}

func (m *ReplyGetGroups) GetChannels() []*Peer {
	if m != nil {
		return m.Channels
	}
	return nil
}

type ReqDeleteMessage struct {
	ChatType ChatType `protobuf:"varint,1,opt,name=ChatType,proto3,enum=imapigateway.ChatType" json:"ChatType,omitempty"`
	UserId   int32    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChatId   int32    `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	MsgId    []int32  `protobuf:"varint,4,rep,packed,name=msg_id,json=msgId" json:"msg_id,omitempty"`
	Debug    *Debug   `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqDeleteMessage) Reset()                    { *m = ReqDeleteMessage{} }
func (m *ReqDeleteMessage) String() string            { return proto.CompactTextString(m) }
func (*ReqDeleteMessage) ProtoMessage()               {}
func (*ReqDeleteMessage) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{187} }

func (m *ReqDeleteMessage) GetChatType() ChatType {
	if m != nil {
		return m.ChatType
	}
	return ChatType_ChatTypeZero
}

func (m *ReqDeleteMessage) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqDeleteMessage) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ReqDeleteMessage) GetMsgId() []int32 {
	if m != nil {
		return m.MsgId
	}
	return nil
}

func (m *ReqDeleteMessage) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqSendChatAction struct {
	ChatType   ChatType `protobuf:"varint,1,opt,name=ChatType,proto3,enum=imapigateway.ChatType" json:"ChatType,omitempty"`
	UserId     int32    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChatId     int32    `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	ActionData []byte   `protobuf:"bytes,4,opt,name=actionData,proto3" json:"actionData,omitempty"`
	Debug      *Debug   `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqSendChatAction) Reset()                    { *m = ReqSendChatAction{} }
func (m *ReqSendChatAction) String() string            { return proto.CompactTextString(m) }
func (*ReqSendChatAction) ProtoMessage()               {}
func (*ReqSendChatAction) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{188} }

func (m *ReqSendChatAction) GetChatType() ChatType {
	if m != nil {
		return m.ChatType
	}
	return ChatType_ChatTypeZero
}

func (m *ReqSendChatAction) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqSendChatAction) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ReqSendChatAction) GetActionData() []byte {
	if m != nil {
		return m.ActionData
	}
	return nil
}

func (m *ReqSendChatAction) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqData struct {
	ChatType ChatType `protobuf:"varint,1,opt,name=ChatType,proto3,enum=imapigateway.ChatType" json:"ChatType,omitempty"`
	ReqData  []byte   `protobuf:"bytes,2,opt,name=reqData,proto3" json:"reqData,omitempty"`
	BotId    int32    `protobuf:"varint,3,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
}

func (m *ReqData) Reset()                    { *m = ReqData{} }
func (m *ReqData) String() string            { return proto.CompactTextString(m) }
func (*ReqData) ProtoMessage()               {}
func (*ReqData) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{189} }

func (m *ReqData) GetChatType() ChatType {
	if m != nil {
		return m.ChatType
	}
	return ChatType_ChatTypeZero
}

func (m *ReqData) GetReqData() []byte {
	if m != nil {
		return m.ReqData
	}
	return nil
}

func (m *ReqData) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

type ReplyData struct {
	Reply []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	Error int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyData) Reset()                    { *m = ReplyData{} }
func (m *ReplyData) String() string            { return proto.CompactTextString(m) }
func (*ReplyData) ProtoMessage()               {}
func (*ReplyData) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{190} }

func (m *ReplyData) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyData) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

type ReqGetChatMembersCount struct {
	ChatType ChatType `protobuf:"varint,1,opt,name=ChatType,proto3,enum=imapigateway.ChatType" json:"ChatType,omitempty"`
	UserId   int32    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChatId   int32    `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Debug    *Debug   `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetChatMembersCount) Reset()         { *m = ReqGetChatMembersCount{} }
func (m *ReqGetChatMembersCount) String() string { return proto.CompactTextString(m) }
func (*ReqGetChatMembersCount) ProtoMessage()    {}
func (*ReqGetChatMembersCount) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{191}
}

func (m *ReqGetChatMembersCount) GetChatType() ChatType {
	if m != nil {
		return m.ChatType
	}
	return ChatType_ChatTypeZero
}

func (m *ReqGetChatMembersCount) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetChatMembersCount) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ReqGetChatMembersCount) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetChatMembersCount struct {
	ChatMembersCount int32 `protobuf:"varint,1,opt,name=ChatMembersCount,proto3" json:"ChatMembersCount,omitempty"`
	ErrorCode        int32 `protobuf:"varint,2,opt,name=ErrorCode,proto3" json:"ErrorCode,omitempty"`
}

func (m *ReplyGetChatMembersCount) Reset()         { *m = ReplyGetChatMembersCount{} }
func (m *ReplyGetChatMembersCount) String() string { return proto.CompactTextString(m) }
func (*ReplyGetChatMembersCount) ProtoMessage()    {}
func (*ReplyGetChatMembersCount) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{192}
}

func (m *ReplyGetChatMembersCount) GetChatMembersCount() int32 {
	if m != nil {
		return m.ChatMembersCount
	}
	return 0
}

func (m *ReplyGetChatMembersCount) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 通过群Id 用户Id 获取群基本信息
type GetChatInfoReq struct {
	ChatId   int32  `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId   int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	RobotGet bool   `protobuf:"varint,3,opt,name=robot_get,json=robotGet,proto3" json:"robot_get,omitempty"`
	Dlog     *Debug `protobuf:"bytes,4,opt,name=Dlog" json:"Dlog,omitempty"`
}

func (m *GetChatInfoReq) Reset()                    { *m = GetChatInfoReq{} }
func (m *GetChatInfoReq) String() string            { return proto.CompactTextString(m) }
func (*GetChatInfoReq) ProtoMessage()               {}
func (*GetChatInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{193} }

func (m *GetChatInfoReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *GetChatInfoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetChatInfoReq) GetRobotGet() bool {
	if m != nil {
		return m.RobotGet
	}
	return false
}

func (m *GetChatInfoReq) GetDlog() *Debug {
	if m != nil {
		return m.Dlog
	}
	return nil
}

// 获取用户信息、群、超级群信息的请求
type GetUsersChatsReq struct {
	Userid        int32   `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	Users         []int32 `protobuf:"varint,2,rep,packed,name=users" json:"users,omitempty"`
	Chatid        []int32 `protobuf:"varint,3,rep,packed,name=chatid" json:"chatid,omitempty"`
	Channelid     []int32 `protobuf:"varint,4,rep,packed,name=channelid" json:"channelid,omitempty"`
	ProtocolLayer int32   `protobuf:"varint,5,opt,name=protocol_layer,json=protocolLayer,proto3" json:"protocol_layer,omitempty"`
	Dlog          *Debug  `protobuf:"bytes,6,opt,name=Dlog" json:"Dlog,omitempty"`
}

func (m *GetUsersChatsReq) Reset()                    { *m = GetUsersChatsReq{} }
func (m *GetUsersChatsReq) String() string            { return proto.CompactTextString(m) }
func (*GetUsersChatsReq) ProtoMessage()               {}
func (*GetUsersChatsReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{194} }

func (m *GetUsersChatsReq) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *GetUsersChatsReq) GetUsers() []int32 {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GetUsersChatsReq) GetChatid() []int32 {
	if m != nil {
		return m.Chatid
	}
	return nil
}

func (m *GetUsersChatsReq) GetChannelid() []int32 {
	if m != nil {
		return m.Channelid
	}
	return nil
}

func (m *GetUsersChatsReq) GetProtocolLayer() int32 {
	if m != nil {
		return m.ProtocolLayer
	}
	return 0
}

func (m *GetUsersChatsReq) GetDlog() *Debug {
	if m != nil {
		return m.Dlog
	}
	return nil
}

// 获取用户信息、群、超级群信息的返回
type GetUsersChatsResult struct {
	// repeated ChannelInfoBase channels = 1;
	// repeated GetChatInfoResp chats = 3;
	Channels   [][]byte       `protobuf:"bytes,1,rep,name=channels" json:"channels,omitempty"`
	Users      *UserInfoArray `protobuf:"bytes,2,opt,name=users" json:"users,omitempty"`
	Chats      [][]byte       `protobuf:"bytes,3,rep,name=chats" json:"chats,omitempty"`
	NoChats    []int32        `protobuf:"varint,4,rep,packed,name=no_chats,json=noChats" json:"no_chats,omitempty"`
	NoChans    []int32        `protobuf:"varint,5,rep,packed,name=no_chans,json=noChans" json:"no_chans,omitempty"`
	Resultcode ChatResultCode `protobuf:"varint,6,opt,name=resultcode,proto3,enum=imapigateway.ChatResultCode" json:"resultcode,omitempty"`
}

func (m *GetUsersChatsResult) Reset()         { *m = GetUsersChatsResult{} }
func (m *GetUsersChatsResult) String() string { return proto.CompactTextString(m) }
func (*GetUsersChatsResult) ProtoMessage()    {}
func (*GetUsersChatsResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{195}
}

func (m *GetUsersChatsResult) GetChannels() [][]byte {
	if m != nil {
		return m.Channels
	}
	return nil
}

func (m *GetUsersChatsResult) GetUsers() *UserInfoArray {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GetUsersChatsResult) GetChats() [][]byte {
	if m != nil {
		return m.Chats
	}
	return nil
}

func (m *GetUsersChatsResult) GetNoChats() []int32 {
	if m != nil {
		return m.NoChats
	}
	return nil
}

func (m *GetUsersChatsResult) GetNoChans() []int32 {
	if m != nil {
		return m.NoChans
	}
	return nil
}

func (m *GetUsersChatsResult) GetResultcode() ChatResultCode {
	if m != nil {
		return m.Resultcode
	}
	return ChatResultCode_Chat_RPC_OK
}

// 根据用户id获取用户ID
type GetUserInfoByIdReq struct {
	SelfId int32  `protobuf:"varint,1,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Debug  *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetUserInfoByIdReq) Reset()         { *m = GetUserInfoByIdReq{} }
func (m *GetUserInfoByIdReq) String() string { return proto.CompactTextString(m) }
func (*GetUserInfoByIdReq) ProtoMessage()    {}
func (*GetUserInfoByIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{196}
}

func (m *GetUserInfoByIdReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *GetUserInfoByIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetUserInfoByIdReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type GetUserInfoByIdArrReq struct {
	SelfId  int32   `protobuf:"varint,1,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
	UserIds []int32 `protobuf:"varint,2,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
	Debug   *Debug  `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetUserInfoByIdArrReq) Reset()         { *m = GetUserInfoByIdArrReq{} }
func (m *GetUserInfoByIdArrReq) String() string { return proto.CompactTextString(m) }
func (*GetUserInfoByIdArrReq) ProtoMessage()    {}
func (*GetUserInfoByIdArrReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{197}
}

func (m *GetUserInfoByIdArrReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *GetUserInfoByIdArrReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *GetUserInfoByIdArrReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 更新用户信息
type UpdateUserProfileReq struct {
	UserId    int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Flags     int32  `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	FirstName string `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName  string `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	About     string `protobuf:"bytes,5,opt,name=about,proto3" json:"about,omitempty"`
	Debug     *Debug `protobuf:"bytes,6,opt,name=debug" json:"debug,omitempty"`
}

func (m *UpdateUserProfileReq) Reset()         { *m = UpdateUserProfileReq{} }
func (m *UpdateUserProfileReq) String() string { return proto.CompactTextString(m) }
func (*UpdateUserProfileReq) ProtoMessage()    {}
func (*UpdateUserProfileReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{198}
}

func (m *UpdateUserProfileReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UpdateUserProfileReq) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UpdateUserProfileReq) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UpdateUserProfileReq) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UpdateUserProfileReq) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *UpdateUserProfileReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 更新用户昵称等的返回结果
type UpdateUserProfileResult struct {
	Uinfo     *UserInfo `protobuf:"bytes,1,opt,name=Uinfo" json:"Uinfo,omitempty"`
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *UpdateUserProfileResult) Reset()         { *m = UpdateUserProfileResult{} }
func (m *UpdateUserProfileResult) String() string { return proto.CompactTextString(m) }
func (*UpdateUserProfileResult) ProtoMessage()    {}
func (*UpdateUserProfileResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{199}
}

func (m *UpdateUserProfileResult) GetUinfo() *UserInfo {
	if m != nil {
		return m.Uinfo
	}
	return nil
}

func (m *UpdateUserProfileResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 根据用户电话号码来获取用户信息
type GetUserByphone struct {
	Phone string `protobuf:"bytes,1,opt,name=phone,proto3" json:"phone,omitempty"`
	Debug *Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetUserByphone) Reset()                    { *m = GetUserByphone{} }
func (m *GetUserByphone) String() string            { return proto.CompactTextString(m) }
func (*GetUserByphone) ProtoMessage()               {}
func (*GetUserByphone) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{200} }

func (m *GetUserByphone) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *GetUserByphone) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UpdateBotInfoSuppReq struct {
	UserId      int32  `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Placeholder string `protobuf:"bytes,2,opt,name=Placeholder,proto3" json:"Placeholder,omitempty"`
	Geo         bool   `protobuf:"varint,3,opt,name=geo,proto3" json:"geo,omitempty"`
	Debug       *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *UpdateBotInfoSuppReq) Reset()         { *m = UpdateBotInfoSuppReq{} }
func (m *UpdateBotInfoSuppReq) String() string { return proto.CompactTextString(m) }
func (*UpdateBotInfoSuppReq) ProtoMessage()    {}
func (*UpdateBotInfoSuppReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{201}
}

func (m *UpdateBotInfoSuppReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UpdateBotInfoSuppReq) GetPlaceholder() string {
	if m != nil {
		return m.Placeholder
	}
	return ""
}

func (m *UpdateBotInfoSuppReq) GetGeo() bool {
	if m != nil {
		return m.Geo
	}
	return false
}

func (m *UpdateBotInfoSuppReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UpdateBotInfoSuppResult struct {
	Errorcode ReErrCode `protobuf:"varint,1,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *UpdateBotInfoSuppResult) Reset()         { *m = UpdateBotInfoSuppResult{} }
func (m *UpdateBotInfoSuppResult) String() string { return proto.CompactTextString(m) }
func (*UpdateBotInfoSuppResult) ProtoMessage()    {}
func (*UpdateBotInfoSuppResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{202}
}

func (m *UpdateBotInfoSuppResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 更新机器人头像请求
type UpdateBotPicRequest struct {
	BotId int32  `protobuf:"varint,1,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	Photo []byte `protobuf:"bytes,2,opt,name=photo,proto3" json:"photo,omitempty"`
	Debug *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *UpdateBotPicRequest) Reset()         { *m = UpdateBotPicRequest{} }
func (m *UpdateBotPicRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateBotPicRequest) ProtoMessage()    {}
func (*UpdateBotPicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{203}
}

func (m *UpdateBotPicRequest) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

func (m *UpdateBotPicRequest) GetPhoto() []byte {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *UpdateBotPicRequest) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UpdateBotPicResult struct {
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *UpdateBotPicResult) Reset()         { *m = UpdateBotPicResult{} }
func (m *UpdateBotPicResult) String() string { return proto.CompactTextString(m) }
func (*UpdateBotPicResult) ProtoMessage()    {}
func (*UpdateBotPicResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{204}
}

func (m *UpdateBotPicResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 更新用户的username的请求
type UpdateuserNameReq struct {
	UserId   int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	UserName string `protobuf:"bytes,2,opt,name=userName,proto3" json:"userName,omitempty"`
	Debug    *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
	KeyId    int64  `protobuf:"varint,4,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *UpdateuserNameReq) Reset()                    { *m = UpdateuserNameReq{} }
func (m *UpdateuserNameReq) String() string            { return proto.CompactTextString(m) }
func (*UpdateuserNameReq) ProtoMessage()               {}
func (*UpdateuserNameReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{205} }

func (m *UpdateuserNameReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UpdateuserNameReq) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *UpdateuserNameReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *UpdateuserNameReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

// 更新用户的username的返回结果
type UpdateuserNameResult struct {
	Uinfo     *UserInfo `protobuf:"bytes,1,opt,name=Uinfo" json:"Uinfo,omitempty"`
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *UpdateuserNameResult) Reset()         { *m = UpdateuserNameResult{} }
func (m *UpdateuserNameResult) String() string { return proto.CompactTextString(m) }
func (*UpdateuserNameResult) ProtoMessage()    {}
func (*UpdateuserNameResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{206}
}

func (m *UpdateuserNameResult) GetUinfo() *UserInfo {
	if m != nil {
		return m.Uinfo
	}
	return nil
}

func (m *UpdateuserNameResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 注册指定用户的请求
type RegisterUserInfoResult struct {
	Uinfo     *UserInfo `protobuf:"bytes,1,opt,name=uinfo" json:"uinfo,omitempty"`
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *RegisterUserInfoResult) Reset()         { *m = RegisterUserInfoResult{} }
func (m *RegisterUserInfoResult) String() string { return proto.CompactTextString(m) }
func (*RegisterUserInfoResult) ProtoMessage()    {}
func (*RegisterUserInfoResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{207}
}

func (m *RegisterUserInfoResult) GetUinfo() *UserInfo {
	if m != nil {
		return m.Uinfo
	}
	return nil
}

func (m *RegisterUserInfoResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 删除账号的请求
type DeleteAccountByIdReq struct {
	UserId int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	DelId  int32  `protobuf:"varint,2,opt,name=del_id,json=delId,proto3" json:"del_id,omitempty"`
	Debug  *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *DeleteAccountByIdReq) Reset()         { *m = DeleteAccountByIdReq{} }
func (m *DeleteAccountByIdReq) String() string { return proto.CompactTextString(m) }
func (*DeleteAccountByIdReq) ProtoMessage()    {}
func (*DeleteAccountByIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{208}
}

func (m *DeleteAccountByIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteAccountByIdReq) GetDelId() int32 {
	if m != nil {
		return m.DelId
	}
	return 0
}

func (m *DeleteAccountByIdReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 删除账号的返回结果
type DelAccountResult struct {
	Errorcode ReErrCode `protobuf:"varint,1,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *DelAccountResult) Reset()                    { *m = DelAccountResult{} }
func (m *DelAccountResult) String() string            { return proto.CompactTextString(m) }
func (*DelAccountResult) ProtoMessage()               {}
func (*DelAccountResult) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{209} }

func (m *DelAccountResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 用户注册的请求结构
type SignUpReq struct {
	PhoneNumber    string `protobuf:"bytes,1,opt,name=PhoneNumber,proto3" json:"PhoneNumber,omitempty"`
	PhoneCodeHash  string `protobuf:"bytes,2,opt,name=PhoneCodeHash,proto3" json:"PhoneCodeHash,omitempty"`
	PhoneCode      string `protobuf:"bytes,3,opt,name=PhoneCode,proto3" json:"PhoneCode,omitempty"`
	KeyId          int64  `protobuf:"varint,5,opt,name=keyId,proto3" json:"keyId,omitempty"`
	FirstName      string `protobuf:"bytes,6,opt,name=FirstName,proto3" json:"FirstName,omitempty"`
	LastName       string `protobuf:"bytes,7,opt,name=LastName,proto3" json:"LastName,omitempty"`
	IsBot          bool   `protobuf:"varint,8,opt,name=is_bot,json=isBot,proto3" json:"is_bot,omitempty"`
	BotInfoVersion int32  `protobuf:"varint,9,opt,name=bot_info_version,json=botInfoVersion,proto3" json:"bot_info_version,omitempty"`
	BotChatHistory bool   `protobuf:"varint,10,opt,name=bot_chat_history,json=botChatHistory,proto3" json:"bot_chat_history,omitempty"`
	BotNoChats     bool   `protobuf:"varint,11,opt,name=bot_no_chats,json=botNoChats,proto3" json:"bot_no_chats,omitempty"`
	DcId           int32  `protobuf:"varint,12,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	Debug          *Debug `protobuf:"bytes,13,opt,name=debug" json:"debug,omitempty"`
	CountryCode    string `protobuf:"bytes,14,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	LocalPhone     string `protobuf:"bytes,15,opt,name=local_phone,json=localPhone,proto3" json:"local_phone,omitempty"`
}

func (m *SignUpReq) Reset()                    { *m = SignUpReq{} }
func (m *SignUpReq) String() string            { return proto.CompactTextString(m) }
func (*SignUpReq) ProtoMessage()               {}
func (*SignUpReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{210} }

func (m *SignUpReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SignUpReq) GetPhoneCodeHash() string {
	if m != nil {
		return m.PhoneCodeHash
	}
	return ""
}

func (m *SignUpReq) GetPhoneCode() string {
	if m != nil {
		return m.PhoneCode
	}
	return ""
}

func (m *SignUpReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SignUpReq) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *SignUpReq) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *SignUpReq) GetIsBot() bool {
	if m != nil {
		return m.IsBot
	}
	return false
}

func (m *SignUpReq) GetBotInfoVersion() int32 {
	if m != nil {
		return m.BotInfoVersion
	}
	return 0
}

func (m *SignUpReq) GetBotChatHistory() bool {
	if m != nil {
		return m.BotChatHistory
	}
	return false
}

func (m *SignUpReq) GetBotNoChats() bool {
	if m != nil {
		return m.BotNoChats
	}
	return false
}

func (m *SignUpReq) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *SignUpReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SignUpReq) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *SignUpReq) GetLocalPhone() string {
	if m != nil {
		return m.LocalPhone
	}
	return ""
}

type AuthSignUpResult struct {
	Code     AuthSignUpResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imapigateway.AuthSignUpResult_ResultCode" json:"code,omitempty"`
	UserInfo *UserInfo                   `protobuf:"bytes,2,opt,name=userInfo" json:"userInfo,omitempty"`
}

func (m *AuthSignUpResult) Reset()                    { *m = AuthSignUpResult{} }
func (m *AuthSignUpResult) String() string            { return proto.CompactTextString(m) }
func (*AuthSignUpResult) ProtoMessage()               {}
func (*AuthSignUpResult) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{211} }

func (m *AuthSignUpResult) GetCode() AuthSignUpResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return AuthSignUpResult_Success
}

func (m *AuthSignUpResult) GetUserInfo() *UserInfo {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

// getfull user的请求
type GetFullUserReq struct {
	SelfId     int32  `protobuf:"varint,1,opt,name=selfId,proto3" json:"selfId,omitempty"`
	UserId     int32  `protobuf:"varint,2,opt,name=UserId,proto3" json:"UserId,omitempty"`
	AccessHash int64  `protobuf:"varint,3,opt,name=AccessHash,proto3" json:"AccessHash,omitempty"`
	Debug      *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetFullUserReq) Reset()                    { *m = GetFullUserReq{} }
func (m *GetFullUserReq) String() string            { return proto.CompactTextString(m) }
func (*GetFullUserReq) ProtoMessage()               {}
func (*GetFullUserReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{212} }

func (m *GetFullUserReq) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *GetFullUserReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetFullUserReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GetFullUserReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// getfull user的请求
type GetFullUserResult struct {
	Uinfo               *UserInfo `protobuf:"bytes,1,opt,name=uinfo" json:"uinfo,omitempty"`
	Isblocked           bool      `protobuf:"varint,2,opt,name=isblocked,proto3" json:"isblocked,omitempty"`
	PhoneCallsPrivate   bool      `protobuf:"varint,3,opt,name=phone_calls_private,json=phoneCallsPrivate,proto3" json:"phone_calls_private,omitempty"`
	PhoneCallsAvailable bool      `protobuf:"varint,4,opt,name=phone_calls_available,json=phoneCallsAvailable,proto3" json:"phone_calls_available,omitempty"`
	About               string    `protobuf:"bytes,5,opt,name=about,proto3" json:"about,omitempty"`
	CommonChat          int32     `protobuf:"varint,6,opt,name=common_chat,json=commonChat,proto3" json:"common_chat,omitempty"`
	Extend              string    `protobuf:"bytes,7,opt,name=extend,proto3" json:"extend,omitempty"`
	Errorcode           ReErrCode `protobuf:"varint,8,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *GetFullUserResult) Reset()                    { *m = GetFullUserResult{} }
func (m *GetFullUserResult) String() string            { return proto.CompactTextString(m) }
func (*GetFullUserResult) ProtoMessage()               {}
func (*GetFullUserResult) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{213} }

func (m *GetFullUserResult) GetUinfo() *UserInfo {
	if m != nil {
		return m.Uinfo
	}
	return nil
}

func (m *GetFullUserResult) GetIsblocked() bool {
	if m != nil {
		return m.Isblocked
	}
	return false
}

func (m *GetFullUserResult) GetPhoneCallsPrivate() bool {
	if m != nil {
		return m.PhoneCallsPrivate
	}
	return false
}

func (m *GetFullUserResult) GetPhoneCallsAvailable() bool {
	if m != nil {
		return m.PhoneCallsAvailable
	}
	return false
}

func (m *GetFullUserResult) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *GetFullUserResult) GetCommonChat() int32 {
	if m != nil {
		return m.CommonChat
	}
	return 0
}

func (m *GetFullUserResult) GetExtend() string {
	if m != nil {
		return m.Extend
	}
	return ""
}

func (m *GetFullUserResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

// 根据用户userName来获取用户基本信息
type GetUserByUsername struct {
	SelfId   int32  `protobuf:"varint,1,opt,name=self_id,json=selfId,proto3" json:"self_id,omitempty"`
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Debug    *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetUserByUsername) Reset()                    { *m = GetUserByUsername{} }
func (m *GetUserByUsername) String() string            { return proto.CompactTextString(m) }
func (*GetUserByUsername) ProtoMessage()               {}
func (*GetUserByUsername) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{214} }

func (m *GetUserByUsername) GetSelfId() int32 {
	if m != nil {
		return m.SelfId
	}
	return 0
}

func (m *GetUserByUsername) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GetUserByUsername) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 获取群的完整信息
type ReqGetFullChat struct {
	Fromid int32  `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Chatid int32  `protobuf:"varint,2,opt,name=chatid,proto3" json:"chatid,omitempty"`
	Debug  *Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetFullChat) Reset()                    { *m = ReqGetFullChat{} }
func (m *ReqGetFullChat) String() string            { return proto.CompactTextString(m) }
func (*ReqGetFullChat) ProtoMessage()               {}
func (*ReqGetFullChat) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{215} }

func (m *ReqGetFullChat) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqGetFullChat) GetChatid() int32 {
	if m != nil {
		return m.Chatid
	}
	return 0
}

func (m *ReqGetFullChat) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetFullChat struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyGetFullChat) Reset()                    { *m = ReplyGetFullChat{} }
func (m *ReplyGetFullChat) String() string            { return proto.CompactTextString(m) }
func (*ReplyGetFullChat) ProtoMessage()               {}
func (*ReplyGetFullChat) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{216} }

func (m *ReplyGetFullChat) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyGetFullChat) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 退出超级群
type ReqLeaveChannel struct {
	ChannelId int32  `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	UserId    int32  `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	FromKeyid int64  `protobuf:"varint,3,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqLeaveChannel) Reset()                    { *m = ReqLeaveChannel{} }
func (m *ReqLeaveChannel) String() string            { return proto.CompactTextString(m) }
func (*ReqLeaveChannel) ProtoMessage()               {}
func (*ReqLeaveChannel) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{217} }

func (m *ReqLeaveChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqLeaveChannel) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqLeaveChannel) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqLeaveChannel) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 发送媒体
type ReqSendMedia struct {
	Fromid       int32    `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Flags        int32    `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Silent       bool     `protobuf:"varint,3,opt,name=silent,proto3" json:"silent,omitempty"`
	Background   bool     `protobuf:"varint,4,opt,name=background,proto3" json:"background,omitempty"`
	ClearDraft   bool     `protobuf:"varint,5,opt,name=clear_draft,json=clearDraft,proto3" json:"clear_draft,omitempty"`
	Peer         []byte   `protobuf:"bytes,6,opt,name=peer,proto3" json:"peer,omitempty"`
	ReplyToMsgId int32    `protobuf:"varint,7,opt,name=reply_to_msg_id,json=replyToMsgId,proto3" json:"reply_to_msg_id,omitempty"`
	Media        []byte   `protobuf:"bytes,8,opt,name=media,proto3" json:"media,omitempty"`
	MultiMedia   [][]byte `protobuf:"bytes,9,rep,name=multi_media,json=multiMedia" json:"multi_media,omitempty"`
	RandomId     int64    `protobuf:"varint,10,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	ReplyMarkup  []byte   `protobuf:"bytes,11,opt,name=reply_markup,json=replyMarkup,proto3" json:"reply_markup,omitempty"`
	Newfileid    int64    `protobuf:"varint,12,opt,name=newfileid,proto3" json:"newfileid,omitempty"`
	FromkeyId    uint64   `protobuf:"varint,13,opt,name=fromkey_id,json=fromkeyId,proto3" json:"fromkey_id,omitempty"`
	Chatmeber    []int32  `protobuf:"varint,14,rep,packed,name=chatmeber" json:"chatmeber,omitempty"`
	Debug        *Debug   `protobuf:"bytes,15,opt,name=debug" json:"debug,omitempty"`
	ViaBotId     int32    `protobuf:"varint,16,opt,name=via_bot_id,json=viaBotId,proto3" json:"via_bot_id,omitempty"`
}

func (m *ReqSendMedia) Reset()                    { *m = ReqSendMedia{} }
func (m *ReqSendMedia) String() string            { return proto.CompactTextString(m) }
func (*ReqSendMedia) ProtoMessage()               {}
func (*ReqSendMedia) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{218} }

func (m *ReqSendMedia) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqSendMedia) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ReqSendMedia) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *ReqSendMedia) GetBackground() bool {
	if m != nil {
		return m.Background
	}
	return false
}

func (m *ReqSendMedia) GetClearDraft() bool {
	if m != nil {
		return m.ClearDraft
	}
	return false
}

func (m *ReqSendMedia) GetPeer() []byte {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *ReqSendMedia) GetReplyToMsgId() int32 {
	if m != nil {
		return m.ReplyToMsgId
	}
	return 0
}

func (m *ReqSendMedia) GetMedia() []byte {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *ReqSendMedia) GetMultiMedia() [][]byte {
	if m != nil {
		return m.MultiMedia
	}
	return nil
}

func (m *ReqSendMedia) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *ReqSendMedia) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *ReqSendMedia) GetNewfileid() int64 {
	if m != nil {
		return m.Newfileid
	}
	return 0
}

func (m *ReqSendMedia) GetFromkeyId() uint64 {
	if m != nil {
		return m.FromkeyId
	}
	return 0
}

func (m *ReqSendMedia) GetChatmeber() []int32 {
	if m != nil {
		return m.Chatmeber
	}
	return nil
}

func (m *ReqSendMedia) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *ReqSendMedia) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

// 状态返回
type ReplyResult struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyResult) Reset()                    { *m = ReplyResult{} }
func (m *ReplyResult) String() string            { return proto.CompactTextString(m) }
func (*ReplyResult) ProtoMessage()               {}
func (*ReplyResult) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{219} }

func (m *ReplyResult) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyResult) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 编辑群名字
type ReqEditChatTitle struct {
	Fromid    int32  `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Chatid    int32  `protobuf:"varint,2,opt,name=chatid,proto3" json:"chatid,omitempty"`
	Title     string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	FromKeyid uint64 `protobuf:"varint,4,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqEditChatTitle) Reset()                    { *m = ReqEditChatTitle{} }
func (m *ReqEditChatTitle) String() string            { return proto.CompactTextString(m) }
func (*ReqEditChatTitle) ProtoMessage()               {}
func (*ReqEditChatTitle) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{220} }

func (m *ReqEditChatTitle) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqEditChatTitle) GetChatid() int32 {
	if m != nil {
		return m.Chatid
	}
	return 0
}

func (m *ReqEditChatTitle) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ReqEditChatTitle) GetFromKeyid() uint64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqEditChatTitle) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyEditChatTitle struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,5,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyEditChatTitle) Reset()         { *m = ReplyEditChatTitle{} }
func (m *ReplyEditChatTitle) String() string { return proto.CompactTextString(m) }
func (*ReplyEditChatTitle) ProtoMessage()    {}
func (*ReplyEditChatTitle) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{221}
}

func (m *ReplyEditChatTitle) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyEditChatTitle) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 获取一个sticker下面的所有贴图信息的请求
type GetStickerSetPackDcInfosReq struct {
	Id    int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Debug *Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetStickerSetPackDcInfosReq) Reset()         { *m = GetStickerSetPackDcInfosReq{} }
func (m *GetStickerSetPackDcInfosReq) String() string { return proto.CompactTextString(m) }
func (*GetStickerSetPackDcInfosReq) ProtoMessage()    {}
func (*GetStickerSetPackDcInfosReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{222}
}

func (m *GetStickerSetPackDcInfosReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GetStickerSetPackDcInfosReq) GetDebug() *Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 获取一个sticker下面的所有贴图信息的返回
type GetStickerSetPackDcInfosResult struct {
	StPDcInfo []*StickerPackDocumentInfo `protobuf:"bytes,1,rep,name=StPDcInfo" json:"StPDcInfo,omitempty"`
}

func (m *GetStickerSetPackDcInfosResult) Reset()         { *m = GetStickerSetPackDcInfosResult{} }
func (m *GetStickerSetPackDcInfosResult) String() string { return proto.CompactTextString(m) }
func (*GetStickerSetPackDcInfosResult) ProtoMessage()    {}
func (*GetStickerSetPackDcInfosResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{223}
}

func (m *GetStickerSetPackDcInfosResult) GetStPDcInfo() []*StickerPackDocumentInfo {
	if m != nil {
		return m.StPDcInfo
	}
	return nil
}

// sticker集合里面具体内容
// 存储单个sticker内容请求
type StickerPackDocumentBase struct {
	AttributesStikerSetId         int64  `protobuf:"varint,1,opt,name=attributes_stiker_set_id,json=attributesStikerSetId,proto3" json:"attributes_stiker_set_id,omitempty"`
	DocumentId                    uint64 `protobuf:"varint,2,opt,name=document_id,json=documentId,proto3" json:"document_id,omitempty"`
	AccessHash                    int64  `protobuf:"varint,3,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	MimeType                      string `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	Size_                         int32  `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	Thumb                         string `protobuf:"bytes,6,opt,name=thumb,proto3" json:"thumb,omitempty"`
	DcId                          int32  `protobuf:"varint,7,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	Date                          int32  `protobuf:"varint,8,opt,name=date,proto3" json:"date,omitempty"`
	AttributesImageSizeW          int32  `protobuf:"varint,9,opt,name=attributes_image_size_w,json=attributesImageSizeW,proto3" json:"attributes_image_size_w,omitempty"`
	AttributesImageSizeH          int32  `protobuf:"varint,10,opt,name=attributes_image_size_h,json=attributesImageSizeH,proto3" json:"attributes_image_size_h,omitempty"`
	AttributesStikerAlt           string `protobuf:"bytes,11,opt,name=attributes_stiker_alt,json=attributesStikerAlt,proto3" json:"attributes_stiker_alt,omitempty"`
	AttributesStikerSetAccessHash int64  `protobuf:"varint,12,opt,name=attributes_stiker_set_access_hash,json=attributesStikerSetAccessHash,proto3" json:"attributes_stiker_set_access_hash,omitempty"`
	AttributesFileName            string `protobuf:"bytes,13,opt,name=attributes_file_name,json=attributesFileName,proto3" json:"attributes_file_name,omitempty"`
}

func (m *StickerPackDocumentBase) Reset()         { *m = StickerPackDocumentBase{} }
func (m *StickerPackDocumentBase) String() string { return proto.CompactTextString(m) }
func (*StickerPackDocumentBase) ProtoMessage()    {}
func (*StickerPackDocumentBase) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{224}
}

func (m *StickerPackDocumentBase) GetAttributesStikerSetId() int64 {
	if m != nil {
		return m.AttributesStikerSetId
	}
	return 0
}

func (m *StickerPackDocumentBase) GetDocumentId() uint64 {
	if m != nil {
		return m.DocumentId
	}
	return 0
}

func (m *StickerPackDocumentBase) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *StickerPackDocumentBase) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *StickerPackDocumentBase) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *StickerPackDocumentBase) GetThumb() string {
	if m != nil {
		return m.Thumb
	}
	return ""
}

func (m *StickerPackDocumentBase) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *StickerPackDocumentBase) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *StickerPackDocumentBase) GetAttributesImageSizeW() int32 {
	if m != nil {
		return m.AttributesImageSizeW
	}
	return 0
}

func (m *StickerPackDocumentBase) GetAttributesImageSizeH() int32 {
	if m != nil {
		return m.AttributesImageSizeH
	}
	return 0
}

func (m *StickerPackDocumentBase) GetAttributesStikerAlt() string {
	if m != nil {
		return m.AttributesStikerAlt
	}
	return ""
}

func (m *StickerPackDocumentBase) GetAttributesStikerSetAccessHash() int64 {
	if m != nil {
		return m.AttributesStikerSetAccessHash
	}
	return 0
}

func (m *StickerPackDocumentBase) GetAttributesFileName() string {
	if m != nil {
		return m.AttributesFileName
	}
	return ""
}

type StickerPackDocumentInfo struct {
	Id       int32                    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	InfoBase *StickerPackDocumentBase `protobuf:"bytes,2,opt,name=infoBase" json:"infoBase,omitempty"`
}

func (m *StickerPackDocumentInfo) Reset()         { *m = StickerPackDocumentInfo{} }
func (m *StickerPackDocumentInfo) String() string { return proto.CompactTextString(m) }
func (*StickerPackDocumentInfo) ProtoMessage()    {}
func (*StickerPackDocumentInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{225}
}

func (m *StickerPackDocumentInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *StickerPackDocumentInfo) GetInfoBase() *StickerPackDocumentBase {
	if m != nil {
		return m.InfoBase
	}
	return nil
}

type GetUserInfoByIdArrResult struct {
	Uinfo     []*UserInfo `protobuf:"bytes,1,rep,name=Uinfo" json:"Uinfo,omitempty"`
	Errorcode ReErrCode   `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *GetUserInfoByIdArrResult) Reset()         { *m = GetUserInfoByIdArrResult{} }
func (m *GetUserInfoByIdArrResult) String() string { return proto.CompactTextString(m) }
func (*GetUserInfoByIdArrResult) ProtoMessage()    {}
func (*GetUserInfoByIdArrResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{226}
}

func (m *GetUserInfoByIdArrResult) GetUinfo() []*UserInfo {
	if m != nil {
		return m.Uinfo
	}
	return nil
}

func (m *GetUserInfoByIdArrResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

type SetBotVerifiedReq struct {
	UserId   int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Verified bool  `protobuf:"varint,2,opt,name=verified,proto3" json:"verified,omitempty"`
}

func (m *SetBotVerifiedReq) Reset()                    { *m = SetBotVerifiedReq{} }
func (m *SetBotVerifiedReq) String() string            { return proto.CompactTextString(m) }
func (*SetBotVerifiedReq) ProtoMessage()               {}
func (*SetBotVerifiedReq) Descriptor() ([]byte, []int) { return fileDescriptorImapigateway, []int{227} }

func (m *SetBotVerifiedReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetBotVerifiedReq) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

type SetBotVerifiedReply struct {
	Errorcode ReErrCode `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *SetBotVerifiedReply) Reset()         { *m = SetBotVerifiedReply{} }
func (m *SetBotVerifiedReply) String() string { return proto.CompactTextString(m) }
func (*SetBotVerifiedReply) ProtoMessage()    {}
func (*SetBotVerifiedReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{228}
}

func (m *SetBotVerifiedReply) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

type ContactsGetCommonContactsReq struct {
	UserIds []int32 `protobuf:"varint,1,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
}

func (m *ContactsGetCommonContactsReq) Reset()         { *m = ContactsGetCommonContactsReq{} }
func (m *ContactsGetCommonContactsReq) String() string { return proto.CompactTextString(m) }
func (*ContactsGetCommonContactsReq) ProtoMessage()    {}
func (*ContactsGetCommonContactsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{229}
}

func (m *ContactsGetCommonContactsReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type ContactsGetCommonContactsResult struct {
	UserInfos []*UserInfo `protobuf:"bytes,1,rep,name=user_infos,json=userInfos" json:"user_infos,omitempty"`
	Errorcode ReErrCode   `protobuf:"varint,2,opt,name=Errorcode,proto3,enum=imapigateway.ReErrCode" json:"Errorcode,omitempty"`
}

func (m *ContactsGetCommonContactsResult) Reset()         { *m = ContactsGetCommonContactsResult{} }
func (m *ContactsGetCommonContactsResult) String() string { return proto.CompactTextString(m) }
func (*ContactsGetCommonContactsResult) ProtoMessage()    {}
func (*ContactsGetCommonContactsResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImapigateway, []int{230}
}

func (m *ContactsGetCommonContactsResult) GetUserInfos() []*UserInfo {
	if m != nil {
		return m.UserInfos
	}
	return nil
}

func (m *ContactsGetCommonContactsResult) GetErrorcode() ReErrCode {
	if m != nil {
		return m.Errorcode
	}
	return ReErrCode_Success
}

func init() {
	proto.RegisterType((*GetGroupUserIdsReq)(nil), "imapigateway.GetGroupUserIdsReq")
	proto.RegisterType((*GetGroupUserIdsRsp)(nil), "imapigateway.GetGroupUserIdsRsp")
	proto.RegisterType((*LiveStartReq)(nil), "imapigateway.LiveStartReq")
	proto.RegisterType((*LiveStartRsp)(nil), "imapigateway.LiveStartRsp")
	proto.RegisterType((*LiveStopReq)(nil), "imapigateway.LiveStopReq")
	proto.RegisterType((*LiveStopRsp)(nil), "imapigateway.LiveStopRsp")
	proto.RegisterType((*GetLiveInviteUrlReq)(nil), "imapigateway.GetLiveInviteUrlReq")
	proto.RegisterType((*GetLiveInviteUrlRsp)(nil), "imapigateway.GetLiveInviteUrlRsp")
	proto.RegisterType((*EditLiveInfoReq)(nil), "imapigateway.EditLiveInfoReq")
	proto.RegisterType((*EditLiveInfoRsp)(nil), "imapigateway.EditLiveInfoRsp")
	proto.RegisterType((*GroupLiveCheckReq)(nil), "imapigateway.GroupLiveCheckReq")
	proto.RegisterType((*GroupLiveCheckRsp)(nil), "imapigateway.GroupLiveCheckRsp")
	proto.RegisterType((*GetLiveInviteCntReq)(nil), "imapigateway.GetLiveInviteCntReq")
	proto.RegisterType((*GetLiveInviteCntRsp)(nil), "imapigateway.GetLiveInviteCntRsp")
	proto.RegisterType((*CheckUserInGroupReq)(nil), "imapigateway.CheckUserInGroupReq")
	proto.RegisterType((*CheckUserInGroupRsp)(nil), "imapigateway.CheckUserInGroupRsp")
	proto.RegisterType((*LivePushReq)(nil), "imapigateway.LivePushReq")
	proto.RegisterType((*LivePushResult)(nil), "imapigateway.LivePushResult")
	proto.RegisterType((*ReqKickFromChannel)(nil), "imapigateway.ReqKickFromChannel")
	proto.RegisterType((*CheckUserNameReq)(nil), "imapigateway.CheckUserNameReq")
	proto.RegisterType((*CheckUserNameResp)(nil), "imapigateway.CheckUserNameResp")
	proto.RegisterType((*ReqSendCodeMsg)(nil), "imapigateway.ReqSendCodeMsg")
	proto.RegisterType((*ChannelBannedRights)(nil), "imapigateway.ChannelBannedRights")
	proto.RegisterType((*ReqEditBanChannelUser)(nil), "imapigateway.ReqEditBanChannelUser")
	proto.RegisterType((*ReqEditEveryoneQuiet)(nil), "imapigateway.ReqEditEveryoneQuiet")
	proto.RegisterType((*GetChannelUserInfoReq)(nil), "imapigateway.GetChannelUserInfoReq")
	proto.RegisterType((*GetChannelUserInfoResp)(nil), "imapigateway.GetChannelUserInfoResp")
	proto.RegisterType((*CheckIsSelfContactReq)(nil), "imapigateway.CheckIsSelfContactReq")
	proto.RegisterType((*CheckIsSelfContactResult)(nil), "imapigateway.CheckIsSelfContactResult")
	proto.RegisterType((*MomentFollowReq)(nil), "imapigateway.MomentFollowReq")
	proto.RegisterType((*MomentFollowResp)(nil), "imapigateway.MomentFollowResp")
	proto.RegisterType((*MomentData)(nil), "imapigateway.MomentData")
	proto.RegisterType((*SysNotifyData)(nil), "imapigateway.SysNotifyData")
	proto.RegisterType((*NotifyMedia)(nil), "imapigateway.NotifyMedia")
	proto.RegisterType((*NotifyText)(nil), "imapigateway.NotifyText")
	proto.RegisterType((*SendMediaSysNotifyReq)(nil), "imapigateway.SendMediaSysNotifyReq")
	proto.RegisterType((*FailUser)(nil), "imapigateway.FailUser")
	proto.RegisterType((*SucceedUser)(nil), "imapigateway.SucceedUser")
	proto.RegisterType((*SendMediaSysNotifyResult)(nil), "imapigateway.SendMediaSysNotifyResult")
	proto.RegisterType((*SearchUserByNicknameReq)(nil), "imapigateway.SearchUserByNicknameReq")
	proto.RegisterType((*SearchUserByNicknameResult)(nil), "imapigateway.SearchUserByNicknameResult")
	proto.RegisterType((*Entity)(nil), "imapigateway.Entity")
	proto.RegisterType((*MomentNotifyData)(nil), "imapigateway.MomentNotifyData")
	proto.RegisterType((*MomentNotifyReq)(nil), "imapigateway.MomentNotifyReq")
	proto.RegisterType((*MomentNotifyResult)(nil), "imapigateway.MomentNotifyResult")
	proto.RegisterType((*CheckIsMuteContactReq)(nil), "imapigateway.CheckIsMuteContactReq")
	proto.RegisterType((*CheckIsMuteContactResult)(nil), "imapigateway.CheckIsMuteContactResult")
	proto.RegisterType((*ContactInfo)(nil), "imapigateway.contactInfo")
	proto.RegisterType((*ContatsGetContactsReq)(nil), "imapigateway.ContatsGetContactsReq")
	proto.RegisterType((*ContatsGetContactsResult)(nil), "imapigateway.ContatsGetContactsResult")
	proto.RegisterType((*MomentState)(nil), "imapigateway.MomentState")
	proto.RegisterType((*ReqUpdateMoments)(nil), "imapigateway.ReqUpdateMoments")
	proto.RegisterType((*ResUpdateMoments)(nil), "imapigateway.ResUpdateMoments")
	proto.RegisterType((*ReqIntegralUniversalBusiness)(nil), "imapigateway.ReqIntegralUniversalBusiness")
	proto.RegisterType((*ReplyIntegralUniversalBusiness)(nil), "imapigateway.ReplyIntegralUniversalBusiness")
	proto.RegisterType((*OtherTransReq)(nil), "imapigateway.OtherTransReq")
	proto.RegisterType((*OtherTransResp)(nil), "imapigateway.OtherTransResp")
	proto.RegisterType((*SetUserDetailReq)(nil), "imapigateway.SetUserDetailReq")
	proto.RegisterType((*SetUserDetailResult)(nil), "imapigateway.SetUserDetailResult")
	proto.RegisterType((*GetUserByUsernameReq)(nil), "imapigateway.GetUserByUsernameReq")
	proto.RegisterType((*GetUserInfoResult)(nil), "imapigateway.GetUserInfoResult")
	proto.RegisterType((*SendGameRedReq)(nil), "imapigateway.SendGameRedReq")
	proto.RegisterType((*QryGameRdpReq)(nil), "imapigateway.QryGameRdpReq")
	proto.RegisterType((*RcvGameRedReq)(nil), "imapigateway.RcvGameRedReq")
	proto.RegisterType((*GameRedResp)(nil), "imapigateway.GameRedResp")
	proto.RegisterType((*SendRDPReq)(nil), "imapigateway.SendRDPReq")
	proto.RegisterType((*SendRDPResp)(nil), "imapigateway.SendRDPResp")
	proto.RegisterType((*CheckRDPReq)(nil), "imapigateway.CheckRDPReq")
	proto.RegisterType((*CheckRDPResp)(nil), "imapigateway.CheckRDPResp")
	proto.RegisterType((*ReceiveRDPReq)(nil), "imapigateway.ReceiveRDPReq")
	proto.RegisterType((*ReceiveRDPResp)(nil), "imapigateway.ReceiveRDPResp")
	proto.RegisterType((*ReplyEditChannelAbout)(nil), "imapigateway.ReplyEditChannelAbout")
	proto.RegisterType((*ReplyEditChannelTitle)(nil), "imapigateway.ReplyEditChannelTitle")
	proto.RegisterType((*BotUpdateInfo)(nil), "imapigateway.BotUpdateInfo")
	proto.RegisterType((*BotUpdateInfoResult)(nil), "imapigateway.BotUpdateInfoResult")
	proto.RegisterType((*ReplyUpdatePinnedChannelMessage)(nil), "imapigateway.ReplyUpdatePinnedChannelMessage")
	proto.RegisterType((*ReplyLeaveChannel)(nil), "imapigateway.ReplyLeaveChannel")
	proto.RegisterType((*ReqGetAllChats)(nil), "imapigateway.ReqGetAllChats")
	proto.RegisterType((*ReplyGetAllChats)(nil), "imapigateway.ReplyGetAllChats")
	proto.RegisterType((*ReqGetchannelDifference)(nil), "imapigateway.ReqGetchannelDifference")
	proto.RegisterType((*ReplyChannelDiffCommon)(nil), "imapigateway.ReplyChannelDiffCommon")
	proto.RegisterType((*ReqFullchannel)(nil), "imapigateway.ReqFullchannel")
	proto.RegisterType((*ReplyFullChannel)(nil), "imapigateway.ReplyFullChannel")
	proto.RegisterType((*ReqDeleteMessages)(nil), "imapigateway.ReqDeleteMessages")
	proto.RegisterType((*ReplyDeleteMessages)(nil), "imapigateway.ReplyDeleteMessages")
	proto.RegisterType((*RegisterUserInfoReq)(nil), "imapigateway.RegisterUserInfoReq")
	proto.RegisterType((*ReqGetFullChannel)(nil), "imapigateway.ReqGetFullChannel")
	proto.RegisterType((*ReqGetParticipants)(nil), "imapigateway.ReqGetParticipants")
	proto.RegisterType((*ReqUpdatePinnedChannelMessage)(nil), "imapigateway.ReqUpdatePinnedChannelMessage")
	proto.RegisterType((*ReqEditChannelAbout)(nil), "imapigateway.ReqEditChannelAbout")
	proto.RegisterType((*ReqEditChannelTitle)(nil), "imapigateway.ReqEditChannelTitle")
	proto.RegisterType((*ReplyChannelData)(nil), "imapigateway.ReplyChannelData")
	proto.RegisterType((*ReqDelManualBlockList)(nil), "imapigateway.ReqDelManualBlockList")
	proto.RegisterType((*ReqSetManualBlockList)(nil), "imapigateway.ReqSetManualBlockList")
	proto.RegisterType((*BlockUser)(nil), "imapigateway.BlockUser")
	proto.RegisterType((*ManualBlockReplyData)(nil), "imapigateway.ManualBlockReplyData")
	proto.RegisterType((*StoreShopStickerSetDocumentsReq)(nil), "imapigateway.StoreShopStickerSetDocumentsReq")
	proto.RegisterType((*StoreShopStickerSetDocumentsResult)(nil), "imapigateway.StoreShopStickerSetDocumentsResult")
	proto.RegisterType((*AuthorStickerSet)(nil), "imapigateway.AuthorStickerSet")
	proto.RegisterType((*GetAuthorAllStickerSetReq)(nil), "imapigateway.GetAuthorAllStickerSetReq")
	proto.RegisterType((*GetAuthorAllStickerSetResult)(nil), "imapigateway.GetAuthorAllStickerSetResult")
	proto.RegisterType((*DeleteStickerPackDocumentReq)(nil), "imapigateway.DeleteStickerPackDocumentReq")
	proto.RegisterType((*DeleteStickerPackDocumentResult)(nil), "imapigateway.DeleteStickerPackDocumentResult")
	proto.RegisterType((*GetStickerSetInfoReq)(nil), "imapigateway.GetStickerSetInfoReq")
	proto.RegisterType((*StickerSetInfo)(nil), "imapigateway.StickerSetInfo")
	proto.RegisterType((*GetStickerSetInfoResult)(nil), "imapigateway.GetStickerSetInfoResult")
	proto.RegisterType((*DeleteStickerSetReq)(nil), "imapigateway.DeleteStickerSetReq")
	proto.RegisterType((*DeleteStickerSetResult)(nil), "imapigateway.DeleteStickerSetResult")
	proto.RegisterType((*StoreUserStickerSetReq)(nil), "imapigateway.StoreUserStickerSetReq")
	proto.RegisterType((*StoreUserStickerSetResult)(nil), "imapigateway.StoreUserStickerSetResult")
	proto.RegisterType((*StoreStickerPackDcReq)(nil), "imapigateway.StoreStickerPackDcReq")
	proto.RegisterType((*StoreStickerPackDcResult)(nil), "imapigateway.StoreStickerPackDcResult")
	proto.RegisterType((*StoreShopStickerSetReq)(nil), "imapigateway.StoreShopStickerSetReq")
	proto.RegisterType((*StoreShopStickerSetResult)(nil), "imapigateway.StoreShopStickerSetResult")
	proto.RegisterType((*ResizeRequest)(nil), "imapigateway.ResizeRequest")
	proto.RegisterType((*ResizeReply)(nil), "imapigateway.ResizeReply")
	proto.RegisterType((*ConstraintRequest)(nil), "imapigateway.ConstraintRequest")
	proto.RegisterType((*ConstraintReply)(nil), "imapigateway.ConstraintReply")
	proto.RegisterType((*CompressImageRequest)(nil), "imapigateway.CompressImageRequest")
	proto.RegisterType((*CompressImageReply)(nil), "imapigateway.CompressImageReply")
	proto.RegisterType((*VideoPreviewRequest)(nil), "imapigateway.VideoPreviewRequest")
	proto.RegisterType((*VideoPreviewReply)(nil), "imapigateway.VideoPreviewReply")
	proto.RegisterType((*AudioPreviewRequest)(nil), "imapigateway.AudioPreviewRequest")
	proto.RegisterType((*AudioPreviewReply)(nil), "imapigateway.AudioPreviewReply")
	proto.RegisterType((*ReqParticipants)(nil), "imapigateway.ReqParticipants")
	proto.RegisterType((*ReplyParticipants)(nil), "imapigateway.ReplyParticipants")
	proto.RegisterType((*ReqCreateChat)(nil), "imapigateway.ReqCreateChat")
	proto.RegisterType((*ReplyCreateChat)(nil), "imapigateway.ReplyCreateChat")
	proto.RegisterType((*ReqMigrateChat)(nil), "imapigateway.ReqMigrateChat")
	proto.RegisterType((*ReplyMigrateChat)(nil), "imapigateway.ReplyMigrateChat")
	proto.RegisterType((*ReqJoinChannel)(nil), "imapigateway.ReqJoinChannel")
	proto.RegisterType((*ReplyJoinChannel)(nil), "imapigateway.ReplyJoinChannel")
	proto.RegisterType((*ReqChangeGroupAndChannelCrator)(nil), "imapigateway.ReqChangeGroupAndChannelCrator")
	proto.RegisterType((*ReplyChangeGroupAndChannelCrator)(nil), "imapigateway.ReplyChangeGroupAndChannelCrator")
	proto.RegisterType((*ReqBotCallMessageMedia)(nil), "imapigateway.ReqBotCallMessageMedia")
	proto.RegisterType((*RequestDialog)(nil), "imapigateway.RequestDialog")
	proto.RegisterType((*ReplyDialog)(nil), "imapigateway.ReplyDialog")
	proto.RegisterType((*UserScore)(nil), "imapigateway.UserScore")
	proto.RegisterType((*ReqSetGameScore)(nil), "imapigateway.ReqSetGameScore")
	proto.RegisterType((*ReplySetGameScore)(nil), "imapigateway.ReplySetGameScore")
	proto.RegisterType((*ReplyBanChannelUser)(nil), "imapigateway.ReplyBanChannelUser")
	proto.RegisterType((*ReqBanChannelUser)(nil), "imapigateway.ReqBanChannelUser")
	proto.RegisterType((*ReqGetChannels)(nil), "imapigateway.ReqGetChannels")
	proto.RegisterType((*ReplyGetChannels)(nil), "imapigateway.ReplyGetChannels")
	proto.RegisterType((*ReqDeleteChatUser)(nil), "imapigateway.ReqDeleteChatUser")
	proto.RegisterType((*ReplyDeleteChatUser)(nil), "imapigateway.ReplyDeleteChatUser")
	proto.RegisterType((*ChannelInactiveUser)(nil), "imapigateway.ChannelInactiveUser")
	proto.RegisterType((*GetChannelInactiveUsersReq)(nil), "imapigateway.GetChannelInactiveUsersReq")
	proto.RegisterType((*GetChannelInactiveUsersResult)(nil), "imapigateway.GetChannelInactiveUsersResult")
	proto.RegisterType((*ReqBotInlineCall)(nil), "imapigateway.ReqBotInlineCall")
	proto.RegisterType((*ReplyBotInlineCall)(nil), "imapigateway.ReplyBotInlineCall")
	proto.RegisterType((*InlineCall)(nil), "imapigateway.InlineCall")
	proto.RegisterType((*ReqSendUserMsg)(nil), "imapigateway.ReqSendUserMsg")
	proto.RegisterType((*ReplyBool)(nil), "imapigateway.ReplyBool")
	proto.RegisterType((*ReqBotCall)(nil), "imapigateway.ReqBotCall")
	proto.RegisterType((*ReplyBotCall)(nil), "imapigateway.ReplyBotCall")
	proto.RegisterType((*ReqGetMessageByUserIdUuid)(nil), "imapigateway.ReqGetMessageByUserIdUuid")
	proto.RegisterType((*ReplyGetMessageByUserIdUuid)(nil), "imapigateway.ReplyGetMessageByUserIdUuid")
	proto.RegisterType((*ReqGetChannelMessageByChannelIdMsgId)(nil), "imapigateway.ReqGetChannelMessageByChannelIdMsgId")
	proto.RegisterType((*ReplyGetChannelMessageByChannelIdMsgId)(nil), "imapigateway.ReplyGetChannelMessageByChannelIdMsgId")
	proto.RegisterType((*ReqGetMessageByUserIdMsgId)(nil), "imapigateway.ReqGetMessageByUserIdMsgId")
	proto.RegisterType((*ReplyGetMessageByUserIdMsgId)(nil), "imapigateway.ReplyGetMessageByUserIdMsgId")
	proto.RegisterType((*MsgFileDescReq)(nil), "imapigateway.MsgFileDescReq")
	proto.RegisterType((*MsgFileDescResp)(nil), "imapigateway.MsgFileDescResp")
	proto.RegisterType((*MsgServiceLimitReq)(nil), "imapigateway.MsgServiceLimitReq")
	proto.RegisterType((*MsgServiceLimitResp)(nil), "imapigateway.MsgServiceLimitResp")
	proto.RegisterType((*MsgGetFidReq)(nil), "imapigateway.MsgGetFidReq")
	proto.RegisterType((*MsgGetFidResp)(nil), "imapigateway.MsgGetFidResp")
	proto.RegisterType((*MsgFilePartsReq)(nil), "imapigateway.MsgFilePartsReq")
	proto.RegisterType((*MsgFilePartsResp)(nil), "imapigateway.MsgFilePartsResp")
	proto.RegisterType((*MsgUploadFileReq)(nil), "imapigateway.MsgUploadFileReq")
	proto.RegisterType((*MsgUploadFileResp)(nil), "imapigateway.MsgUploadFileResp")
	proto.RegisterType((*MsgDownloadFileReq)(nil), "imapigateway.MsgDownloadFileReq")
	proto.RegisterType((*DownloadFileRespPara1)(nil), "imapigateway.DownloadFileRespPara1")
	proto.RegisterType((*DownloadFileRespPara2)(nil), "imapigateway.DownloadFileRespPara2")
	proto.RegisterType((*MsgDownloadFileResp)(nil), "imapigateway.MsgDownloadFileResp")
	proto.RegisterType((*MsgQueryObjInfoReq)(nil), "imapigateway.MsgQueryObjInfoReq")
	proto.RegisterType((*QueryObjInfoRespPara)(nil), "imapigateway.QueryObjInfoRespPara")
	proto.RegisterType((*MsgQueryObjInfoResp)(nil), "imapigateway.MsgQueryObjInfoResp")
	proto.RegisterType((*MsgGetFileDescReq)(nil), "imapigateway.MsgGetFileDescReq")
	proto.RegisterType((*MsgGetFileDescResp)(nil), "imapigateway.MsgGetFileDescResp")
	proto.RegisterType((*GetChannelInfoReq)(nil), "imapigateway.GetChannelInfoReq")
	proto.RegisterType((*GetChannelInfoResp)(nil), "imapigateway.GetChannelInfoResp")
	proto.RegisterType((*ReqGetAdminGroups)(nil), "imapigateway.ReqGetAdminGroups")
	proto.RegisterType((*ReqGetGroups)(nil), "imapigateway.ReqGetGroups")
	proto.RegisterType((*Peer)(nil), "imapigateway.Peer")
	proto.RegisterType((*ReplyGetGroups)(nil), "imapigateway.ReplyGetGroups")
	proto.RegisterType((*ReqDeleteMessage)(nil), "imapigateway.ReqDeleteMessage")
	proto.RegisterType((*ReqSendChatAction)(nil), "imapigateway.ReqSendChatAction")
	proto.RegisterType((*ReqData)(nil), "imapigateway.ReqData")
	proto.RegisterType((*ReplyData)(nil), "imapigateway.ReplyData")
	proto.RegisterType((*ReqGetChatMembersCount)(nil), "imapigateway.ReqGetChatMembersCount")
	proto.RegisterType((*ReplyGetChatMembersCount)(nil), "imapigateway.ReplyGetChatMembersCount")
	proto.RegisterType((*GetChatInfoReq)(nil), "imapigateway.GetChatInfoReq")
	proto.RegisterType((*GetUsersChatsReq)(nil), "imapigateway.GetUsersChatsReq")
	proto.RegisterType((*GetUsersChatsResult)(nil), "imapigateway.GetUsersChatsResult")
	proto.RegisterType((*GetUserInfoByIdReq)(nil), "imapigateway.GetUserInfoByIdReq")
	proto.RegisterType((*GetUserInfoByIdArrReq)(nil), "imapigateway.GetUserInfoByIdArrReq")
	proto.RegisterType((*UpdateUserProfileReq)(nil), "imapigateway.UpdateUserProfileReq")
	proto.RegisterType((*UpdateUserProfileResult)(nil), "imapigateway.UpdateUserProfileResult")
	proto.RegisterType((*GetUserByphone)(nil), "imapigateway.GetUserByphone")
	proto.RegisterType((*UpdateBotInfoSuppReq)(nil), "imapigateway.UpdateBotInfoSuppReq")
	proto.RegisterType((*UpdateBotInfoSuppResult)(nil), "imapigateway.UpdateBotInfoSuppResult")
	proto.RegisterType((*UpdateBotPicRequest)(nil), "imapigateway.UpdateBotPicRequest")
	proto.RegisterType((*UpdateBotPicResult)(nil), "imapigateway.UpdateBotPicResult")
	proto.RegisterType((*UpdateuserNameReq)(nil), "imapigateway.UpdateuserNameReq")
	proto.RegisterType((*UpdateuserNameResult)(nil), "imapigateway.UpdateuserNameResult")
	proto.RegisterType((*RegisterUserInfoResult)(nil), "imapigateway.RegisterUserInfoResult")
	proto.RegisterType((*DeleteAccountByIdReq)(nil), "imapigateway.DeleteAccountByIdReq")
	proto.RegisterType((*DelAccountResult)(nil), "imapigateway.DelAccountResult")
	proto.RegisterType((*SignUpReq)(nil), "imapigateway.SignUpReq")
	proto.RegisterType((*AuthSignUpResult)(nil), "imapigateway.AuthSignUpResult")
	proto.RegisterType((*GetFullUserReq)(nil), "imapigateway.GetFullUserReq")
	proto.RegisterType((*GetFullUserResult)(nil), "imapigateway.GetFullUserResult")
	proto.RegisterType((*GetUserByUsername)(nil), "imapigateway.GetUserByUsername")
	proto.RegisterType((*ReqGetFullChat)(nil), "imapigateway.ReqGetFullChat")
	proto.RegisterType((*ReplyGetFullChat)(nil), "imapigateway.ReplyGetFullChat")
	proto.RegisterType((*ReqLeaveChannel)(nil), "imapigateway.ReqLeaveChannel")
	proto.RegisterType((*ReqSendMedia)(nil), "imapigateway.ReqSendMedia")
	proto.RegisterType((*ReplyResult)(nil), "imapigateway.ReplyResult")
	proto.RegisterType((*ReqEditChatTitle)(nil), "imapigateway.ReqEditChatTitle")
	proto.RegisterType((*ReplyEditChatTitle)(nil), "imapigateway.ReplyEditChatTitle")
	proto.RegisterType((*GetStickerSetPackDcInfosReq)(nil), "imapigateway.GetStickerSetPackDcInfosReq")
	proto.RegisterType((*GetStickerSetPackDcInfosResult)(nil), "imapigateway.GetStickerSetPackDcInfosResult")
	proto.RegisterType((*StickerPackDocumentBase)(nil), "imapigateway.StickerPackDocumentBase")
	proto.RegisterType((*StickerPackDocumentInfo)(nil), "imapigateway.StickerPackDocumentInfo")
	proto.RegisterType((*GetUserInfoByIdArrResult)(nil), "imapigateway.GetUserInfoByIdArrResult")
	proto.RegisterType((*SetBotVerifiedReq)(nil), "imapigateway.SetBotVerifiedReq")
	proto.RegisterType((*SetBotVerifiedReply)(nil), "imapigateway.SetBotVerifiedReply")
	proto.RegisterType((*ContactsGetCommonContactsReq)(nil), "imapigateway.ContactsGetCommonContactsReq")
	proto.RegisterType((*ContactsGetCommonContactsResult)(nil), "imapigateway.ContactsGetCommonContactsResult")
	proto.RegisterEnum("imapigateway.GroupLiveReplyCode", GroupLiveReplyCode_name, GroupLiveReplyCode_value)
	proto.RegisterEnum("imapigateway.ChatType", ChatType_name, ChatType_value)
	proto.RegisterEnum("imapigateway.MsgFromID", MsgFromID_name, MsgFromID_value)
	proto.RegisterEnum("imapigateway.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterEnum("imapigateway.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterEnum("imapigateway.CheckIsMuteContactResult_ResultCode", CheckIsMuteContactResult_ResultCode_name, CheckIsMuteContactResult_ResultCode_value)
	proto.RegisterEnum("imapigateway.AuthSignUpResult_ResultCode", AuthSignUpResult_ResultCode_name, AuthSignUpResult_ResultCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ApiGatewayService service

type ApiGatewayServiceClient interface {
	// 注册用户和普通机器人信息
	RegisterUserInfo(ctx context.Context, in *RegisterUserInfoReq, opts ...grpc.CallOption) (*RegisterUserInfoResult, error)
	// 注册红包机器人接口
	RegisterRedBotInfo(ctx context.Context, in *RegisterUserInfoReq, opts ...grpc.CallOption) (*RegisterUserInfoResult, error)
	// 更新用户的username
	UpdateUserName(ctx context.Context, in *UpdateuserNameReq, opts ...grpc.CallOption) (*UpdateuserNameResult, error)
	// 账号(标记删除)
	DeleteUserInfoById(ctx context.Context, in *DeleteAccountByIdReq, opts ...grpc.CallOption) (*DelAccountResult, error)
	// 删除消息
	DeleteMessages(ctx context.Context, in *ReqDeleteMessages, opts ...grpc.CallOption) (*ReplyDeleteMessages, error)
	// 机器人调用接口
	BotCall(ctx context.Context, in *ReqBotCall, opts ...grpc.CallOption) (*ReplyBotCall, error)
	// 根据 消息id和用户id 获取单聊消息\普通群消息
	GetMessageByUserIdMsgId(ctx context.Context, in *ReqGetMessageByUserIdMsgId, opts ...grpc.CallOption) (*ReplyGetMessageByUserIdMsgId, error)
	// 获取full channel
	GetFullChannel(ctx context.Context, in *ReqFullchannel, opts ...grpc.CallOption) (*ReplyFullChannel, error)
	// 获取超级群或者频道的修正信息
	GetChannelDifference(ctx context.Context, in *ReqGetchannelDifference, opts ...grpc.CallOption) (*ReplyChannelDiffCommon, error)
	// 获取成员信息
	GetParticipants(ctx context.Context, in *ReqParticipants, opts ...grpc.CallOption) (*ReplyParticipants, error)
	// 获取所有群 (除去部分)
	GetAllChats(ctx context.Context, in *ReqGetAllChats, opts ...grpc.CallOption) (*ReplyGetAllChats, error)
	// 离开超级群或者频道
	LeaveChannel(ctx context.Context, in *ReqLeaveChannel, opts ...grpc.CallOption) (*ReplyLeaveChannel, error)
	// 置顶超级群或者频道的消息
	UpdatePinnedChannelMessage(ctx context.Context, in *ReqUpdatePinnedChannelMessage, opts ...grpc.CallOption) (*ReplyUpdatePinnedChannelMessage, error)
	// 更新firstName,lastName和about
	UpdateUserProfile(ctx context.Context, in *UpdateUserProfileReq, opts ...grpc.CallOption) (*UpdateUserProfileResult, error)
	// 更新机器人相关信息
	UpdateBotInfo(ctx context.Context, in *BotUpdateInfo, opts ...grpc.CallOption) (*BotUpdateInfoResult, error)
	// 编辑超级群或者频道的标题
	EditChannelTitle(ctx context.Context, in *ReqEditChannelTitle, opts ...grpc.CallOption) (*ReplyEditChannelTitle, error)
	// 修改超级群或者频道的描述信息
	EditChannelAbout(ctx context.Context, in *ReqEditChannelAbout, opts ...grpc.CallOption) (*ReplyEditChannelAbout, error)
	// UploadFile 上传文件或文件片
	UploadFile(ctx context.Context, in *MsgUploadFileReq, opts ...grpc.CallOption) (*MsgUploadFileResp, error)
	// 网关上传文件描述信息
	GatewayUploadFileDesc(ctx context.Context, in *MsgFileDescReq, opts ...grpc.CallOption) (*MsgFileDescResp, error)
	// 发送红包
	SendRDP(ctx context.Context, in *SendRDPReq, opts ...grpc.CallOption) (*SendRDPResp, error)
	// 　检查红包
	CheckRDP(ctx context.Context, in *CheckRDPReq, opts ...grpc.CallOption) (*CheckRDPResp, error)
	// 　领取红包
	ReceiveRDP(ctx context.Context, in *ReceiveRDPReq, opts ...grpc.CallOption) (*ReceiveRDPResp, error)
	// 获取全部用户信息
	GetFullUser(ctx context.Context, in *GetFullUserReq, opts ...grpc.CallOption) (*GetFullUserResult, error)
	// 新增获取用户信息接口
	GetUserInfoById(ctx context.Context, in *GetUserInfoByIdReq, opts ...grpc.CallOption) (*GetUserInfoResult, error)
	// 发送红包游戏
	SendRedGame(ctx context.Context, in *SendGameRedReq, opts ...grpc.CallOption) (*GameRedResp, error)
	// 领取红包游戏
	ReceiveRedGame(ctx context.Context, in *RcvGameRedReq, opts ...grpc.CallOption) (*GameRedResp, error)
	// 查询游戏红包详情
	QueryRedGame(ctx context.Context, in *QryGameRdpReq, opts ...grpc.CallOption) (*GameRedResp, error)
	// 通过用户名获取用户Id
	GetUserIdByUserName(ctx context.Context, in *GetUserByUsernameReq, opts ...grpc.CallOption) (*GetUserInfoResult, error)
	// 设置用户生日和性别
	SetUserDetail(ctx context.Context, in *SetUserDetailReq, opts ...grpc.CallOption) (*SetUserDetailResult, error)
	// 更新机器人头像请求
	UpdateBotPic(ctx context.Context, in *UpdateBotPicRequest, opts ...grpc.CallOption) (*UpdateBotPicResult, error)
	// DownloadFile 下载文件或文件片
	DownloadFile(ctx context.Context, in *MsgDownloadFileReq, opts ...grpc.CallOption) (*MsgDownloadFileResp, error)
	// 新增支付获取游戏规则借口
	OtherTrans(ctx context.Context, in *OtherTransReq, opts ...grpc.CallOption) (*OtherTransResp, error)
	// 积分通用接口
	IntegralUniversalBusiness(ctx context.Context, in *ReqIntegralUniversalBusiness, opts ...grpc.CallOption) (*ReplyIntegralUniversalBusiness, error)
	// 获取回复消息
	GetChannelMsg(ctx context.Context, in *ReqGetChannelMessageByChannelIdMsgId, opts ...grpc.CallOption) (*ReplyGetChannelMessageByChannelIdMsgId, error)
	// 新增官方标志设置（内部调用）
	SetBotVerified(ctx context.Context, in *SetBotVerifiedReq, opts ...grpc.CallOption) (*SetBotVerifiedReply, error)
	// 获取机器人消息Id通过uuid
	GetMessageByUserIdUuid(ctx context.Context, in *ReqGetMessageByUserIdUuid, opts ...grpc.CallOption) (*ReplyGetMessageByUserIdUuid, error)
	// 获取多个好友的共同好友
	ContactsGetCommonContacts(ctx context.Context, in *ContactsGetCommonContactsReq, opts ...grpc.CallOption) (*ContactsGetCommonContactsResult, error)
	// 更新朋友圈通知
	UpdateMoments(ctx context.Context, in *ReqUpdateMoments, opts ...grpc.CallOption) (*ResUpdateMoments, error)
	// 获取用户联系人列表
	ContactsGetContacts(ctx context.Context, in *ContatsGetContactsReq, opts ...grpc.CallOption) (*ContatsGetContactsResult, error)
	// 根据用户Id来获取用户信息selfId 代表自己的Id userId 代表需要获取的用户的Id
	CheckIsMuteContact(ctx context.Context, in *CheckIsMuteContactReq, opts ...grpc.CallOption) (*CheckIsMuteContactResult, error)
	// 朋友圈互动通知
	MomentNotify(ctx context.Context, in *MomentNotifyReq, opts ...grpc.CallOption) (*MomentNotifyResult, error)
	// 根据用户昵称搜索
	SearchUserByNickname(ctx context.Context, in *SearchUserByNicknameReq, opts ...grpc.CallOption) (*SearchUserByNicknameResult, error)
	// 系统号发送消息
	SendMediaSysNotify(ctx context.Context, in *SendMediaSysNotifyReq, opts ...grpc.CallOption) (*SendMediaSysNotifyResult, error)
	// 朋友圈关注用户
	MomentFollow(ctx context.Context, in *MomentFollowReq, opts ...grpc.CallOption) (*MomentFollowResp, error)
	// 检测是否是自己的好友
	CheckIsSelfContact(ctx context.Context, in *CheckIsSelfContactReq, opts ...grpc.CallOption) (*CheckIsSelfContactResult, error)
	// 新增获取用户信息
	GetUserInfoByIdArr(ctx context.Context, in *GetUserInfoByIdArrReq, opts ...grpc.CallOption) (*GetUserInfoByIdArrResult, error)
	// 获取某个群成员信息
	GetChannelUserInfo(ctx context.Context, in *GetChannelUserInfoReq, opts ...grpc.CallOption) (*GetChannelUserInfoResp, error)
	// 超级群全体禁言
	EditEveryoneQuiet(ctx context.Context, in *ReqEditEveryoneQuiet, opts ...grpc.CallOption) (*ReplyChannelData, error)
	// 禁言单个用户
	EditBanChannelUser(ctx context.Context, in *ReqEditBanChannelUser, opts ...grpc.CallOption) (*ReplyChannelData, error)
	// 通过手机号获取用户信息
	GetUserInfoByPhone(ctx context.Context, in *GetUserByphone, opts ...grpc.CallOption) (*GetUserInfoResult, error)
	// 发送短信消息接口
	SendCodeMsg(ctx context.Context, in *ReqSendCodeMsg, opts ...grpc.CallOption) (*ReplyBool, error)
	// 群直播开始
	GroupLiveStart(ctx context.Context, in *LiveStartReq, opts ...grpc.CallOption) (*LiveStartRsp, error)
	// 群直播结束
	GroupLiveStop(ctx context.Context, in *LiveStopReq, opts ...grpc.CallOption) (*LiveStopRsp, error)
	// 获取主播邀请链接
	GetLiveInviteUrl(ctx context.Context, in *GetLiveInviteUrlReq, opts ...grpc.CallOption) (*GetLiveInviteUrlRsp, error)
	// 获取用户名是否唯一
	CheckUserName(ctx context.Context, in *CheckUserNameReq, opts ...grpc.CallOption) (*CheckUserNameResp, error)
	// 修改直播信息
	EditLiveInfo(ctx context.Context, in *EditLiveInfoReq, opts ...grpc.CallOption) (*EditLiveInfoRsp, error)
	// 检测直播信息
	GroupLiveCheck(ctx context.Context, in *GroupLiveCheckReq, opts ...grpc.CallOption) (*GroupLiveCheckRsp, error)
	// 获取链接邀请
	GetLiveInviteCnt(ctx context.Context, in *GetLiveInviteCntReq, opts ...grpc.CallOption) (*GetLiveInviteCntRsp, error)
	// 踢人出超级群或者频道
	KickFromChannel(ctx context.Context, in *ReqKickFromChannel, opts ...grpc.CallOption) (*ReplyChannelData, error)
	// 检查用户是否是在群里
	CheckUserInGroup(ctx context.Context, in *CheckUserInGroupReq, opts ...grpc.CallOption) (*CheckUserInGroupRsp, error)
	// 推送消息通知
	LivePush(ctx context.Context, in *LivePushReq, opts ...grpc.CallOption) (*LivePushResult, error)
	// 分页获取群用户id 用于直播推送
	GetGroupUserIds(ctx context.Context, in *GetGroupUserIdsReq, opts ...grpc.CallOption) (*GetGroupUserIdsRsp, error)
}

type apiGatewayServiceClient struct {
	cc *grpc.ClientConn
}

func NewApiGatewayServiceClient(cc *grpc.ClientConn) ApiGatewayServiceClient {
	return &apiGatewayServiceClient{cc}
}

func (c *apiGatewayServiceClient) RegisterUserInfo(ctx context.Context, in *RegisterUserInfoReq, opts ...grpc.CallOption) (*RegisterUserInfoResult, error) {
	out := new(RegisterUserInfoResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/RegisterUserInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) RegisterRedBotInfo(ctx context.Context, in *RegisterUserInfoReq, opts ...grpc.CallOption) (*RegisterUserInfoResult, error) {
	out := new(RegisterUserInfoResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/RegisterRedBotInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) UpdateUserName(ctx context.Context, in *UpdateuserNameReq, opts ...grpc.CallOption) (*UpdateuserNameResult, error) {
	out := new(UpdateuserNameResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/UpdateUserName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) DeleteUserInfoById(ctx context.Context, in *DeleteAccountByIdReq, opts ...grpc.CallOption) (*DelAccountResult, error) {
	out := new(DelAccountResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/DeleteUserInfoById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) DeleteMessages(ctx context.Context, in *ReqDeleteMessages, opts ...grpc.CallOption) (*ReplyDeleteMessages, error) {
	out := new(ReplyDeleteMessages)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/DeleteMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) BotCall(ctx context.Context, in *ReqBotCall, opts ...grpc.CallOption) (*ReplyBotCall, error) {
	out := new(ReplyBotCall)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/BotCall", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetMessageByUserIdMsgId(ctx context.Context, in *ReqGetMessageByUserIdMsgId, opts ...grpc.CallOption) (*ReplyGetMessageByUserIdMsgId, error) {
	out := new(ReplyGetMessageByUserIdMsgId)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetMessageByUserIdMsgId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetFullChannel(ctx context.Context, in *ReqFullchannel, opts ...grpc.CallOption) (*ReplyFullChannel, error) {
	out := new(ReplyFullChannel)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetFullChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetChannelDifference(ctx context.Context, in *ReqGetchannelDifference, opts ...grpc.CallOption) (*ReplyChannelDiffCommon, error) {
	out := new(ReplyChannelDiffCommon)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetChannelDifference", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetParticipants(ctx context.Context, in *ReqParticipants, opts ...grpc.CallOption) (*ReplyParticipants, error) {
	out := new(ReplyParticipants)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetParticipants", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetAllChats(ctx context.Context, in *ReqGetAllChats, opts ...grpc.CallOption) (*ReplyGetAllChats, error) {
	out := new(ReplyGetAllChats)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetAllChats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) LeaveChannel(ctx context.Context, in *ReqLeaveChannel, opts ...grpc.CallOption) (*ReplyLeaveChannel, error) {
	out := new(ReplyLeaveChannel)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/LeaveChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) UpdatePinnedChannelMessage(ctx context.Context, in *ReqUpdatePinnedChannelMessage, opts ...grpc.CallOption) (*ReplyUpdatePinnedChannelMessage, error) {
	out := new(ReplyUpdatePinnedChannelMessage)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/UpdatePinnedChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) UpdateUserProfile(ctx context.Context, in *UpdateUserProfileReq, opts ...grpc.CallOption) (*UpdateUserProfileResult, error) {
	out := new(UpdateUserProfileResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/UpdateUserProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) UpdateBotInfo(ctx context.Context, in *BotUpdateInfo, opts ...grpc.CallOption) (*BotUpdateInfoResult, error) {
	out := new(BotUpdateInfoResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/UpdateBotInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) EditChannelTitle(ctx context.Context, in *ReqEditChannelTitle, opts ...grpc.CallOption) (*ReplyEditChannelTitle, error) {
	out := new(ReplyEditChannelTitle)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/EditChannelTitle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) EditChannelAbout(ctx context.Context, in *ReqEditChannelAbout, opts ...grpc.CallOption) (*ReplyEditChannelAbout, error) {
	out := new(ReplyEditChannelAbout)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/EditChannelAbout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) UploadFile(ctx context.Context, in *MsgUploadFileReq, opts ...grpc.CallOption) (*MsgUploadFileResp, error) {
	out := new(MsgUploadFileResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/UploadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GatewayUploadFileDesc(ctx context.Context, in *MsgFileDescReq, opts ...grpc.CallOption) (*MsgFileDescResp, error) {
	out := new(MsgFileDescResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GatewayUploadFileDesc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) SendRDP(ctx context.Context, in *SendRDPReq, opts ...grpc.CallOption) (*SendRDPResp, error) {
	out := new(SendRDPResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/SendRDP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) CheckRDP(ctx context.Context, in *CheckRDPReq, opts ...grpc.CallOption) (*CheckRDPResp, error) {
	out := new(CheckRDPResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/CheckRDP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) ReceiveRDP(ctx context.Context, in *ReceiveRDPReq, opts ...grpc.CallOption) (*ReceiveRDPResp, error) {
	out := new(ReceiveRDPResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/ReceiveRDP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetFullUser(ctx context.Context, in *GetFullUserReq, opts ...grpc.CallOption) (*GetFullUserResult, error) {
	out := new(GetFullUserResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetFullUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetUserInfoById(ctx context.Context, in *GetUserInfoByIdReq, opts ...grpc.CallOption) (*GetUserInfoResult, error) {
	out := new(GetUserInfoResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetUserInfoById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) SendRedGame(ctx context.Context, in *SendGameRedReq, opts ...grpc.CallOption) (*GameRedResp, error) {
	out := new(GameRedResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/SendRedGame", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) ReceiveRedGame(ctx context.Context, in *RcvGameRedReq, opts ...grpc.CallOption) (*GameRedResp, error) {
	out := new(GameRedResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/ReceiveRedGame", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) QueryRedGame(ctx context.Context, in *QryGameRdpReq, opts ...grpc.CallOption) (*GameRedResp, error) {
	out := new(GameRedResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/QueryRedGame", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetUserIdByUserName(ctx context.Context, in *GetUserByUsernameReq, opts ...grpc.CallOption) (*GetUserInfoResult, error) {
	out := new(GetUserInfoResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetUserIdByUserName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) SetUserDetail(ctx context.Context, in *SetUserDetailReq, opts ...grpc.CallOption) (*SetUserDetailResult, error) {
	out := new(SetUserDetailResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/SetUserDetail", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) UpdateBotPic(ctx context.Context, in *UpdateBotPicRequest, opts ...grpc.CallOption) (*UpdateBotPicResult, error) {
	out := new(UpdateBotPicResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/UpdateBotPic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) DownloadFile(ctx context.Context, in *MsgDownloadFileReq, opts ...grpc.CallOption) (*MsgDownloadFileResp, error) {
	out := new(MsgDownloadFileResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/DownloadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) OtherTrans(ctx context.Context, in *OtherTransReq, opts ...grpc.CallOption) (*OtherTransResp, error) {
	out := new(OtherTransResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/OtherTrans", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) IntegralUniversalBusiness(ctx context.Context, in *ReqIntegralUniversalBusiness, opts ...grpc.CallOption) (*ReplyIntegralUniversalBusiness, error) {
	out := new(ReplyIntegralUniversalBusiness)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/IntegralUniversalBusiness", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetChannelMsg(ctx context.Context, in *ReqGetChannelMessageByChannelIdMsgId, opts ...grpc.CallOption) (*ReplyGetChannelMessageByChannelIdMsgId, error) {
	out := new(ReplyGetChannelMessageByChannelIdMsgId)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetChannelMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) SetBotVerified(ctx context.Context, in *SetBotVerifiedReq, opts ...grpc.CallOption) (*SetBotVerifiedReply, error) {
	out := new(SetBotVerifiedReply)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/SetBotVerified", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetMessageByUserIdUuid(ctx context.Context, in *ReqGetMessageByUserIdUuid, opts ...grpc.CallOption) (*ReplyGetMessageByUserIdUuid, error) {
	out := new(ReplyGetMessageByUserIdUuid)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetMessageByUserIdUuid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) ContactsGetCommonContacts(ctx context.Context, in *ContactsGetCommonContactsReq, opts ...grpc.CallOption) (*ContactsGetCommonContactsResult, error) {
	out := new(ContactsGetCommonContactsResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/ContactsGetCommonContacts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) UpdateMoments(ctx context.Context, in *ReqUpdateMoments, opts ...grpc.CallOption) (*ResUpdateMoments, error) {
	out := new(ResUpdateMoments)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/UpdateMoments", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) ContactsGetContacts(ctx context.Context, in *ContatsGetContactsReq, opts ...grpc.CallOption) (*ContatsGetContactsResult, error) {
	out := new(ContatsGetContactsResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/ContactsGetContacts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) CheckIsMuteContact(ctx context.Context, in *CheckIsMuteContactReq, opts ...grpc.CallOption) (*CheckIsMuteContactResult, error) {
	out := new(CheckIsMuteContactResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/CheckIsMuteContact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) MomentNotify(ctx context.Context, in *MomentNotifyReq, opts ...grpc.CallOption) (*MomentNotifyResult, error) {
	out := new(MomentNotifyResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/MomentNotify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) SearchUserByNickname(ctx context.Context, in *SearchUserByNicknameReq, opts ...grpc.CallOption) (*SearchUserByNicknameResult, error) {
	out := new(SearchUserByNicknameResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/SearchUserByNickname", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) SendMediaSysNotify(ctx context.Context, in *SendMediaSysNotifyReq, opts ...grpc.CallOption) (*SendMediaSysNotifyResult, error) {
	out := new(SendMediaSysNotifyResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/SendMediaSysNotify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) MomentFollow(ctx context.Context, in *MomentFollowReq, opts ...grpc.CallOption) (*MomentFollowResp, error) {
	out := new(MomentFollowResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/MomentFollow", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) CheckIsSelfContact(ctx context.Context, in *CheckIsSelfContactReq, opts ...grpc.CallOption) (*CheckIsSelfContactResult, error) {
	out := new(CheckIsSelfContactResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/CheckIsSelfContact", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetUserInfoByIdArr(ctx context.Context, in *GetUserInfoByIdArrReq, opts ...grpc.CallOption) (*GetUserInfoByIdArrResult, error) {
	out := new(GetUserInfoByIdArrResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetUserInfoByIdArr", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetChannelUserInfo(ctx context.Context, in *GetChannelUserInfoReq, opts ...grpc.CallOption) (*GetChannelUserInfoResp, error) {
	out := new(GetChannelUserInfoResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetChannelUserInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) EditEveryoneQuiet(ctx context.Context, in *ReqEditEveryoneQuiet, opts ...grpc.CallOption) (*ReplyChannelData, error) {
	out := new(ReplyChannelData)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/EditEveryoneQuiet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) EditBanChannelUser(ctx context.Context, in *ReqEditBanChannelUser, opts ...grpc.CallOption) (*ReplyChannelData, error) {
	out := new(ReplyChannelData)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/EditBanChannelUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetUserInfoByPhone(ctx context.Context, in *GetUserByphone, opts ...grpc.CallOption) (*GetUserInfoResult, error) {
	out := new(GetUserInfoResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetUserInfoByPhone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) SendCodeMsg(ctx context.Context, in *ReqSendCodeMsg, opts ...grpc.CallOption) (*ReplyBool, error) {
	out := new(ReplyBool)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/SendCodeMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GroupLiveStart(ctx context.Context, in *LiveStartReq, opts ...grpc.CallOption) (*LiveStartRsp, error) {
	out := new(LiveStartRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GroupLiveStart", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GroupLiveStop(ctx context.Context, in *LiveStopReq, opts ...grpc.CallOption) (*LiveStopRsp, error) {
	out := new(LiveStopRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GroupLiveStop", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetLiveInviteUrl(ctx context.Context, in *GetLiveInviteUrlReq, opts ...grpc.CallOption) (*GetLiveInviteUrlRsp, error) {
	out := new(GetLiveInviteUrlRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetLiveInviteUrl", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) CheckUserName(ctx context.Context, in *CheckUserNameReq, opts ...grpc.CallOption) (*CheckUserNameResp, error) {
	out := new(CheckUserNameResp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/CheckUserName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) EditLiveInfo(ctx context.Context, in *EditLiveInfoReq, opts ...grpc.CallOption) (*EditLiveInfoRsp, error) {
	out := new(EditLiveInfoRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/EditLiveInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GroupLiveCheck(ctx context.Context, in *GroupLiveCheckReq, opts ...grpc.CallOption) (*GroupLiveCheckRsp, error) {
	out := new(GroupLiveCheckRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GroupLiveCheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetLiveInviteCnt(ctx context.Context, in *GetLiveInviteCntReq, opts ...grpc.CallOption) (*GetLiveInviteCntRsp, error) {
	out := new(GetLiveInviteCntRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetLiveInviteCnt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) KickFromChannel(ctx context.Context, in *ReqKickFromChannel, opts ...grpc.CallOption) (*ReplyChannelData, error) {
	out := new(ReplyChannelData)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/KickFromChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) CheckUserInGroup(ctx context.Context, in *CheckUserInGroupReq, opts ...grpc.CallOption) (*CheckUserInGroupRsp, error) {
	out := new(CheckUserInGroupRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/CheckUserInGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) LivePush(ctx context.Context, in *LivePushReq, opts ...grpc.CallOption) (*LivePushResult, error) {
	out := new(LivePushResult)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/LivePush", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiGatewayServiceClient) GetGroupUserIds(ctx context.Context, in *GetGroupUserIdsReq, opts ...grpc.CallOption) (*GetGroupUserIdsRsp, error) {
	out := new(GetGroupUserIdsRsp)
	err := grpc.Invoke(ctx, "/imapigateway.ApiGatewayService/GetGroupUserIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ApiGatewayService service

type ApiGatewayServiceServer interface {
	// 注册用户和普通机器人信息
	RegisterUserInfo(context.Context, *RegisterUserInfoReq) (*RegisterUserInfoResult, error)
	// 注册红包机器人接口
	RegisterRedBotInfo(context.Context, *RegisterUserInfoReq) (*RegisterUserInfoResult, error)
	// 更新用户的username
	UpdateUserName(context.Context, *UpdateuserNameReq) (*UpdateuserNameResult, error)
	// 账号(标记删除)
	DeleteUserInfoById(context.Context, *DeleteAccountByIdReq) (*DelAccountResult, error)
	// 删除消息
	DeleteMessages(context.Context, *ReqDeleteMessages) (*ReplyDeleteMessages, error)
	// 机器人调用接口
	BotCall(context.Context, *ReqBotCall) (*ReplyBotCall, error)
	// 根据 消息id和用户id 获取单聊消息\普通群消息
	GetMessageByUserIdMsgId(context.Context, *ReqGetMessageByUserIdMsgId) (*ReplyGetMessageByUserIdMsgId, error)
	// 获取full channel
	GetFullChannel(context.Context, *ReqFullchannel) (*ReplyFullChannel, error)
	// 获取超级群或者频道的修正信息
	GetChannelDifference(context.Context, *ReqGetchannelDifference) (*ReplyChannelDiffCommon, error)
	// 获取成员信息
	GetParticipants(context.Context, *ReqParticipants) (*ReplyParticipants, error)
	// 获取所有群 (除去部分)
	GetAllChats(context.Context, *ReqGetAllChats) (*ReplyGetAllChats, error)
	// 离开超级群或者频道
	LeaveChannel(context.Context, *ReqLeaveChannel) (*ReplyLeaveChannel, error)
	// 置顶超级群或者频道的消息
	UpdatePinnedChannelMessage(context.Context, *ReqUpdatePinnedChannelMessage) (*ReplyUpdatePinnedChannelMessage, error)
	// 更新firstName,lastName和about
	UpdateUserProfile(context.Context, *UpdateUserProfileReq) (*UpdateUserProfileResult, error)
	// 更新机器人相关信息
	UpdateBotInfo(context.Context, *BotUpdateInfo) (*BotUpdateInfoResult, error)
	// 编辑超级群或者频道的标题
	EditChannelTitle(context.Context, *ReqEditChannelTitle) (*ReplyEditChannelTitle, error)
	// 修改超级群或者频道的描述信息
	EditChannelAbout(context.Context, *ReqEditChannelAbout) (*ReplyEditChannelAbout, error)
	// UploadFile 上传文件或文件片
	UploadFile(context.Context, *MsgUploadFileReq) (*MsgUploadFileResp, error)
	// 网关上传文件描述信息
	GatewayUploadFileDesc(context.Context, *MsgFileDescReq) (*MsgFileDescResp, error)
	// 发送红包
	SendRDP(context.Context, *SendRDPReq) (*SendRDPResp, error)
	// 　检查红包
	CheckRDP(context.Context, *CheckRDPReq) (*CheckRDPResp, error)
	// 　领取红包
	ReceiveRDP(context.Context, *ReceiveRDPReq) (*ReceiveRDPResp, error)
	// 获取全部用户信息
	GetFullUser(context.Context, *GetFullUserReq) (*GetFullUserResult, error)
	// 新增获取用户信息接口
	GetUserInfoById(context.Context, *GetUserInfoByIdReq) (*GetUserInfoResult, error)
	// 发送红包游戏
	SendRedGame(context.Context, *SendGameRedReq) (*GameRedResp, error)
	// 领取红包游戏
	ReceiveRedGame(context.Context, *RcvGameRedReq) (*GameRedResp, error)
	// 查询游戏红包详情
	QueryRedGame(context.Context, *QryGameRdpReq) (*GameRedResp, error)
	// 通过用户名获取用户Id
	GetUserIdByUserName(context.Context, *GetUserByUsernameReq) (*GetUserInfoResult, error)
	// 设置用户生日和性别
	SetUserDetail(context.Context, *SetUserDetailReq) (*SetUserDetailResult, error)
	// 更新机器人头像请求
	UpdateBotPic(context.Context, *UpdateBotPicRequest) (*UpdateBotPicResult, error)
	// DownloadFile 下载文件或文件片
	DownloadFile(context.Context, *MsgDownloadFileReq) (*MsgDownloadFileResp, error)
	// 新增支付获取游戏规则借口
	OtherTrans(context.Context, *OtherTransReq) (*OtherTransResp, error)
	// 积分通用接口
	IntegralUniversalBusiness(context.Context, *ReqIntegralUniversalBusiness) (*ReplyIntegralUniversalBusiness, error)
	// 获取回复消息
	GetChannelMsg(context.Context, *ReqGetChannelMessageByChannelIdMsgId) (*ReplyGetChannelMessageByChannelIdMsgId, error)
	// 新增官方标志设置（内部调用）
	SetBotVerified(context.Context, *SetBotVerifiedReq) (*SetBotVerifiedReply, error)
	// 获取机器人消息Id通过uuid
	GetMessageByUserIdUuid(context.Context, *ReqGetMessageByUserIdUuid) (*ReplyGetMessageByUserIdUuid, error)
	// 获取多个好友的共同好友
	ContactsGetCommonContacts(context.Context, *ContactsGetCommonContactsReq) (*ContactsGetCommonContactsResult, error)
	// 更新朋友圈通知
	UpdateMoments(context.Context, *ReqUpdateMoments) (*ResUpdateMoments, error)
	// 获取用户联系人列表
	ContactsGetContacts(context.Context, *ContatsGetContactsReq) (*ContatsGetContactsResult, error)
	// 根据用户Id来获取用户信息selfId 代表自己的Id userId 代表需要获取的用户的Id
	CheckIsMuteContact(context.Context, *CheckIsMuteContactReq) (*CheckIsMuteContactResult, error)
	// 朋友圈互动通知
	MomentNotify(context.Context, *MomentNotifyReq) (*MomentNotifyResult, error)
	// 根据用户昵称搜索
	SearchUserByNickname(context.Context, *SearchUserByNicknameReq) (*SearchUserByNicknameResult, error)
	// 系统号发送消息
	SendMediaSysNotify(context.Context, *SendMediaSysNotifyReq) (*SendMediaSysNotifyResult, error)
	// 朋友圈关注用户
	MomentFollow(context.Context, *MomentFollowReq) (*MomentFollowResp, error)
	// 检测是否是自己的好友
	CheckIsSelfContact(context.Context, *CheckIsSelfContactReq) (*CheckIsSelfContactResult, error)
	// 新增获取用户信息
	GetUserInfoByIdArr(context.Context, *GetUserInfoByIdArrReq) (*GetUserInfoByIdArrResult, error)
	// 获取某个群成员信息
	GetChannelUserInfo(context.Context, *GetChannelUserInfoReq) (*GetChannelUserInfoResp, error)
	// 超级群全体禁言
	EditEveryoneQuiet(context.Context, *ReqEditEveryoneQuiet) (*ReplyChannelData, error)
	// 禁言单个用户
	EditBanChannelUser(context.Context, *ReqEditBanChannelUser) (*ReplyChannelData, error)
	// 通过手机号获取用户信息
	GetUserInfoByPhone(context.Context, *GetUserByphone) (*GetUserInfoResult, error)
	// 发送短信消息接口
	SendCodeMsg(context.Context, *ReqSendCodeMsg) (*ReplyBool, error)
	// 群直播开始
	GroupLiveStart(context.Context, *LiveStartReq) (*LiveStartRsp, error)
	// 群直播结束
	GroupLiveStop(context.Context, *LiveStopReq) (*LiveStopRsp, error)
	// 获取主播邀请链接
	GetLiveInviteUrl(context.Context, *GetLiveInviteUrlReq) (*GetLiveInviteUrlRsp, error)
	// 获取用户名是否唯一
	CheckUserName(context.Context, *CheckUserNameReq) (*CheckUserNameResp, error)
	// 修改直播信息
	EditLiveInfo(context.Context, *EditLiveInfoReq) (*EditLiveInfoRsp, error)
	// 检测直播信息
	GroupLiveCheck(context.Context, *GroupLiveCheckReq) (*GroupLiveCheckRsp, error)
	// 获取链接邀请
	GetLiveInviteCnt(context.Context, *GetLiveInviteCntReq) (*GetLiveInviteCntRsp, error)
	// 踢人出超级群或者频道
	KickFromChannel(context.Context, *ReqKickFromChannel) (*ReplyChannelData, error)
	// 检查用户是否是在群里
	CheckUserInGroup(context.Context, *CheckUserInGroupReq) (*CheckUserInGroupRsp, error)
	// 推送消息通知
	LivePush(context.Context, *LivePushReq) (*LivePushResult, error)
	// 分页获取群用户id 用于直播推送
	GetGroupUserIds(context.Context, *GetGroupUserIdsReq) (*GetGroupUserIdsRsp, error)
}

func RegisterApiGatewayServiceServer(s *grpc.Server, srv ApiGatewayServiceServer) {
	s.RegisterService(&_ApiGatewayService_serviceDesc, srv)
}

func _ApiGatewayService_RegisterUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).RegisterUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/RegisterUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).RegisterUserInfo(ctx, req.(*RegisterUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_RegisterRedBotInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).RegisterRedBotInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/RegisterRedBotInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).RegisterRedBotInfo(ctx, req.(*RegisterUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_UpdateUserName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateuserNameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).UpdateUserName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/UpdateUserName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).UpdateUserName(ctx, req.(*UpdateuserNameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_DeleteUserInfoById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).DeleteUserInfoById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/DeleteUserInfoById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).DeleteUserInfoById(ctx, req.(*DeleteAccountByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_DeleteMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqDeleteMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).DeleteMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/DeleteMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).DeleteMessages(ctx, req.(*ReqDeleteMessages))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_BotCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqBotCall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).BotCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/BotCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).BotCall(ctx, req.(*ReqBotCall))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetMessageByUserIdMsgId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetMessageByUserIdMsgId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetMessageByUserIdMsgId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetMessageByUserIdMsgId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetMessageByUserIdMsgId(ctx, req.(*ReqGetMessageByUserIdMsgId))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetFullChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqFullchannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetFullChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetFullChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetFullChannel(ctx, req.(*ReqFullchannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetChannelDifference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetchannelDifference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetChannelDifference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetChannelDifference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetChannelDifference(ctx, req.(*ReqGetchannelDifference))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqParticipants)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetParticipants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetParticipants(ctx, req.(*ReqParticipants))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetAllChats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetAllChats)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetAllChats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetAllChats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetAllChats(ctx, req.(*ReqGetAllChats))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_LeaveChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqLeaveChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).LeaveChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/LeaveChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).LeaveChannel(ctx, req.(*ReqLeaveChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_UpdatePinnedChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUpdatePinnedChannelMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).UpdatePinnedChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/UpdatePinnedChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).UpdatePinnedChannelMessage(ctx, req.(*ReqUpdatePinnedChannelMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_UpdateUserProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserProfileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).UpdateUserProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/UpdateUserProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).UpdateUserProfile(ctx, req.(*UpdateUserProfileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_UpdateBotInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BotUpdateInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).UpdateBotInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/UpdateBotInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).UpdateBotInfo(ctx, req.(*BotUpdateInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_EditChannelTitle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqEditChannelTitle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).EditChannelTitle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/EditChannelTitle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).EditChannelTitle(ctx, req.(*ReqEditChannelTitle))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_EditChannelAbout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqEditChannelAbout)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).EditChannelAbout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/EditChannelAbout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).EditChannelAbout(ctx, req.(*ReqEditChannelAbout))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUploadFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).UploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/UploadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).UploadFile(ctx, req.(*MsgUploadFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GatewayUploadFileDesc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFileDescReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GatewayUploadFileDesc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GatewayUploadFileDesc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GatewayUploadFileDesc(ctx, req.(*MsgFileDescReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_SendRDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRDPReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).SendRDP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/SendRDP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).SendRDP(ctx, req.(*SendRDPReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_CheckRDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckRDPReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).CheckRDP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/CheckRDP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).CheckRDP(ctx, req.(*CheckRDPReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_ReceiveRDP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveRDPReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).ReceiveRDP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/ReceiveRDP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).ReceiveRDP(ctx, req.(*ReceiveRDPReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetFullUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFullUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetFullUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetFullUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetFullUser(ctx, req.(*GetFullUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetUserInfoById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoByIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetUserInfoById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetUserInfoById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetUserInfoById(ctx, req.(*GetUserInfoByIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_SendRedGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendGameRedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).SendRedGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/SendRedGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).SendRedGame(ctx, req.(*SendGameRedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_ReceiveRedGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RcvGameRedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).ReceiveRedGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/ReceiveRedGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).ReceiveRedGame(ctx, req.(*RcvGameRedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_QueryRedGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QryGameRdpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).QueryRedGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/QueryRedGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).QueryRedGame(ctx, req.(*QryGameRdpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetUserIdByUserName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByUsernameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetUserIdByUserName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetUserIdByUserName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetUserIdByUserName(ctx, req.(*GetUserByUsernameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_SetUserDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).SetUserDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/SetUserDetail",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).SetUserDetail(ctx, req.(*SetUserDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_UpdateBotPic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBotPicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).UpdateBotPic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/UpdateBotPic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).UpdateBotPic(ctx, req.(*UpdateBotPicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_DownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDownloadFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).DownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/DownloadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).DownloadFile(ctx, req.(*MsgDownloadFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_OtherTrans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OtherTransReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).OtherTrans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/OtherTrans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).OtherTrans(ctx, req.(*OtherTransReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_IntegralUniversalBusiness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqIntegralUniversalBusiness)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).IntegralUniversalBusiness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/IntegralUniversalBusiness",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).IntegralUniversalBusiness(ctx, req.(*ReqIntegralUniversalBusiness))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetChannelMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetChannelMessageByChannelIdMsgId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetChannelMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetChannelMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetChannelMsg(ctx, req.(*ReqGetChannelMessageByChannelIdMsgId))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_SetBotVerified_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBotVerifiedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).SetBotVerified(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/SetBotVerified",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).SetBotVerified(ctx, req.(*SetBotVerifiedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetMessageByUserIdUuid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetMessageByUserIdUuid)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetMessageByUserIdUuid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetMessageByUserIdUuid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetMessageByUserIdUuid(ctx, req.(*ReqGetMessageByUserIdUuid))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_ContactsGetCommonContacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContactsGetCommonContactsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).ContactsGetCommonContacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/ContactsGetCommonContacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).ContactsGetCommonContacts(ctx, req.(*ContactsGetCommonContactsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_UpdateMoments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUpdateMoments)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).UpdateMoments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/UpdateMoments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).UpdateMoments(ctx, req.(*ReqUpdateMoments))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_ContactsGetContacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContatsGetContactsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).ContactsGetContacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/ContactsGetContacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).ContactsGetContacts(ctx, req.(*ContatsGetContactsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_CheckIsMuteContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckIsMuteContactReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).CheckIsMuteContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/CheckIsMuteContact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).CheckIsMuteContact(ctx, req.(*CheckIsMuteContactReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_MomentNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MomentNotifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).MomentNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/MomentNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).MomentNotify(ctx, req.(*MomentNotifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_SearchUserByNickname_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchUserByNicknameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).SearchUserByNickname(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/SearchUserByNickname",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).SearchUserByNickname(ctx, req.(*SearchUserByNicknameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_SendMediaSysNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMediaSysNotifyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).SendMediaSysNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/SendMediaSysNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).SendMediaSysNotify(ctx, req.(*SendMediaSysNotifyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_MomentFollow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MomentFollowReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).MomentFollow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/MomentFollow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).MomentFollow(ctx, req.(*MomentFollowReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_CheckIsSelfContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckIsSelfContactReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).CheckIsSelfContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/CheckIsSelfContact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).CheckIsSelfContact(ctx, req.(*CheckIsSelfContactReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetUserInfoByIdArr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoByIdArrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetUserInfoByIdArr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetUserInfoByIdArr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetUserInfoByIdArr(ctx, req.(*GetUserInfoByIdArrReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetChannelUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetChannelUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetChannelUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetChannelUserInfo(ctx, req.(*GetChannelUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_EditEveryoneQuiet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqEditEveryoneQuiet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).EditEveryoneQuiet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/EditEveryoneQuiet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).EditEveryoneQuiet(ctx, req.(*ReqEditEveryoneQuiet))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_EditBanChannelUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqEditBanChannelUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).EditBanChannelUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/EditBanChannelUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).EditBanChannelUser(ctx, req.(*ReqEditBanChannelUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetUserInfoByPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserByphone)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetUserInfoByPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetUserInfoByPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetUserInfoByPhone(ctx, req.(*GetUserByphone))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_SendCodeMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqSendCodeMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).SendCodeMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/SendCodeMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).SendCodeMsg(ctx, req.(*ReqSendCodeMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GroupLiveStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiveStartReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GroupLiveStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GroupLiveStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GroupLiveStart(ctx, req.(*LiveStartReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GroupLiveStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LiveStopReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GroupLiveStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GroupLiveStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GroupLiveStop(ctx, req.(*LiveStopReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetLiveInviteUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiveInviteUrlReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetLiveInviteUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetLiveInviteUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetLiveInviteUrl(ctx, req.(*GetLiveInviteUrlReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_CheckUserName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserNameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).CheckUserName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/CheckUserName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).CheckUserName(ctx, req.(*CheckUserNameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_EditLiveInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditLiveInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).EditLiveInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/EditLiveInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).EditLiveInfo(ctx, req.(*EditLiveInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GroupLiveCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupLiveCheckReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GroupLiveCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GroupLiveCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GroupLiveCheck(ctx, req.(*GroupLiveCheckReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetLiveInviteCnt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLiveInviteCntReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetLiveInviteCnt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetLiveInviteCnt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetLiveInviteCnt(ctx, req.(*GetLiveInviteCntReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_KickFromChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqKickFromChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).KickFromChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/KickFromChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).KickFromChannel(ctx, req.(*ReqKickFromChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_CheckUserInGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserInGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).CheckUserInGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/CheckUserInGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).CheckUserInGroup(ctx, req.(*CheckUserInGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_LivePush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LivePushReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).LivePush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/LivePush",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).LivePush(ctx, req.(*LivePushReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiGatewayService_GetGroupUserIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupUserIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiGatewayServiceServer).GetGroupUserIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imapigateway.ApiGatewayService/GetGroupUserIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiGatewayServiceServer).GetGroupUserIds(ctx, req.(*GetGroupUserIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ApiGatewayService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imapigateway.ApiGatewayService",
	HandlerType: (*ApiGatewayServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterUserInfo",
			Handler:    _ApiGatewayService_RegisterUserInfo_Handler,
		},
		{
			MethodName: "RegisterRedBotInfo",
			Handler:    _ApiGatewayService_RegisterRedBotInfo_Handler,
		},
		{
			MethodName: "UpdateUserName",
			Handler:    _ApiGatewayService_UpdateUserName_Handler,
		},
		{
			MethodName: "DeleteUserInfoById",
			Handler:    _ApiGatewayService_DeleteUserInfoById_Handler,
		},
		{
			MethodName: "DeleteMessages",
			Handler:    _ApiGatewayService_DeleteMessages_Handler,
		},
		{
			MethodName: "BotCall",
			Handler:    _ApiGatewayService_BotCall_Handler,
		},
		{
			MethodName: "GetMessageByUserIdMsgId",
			Handler:    _ApiGatewayService_GetMessageByUserIdMsgId_Handler,
		},
		{
			MethodName: "GetFullChannel",
			Handler:    _ApiGatewayService_GetFullChannel_Handler,
		},
		{
			MethodName: "GetChannelDifference",
			Handler:    _ApiGatewayService_GetChannelDifference_Handler,
		},
		{
			MethodName: "GetParticipants",
			Handler:    _ApiGatewayService_GetParticipants_Handler,
		},
		{
			MethodName: "GetAllChats",
			Handler:    _ApiGatewayService_GetAllChats_Handler,
		},
		{
			MethodName: "LeaveChannel",
			Handler:    _ApiGatewayService_LeaveChannel_Handler,
		},
		{
			MethodName: "UpdatePinnedChannelMessage",
			Handler:    _ApiGatewayService_UpdatePinnedChannelMessage_Handler,
		},
		{
			MethodName: "UpdateUserProfile",
			Handler:    _ApiGatewayService_UpdateUserProfile_Handler,
		},
		{
			MethodName: "UpdateBotInfo",
			Handler:    _ApiGatewayService_UpdateBotInfo_Handler,
		},
		{
			MethodName: "EditChannelTitle",
			Handler:    _ApiGatewayService_EditChannelTitle_Handler,
		},
		{
			MethodName: "EditChannelAbout",
			Handler:    _ApiGatewayService_EditChannelAbout_Handler,
		},
		{
			MethodName: "UploadFile",
			Handler:    _ApiGatewayService_UploadFile_Handler,
		},
		{
			MethodName: "GatewayUploadFileDesc",
			Handler:    _ApiGatewayService_GatewayUploadFileDesc_Handler,
		},
		{
			MethodName: "SendRDP",
			Handler:    _ApiGatewayService_SendRDP_Handler,
		},
		{
			MethodName: "CheckRDP",
			Handler:    _ApiGatewayService_CheckRDP_Handler,
		},
		{
			MethodName: "ReceiveRDP",
			Handler:    _ApiGatewayService_ReceiveRDP_Handler,
		},
		{
			MethodName: "GetFullUser",
			Handler:    _ApiGatewayService_GetFullUser_Handler,
		},
		{
			MethodName: "GetUserInfoById",
			Handler:    _ApiGatewayService_GetUserInfoById_Handler,
		},
		{
			MethodName: "SendRedGame",
			Handler:    _ApiGatewayService_SendRedGame_Handler,
		},
		{
			MethodName: "ReceiveRedGame",
			Handler:    _ApiGatewayService_ReceiveRedGame_Handler,
		},
		{
			MethodName: "QueryRedGame",
			Handler:    _ApiGatewayService_QueryRedGame_Handler,
		},
		{
			MethodName: "GetUserIdByUserName",
			Handler:    _ApiGatewayService_GetUserIdByUserName_Handler,
		},
		{
			MethodName: "SetUserDetail",
			Handler:    _ApiGatewayService_SetUserDetail_Handler,
		},
		{
			MethodName: "UpdateBotPic",
			Handler:    _ApiGatewayService_UpdateBotPic_Handler,
		},
		{
			MethodName: "DownloadFile",
			Handler:    _ApiGatewayService_DownloadFile_Handler,
		},
		{
			MethodName: "OtherTrans",
			Handler:    _ApiGatewayService_OtherTrans_Handler,
		},
		{
			MethodName: "IntegralUniversalBusiness",
			Handler:    _ApiGatewayService_IntegralUniversalBusiness_Handler,
		},
		{
			MethodName: "GetChannelMsg",
			Handler:    _ApiGatewayService_GetChannelMsg_Handler,
		},
		{
			MethodName: "SetBotVerified",
			Handler:    _ApiGatewayService_SetBotVerified_Handler,
		},
		{
			MethodName: "GetMessageByUserIdUuid",
			Handler:    _ApiGatewayService_GetMessageByUserIdUuid_Handler,
		},
		{
			MethodName: "ContactsGetCommonContacts",
			Handler:    _ApiGatewayService_ContactsGetCommonContacts_Handler,
		},
		{
			MethodName: "UpdateMoments",
			Handler:    _ApiGatewayService_UpdateMoments_Handler,
		},
		{
			MethodName: "ContactsGetContacts",
			Handler:    _ApiGatewayService_ContactsGetContacts_Handler,
		},
		{
			MethodName: "CheckIsMuteContact",
			Handler:    _ApiGatewayService_CheckIsMuteContact_Handler,
		},
		{
			MethodName: "MomentNotify",
			Handler:    _ApiGatewayService_MomentNotify_Handler,
		},
		{
			MethodName: "SearchUserByNickname",
			Handler:    _ApiGatewayService_SearchUserByNickname_Handler,
		},
		{
			MethodName: "SendMediaSysNotify",
			Handler:    _ApiGatewayService_SendMediaSysNotify_Handler,
		},
		{
			MethodName: "MomentFollow",
			Handler:    _ApiGatewayService_MomentFollow_Handler,
		},
		{
			MethodName: "CheckIsSelfContact",
			Handler:    _ApiGatewayService_CheckIsSelfContact_Handler,
		},
		{
			MethodName: "GetUserInfoByIdArr",
			Handler:    _ApiGatewayService_GetUserInfoByIdArr_Handler,
		},
		{
			MethodName: "GetChannelUserInfo",
			Handler:    _ApiGatewayService_GetChannelUserInfo_Handler,
		},
		{
			MethodName: "EditEveryoneQuiet",
			Handler:    _ApiGatewayService_EditEveryoneQuiet_Handler,
		},
		{
			MethodName: "EditBanChannelUser",
			Handler:    _ApiGatewayService_EditBanChannelUser_Handler,
		},
		{
			MethodName: "GetUserInfoByPhone",
			Handler:    _ApiGatewayService_GetUserInfoByPhone_Handler,
		},
		{
			MethodName: "SendCodeMsg",
			Handler:    _ApiGatewayService_SendCodeMsg_Handler,
		},
		{
			MethodName: "GroupLiveStart",
			Handler:    _ApiGatewayService_GroupLiveStart_Handler,
		},
		{
			MethodName: "GroupLiveStop",
			Handler:    _ApiGatewayService_GroupLiveStop_Handler,
		},
		{
			MethodName: "GetLiveInviteUrl",
			Handler:    _ApiGatewayService_GetLiveInviteUrl_Handler,
		},
		{
			MethodName: "CheckUserName",
			Handler:    _ApiGatewayService_CheckUserName_Handler,
		},
		{
			MethodName: "EditLiveInfo",
			Handler:    _ApiGatewayService_EditLiveInfo_Handler,
		},
		{
			MethodName: "GroupLiveCheck",
			Handler:    _ApiGatewayService_GroupLiveCheck_Handler,
		},
		{
			MethodName: "GetLiveInviteCnt",
			Handler:    _ApiGatewayService_GetLiveInviteCnt_Handler,
		},
		{
			MethodName: "KickFromChannel",
			Handler:    _ApiGatewayService_KickFromChannel_Handler,
		},
		{
			MethodName: "CheckUserInGroup",
			Handler:    _ApiGatewayService_CheckUserInGroup_Handler,
		},
		{
			MethodName: "LivePush",
			Handler:    _ApiGatewayService_LivePush_Handler,
		},
		{
			MethodName: "GetGroupUserIds",
			Handler:    _ApiGatewayService_GetGroupUserIds_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imapigateway/imapigateway.proto",
}

func (m *GetGroupUserIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGroupUserIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChanId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChanId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Offset))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Length))
	}
	return i, nil
}

func (m *GetGroupUserIdsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetGroupUserIdsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RetNo != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.RetNo))
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Total))
	}
	if m.Count != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Count))
	}
	if len(m.Users) > 0 {
		dAtA2 := make([]byte, len(m.Users)*10)
		var j1 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *LiveStartReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiveStartReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BeginAt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BeginAt))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.LiveStat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveStat))
	}
	if m.LiveType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveType))
	}
	if m.LiveUser != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveUser))
	}
	if m.LiveRoom != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveRoom))
	}
	if m.LivePkId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LivePkId))
	}
	if len(m.LiveFlag) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LiveFlag)))
		i += copy(dAtA[i:], m.LiveFlag)
	}
	if len(m.LiveName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LiveName)))
		i += copy(dAtA[i:], m.LiveName)
	}
	if len(m.LiveIcon) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LiveIcon)))
		i += copy(dAtA[i:], m.LiveIcon)
	}
	return i, nil
}

func (m *LiveStartRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiveStartRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReplyCode))
	}
	if len(m.InviteUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.InviteUrl)))
		i += copy(dAtA[i:], m.InviteUrl)
	}
	return i, nil
}

func (m *LiveStopReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiveStopReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveUser))
	}
	if m.LiveStat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveStat))
	}
	if len(m.LiveCode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LiveCode)))
		i += copy(dAtA[i:], m.LiveCode)
	}
	return i, nil
}

func (m *LiveStopRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiveStopRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RetCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.RetCode))
	}
	if m.Invited != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Invited))
	}
	return i, nil
}

func (m *GetLiveInviteUrlReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveInviteUrlReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BeginAt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BeginAt))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveUser))
	}
	return i, nil
}

func (m *GetLiveInviteUrlRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveInviteUrlRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReplyCode))
	}
	if len(m.InviteUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.InviteUrl)))
		i += copy(dAtA[i:], m.InviteUrl)
	}
	return i, nil
}

func (m *EditLiveInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditLiveInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BeginAt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BeginAt))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.LiveStat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveStat))
	}
	if m.LiveType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveType))
	}
	if m.LiveUser != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveUser))
	}
	if m.LiveRoom != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveRoom))
	}
	if len(m.LiveFlag) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LiveFlag)))
		i += copy(dAtA[i:], m.LiveFlag)
	}
	if len(m.LiveName) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LiveName)))
		i += copy(dAtA[i:], m.LiveName)
	}
	if len(m.LiveIcon) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LiveIcon)))
		i += copy(dAtA[i:], m.LiveIcon)
	}
	return i, nil
}

func (m *EditLiveInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditLiveInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReplyCode))
	}
	if len(m.ReplyData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReplyData)))
		i += copy(dAtA[i:], m.ReplyData)
	}
	return i, nil
}

func (m *GroupLiveCheckReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupLiveCheckReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveUser))
	}
	return i, nil
}

func (m *GroupLiveCheckRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupLiveCheckRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReplyCode))
	}
	if len(m.ReplyData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReplyData)))
		i += copy(dAtA[i:], m.ReplyData)
	}
	return i, nil
}

func (m *GetLiveInviteCntReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveInviteCntReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.LiveUser))
	}
	return i, nil
}

func (m *GetLiveInviteCntRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLiveInviteCntRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RetCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.RetCode))
	}
	if m.Invited != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Invited))
	}
	return i, nil
}

func (m *CheckUserInGroupReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUserInGroupReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *CheckUserInGroupRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUserInGroupRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InGroup {
		dAtA[i] = 0x8
		i++
		if m.InGroup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LivePushReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LivePushReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA4 := make([]byte, len(m.UserIds)*10)
		var j3 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.SelfId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if m.Type != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *LivePushResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LivePushResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReqKickFromChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqKickFromChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.Kicker != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Kicker))
	}
	if m.Kickee != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Kickee))
	}
	if m.IsBotUser {
		dAtA[i] = 0x20
		i++
		if m.IsBotUser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsKicked {
		dAtA[i] = 0x28
		i++
		if m.IsKicked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KickedId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.KickedId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n5, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *CheckUserNameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUserNameReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n6, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CheckUserNameResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUserNameResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Occpuy {
		dAtA[i] = 0x8
		i++
		if m.Occpuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorMsg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ErrorMsg)))
		i += copy(dAtA[i:], m.ErrorMsg)
	}
	return i, nil
}

func (m *ReqSendCodeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSendCodeMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Userid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Keyid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Keyid))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n7, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ChannelBannedRights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelBannedRights) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if m.ViewMessages {
		dAtA[i] = 0x10
		i++
		if m.ViewMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendMessages {
		dAtA[i] = 0x18
		i++
		if m.SendMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendMedia {
		dAtA[i] = 0x20
		i++
		if m.SendMedia {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendStickers {
		dAtA[i] = 0x28
		i++
		if m.SendStickers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendGifs {
		dAtA[i] = 0x30
		i++
		if m.SendGifs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendGames {
		dAtA[i] = 0x38
		i++
		if m.SendGames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendInline {
		dAtA[i] = 0x40
		i++
		if m.SendInline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EmbedLinks {
		dAtA[i] = 0x48
		i++
		if m.EmbedLinks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UntilDate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UntilDate))
	}
	if m.InviteUser {
		dAtA[i] = 0x58
		i++
		if m.InviteUser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PinMessage {
		dAtA[i] = 0x60
		i++
		if m.PinMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChangeGroupInfo {
		dAtA[i] = 0x68
		i++
		if m.ChangeGroupInfo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendPolls {
		dAtA[i] = 0x70
		i++
		if m.SendPolls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReqEditBanChannelUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqEditBanChannelUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.BannedUserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BannedUserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.UtilDate != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UtilDate))
	}
	if m.ChannelBannedRights != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelBannedRights.Size()))
		n8, err := m.ChannelBannedRights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n9, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *ReqEditEveryoneQuiet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqEditEveryoneQuiet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.Quiet {
		dAtA[i] = 0x18
		i++
		if m.Quiet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n10, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *GetChannelUserInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelUserInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n11, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *GetChannelUserInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelUserInfoResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	return i, nil
}

func (m *CheckIsSelfContactReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckIsSelfContactReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n12, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *CheckIsSelfContactResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckIsSelfContactResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSelfContact {
		dAtA[i] = 0x8
		i++
		if m.IsSelfContact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *MomentFollowReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MomentFollowReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.FollowId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FollowId))
	}
	if m.IsFollow != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.IsFollow))
	}
	return i, nil
}

func (m *MomentFollowResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MomentFollowResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *MomentData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MomentData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ForumId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ForumId))
	}
	if m.ForumType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ForumType))
	}
	if len(m.ForumImage) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ForumImage)))
		i += copy(dAtA[i:], m.ForumImage)
	}
	if len(m.ForumText) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ForumText)))
		i += copy(dAtA[i:], m.ForumText)
	}
	if m.WithId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.WithId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MsgId))
	}
	if len(m.MsgContent) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MsgContent)))
		i += copy(dAtA[i:], m.MsgContent)
	}
	if m.IsFollowed != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.IsFollowed))
	}
	return i, nil
}

func (m *SysNotifyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysNotifyData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MsgTitle) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MsgTitle)))
		i += copy(dAtA[i:], m.MsgTitle)
	}
	if m.MsgTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MsgTime))
	}
	if len(m.MsgUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MsgUrl)))
		i += copy(dAtA[i:], m.MsgUrl)
	}
	if len(m.MsgButtonText) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MsgButtonText)))
		i += copy(dAtA[i:], m.MsgButtonText)
	}
	if m.InteractMsg != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.InteractMsg.Size()))
		n13, err := m.InteractMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.IsPush {
		dAtA[i] = 0x30
		i++
		if m.IsPush {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *NotifyMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotifyMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Seq))
	}
	if len(m.Fid) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Fid)))
		i += copy(dAtA[i:], m.Fid)
	}
	if len(m.ContentType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ContentType)))
		i += copy(dAtA[i:], m.ContentType)
	}
	if m.PartNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PartNum))
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if len(m.Md5) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Md5)))
		i += copy(dAtA[i:], m.Md5)
	}
	if m.Width != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *NotifyText) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NotifyText) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Seq))
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *SendMediaSysNotifyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMediaSysNotifyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SourceCode))
	}
	if m.BusinessCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BusinessCode))
	}
	if len(m.NotifyMedias) > 0 {
		for _, msg := range m.NotifyMedias {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NotifyTexts) > 0 {
		for _, msg := range m.NotifyTexts {
			dAtA[i] = 0x22
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Users) > 0 {
		dAtA15 := make([]byte, len(m.Users)*10)
		var j14 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	if m.Data != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Data.Size()))
		n16, err := m.Data.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.FromId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if len(m.MsgId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MsgId)))
		i += copy(dAtA[i:], m.MsgId)
	}
	return i, nil
}

func (m *FailUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FailUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.User))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *SucceedUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SucceedUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.User))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *SendMediaSysNotifyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMediaSysNotifyResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorMsg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ErrorMsg)))
		i += copy(dAtA[i:], m.ErrorMsg)
	}
	if len(m.FailUsers) > 0 {
		for _, msg := range m.FailUsers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SucceedUsers) > 0 {
		for _, msg := range m.SucceedUsers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SearchUserByNicknameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUserByNicknameReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nickname) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	if len(m.UserIds) > 0 {
		dAtA18 := make([]byte, len(m.UserIds)*10)
		var j17 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Offset))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Limit))
	}
	if m.SelfId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	return i, nil
}

func (m *SearchUserByNicknameResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUserByNicknameResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserInfos) > 0 {
		for _, msg := range m.UserInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Type))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Offset))
	}
	if m.Length != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Length))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *MomentNotifyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MomentNotifyData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SourceCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SourceCode))
	}
	if m.BusinessCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BusinessCode))
	}
	if m.ToId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ToId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.WithId))
	}
	if m.ForumId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ForumId))
	}
	if m.ForumType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ForumType))
	}
	if len(m.ForumImage) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ForumImage)))
		i += copy(dAtA[i:], m.ForumImage)
	}
	if len(m.ForumText) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ForumText)))
		i += copy(dAtA[i:], m.ForumText)
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MsgId))
	}
	if len(m.MsgContent) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MsgContent)))
		i += copy(dAtA[i:], m.MsgContent)
	}
	if m.IsFollowed != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.IsFollowed))
	}
	if m.MsgTime != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MsgTime))
	}
	if len(m.Entites) > 0 {
		for _, msg := range m.Entites {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MomentNotifyReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MomentNotifyReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MomentNotifyData) > 0 {
		for _, msg := range m.MomentNotifyData {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *MomentNotifyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MomentNotifyResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.ErrorMsg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ErrorMsg)))
		i += copy(dAtA[i:], m.ErrorMsg)
	}
	return i, nil
}

func (m *CheckIsMuteContactReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckIsMuteContactReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *CheckIsMuteContactResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckIsMuteContactResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	if m.Result {
		dAtA[i] = 0x10
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ContactInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContactInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.ContactId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ContactId))
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.IsSelfContacted {
		dAtA[i] = 0x28
		i++
		if m.IsSelfContacted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SelfIsContacted {
		dAtA[i] = 0x30
		i++
		if m.SelfIsContacted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StarMark {
		dAtA[i] = 0x38
		i++
		if m.StarMark {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.HasPhone {
		dAtA[i] = 0x40
		i++
		if m.HasPhone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if len(m.About) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.About)))
		i += copy(dAtA[i:], m.About)
	}
	return i, nil
}

func (m *ContatsGetContactsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContatsGetContactsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.KeyId))
	}
	if len(m.Contacthash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Contacthash)))
		i += copy(dAtA[i:], m.Contacthash)
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n19, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *ContatsGetContactsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContatsGetContactsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContactArr) > 0 {
		for _, msg := range m.ContactArr {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UserInfoArr) > 0 {
		for _, msg := range m.UserInfoArr {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *MomentState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MomentState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA21 := make([]byte, len(m.UserId)*10)
		var j20 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ReqUpdateMoments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateMoments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MomentStates) > 0 {
		for _, msg := range m.MomentStates {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SelfId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	return i, nil
}

func (m *ResUpdateMoments) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResUpdateMoments) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *ReqIntegralUniversalBusiness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqIntegralUniversalBusiness) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.ImUserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ImUserId))
	}
	if m.ImKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ImKeyId))
	}
	if m.BusinessId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BusinessId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ReplyIntegralUniversalBusiness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyIntegralUniversalBusiness) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *OtherTransReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OtherTransReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.KeyId))
	}
	if len(m.IpAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.IpAddr)))
		i += copy(dAtA[i:], m.IpAddr)
	}
	if m.ReqMessagId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReqMessagId))
	}
	if len(m.ReqBytes) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReqBytes)))
		i += copy(dAtA[i:], m.ReqBytes)
	}
	return i, nil
}

func (m *OtherTransResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OtherTransResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RespBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.RespBytes)))
		i += copy(dAtA[i:], m.RespBytes)
	}
	return i, nil
}

func (m *SetUserDetailReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUserDetailReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Sex != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Sex))
	}
	if m.Birthday != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Birthday))
	}
	if len(m.Extend) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Extend)))
		i += copy(dAtA[i:], m.Extend)
	}
	return i, nil
}

func (m *SetUserDetailResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUserDetailResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Successful {
		dAtA[i] = 0x8
		i++
		if m.Successful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetUserByUsernameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByUsernameReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	return i, nil
}

func (m *GetUserInfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserInfoResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uinfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Uinfo.Size()))
		n22, err := m.Uinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *SendGameRedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendGameRedReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if len(m.RdpRsp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.RdpRsp)))
		i += copy(dAtA[i:], m.RdpRsp)
	}
	return i, nil
}

func (m *QryGameRdpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QryGameRdpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	return i, nil
}

func (m *RcvGameRedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RcvGameRedReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if len(m.RdpRsp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.RdpRsp)))
		i += copy(dAtA[i:], m.RdpRsp)
	}
	return i, nil
}

func (m *GameRedResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameRedResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *SendRDPReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRDPReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Debug != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n23, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.ReqMessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReqMessageId))
	}
	if len(m.ReqBytes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReqBytes)))
		i += copy(dAtA[i:], m.ReqBytes)
	}
	if m.RedMessageId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.RedMessageId))
	}
	if m.RedChanelId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.RedChanelId))
	}
	return i, nil
}

func (m *SendRDPResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendRDPResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RespBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.RespBytes)))
		i += copy(dAtA[i:], m.RespBytes)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *CheckRDPReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRDPReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Debug != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n24, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ReqMessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReqMessageId))
	}
	if len(m.ReqBytes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReqBytes)))
		i += copy(dAtA[i:], m.ReqBytes)
	}
	return i, nil
}

func (m *CheckRDPResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckRDPResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RespBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.RespBytes)))
		i += copy(dAtA[i:], m.RespBytes)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReceiveRDPReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveRDPReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Debug != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n25, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.ReqMessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReqMessageId))
	}
	if len(m.ReqBytes) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReqBytes)))
		i += copy(dAtA[i:], m.ReqBytes)
	}
	return i, nil
}

func (m *ReceiveRDPResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveRDPResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RespBytes) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.RespBytes)))
		i += copy(dAtA[i:], m.RespBytes)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReplyEditChannelAbout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyEditChannelAbout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Succeed {
		dAtA[i] = 0x8
		i++
		if m.Succeed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReplyEditChannelTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyEditChannelTitle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *BotUpdateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotUpdateInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.BotInfoVersion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		dAtA[i] = 0x18
		i++
		if m.BotChatHistory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BotNoChat {
		dAtA[i] = 0x20
		i++
		if m.BotNoChat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n26, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *BotUpdateInfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BotUpdateInfoResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *ReplyUpdatePinnedChannelMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyUpdatePinnedChannelMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReplyLeaveChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyLeaveChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqGetAllChats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetAllChats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n27, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *ReplyGetAllChats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetAllChats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chats) > 0 {
		dAtA29 := make([]byte, len(m.Chats)*10)
		var j28 int
		for _, num1 := range m.Chats {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqGetchannelDifference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetchannelDifference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if m.Force {
		dAtA[i] = 0x20
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Pts))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Limit))
	}
	if m.Range_MinId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Range_MinId))
	}
	if m.Range_MaxId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Range_MaxId))
	}
	if m.Device != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Device))
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n30, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *ReplyChannelDiffCommon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyChannelDiffCommon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Difference) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Difference)))
		i += copy(dAtA[i:], m.Difference)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqFullchannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqFullchannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n31, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *ReplyFullChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyFullChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Updates)))
		i += copy(dAtA[i:], m.Updates)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqDeleteMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDeleteMessages) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if m.Revoke {
		dAtA[i] = 0x20
		i++
		if m.Revoke {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Id) > 0 {
		dAtA33 := make([]byte, len(m.Id)*10)
		var j32 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	if m.Channelid != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Channelid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n34, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *ReplyDeleteMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyDeleteMessages) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *RegisterUserInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterUserInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.IsBot {
		dAtA[i] = 0x30
		i++
		if m.IsBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BotInfoVersion != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		dAtA[i] = 0x40
		i++
		if m.BotChatHistory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BotNoChats {
		dAtA[i] = 0x48
		i++
		if m.BotNoChats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CountryCode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.CountryCode)))
		i += copy(dAtA[i:], m.CountryCode)
	}
	if len(m.LocalPhone) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LocalPhone)))
		i += copy(dAtA[i:], m.LocalPhone)
	}
	if m.Dc != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Dc))
	}
	if m.GroupNow != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupNow))
	}
	if m.Debug != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n35, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Sex != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Sex))
	}
	if m.Birthday != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Birthday))
	}
	return i, nil
}

func (m *ReqGetFullChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetFullChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n36, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *ReqGetParticipants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetParticipants) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OffSet != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.OffSet))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Limit))
	}
	if m.PartiType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PartiType))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if len(m.Q) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Q)))
		i += copy(dAtA[i:], m.Q)
	}
	if m.Hash != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Hash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n37, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *ReqUpdatePinnedChannelMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdatePinnedChannelMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if m.Silent {
		dAtA[i] = 0x18
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.Id != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n38, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *ReqEditChannelAbout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqEditChannelAbout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.About) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.About)))
		i += copy(dAtA[i:], m.About)
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n39, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *ReqEditChannelTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqEditChannelTitle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n40, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *ReplyChannelData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyChannelData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	return i, nil
}

func (m *ReqDelManualBlockList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDelManualBlockList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UnBlockUser != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UnBlockUser.Size()))
		n41, err := m.UnBlockUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.BotId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n42, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *ReqSetManualBlockList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetManualBlockList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockUser != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BlockUser.Size()))
		n43, err := m.BlockUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.BotId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n44, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *BlockUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.BlockTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BlockTime))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	return i, nil
}

func (m *ManualBlockReplyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManualBlockReplyData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReplyData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReplyData)))
		i += copy(dAtA[i:], m.ReplyData)
	}
	if m.Reply {
		dAtA[i] = 0x10
		i++
		if m.Reply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *StoreShopStickerSetDocumentsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreShopStickerSetDocumentsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if len(m.Documents) > 0 {
		dAtA46 := make([]byte, len(m.Documents)*10)
		var j45 int
		for _, num1 := range m.Documents {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA46[j45] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j45++
			}
			dAtA46[j45] = uint8(num)
			j45++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j45))
		i += copy(dAtA[i:], dAtA46[:j45])
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n47, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func (m *StoreShopStickerSetDocumentsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreShopStickerSetDocumentsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *AuthorStickerSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorStickerSet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.StickersetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.StickersetId))
	}
	if len(m.ShortName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ShortName)))
		i += copy(dAtA[i:], m.ShortName)
	}
	if m.Archived {
		dAtA[i] = 0x20
		i++
		if m.Archived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Installed {
		dAtA[i] = 0x28
		i++
		if m.Installed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Disabled {
		dAtA[i] = 0x30
		i++
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Ordered != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Ordered))
	}
	if m.Created != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Created))
	}
	if m.Updated != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Updated))
	}
	return i, nil
}

func (m *GetAuthorAllStickerSetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthorAllStickerSetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *GetAuthorAllStickerSetResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAuthorAllStickerSetResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	if len(m.Sets) > 0 {
		for _, msg := range m.Sets {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeleteStickerPackDocumentReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStickerPackDocumentReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if m.StickersetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.StickersetId))
	}
	return i, nil
}

func (m *DeleteStickerPackDocumentResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStickerPackDocumentResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *GetStickerSetInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStickerSetInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if len(m.ShortName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ShortName)))
		i += copy(dAtA[i:], m.ShortName)
	}
	if m.IsId {
		dAtA[i] = 0x18
		i++
		if m.IsId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n48, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *StickerSetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerSetInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Free {
		dAtA[i] = 0x18
		i++
		if m.Free {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Official {
		dAtA[i] = 0x20
		i++
		if m.Official {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Masks {
		dAtA[i] = 0x28
		i++
		if m.Masks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.ShortName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ShortName)))
		i += copy(dAtA[i:], m.ShortName)
	}
	if m.Count != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Count))
	}
	if m.Hash != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Hash))
	}
	if len(m.Emoticon) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Emoticon)))
		i += copy(dAtA[i:], m.Emoticon)
	}
	if len(m.Documents) > 0 {
		dAtA50 := make([]byte, len(m.Documents)*10)
		var j49 int
		for _, num1 := range m.Documents {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j49))
		i += copy(dAtA[i:], dAtA50[:j49])
	}
	return i, nil
}

func (m *GetStickerSetInfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStickerSetInfoResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StickerSetInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.StickerSetInfo.Size()))
		n51, err := m.StickerSetInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *DeleteStickerSetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStickerSetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StickerId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.StickerId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n52, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *DeleteStickerSetResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteStickerSetResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *StoreUserStickerSetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreUserStickerSetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.StickersetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.StickersetId))
	}
	if m.Installed {
		dAtA[i] = 0x18
		i++
		if m.Installed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Disabled {
		dAtA[i] = 0x20
		i++
		if m.Disabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Order != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Order))
	}
	if m.Archived {
		dAtA[i] = 0x30
		i++
		if m.Archived {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Debug != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n53, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	return i, nil
}

func (m *StoreUserStickerSetResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreUserStickerSetResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *StoreStickerPackDcReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStickerPackDcReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Stickpackbase != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Stickpackbase.Size()))
		n54, err := m.Stickpackbase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n55, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *StoreStickerPackDcResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStickerPackDcResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *StoreShopStickerSetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreShopStickerSetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AccessHash != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Free {
		dAtA[i] = 0x10
		i++
		if m.Free {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Official {
		dAtA[i] = 0x18
		i++
		if m.Official {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Masks {
		dAtA[i] = 0x20
		i++
		if m.Masks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.ShortName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ShortName)))
		i += copy(dAtA[i:], m.ShortName)
	}
	if m.Count != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Count))
	}
	if m.Hash != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Hash))
	}
	if len(m.Emoticon) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Emoticon)))
		i += copy(dAtA[i:], m.Emoticon)
	}
	if len(m.Documents) > 0 {
		dAtA57 := make([]byte, len(m.Documents)*10)
		var j56 int
		for _, num1 := range m.Documents {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA57[j56] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j56++
			}
			dAtA57[j56] = uint8(num)
			j56++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j56))
		i += copy(dAtA[i:], dAtA57[:j56])
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n58, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.UserId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *StoreShopStickerSetResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreShopStickerSetResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *ResizeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResizeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *ResizeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResizeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Status))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ConstraintRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.MaxSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MaxSize))
	}
	if m.OutputWebp {
		dAtA[i] = 0x18
		i++
		if m.OutputWebp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ConstraintReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConstraintReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Status))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Width != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Height))
	}
	if m.OriginWidth != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.OriginWidth))
	}
	if m.OriginHeight != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.OriginHeight))
	}
	return i, nil
}

func (m *CompressImageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompressImageRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Quality != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Quality))
	}
	return i, nil
}

func (m *CompressImageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompressImageReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Status))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *VideoPreviewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoPreviewRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.MaxSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MaxSize))
	}
	return i, nil
}

func (m *VideoPreviewReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoPreviewReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Status))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Duration))
	}
	if len(m.Preview) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Preview)))
		i += copy(dAtA[i:], m.Preview)
	}
	if m.Width != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *AudioPreviewRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioPreviewRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.MaxSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MaxSize))
	}
	return i, nil
}

func (m *AudioPreviewReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioPreviewReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Status))
	}
	if m.Duration != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Duration))
	}
	if len(m.Cover) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Cover)))
		i += copy(dAtA[i:], m.Cover)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Artist) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Artist)))
		i += copy(dAtA[i:], m.Artist)
	}
	if m.Width != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *ReqParticipants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqParticipants) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OffSet != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.OffSet))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Limit))
	}
	if m.PartiType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PartiType))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if len(m.Q) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Q)))
		i += copy(dAtA[i:], m.Q)
	}
	if m.Hash != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Hash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n59, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	return i, nil
}

func (m *ReplyParticipants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyParticipants) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Updates)))
		i += copy(dAtA[i:], m.Updates)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqCreateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqCreateChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chatid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Chatid))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.Creator != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Creator))
	}
	if len(m.Users) > 0 {
		dAtA61 := make([]byte, len(m.Users)*10)
		var j60 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j60))
		i += copy(dAtA[i:], dAtA61[:j60])
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n62, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *ReplyCreateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyCreateChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqMigrateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqMigrateChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Chatid))
	}
	if m.Fromkeyid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromkeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n63, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	return i, nil
}

func (m *ReplyMigrateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyMigrateChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqJoinChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqJoinChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.ByLink {
		dAtA[i] = 0x38
		i++
		if m.ByLink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Invitor != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Invitor))
	}
	if m.InviteType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.InviteType))
	}
	if m.Debug != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n64, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	return i, nil
}

func (m *ReplyJoinChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyJoinChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqChangeGroupAndChannelCrator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqChangeGroupAndChannelCrator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.GroupId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.OperatorId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.OperatorId))
	}
	if m.IsChat {
		dAtA[i] = 0x20
		i++
		if m.IsChat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReplyChangeGroupAndChannelCrator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyChangeGroupAndChannelCrator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Valid {
		dAtA[i] = 0x8
		i++
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqBotCallMessageMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqBotCallMessageMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromBotId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromBotId))
	}
	if len(m.MsgTxt) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MsgTxt)))
		i += copy(dAtA[i:], m.MsgTxt)
	}
	if len(m.Request) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Request)))
		i += copy(dAtA[i:], m.Request)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Layer))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n65, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	return i, nil
}

func (m *RequestDialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestDialog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Userid))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if m.OffsetDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.OffsetDate))
	}
	if m.OffsetId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.OffsetId))
	}
	if len(m.OffsetPeer) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.OffsetPeer)))
		i += copy(dAtA[i:], m.OffsetPeer)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Limit))
	}
	if m.Debug != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n66, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	return i, nil
}

func (m *ReplyDialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyDialog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *UserScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Userid))
	}
	if m.Score != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Score))
	}
	return i, nil
}

func (m *ReqSetGameScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetGameScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Userid))
	}
	if len(m.Scores) > 0 {
		for _, msg := range m.Scores {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Force {
		dAtA[i] = 0x18
		i++
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DisableEditMessage {
		dAtA[i] = 0x20
		i++
		if m.DisableEditMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatId))
	}
	if m.ChatType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatType))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MessageId))
	}
	if len(m.InlineMessageId) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.InlineMessageId)))
		i += copy(dAtA[i:], m.InlineMessageId)
	}
	if m.Botid != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Botid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n67, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	return i, nil
}

func (m *ReplySetGameScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplySetGameScore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Succeed {
		dAtA[i] = 0x8
		i++
		if m.Succeed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *ReplyBanChannelUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyBanChannelUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Updates)))
		i += copy(dAtA[i:], m.Updates)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqBanChannelUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqBanChannelUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.BannedUserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BannedUserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.UtilDate != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UtilDate))
	}
	if m.ChannelBannedRights != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelBannedRights.Size()))
		n68, err := m.ChannelBannedRights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n69, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	return i, nil
}

func (m *ReqGetChannels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetChannels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelIds) > 0 {
		dAtA71 := make([]byte, len(m.ChannelIds)*10)
		var j70 int
		for _, num1 := range m.ChannelIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j70))
		i += copy(dAtA[i:], dAtA71[:j70])
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n72, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	return i, nil
}

func (m *ReplyGetChannels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetChannels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqDeleteChatUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDeleteChatUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Chatid))
	}
	if m.Userid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Userid))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n73, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *ReplyDeleteChatUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyDeleteChatUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ChannelInactiveUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelInactiveUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Time))
	}
	if len(m.TimeStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.TimeStr)))
		i += copy(dAtA[i:], m.TimeStr)
	}
	return i, nil
}

func (m *GetChannelInactiveUsersReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelInactiveUsersReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Limit))
	}
	if m.Userid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Userid))
	}
	return i, nil
}

func (m *GetChannelInactiveUsersResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelInactiveUsersResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Count))
	}
	if m.Errcode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errcode))
	}
	return i, nil
}

func (m *ReqBotInlineCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqBotInlineCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Debug != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n74, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.BotId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MessageId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.KeyId))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SessionId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *ReplyBotInlineCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyBotInlineCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Inlinecall != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Inlinecall.Size()))
		n75, err := m.Inlinecall.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	return i, nil
}

func (m *InlineCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InlineCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MsgId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatId))
	}
	if m.ChatType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatType))
	}
	if m.BotId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotId))
	}
	return i, nil
}

func (m *ReqSendUserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSendUserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.FromKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyId))
	}
	if m.Toid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Toid))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n76, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func (m *ReplyBool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyBool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqBotCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqBotCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FrombotId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FrombotId))
	}
	if len(m.Request) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Request)))
		i += copy(dAtA[i:], m.Request)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Layer))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n77, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	return i, nil
}

func (m *ReplyBotCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyBotCall) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqGetMessageByUserIdUuid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetMessageByUserIdUuid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.Uuid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Uuid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n78, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *ReplyGetMessageByUserIdUuid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetMessageByUserIdUuid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserMessage.Size()))
		n79, err := m.UserMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqGetChannelMessageByChannelIdMsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetChannelMessageByChannelIdMsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MsgId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n80, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	return i, nil
}

func (m *ReplyGetChannelMessageByChannelIdMsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetChannelMessageByChannelIdMsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserMessage.Size()))
		n81, err := m.UserMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqGetMessageByUserIdMsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetMessageByUserIdMsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.MsgId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n82, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	return i, nil
}

func (m *ReplyGetMessageByUserIdMsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetMessageByUserIdMsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserMessage.Size()))
		n83, err := m.UserMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *MsgFileDescReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFileDescReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgFileDescResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFileDescResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgServiceLimitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgServiceLimitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reserved != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Reserved))
	}
	return i, nil
}

func (m *MsgServiceLimitResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgServiceLimitResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Usfsl != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Usfsl))
	}
	if m.Ubfssl != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Ubfssl))
	}
	if m.Dssl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Dssl))
	}
	return i, nil
}

func (m *MsgGetFidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fileid))
	}
	if m.FileType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FileType))
	}
	if len(m.Md5) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Md5)))
		i += copy(dAtA[i:], m.Md5)
	}
	if m.PartTotal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PartTotal))
	}
	return i, nil
}

func (m *MsgGetFidResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFidResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FileSize))
	}
	if m.Result != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgFilePartsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFilePartsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fileid))
	}
	if m.PartId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PartId))
	}
	if m.FileType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FileType))
	}
	if m.PartTotal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PartTotal))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgFilePartsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFilePartsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgUploadFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUploadFileReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para1 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Para1.Size()))
		n84, err := m.Para1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.Para2 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Para2.Size()))
		n85, err := m.Para2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgUploadFileResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUploadFileResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Result))
	}
	if m.Para1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Para1.Size()))
		n86, err := m.Para1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.Para2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Para2.Size()))
		n87, err := m.Para2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgDownloadFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDownloadFileReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Offset))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Length))
	}
	return i, nil
}

func (m *DownloadFileRespPara1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileRespPara1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fid))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Offset))
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	return i, nil
}

func (m *DownloadFileRespPara2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileRespPara2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Length))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgDownloadFileResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDownloadFileResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Result))
	}
	if m.Para1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Para1.Size()))
		n88, err := m.Para1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.Para2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Para2.Size()))
		n89, err := m.Para2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	return i, nil
}

func (m *MsgQueryObjInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgQueryObjInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fid))
	}
	return i, nil
}

func (m *QueryObjInfoRespPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryObjInfoRespPara) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Size_))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgQueryObjInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgQueryObjInfoResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Para.Size()))
		n90, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetFileDescReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFileDescReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgGetFileDescResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFileDescResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Result))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *GetChannelInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Dlog != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Dlog.Size()))
		n91, err := m.Dlog.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	return i, nil
}

func (m *GetChannelInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelInfoResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaseInfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BaseInfo.Size()))
		n92, err := m.BaseInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.Resultcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Resultcode))
	}
	return i, nil
}

func (m *ReqGetAdminGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetAdminGroups) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserID))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n93, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	return i, nil
}

func (m *ReqGetGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetGroups) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserID))
	}
	if m.PeerFilter != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PeerFilter))
	}
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PeerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.PeerID))
	}
	if len(m.PeerName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.PeerName)))
		i += copy(dAtA[i:], m.PeerName)
	}
	return i, nil
}

func (m *ReplyGetGroups) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetGroups) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, msg := range m.Groups {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SuperGroups) > 0 {
		for _, msg := range m.SuperGroups {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Channels) > 0 {
		for _, msg := range m.Channels {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqDeleteMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDeleteMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatType))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatId))
	}
	if len(m.MsgId) > 0 {
		dAtA95 := make([]byte, len(m.MsgId)*10)
		var j94 int
		for _, num1 := range m.MsgId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA95[j94] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j94++
			}
			dAtA95[j94] = uint8(num)
			j94++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j94))
		i += copy(dAtA[i:], dAtA95[:j94])
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n96, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	return i, nil
}

func (m *ReqSendChatAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSendChatAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatType))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatId))
	}
	if len(m.ActionData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ActionData)))
		i += copy(dAtA[i:], m.ActionData)
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n97, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	return i, nil
}

func (m *ReqData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatType))
	}
	if len(m.ReqData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReqData)))
		i += copy(dAtA[i:], m.ReqData)
	}
	if m.BotId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotId))
	}
	return i, nil
}

func (m *ReplyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqGetChatMembersCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetChatMembersCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatType))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n98, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	return i, nil
}

func (m *ReplyGetChatMembersCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetChatMembersCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatMembersCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatMembersCount))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *GetChatInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChatInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChatId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.RobotGet {
		dAtA[i] = 0x18
		i++
		if m.RobotGet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Dlog != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Dlog.Size()))
		n99, err := m.Dlog.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	return i, nil
}

func (m *GetUsersChatsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUsersChatsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Userid))
	}
	if len(m.Users) > 0 {
		dAtA101 := make([]byte, len(m.Users)*10)
		var j100 int
		for _, num1 := range m.Users {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA101[j100] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j100++
			}
			dAtA101[j100] = uint8(num)
			j100++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j100))
		i += copy(dAtA[i:], dAtA101[:j100])
	}
	if len(m.Chatid) > 0 {
		dAtA103 := make([]byte, len(m.Chatid)*10)
		var j102 int
		for _, num1 := range m.Chatid {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA103[j102] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j102++
			}
			dAtA103[j102] = uint8(num)
			j102++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j102))
		i += copy(dAtA[i:], dAtA103[:j102])
	}
	if len(m.Channelid) > 0 {
		dAtA105 := make([]byte, len(m.Channelid)*10)
		var j104 int
		for _, num1 := range m.Channelid {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA105[j104] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j104++
			}
			dAtA105[j104] = uint8(num)
			j104++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j104))
		i += copy(dAtA[i:], dAtA105[:j104])
	}
	if m.ProtocolLayer != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ProtocolLayer))
	}
	if m.Dlog != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Dlog.Size()))
		n106, err := m.Dlog.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	return i, nil
}

func (m *GetUsersChatsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUsersChatsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, b := range m.Channels {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Users != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Users.Size()))
		n107, err := m.Users.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	if len(m.Chats) > 0 {
		for _, b := range m.Chats {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.NoChats) > 0 {
		dAtA109 := make([]byte, len(m.NoChats)*10)
		var j108 int
		for _, num1 := range m.NoChats {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA109[j108] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j108++
			}
			dAtA109[j108] = uint8(num)
			j108++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j108))
		i += copy(dAtA[i:], dAtA109[:j108])
	}
	if len(m.NoChans) > 0 {
		dAtA111 := make([]byte, len(m.NoChans)*10)
		var j110 int
		for _, num1 := range m.NoChans {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA111[j110] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j110++
			}
			dAtA111[j110] = uint8(num)
			j110++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j110))
		i += copy(dAtA[i:], dAtA111[:j110])
	}
	if m.Resultcode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Resultcode))
	}
	return i, nil
}

func (m *GetUserInfoByIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserInfoByIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n112, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	return i, nil
}

func (m *GetUserInfoByIdArrReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserInfoByIdArrReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if len(m.UserIds) > 0 {
		dAtA114 := make([]byte, len(m.UserIds)*10)
		var j113 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA114[j113] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j113++
			}
			dAtA114[j113] = uint8(num)
			j113++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j113))
		i += copy(dAtA[i:], dAtA114[:j113])
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n115, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	return i, nil
}

func (m *UpdateUserProfileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserProfileReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.About) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.About)))
		i += copy(dAtA[i:], m.About)
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n116, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	return i, nil
}

func (m *UpdateUserProfileResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserProfileResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uinfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Uinfo.Size()))
		n117, err := m.Uinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *GetUserByphone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByphone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phone) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n118, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n118
	}
	return i, nil
}

func (m *UpdateBotInfoSuppReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBotInfoSuppReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if len(m.Placeholder) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Placeholder)))
		i += copy(dAtA[i:], m.Placeholder)
	}
	if m.Geo {
		dAtA[i] = 0x18
		i++
		if m.Geo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n119, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n119
	}
	return i, nil
}

func (m *UpdateBotInfoSuppResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBotInfoSuppResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *UpdateBotPicRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBotPicRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BotId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotId))
	}
	if len(m.Photo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Photo)))
		i += copy(dAtA[i:], m.Photo)
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n120, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n120
	}
	return i, nil
}

func (m *UpdateBotPicResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateBotPicResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *UpdateuserNameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateuserNameReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if len(m.UserName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.UserName)))
		i += copy(dAtA[i:], m.UserName)
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n121, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n121
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *UpdateuserNameResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateuserNameResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uinfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Uinfo.Size()))
		n122, err := m.Uinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *RegisterUserInfoResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterUserInfoResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uinfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Uinfo.Size()))
		n123, err := m.Uinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *DeleteAccountByIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteAccountByIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.DelId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.DelId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n124, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n124
	}
	return i, nil
}

func (m *DelAccountResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelAccountResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *SignUpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignUpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.PhoneCodeHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.PhoneCodeHash)))
		i += copy(dAtA[i:], m.PhoneCodeHash)
	}
	if len(m.PhoneCode) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.PhoneCode)))
		i += copy(dAtA[i:], m.PhoneCode)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.KeyId))
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.IsBot {
		dAtA[i] = 0x40
		i++
		if m.IsBot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BotInfoVersion != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		dAtA[i] = 0x50
		i++
		if m.BotChatHistory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BotNoChats {
		dAtA[i] = 0x58
		i++
		if m.BotNoChats {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DcId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.DcId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n125, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n125
	}
	if len(m.CountryCode) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.CountryCode)))
		i += copy(dAtA[i:], m.CountryCode)
	}
	if len(m.LocalPhone) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.LocalPhone)))
		i += copy(dAtA[i:], m.LocalPhone)
	}
	return i, nil
}

func (m *AuthSignUpResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthSignUpResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Code))
	}
	if m.UserInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserInfo.Size()))
		n126, err := m.UserInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n126
	}
	return i, nil
}

func (m *GetFullUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFullUserReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n127, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n127
	}
	return i, nil
}

func (m *GetFullUserResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFullUserResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uinfo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Uinfo.Size()))
		n128, err := m.Uinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n128
	}
	if m.Isblocked {
		dAtA[i] = 0x10
		i++
		if m.Isblocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PhoneCallsPrivate {
		dAtA[i] = 0x18
		i++
		if m.PhoneCallsPrivate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PhoneCallsAvailable {
		dAtA[i] = 0x20
		i++
		if m.PhoneCallsAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.About) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.About)))
		i += copy(dAtA[i:], m.About)
	}
	if m.CommonChat != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.CommonChat))
	}
	if len(m.Extend) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Extend)))
		i += copy(dAtA[i:], m.Extend)
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *GetUserByUsername) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserByUsername) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SelfId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.SelfId))
	}
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n129, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n129
	}
	return i, nil
}

func (m *ReqGetFullChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetFullChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Chatid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n130, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n130
	}
	return i, nil
}

func (m *ReplyGetFullChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetFullChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqLeaveChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqLeaveChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n131, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n131
	}
	return i, nil
}

func (m *ReqSendMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSendMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Flags))
	}
	if m.Silent {
		dAtA[i] = 0x18
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Background {
		dAtA[i] = 0x20
		i++
		if m.Background {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClearDraft {
		dAtA[i] = 0x28
		i++
		if m.ClearDraft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Peer) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Peer)))
		i += copy(dAtA[i:], m.Peer)
	}
	if m.ReplyToMsgId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ReplyToMsgId))
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.MultiMedia) > 0 {
		for _, b := range m.MultiMedia {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.RandomId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.RandomId))
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if m.Newfileid != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Newfileid))
	}
	if m.FromkeyId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromkeyId))
	}
	if len(m.Chatmeber) > 0 {
		dAtA133 := make([]byte, len(m.Chatmeber)*10)
		var j132 int
		for _, num1 := range m.Chatmeber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA133[j132] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j132++
			}
			dAtA133[j132] = uint8(num)
			j132++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j132))
		i += copy(dAtA[i:], dAtA133[:j132])
	}
	if m.Debug != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n134, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n134
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.ViaBotId))
	}
	return i, nil
}

func (m *ReplyResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReqEditChatTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqEditChatTitle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Chatid))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n135, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n135
	}
	return i, nil
}

func (m *ReplyEditChatTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyEditChatTitle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *GetStickerSetPackDcInfosReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStickerSetPackDcInfosReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Debug.Size()))
		n136, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n136
	}
	return i, nil
}

func (m *GetStickerSetPackDcInfosResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStickerSetPackDcInfosResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StPDcInfo) > 0 {
		for _, msg := range m.StPDcInfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StickerPackDocumentBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerPackDocumentBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AttributesStikerSetId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AttributesStikerSetId))
	}
	if m.DocumentId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.DocumentId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AccessHash))
	}
	if len(m.MimeType) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.MimeType)))
		i += copy(dAtA[i:], m.MimeType)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Size_))
	}
	if len(m.Thumb) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.Thumb)))
		i += copy(dAtA[i:], m.Thumb)
	}
	if m.DcId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.DcId))
	}
	if m.Date != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Date))
	}
	if m.AttributesImageSizeW != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AttributesImageSizeW))
	}
	if m.AttributesImageSizeH != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AttributesImageSizeH))
	}
	if len(m.AttributesStikerAlt) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.AttributesStikerAlt)))
		i += copy(dAtA[i:], m.AttributesStikerAlt)
	}
	if m.AttributesStikerSetAccessHash != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.AttributesStikerSetAccessHash))
	}
	if len(m.AttributesFileName) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(len(m.AttributesFileName)))
		i += copy(dAtA[i:], m.AttributesFileName)
	}
	return i, nil
}

func (m *StickerPackDocumentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StickerPackDocumentInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Id))
	}
	if m.InfoBase != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.InfoBase.Size()))
		n137, err := m.InfoBase.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	return i, nil
}

func (m *GetUserInfoByIdArrResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserInfoByIdArrResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uinfo) > 0 {
		for _, msg := range m.Uinfo {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *SetBotVerifiedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBotVerifiedReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.UserId))
	}
	if m.Verified {
		dAtA[i] = 0x10
		i++
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetBotVerifiedReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetBotVerifiedReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func (m *ContactsGetCommonContactsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContactsGetCommonContactsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA139 := make([]byte, len(m.UserIds)*10)
		var j138 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA139[j138] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j138++
			}
			dAtA139[j138] = uint8(num)
			j138++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(j138))
		i += copy(dAtA[i:], dAtA139[:j138])
	}
	return i, nil
}

func (m *ContactsGetCommonContactsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContactsGetCommonContactsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserInfos) > 0 {
		for _, msg := range m.UserInfos {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImapigateway(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Errorcode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImapigateway(dAtA, i, uint64(m.Errorcode))
	}
	return i, nil
}

func encodeVarintImapigateway(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetGroupUserIdsReq) Size() (n int) {
	var l int
	_ = l
	if m.ChanId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChanId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.Offset != 0 {
		n += 1 + sovImapigateway(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovImapigateway(uint64(m.Length))
	}
	return n
}

func (m *GetGroupUserIdsRsp) Size() (n int) {
	var l int
	_ = l
	if m.RetNo != 0 {
		n += 1 + sovImapigateway(uint64(m.RetNo))
	}
	if m.Total != 0 {
		n += 1 + sovImapigateway(uint64(m.Total))
	}
	if m.Count != 0 {
		n += 1 + sovImapigateway(uint64(m.Count))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	return n
}

func (m *LiveStartReq) Size() (n int) {
	var l int
	_ = l
	if m.BeginAt != 0 {
		n += 1 + sovImapigateway(uint64(m.BeginAt))
	}
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.LiveStat != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveStat))
	}
	if m.LiveType != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveType))
	}
	if m.LiveUser != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveUser))
	}
	if m.LiveRoom != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveRoom))
	}
	if m.LivePkId != 0 {
		n += 1 + sovImapigateway(uint64(m.LivePkId))
	}
	l = len(m.LiveFlag)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LiveName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LiveIcon)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *LiveStartRsp) Size() (n int) {
	var l int
	_ = l
	if m.ReplyCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ReplyCode))
	}
	l = len(m.InviteUrl)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *LiveStopReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveUser))
	}
	if m.LiveStat != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveStat))
	}
	l = len(m.LiveCode)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *LiveStopRsp) Size() (n int) {
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovImapigateway(uint64(m.RetCode))
	}
	if m.Invited != 0 {
		n += 1 + sovImapigateway(uint64(m.Invited))
	}
	return n
}

func (m *GetLiveInviteUrlReq) Size() (n int) {
	var l int
	_ = l
	if m.BeginAt != 0 {
		n += 1 + sovImapigateway(uint64(m.BeginAt))
	}
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveUser))
	}
	return n
}

func (m *GetLiveInviteUrlRsp) Size() (n int) {
	var l int
	_ = l
	if m.ReplyCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ReplyCode))
	}
	l = len(m.InviteUrl)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *EditLiveInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.BeginAt != 0 {
		n += 1 + sovImapigateway(uint64(m.BeginAt))
	}
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.LiveStat != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveStat))
	}
	if m.LiveType != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveType))
	}
	if m.LiveUser != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveUser))
	}
	if m.LiveRoom != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveRoom))
	}
	l = len(m.LiveFlag)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LiveName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LiveIcon)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *EditLiveInfoRsp) Size() (n int) {
	var l int
	_ = l
	if m.ReplyCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ReplyCode))
	}
	l = len(m.ReplyData)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GroupLiveCheckReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveUser))
	}
	return n
}

func (m *GroupLiveCheckRsp) Size() (n int) {
	var l int
	_ = l
	if m.ReplyCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ReplyCode))
	}
	l = len(m.ReplyData)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetLiveInviteCntReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.LiveUser != 0 {
		n += 1 + sovImapigateway(uint64(m.LiveUser))
	}
	return n
}

func (m *GetLiveInviteCntRsp) Size() (n int) {
	var l int
	_ = l
	if m.RetCode != 0 {
		n += 1 + sovImapigateway(uint64(m.RetCode))
	}
	if m.Invited != 0 {
		n += 1 + sovImapigateway(uint64(m.Invited))
	}
	return n
}

func (m *CheckUserInGroupReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	return n
}

func (m *CheckUserInGroupRsp) Size() (n int) {
	var l int
	_ = l
	if m.InGroup {
		n += 2
	}
	return n
}

func (m *LivePushReq) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovImapigateway(uint64(m.Type))
	}
	return n
}

func (m *LivePushResult) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *ReqKickFromChannel) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.Kicker != 0 {
		n += 1 + sovImapigateway(uint64(m.Kicker))
	}
	if m.Kickee != 0 {
		n += 1 + sovImapigateway(uint64(m.Kickee))
	}
	if m.IsBotUser {
		n += 2
	}
	if m.IsKicked {
		n += 2
	}
	if m.KickedId != 0 {
		n += 1 + sovImapigateway(uint64(m.KickedId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *CheckUserNameReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *CheckUserNameResp) Size() (n int) {
	var l int
	_ = l
	if m.Occpuy {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqSendCodeMsg) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovImapigateway(uint64(m.Userid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Keyid != 0 {
		n += 1 + sovImapigateway(uint64(m.Keyid))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ChannelBannedRights) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	if m.ViewMessages {
		n += 2
	}
	if m.SendMessages {
		n += 2
	}
	if m.SendMedia {
		n += 2
	}
	if m.SendStickers {
		n += 2
	}
	if m.SendGifs {
		n += 2
	}
	if m.SendGames {
		n += 2
	}
	if m.SendInline {
		n += 2
	}
	if m.EmbedLinks {
		n += 2
	}
	if m.UntilDate != 0 {
		n += 1 + sovImapigateway(uint64(m.UntilDate))
	}
	if m.InviteUser {
		n += 2
	}
	if m.PinMessage {
		n += 2
	}
	if m.ChangeGroupInfo {
		n += 2
	}
	if m.SendPolls {
		n += 2
	}
	return n
}

func (m *ReqEditBanChannelUser) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.BannedUserId != 0 {
		n += 1 + sovImapigateway(uint64(m.BannedUserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.UtilDate != 0 {
		n += 1 + sovImapigateway(uint64(m.UtilDate))
	}
	if m.ChannelBannedRights != nil {
		l = m.ChannelBannedRights.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqEditEveryoneQuiet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.Quiet {
		n += 2
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetChannelUserInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetChannelUserInfoResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	return n
}

func (m *CheckIsSelfContactReq) Size() (n int) {
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *CheckIsSelfContactResult) Size() (n int) {
	var l int
	_ = l
	if m.IsSelfContact {
		n += 2
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *MomentFollowReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.FollowId != 0 {
		n += 1 + sovImapigateway(uint64(m.FollowId))
	}
	if m.IsFollow != 0 {
		n += 1 + sovImapigateway(uint64(m.IsFollow))
	}
	return n
}

func (m *MomentFollowResp) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *MomentData) Size() (n int) {
	var l int
	_ = l
	if m.ForumId != 0 {
		n += 1 + sovImapigateway(uint64(m.ForumId))
	}
	if m.ForumType != 0 {
		n += 1 + sovImapigateway(uint64(m.ForumType))
	}
	l = len(m.ForumImage)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.ForumText)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.WithId != 0 {
		n += 1 + sovImapigateway(uint64(m.WithId))
	}
	if m.MsgId != 0 {
		n += 1 + sovImapigateway(uint64(m.MsgId))
	}
	l = len(m.MsgContent)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.IsFollowed != 0 {
		n += 1 + sovImapigateway(uint64(m.IsFollowed))
	}
	return n
}

func (m *SysNotifyData) Size() (n int) {
	var l int
	_ = l
	l = len(m.MsgTitle)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.MsgTime != 0 {
		n += 1 + sovImapigateway(uint64(m.MsgTime))
	}
	l = len(m.MsgUrl)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.MsgButtonText)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.InteractMsg != nil {
		l = m.InteractMsg.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.IsPush {
		n += 2
	}
	return n
}

func (m *NotifyMedia) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovImapigateway(uint64(m.Seq))
	}
	l = len(m.Fid)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.PartNum != 0 {
		n += 1 + sovImapigateway(uint64(m.PartNum))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovImapigateway(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovImapigateway(uint64(m.Height))
	}
	return n
}

func (m *NotifyText) Size() (n int) {
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovImapigateway(uint64(m.Seq))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *SendMediaSysNotifyReq) Size() (n int) {
	var l int
	_ = l
	if m.SourceCode != 0 {
		n += 1 + sovImapigateway(uint64(m.SourceCode))
	}
	if m.BusinessCode != 0 {
		n += 1 + sovImapigateway(uint64(m.BusinessCode))
	}
	if len(m.NotifyMedias) > 0 {
		for _, e := range m.NotifyMedias {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if len(m.NotifyTexts) > 0 {
		for _, e := range m.NotifyTexts {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	l = len(m.MsgId)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *FailUser) Size() (n int) {
	var l int
	_ = l
	if m.User != 0 {
		n += 1 + sovImapigateway(uint64(m.User))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *SucceedUser) Size() (n int) {
	var l int
	_ = l
	if m.User != 0 {
		n += 1 + sovImapigateway(uint64(m.User))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *SendMediaSysNotifyResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if len(m.FailUsers) > 0 {
		for _, e := range m.FailUsers {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if len(m.SucceedUsers) > 0 {
		for _, e := range m.SucceedUsers {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	return n
}

func (m *SearchUserByNicknameReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Offset != 0 {
		n += 1 + sovImapigateway(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovImapigateway(uint64(m.Limit))
	}
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	return n
}

func (m *SearchUserByNicknameResult) Size() (n int) {
	var l int
	_ = l
	if len(m.UserInfos) > 0 {
		for _, e := range m.UserInfos {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *Entity) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovImapigateway(uint64(m.Type))
	}
	if m.Offset != 0 {
		n += 1 + sovImapigateway(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovImapigateway(uint64(m.Length))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *MomentNotifyData) Size() (n int) {
	var l int
	_ = l
	if m.SourceCode != 0 {
		n += 1 + sovImapigateway(uint64(m.SourceCode))
	}
	if m.BusinessCode != 0 {
		n += 1 + sovImapigateway(uint64(m.BusinessCode))
	}
	if m.ToId != 0 {
		n += 1 + sovImapigateway(uint64(m.ToId))
	}
	if m.WithId != 0 {
		n += 1 + sovImapigateway(uint64(m.WithId))
	}
	if m.ForumId != 0 {
		n += 1 + sovImapigateway(uint64(m.ForumId))
	}
	if m.ForumType != 0 {
		n += 1 + sovImapigateway(uint64(m.ForumType))
	}
	l = len(m.ForumImage)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.ForumText)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.MsgId != 0 {
		n += 1 + sovImapigateway(uint64(m.MsgId))
	}
	l = len(m.MsgContent)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.IsFollowed != 0 {
		n += 1 + sovImapigateway(uint64(m.IsFollowed))
	}
	if m.MsgTime != 0 {
		n += 1 + sovImapigateway(uint64(m.MsgTime))
	}
	if len(m.Entites) > 0 {
		for _, e := range m.Entites {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	return n
}

func (m *MomentNotifyReq) Size() (n int) {
	var l int
	_ = l
	if len(m.MomentNotifyData) > 0 {
		for _, e := range m.MomentNotifyData {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	return n
}

func (m *MomentNotifyResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *CheckIsMuteContactReq) Size() (n int) {
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	return n
}

func (m *CheckIsMuteContactResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	if m.Result {
		n += 2
	}
	return n
}

func (m *ContactInfo) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.ContactId != 0 {
		n += 1 + sovImapigateway(uint64(m.ContactId))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.IsSelfContacted {
		n += 2
	}
	if m.SelfIsContacted {
		n += 2
	}
	if m.StarMark {
		n += 2
	}
	if m.HasPhone {
		n += 2
	}
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ContatsGetContactsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.KeyId))
	}
	l = len(m.Contacthash)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ContatsGetContactsResult) Size() (n int) {
	var l int
	_ = l
	if len(m.ContactArr) > 0 {
		for _, e := range m.ContactArr {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if len(m.UserInfoArr) > 0 {
		for _, e := range m.UserInfoArr {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *MomentState) Size() (n int) {
	var l int
	_ = l
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Type != 0 {
		n += 1 + sovImapigateway(uint64(m.Type))
	}
	return n
}

func (m *ReqUpdateMoments) Size() (n int) {
	var l int
	_ = l
	if len(m.MomentStates) > 0 {
		for _, e := range m.MomentStates {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	return n
}

func (m *ResUpdateMoments) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImapigateway(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqIntegralUniversalBusiness) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ImUserId != 0 {
		n += 1 + sovImapigateway(uint64(m.ImUserId))
	}
	if m.ImKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.ImKeyId))
	}
	if m.BusinessId != 0 {
		n += 1 + sovImapigateway(uint64(m.BusinessId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyIntegralUniversalBusiness) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *OtherTransReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.KeyId))
	}
	l = len(m.IpAddr)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ReqMessagId != 0 {
		n += 1 + sovImapigateway(uint64(m.ReqMessagId))
	}
	l = len(m.ReqBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *OtherTransResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.RespBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *SetUserDetailReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovImapigateway(uint64(m.Sex))
	}
	if m.Birthday != 0 {
		n += 1 + sovImapigateway(uint64(m.Birthday))
	}
	l = len(m.Extend)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *SetUserDetailResult) Size() (n int) {
	var l int
	_ = l
	if m.Successful {
		n += 2
	}
	return n
}

func (m *GetUserByUsernameReq) Size() (n int) {
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetUserInfoResult) Size() (n int) {
	var l int
	_ = l
	if m.Uinfo != nil {
		l = m.Uinfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *SendGameRedReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.RdpRsp)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *QryGameRdpReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *RcvGameRedReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.RdpRsp)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GameRedResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovImapigateway(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *SendRDPReq) Size() (n int) {
	var l int
	_ = l
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ReqMessageId != 0 {
		n += 1 + sovImapigateway(uint64(m.ReqMessageId))
	}
	l = len(m.ReqBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.RedMessageId != 0 {
		n += 1 + sovImapigateway(uint64(m.RedMessageId))
	}
	if m.RedChanelId != 0 {
		n += 1 + sovImapigateway(uint64(m.RedChanelId))
	}
	return n
}

func (m *SendRDPResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.RespBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *CheckRDPReq) Size() (n int) {
	var l int
	_ = l
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ReqMessageId != 0 {
		n += 1 + sovImapigateway(uint64(m.ReqMessageId))
	}
	l = len(m.ReqBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *CheckRDPResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.RespBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReceiveRDPReq) Size() (n int) {
	var l int
	_ = l
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ReqMessageId != 0 {
		n += 1 + sovImapigateway(uint64(m.ReqMessageId))
	}
	l = len(m.ReqBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReceiveRDPResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.RespBytes)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReplyEditChannelAbout) Size() (n int) {
	var l int
	_ = l
	if m.Succeed {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReplyEditChannelTitle) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *BotUpdateInfo) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.BotInfoVersion != 0 {
		n += 1 + sovImapigateway(uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		n += 2
	}
	if m.BotNoChat {
		n += 2
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *BotUpdateInfoResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *ReplyUpdatePinnedChannelMessage) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReplyLeaveChannel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqGetAllChats) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetAllChats) Size() (n int) {
	var l int
	_ = l
	if len(m.Chats) > 0 {
		l = 0
		for _, e := range m.Chats {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqGetchannelDifference) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	if m.Force {
		n += 2
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.Pts != 0 {
		n += 1 + sovImapigateway(uint64(m.Pts))
	}
	if m.Limit != 0 {
		n += 1 + sovImapigateway(uint64(m.Limit))
	}
	if m.Range_MinId != 0 {
		n += 1 + sovImapigateway(uint64(m.Range_MinId))
	}
	if m.Range_MaxId != 0 {
		n += 1 + sovImapigateway(uint64(m.Range_MaxId))
	}
	if m.Device != 0 {
		n += 1 + sovImapigateway(uint64(m.Device))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyChannelDiffCommon) Size() (n int) {
	var l int
	_ = l
	l = len(m.Difference)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqFullchannel) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyFullChannel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Updates)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqDeleteMessages) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	if m.Revoke {
		n += 2
	}
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Channelid != 0 {
		n += 1 + sovImapigateway(uint64(m.Channelid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyDeleteMessages) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *RegisterUserInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.IsBot {
		n += 2
	}
	if m.BotInfoVersion != 0 {
		n += 1 + sovImapigateway(uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		n += 2
	}
	if m.BotNoChats {
		n += 2
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LocalPhone)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Dc != 0 {
		n += 1 + sovImapigateway(uint64(m.Dc))
	}
	if m.GroupNow != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupNow))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Sex != 0 {
		n += 1 + sovImapigateway(uint64(m.Sex))
	}
	if m.Birthday != 0 {
		n += 2 + sovImapigateway(uint64(m.Birthday))
	}
	return n
}

func (m *ReqGetFullChannel) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqGetParticipants) Size() (n int) {
	var l int
	_ = l
	if m.OffSet != 0 {
		n += 1 + sovImapigateway(uint64(m.OffSet))
	}
	if m.Limit != 0 {
		n += 1 + sovImapigateway(uint64(m.Limit))
	}
	if m.PartiType != 0 {
		n += 1 + sovImapigateway(uint64(m.PartiType))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Hash != 0 {
		n += 1 + sovImapigateway(uint64(m.Hash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqUpdatePinnedChannelMessage) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	if m.Silent {
		n += 2
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqEditChannelAbout) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqEditChannelTitle) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyChannelData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	return n
}

func (m *ReqDelManualBlockList) Size() (n int) {
	var l int
	_ = l
	if m.UnBlockUser != nil {
		l = m.UnBlockUser.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.BotId != 0 {
		n += 1 + sovImapigateway(uint64(m.BotId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqSetManualBlockList) Size() (n int) {
	var l int
	_ = l
	if m.BlockUser != nil {
		l = m.BlockUser.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.BotId != 0 {
		n += 1 + sovImapigateway(uint64(m.BotId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *BlockUser) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.BlockTime != 0 {
		n += 1 + sovImapigateway(uint64(m.BlockTime))
	}
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	return n
}

func (m *ManualBlockReplyData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReplyData)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Reply {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *StoreShopStickerSetDocumentsReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if len(m.Documents) > 0 {
		l = 0
		for _, e := range m.Documents {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *StoreShopStickerSetDocumentsResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *AuthorStickerSet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.StickersetId != 0 {
		n += 1 + sovImapigateway(uint64(m.StickersetId))
	}
	l = len(m.ShortName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Archived {
		n += 2
	}
	if m.Installed {
		n += 2
	}
	if m.Disabled {
		n += 2
	}
	if m.Ordered != 0 {
		n += 1 + sovImapigateway(uint64(m.Ordered))
	}
	if m.Created != 0 {
		n += 1 + sovImapigateway(uint64(m.Created))
	}
	if m.Updated != 0 {
		n += 1 + sovImapigateway(uint64(m.Updated))
	}
	return n
}

func (m *GetAuthorAllStickerSetReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	return n
}

func (m *GetAuthorAllStickerSetResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	if len(m.Sets) > 0 {
		for _, e := range m.Sets {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	return n
}

func (m *DeleteStickerPackDocumentReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if m.StickersetId != 0 {
		n += 1 + sovImapigateway(uint64(m.StickersetId))
	}
	return n
}

func (m *DeleteStickerPackDocumentResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *GetStickerSetInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	l = len(m.ShortName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.IsId {
		n += 2
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *StickerSetInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Free {
		n += 2
	}
	if m.Official {
		n += 2
	}
	if m.Masks {
		n += 2
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.ShortName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovImapigateway(uint64(m.Count))
	}
	if m.Hash != 0 {
		n += 1 + sovImapigateway(uint64(m.Hash))
	}
	l = len(m.Emoticon)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if len(m.Documents) > 0 {
		l = 0
		for _, e := range m.Documents {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	return n
}

func (m *GetStickerSetInfoResult) Size() (n int) {
	var l int
	_ = l
	if m.StickerSetInfo != nil {
		l = m.StickerSetInfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *DeleteStickerSetReq) Size() (n int) {
	var l int
	_ = l
	if m.StickerId != 0 {
		n += 1 + sovImapigateway(uint64(m.StickerId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	return n
}

func (m *DeleteStickerSetResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *StoreUserStickerSetReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.StickersetId != 0 {
		n += 1 + sovImapigateway(uint64(m.StickersetId))
	}
	if m.Installed {
		n += 2
	}
	if m.Disabled {
		n += 2
	}
	if m.Order != 0 {
		n += 1 + sovImapigateway(uint64(m.Order))
	}
	if m.Archived {
		n += 2
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *StoreUserStickerSetResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *StoreStickerPackDcReq) Size() (n int) {
	var l int
	_ = l
	if m.Stickpackbase != nil {
		l = m.Stickpackbase.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *StoreStickerPackDcResult) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *StoreShopStickerSetReq) Size() (n int) {
	var l int
	_ = l
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Free {
		n += 2
	}
	if m.Official {
		n += 2
	}
	if m.Masks {
		n += 2
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.ShortName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovImapigateway(uint64(m.Count))
	}
	if m.Hash != 0 {
		n += 1 + sovImapigateway(uint64(m.Hash))
	}
	l = len(m.Emoticon)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if len(m.Documents) > 0 {
		l = 0
		for _, e := range m.Documents {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	return n
}

func (m *StoreShopStickerSetResult) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *ResizeRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovImapigateway(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovImapigateway(uint64(m.Height))
	}
	return n
}

func (m *ResizeReply) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovImapigateway(uint64(m.Status))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ConstraintRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.MaxSize != 0 {
		n += 1 + sovImapigateway(uint64(m.MaxSize))
	}
	if m.OutputWebp {
		n += 2
	}
	return n
}

func (m *ConstraintReply) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovImapigateway(uint64(m.Status))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovImapigateway(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovImapigateway(uint64(m.Height))
	}
	if m.OriginWidth != 0 {
		n += 1 + sovImapigateway(uint64(m.OriginWidth))
	}
	if m.OriginHeight != 0 {
		n += 1 + sovImapigateway(uint64(m.OriginHeight))
	}
	return n
}

func (m *CompressImageRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Quality != 0 {
		n += 1 + sovImapigateway(uint64(m.Quality))
	}
	return n
}

func (m *CompressImageReply) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovImapigateway(uint64(m.Status))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *VideoPreviewRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.MaxSize != 0 {
		n += 1 + sovImapigateway(uint64(m.MaxSize))
	}
	return n
}

func (m *VideoPreviewReply) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovImapigateway(uint64(m.Status))
	}
	if m.Duration != 0 {
		n += 1 + sovImapigateway(uint64(m.Duration))
	}
	l = len(m.Preview)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovImapigateway(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovImapigateway(uint64(m.Height))
	}
	return n
}

func (m *AudioPreviewRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.MaxSize != 0 {
		n += 1 + sovImapigateway(uint64(m.MaxSize))
	}
	return n
}

func (m *AudioPreviewReply) Size() (n int) {
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovImapigateway(uint64(m.Status))
	}
	if m.Duration != 0 {
		n += 1 + sovImapigateway(uint64(m.Duration))
	}
	l = len(m.Cover)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.Artist)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovImapigateway(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovImapigateway(uint64(m.Height))
	}
	return n
}

func (m *ReqParticipants) Size() (n int) {
	var l int
	_ = l
	if m.OffSet != 0 {
		n += 1 + sovImapigateway(uint64(m.OffSet))
	}
	if m.Limit != 0 {
		n += 1 + sovImapigateway(uint64(m.Limit))
	}
	if m.PartiType != 0 {
		n += 1 + sovImapigateway(uint64(m.PartiType))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Hash != 0 {
		n += 1 + sovImapigateway(uint64(m.Hash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyParticipants) Size() (n int) {
	var l int
	_ = l
	l = len(m.Updates)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqCreateChat) Size() (n int) {
	var l int
	_ = l
	if m.Chatid != 0 {
		n += 1 + sovImapigateway(uint64(m.Chatid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Creator != 0 {
		n += 1 + sovImapigateway(uint64(m.Creator))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyCreateChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqMigrateChat) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		n += 1 + sovImapigateway(uint64(m.Chatid))
	}
	if m.Fromkeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromkeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyMigrateChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqJoinChannel) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.ByLink {
		n += 2
	}
	if m.Invitor != 0 {
		n += 1 + sovImapigateway(uint64(m.Invitor))
	}
	if m.InviteType != 0 {
		n += 1 + sovImapigateway(uint64(m.InviteType))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyJoinChannel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqChangeGroupAndChannelCrator) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovImapigateway(uint64(m.GroupId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.OperatorId != 0 {
		n += 1 + sovImapigateway(uint64(m.OperatorId))
	}
	if m.IsChat {
		n += 2
	}
	return n
}

func (m *ReplyChangeGroupAndChannelCrator) Size() (n int) {
	var l int
	_ = l
	if m.Valid {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqBotCallMessageMedia) Size() (n int) {
	var l int
	_ = l
	if m.FromBotId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromBotId))
	}
	l = len(m.MsgTxt)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.Request)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovImapigateway(uint64(m.Layer))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *RequestDialog) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovImapigateway(uint64(m.Userid))
	}
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	if m.OffsetDate != 0 {
		n += 1 + sovImapigateway(uint64(m.OffsetDate))
	}
	if m.OffsetId != 0 {
		n += 1 + sovImapigateway(uint64(m.OffsetId))
	}
	l = len(m.OffsetPeer)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovImapigateway(uint64(m.Limit))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyDialog) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *UserScore) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovImapigateway(uint64(m.Userid))
	}
	if m.Score != 0 {
		n += 1 + sovImapigateway(uint64(m.Score))
	}
	return n
}

func (m *ReqSetGameScore) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovImapigateway(uint64(m.Userid))
	}
	if len(m.Scores) > 0 {
		for _, e := range m.Scores {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.Force {
		n += 2
	}
	if m.DisableEditMessage {
		n += 2
	}
	if m.ChatId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatId))
	}
	if m.ChatType != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatType))
	}
	if m.MessageId != 0 {
		n += 1 + sovImapigateway(uint64(m.MessageId))
	}
	l = len(m.InlineMessageId)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Botid != 0 {
		n += 1 + sovImapigateway(uint64(m.Botid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplySetGameScore) Size() (n int) {
	var l int
	_ = l
	if m.Succeed {
		n += 2
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *ReplyBanChannelUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Updates)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqBanChannelUser) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.BannedUserId != 0 {
		n += 1 + sovImapigateway(uint64(m.BannedUserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.UtilDate != 0 {
		n += 1 + sovImapigateway(uint64(m.UtilDate))
	}
	if m.ChannelBannedRights != nil {
		l = m.ChannelBannedRights.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqGetChannels) Size() (n int) {
	var l int
	_ = l
	if len(m.ChannelIds) > 0 {
		l = 0
		for _, e := range m.ChannelIds {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetChannels) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqDeleteChatUser) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		n += 1 + sovImapigateway(uint64(m.Chatid))
	}
	if m.Userid != 0 {
		n += 1 + sovImapigateway(uint64(m.Userid))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyDeleteChatUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ChannelInactiveUser) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovImapigateway(uint64(m.Time))
	}
	l = len(m.TimeStr)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetChannelInactiveUsersReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.Limit != 0 {
		n += 1 + sovImapigateway(uint64(m.Limit))
	}
	if m.Userid != 0 {
		n += 1 + sovImapigateway(uint64(m.Userid))
	}
	return n
}

func (m *GetChannelInactiveUsersResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovImapigateway(uint64(m.Count))
	}
	if m.Errcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errcode))
	}
	return n
}

func (m *ReqBotInlineCall) Size() (n int) {
	var l int
	_ = l
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.BotId != 0 {
		n += 1 + sovImapigateway(uint64(m.BotId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImapigateway(uint64(m.MessageId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.KeyId))
	}
	if m.SessionId != 0 {
		n += 1 + sovImapigateway(uint64(m.SessionId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyBotInlineCall) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrCode))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Inlinecall != nil {
		l = m.Inlinecall.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *InlineCall) Size() (n int) {
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovImapigateway(uint64(m.MsgId))
	}
	if m.FromId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatId))
	}
	if m.ChatType != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatType))
	}
	if m.BotId != 0 {
		n += 1 + sovImapigateway(uint64(m.BotId))
	}
	return n
}

func (m *ReqSendUserMsg) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.FromKeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyId))
	}
	if m.Toid != 0 {
		n += 1 + sovImapigateway(uint64(m.Toid))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyBool) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqBotCall) Size() (n int) {
	var l int
	_ = l
	if m.FrombotId != 0 {
		n += 1 + sovImapigateway(uint64(m.FrombotId))
	}
	l = len(m.Request)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovImapigateway(uint64(m.Layer))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyBotCall) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqGetMessageByUserIdUuid) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.Uuid != 0 {
		n += 1 + sovImapigateway(uint64(m.Uuid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetMessageByUserIdUuid) Size() (n int) {
	var l int
	_ = l
	if m.UserMessage != nil {
		l = m.UserMessage.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqGetChannelMessageByChannelIdMsgId) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		n += 1 + sovImapigateway(uint64(m.MsgId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetChannelMessageByChannelIdMsgId) Size() (n int) {
	var l int
	_ = l
	if m.UserMessage != nil {
		l = m.UserMessage.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqGetMessageByUserIdMsgId) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.MsgId != 0 {
		n += 1 + sovImapigateway(uint64(m.MsgId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetMessageByUserIdMsgId) Size() (n int) {
	var l int
	_ = l
	if m.UserMessage != nil {
		l = m.UserMessage.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *MsgFileDescReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *MsgFileDescResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovImapigateway(uint64(m.Result))
	}
	return n
}

func (m *MsgServiceLimitReq) Size() (n int) {
	var l int
	_ = l
	if m.Reserved != 0 {
		n += 1 + sovImapigateway(uint64(m.Reserved))
	}
	return n
}

func (m *MsgServiceLimitResp) Size() (n int) {
	var l int
	_ = l
	if m.Usfsl != 0 {
		n += 1 + sovImapigateway(uint64(m.Usfsl))
	}
	if m.Ubfssl != 0 {
		n += 1 + sovImapigateway(uint64(m.Ubfssl))
	}
	if m.Dssl != 0 {
		n += 1 + sovImapigateway(uint64(m.Dssl))
	}
	return n
}

func (m *MsgGetFidReq) Size() (n int) {
	var l int
	_ = l
	if m.Keyid != 0 {
		n += 1 + sovImapigateway(uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fileid))
	}
	if m.FileType != 0 {
		n += 1 + sovImapigateway(uint64(m.FileType))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.PartTotal != 0 {
		n += 1 + sovImapigateway(uint64(m.PartTotal))
	}
	return n
}

func (m *MsgGetFidResp) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.FileSize != 0 {
		n += 1 + sovImapigateway(uint64(m.FileSize))
	}
	if m.Result != 0 {
		n += 1 + sovImapigateway(uint64(m.Result))
	}
	return n
}

func (m *MsgFilePartsReq) Size() (n int) {
	var l int
	_ = l
	if m.Keyid != 0 {
		n += 1 + sovImapigateway(uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fileid))
	}
	if m.PartId != 0 {
		n += 1 + sovImapigateway(uint64(m.PartId))
	}
	if m.FileType != 0 {
		n += 1 + sovImapigateway(uint64(m.FileType))
	}
	if m.PartTotal != 0 {
		n += 1 + sovImapigateway(uint64(m.PartTotal))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *MsgFilePartsResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovImapigateway(uint64(m.Result))
	}
	return n
}

func (m *MsgUploadFileReq) Size() (n int) {
	var l int
	_ = l
	if m.Para1 != nil {
		l = m.Para1.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Para2 != nil {
		l = m.Para2.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *MsgUploadFileResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovImapigateway(uint64(m.Result))
	}
	if m.Para1 != nil {
		l = m.Para1.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Para2 != nil {
		l = m.Para2.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgDownloadFileReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Offset != 0 {
		n += 1 + sovImapigateway(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovImapigateway(uint64(m.Length))
	}
	return n
}

func (m *DownloadFileRespPara1) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fid))
	}
	if m.Offset != 0 {
		n += 1 + sovImapigateway(uint64(m.Offset))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *DownloadFileRespPara2) Size() (n int) {
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovImapigateway(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *MsgDownloadFileResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovImapigateway(uint64(m.Result))
	}
	if m.Para1 != nil {
		l = m.Para1.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Para2 != nil {
		l = m.Para2.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *MsgQueryObjInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fid))
	}
	return n
}

func (m *QueryObjInfoRespPara) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovImapigateway(uint64(m.Size_))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgQueryObjInfoResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovImapigateway(uint64(m.Result))
	}
	return n
}

func (m *MsgGetFileDescReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgGetFileDescResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovImapigateway(uint64(m.Result))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetChannelInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Dlog != nil {
		l = m.Dlog.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetChannelInfoResp) Size() (n int) {
	var l int
	_ = l
	if m.BaseInfo != nil {
		l = m.BaseInfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Resultcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Resultcode))
	}
	return n
}

func (m *ReqGetAdminGroups) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovImapigateway(uint64(m.UserID))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqGetGroups) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovImapigateway(uint64(m.UserID))
	}
	if m.PeerFilter != 0 {
		n += 1 + sovImapigateway(uint64(m.PeerFilter))
	}
	return n
}

func (m *Peer) Size() (n int) {
	var l int
	_ = l
	if m.PeerID != 0 {
		n += 1 + sovImapigateway(uint64(m.PeerID))
	}
	l = len(m.PeerName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetGroups) Size() (n int) {
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for _, e := range m.Groups {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if len(m.SuperGroups) > 0 {
		for _, e := range m.SuperGroups {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if len(m.Channels) > 0 {
		for _, e := range m.Channels {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	return n
}

func (m *ReqDeleteMessage) Size() (n int) {
	var l int
	_ = l
	if m.ChatType != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatType))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatId))
	}
	if len(m.MsgId) > 0 {
		l = 0
		for _, e := range m.MsgId {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqSendChatAction) Size() (n int) {
	var l int
	_ = l
	if m.ChatType != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatType))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatId))
	}
	l = len(m.ActionData)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqData) Size() (n int) {
	var l int
	_ = l
	if m.ChatType != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatType))
	}
	l = len(m.ReqData)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.BotId != 0 {
		n += 1 + sovImapigateway(uint64(m.BotId))
	}
	return n
}

func (m *ReplyData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqGetChatMembersCount) Size() (n int) {
	var l int
	_ = l
	if m.ChatType != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatType))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetChatMembersCount) Size() (n int) {
	var l int
	_ = l
	if m.ChatMembersCount != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatMembersCount))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImapigateway(uint64(m.ErrorCode))
	}
	return n
}

func (m *GetChatInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.RobotGet {
		n += 2
	}
	if m.Dlog != nil {
		l = m.Dlog.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetUsersChatsReq) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovImapigateway(uint64(m.Userid))
	}
	if len(m.Users) > 0 {
		l = 0
		for _, e := range m.Users {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if len(m.Chatid) > 0 {
		l = 0
		for _, e := range m.Chatid {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if len(m.Channelid) > 0 {
		l = 0
		for _, e := range m.Channelid {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.ProtocolLayer != 0 {
		n += 1 + sovImapigateway(uint64(m.ProtocolLayer))
	}
	if m.Dlog != nil {
		l = m.Dlog.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetUsersChatsResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Channels) > 0 {
		for _, b := range m.Channels {
			l = len(b)
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.Users != nil {
		l = m.Users.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if len(m.Chats) > 0 {
		for _, b := range m.Chats {
			l = len(b)
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if len(m.NoChats) > 0 {
		l = 0
		for _, e := range m.NoChats {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if len(m.NoChans) > 0 {
		l = 0
		for _, e := range m.NoChans {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Resultcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Resultcode))
	}
	return n
}

func (m *GetUserInfoByIdReq) Size() (n int) {
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetUserInfoByIdArrReq) Size() (n int) {
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *UpdateUserProfileReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *UpdateUserProfileResult) Size() (n int) {
	var l int
	_ = l
	if m.Uinfo != nil {
		l = m.Uinfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *GetUserByphone) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *UpdateBotInfoSuppReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	l = len(m.Placeholder)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Geo {
		n += 2
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *UpdateBotInfoSuppResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *UpdateBotPicRequest) Size() (n int) {
	var l int
	_ = l
	if m.BotId != 0 {
		n += 1 + sovImapigateway(uint64(m.BotId))
	}
	l = len(m.Photo)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *UpdateBotPicResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *UpdateuserNameReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	l = len(m.UserName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.KeyId))
	}
	return n
}

func (m *UpdateuserNameResult) Size() (n int) {
	var l int
	_ = l
	if m.Uinfo != nil {
		l = m.Uinfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *RegisterUserInfoResult) Size() (n int) {
	var l int
	_ = l
	if m.Uinfo != nil {
		l = m.Uinfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *DeleteAccountByIdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.DelId != 0 {
		n += 1 + sovImapigateway(uint64(m.DelId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *DelAccountResult) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *SignUpReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.PhoneCodeHash)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.PhoneCode)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.KeyId))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.IsBot {
		n += 2
	}
	if m.BotInfoVersion != 0 {
		n += 1 + sovImapigateway(uint64(m.BotInfoVersion))
	}
	if m.BotChatHistory {
		n += 2
	}
	if m.BotNoChats {
		n += 2
	}
	if m.DcId != 0 {
		n += 1 + sovImapigateway(uint64(m.DcId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	l = len(m.LocalPhone)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *AuthSignUpResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImapigateway(uint64(m.Code))
	}
	if m.UserInfo != nil {
		l = m.UserInfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetFullUserReq) Size() (n int) {
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetFullUserResult) Size() (n int) {
	var l int
	_ = l
	if m.Uinfo != nil {
		l = m.Uinfo.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Isblocked {
		n += 2
	}
	if m.PhoneCallsPrivate {
		n += 2
	}
	if m.PhoneCallsAvailable {
		n += 2
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.CommonChat != 0 {
		n += 1 + sovImapigateway(uint64(m.CommonChat))
	}
	l = len(m.Extend)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *GetUserByUsername) Size() (n int) {
	var l int
	_ = l
	if m.SelfId != 0 {
		n += 1 + sovImapigateway(uint64(m.SelfId))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqGetFullChat) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		n += 1 + sovImapigateway(uint64(m.Chatid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyGetFullChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqLeaveChannel) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImapigateway(uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReqSendMedia) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.Flags != 0 {
		n += 1 + sovImapigateway(uint64(m.Flags))
	}
	if m.Silent {
		n += 2
	}
	if m.Background {
		n += 2
	}
	if m.ClearDraft {
		n += 2
	}
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ReplyToMsgId != 0 {
		n += 1 + sovImapigateway(uint64(m.ReplyToMsgId))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if len(m.MultiMedia) > 0 {
		for _, b := range m.MultiMedia {
			l = len(b)
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.RandomId != 0 {
		n += 1 + sovImapigateway(uint64(m.RandomId))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Newfileid != 0 {
		n += 1 + sovImapigateway(uint64(m.Newfileid))
	}
	if m.FromkeyId != 0 {
		n += 1 + sovImapigateway(uint64(m.FromkeyId))
	}
	if len(m.Chatmeber) > 0 {
		l = 0
		for _, e := range m.Chatmeber {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.ViaBotId != 0 {
		n += 2 + sovImapigateway(uint64(m.ViaBotId))
	}
	return n
}

func (m *ReplyResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *ReqEditChatTitle) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImapigateway(uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		n += 1 + sovImapigateway(uint64(m.Chatid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImapigateway(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *ReplyEditChatTitle) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImapigateway(uint64(m.Error))
	}
	return n
}

func (m *GetStickerSetPackDcInfosReq) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetStickerSetPackDcInfosResult) Size() (n int) {
	var l int
	_ = l
	if len(m.StPDcInfo) > 0 {
		for _, e := range m.StPDcInfo {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	return n
}

func (m *StickerPackDocumentBase) Size() (n int) {
	var l int
	_ = l
	if m.AttributesStikerSetId != 0 {
		n += 1 + sovImapigateway(uint64(m.AttributesStikerSetId))
	}
	if m.DocumentId != 0 {
		n += 1 + sovImapigateway(uint64(m.DocumentId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AccessHash))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovImapigateway(uint64(m.Size_))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.DcId != 0 {
		n += 1 + sovImapigateway(uint64(m.DcId))
	}
	if m.Date != 0 {
		n += 1 + sovImapigateway(uint64(m.Date))
	}
	if m.AttributesImageSizeW != 0 {
		n += 1 + sovImapigateway(uint64(m.AttributesImageSizeW))
	}
	if m.AttributesImageSizeH != 0 {
		n += 1 + sovImapigateway(uint64(m.AttributesImageSizeH))
	}
	l = len(m.AttributesStikerAlt)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	if m.AttributesStikerSetAccessHash != 0 {
		n += 1 + sovImapigateway(uint64(m.AttributesStikerSetAccessHash))
	}
	l = len(m.AttributesFileName)
	if l > 0 {
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *StickerPackDocumentInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImapigateway(uint64(m.Id))
	}
	if m.InfoBase != nil {
		l = m.InfoBase.Size()
		n += 1 + l + sovImapigateway(uint64(l))
	}
	return n
}

func (m *GetUserInfoByIdArrResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Uinfo) > 0 {
		for _, e := range m.Uinfo {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *SetBotVerifiedReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImapigateway(uint64(m.UserId))
	}
	if m.Verified {
		n += 2
	}
	return n
}

func (m *SetBotVerifiedReply) Size() (n int) {
	var l int
	_ = l
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func (m *ContactsGetCommonContactsReq) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovImapigateway(uint64(e))
		}
		n += 1 + sovImapigateway(uint64(l)) + l
	}
	return n
}

func (m *ContactsGetCommonContactsResult) Size() (n int) {
	var l int
	_ = l
	if len(m.UserInfos) > 0 {
		for _, e := range m.UserInfos {
			l = e.Size()
			n += 1 + l + sovImapigateway(uint64(l))
		}
	}
	if m.Errorcode != 0 {
		n += 1 + sovImapigateway(uint64(m.Errorcode))
	}
	return n
}

func sovImapigateway(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImapigateway(x uint64) (n int) {
	return sovImapigateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetGroupUserIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupUserIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupUserIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChanId", wireType)
			}
			m.ChanId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChanId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupUserIdsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupUserIdsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupUserIdsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetNo", wireType)
			}
			m.RetNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetNo |= (GroupLiveReplyCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiveStartReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiveStartReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiveStartReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginAt", wireType)
			}
			m.BeginAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginAt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStat", wireType)
			}
			m.LiveStat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStat |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveType", wireType)
			}
			m.LiveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveUser", wireType)
			}
			m.LiveUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveUser |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveRoom", wireType)
			}
			m.LiveRoom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveRoom |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivePkId", wireType)
			}
			m.LivePkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LivePkId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiveStartRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiveStartRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiveStartRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= (GroupLiveReplyCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiveStopReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiveStopReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiveStopReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveUser", wireType)
			}
			m.LiveUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveUser |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStat", wireType)
			}
			m.LiveStat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStat |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiveStopRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiveStopRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiveStopRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= (GroupLiveReplyCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invited", wireType)
			}
			m.Invited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invited |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveInviteUrlReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveInviteUrlReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveInviteUrlReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginAt", wireType)
			}
			m.BeginAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginAt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveUser", wireType)
			}
			m.LiveUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveUser |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveInviteUrlRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveInviteUrlRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveInviteUrlRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= (GroupLiveReplyCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InviteUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditLiveInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditLiveInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditLiveInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginAt", wireType)
			}
			m.BeginAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeginAt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveStat", wireType)
			}
			m.LiveStat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveStat |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveType", wireType)
			}
			m.LiveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveUser", wireType)
			}
			m.LiveUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveUser |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveRoom", wireType)
			}
			m.LiveRoom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveRoom |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LiveIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditLiveInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditLiveInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditLiveInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= (GroupLiveReplyCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupLiveCheckReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupLiveCheckReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupLiveCheckReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveUser", wireType)
			}
			m.LiveUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveUser |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupLiveCheckRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupLiveCheckRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupLiveCheckRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= (GroupLiveReplyCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveInviteCntReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveInviteCntReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveInviteCntReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiveUser", wireType)
			}
			m.LiveUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiveUser |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLiveInviteCntRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLiveInviteCntRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLiveInviteCntRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetCode", wireType)
			}
			m.RetCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetCode |= (GroupLiveReplyCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invited", wireType)
			}
			m.Invited = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invited |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUserInGroupReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUserInGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUserInGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUserInGroupRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUserInGroupRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUserInGroupRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InGroup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InGroup = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LivePushReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LivePushReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LivePushReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LivePushResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LivePushResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LivePushResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqKickFromChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqKickFromChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqKickFromChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kicker", wireType)
			}
			m.Kicker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kicker |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kickee", wireType)
			}
			m.Kickee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kickee |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBotUser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBotUser = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsKicked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsKicked = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KickedId", wireType)
			}
			m.KickedId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KickedId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUserNameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUserNameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUserNameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUserNameResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUserNameResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUserNameResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Occpuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Occpuy = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSendCodeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSendCodeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSendCodeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyid", wireType)
			}
			m.Keyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelBannedRights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelBannedRights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelBannedRights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ViewMessages = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendMessages = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMedia", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendMedia = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendStickers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendStickers = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendGifs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendGifs = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendGames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendGames = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendInline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendInline = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmbedLinks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmbedLinks = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntilDate", wireType)
			}
			m.UntilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteUser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InviteUser = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PinMessage = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeGroupInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChangeGroupInfo = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendPolls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendPolls = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqEditBanChannelUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqEditBanChannelUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqEditBanChannelUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BannedUserId", wireType)
			}
			m.BannedUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BannedUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilDate", wireType)
			}
			m.UtilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UtilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelBannedRights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelBannedRights == nil {
				m.ChannelBannedRights = &ChannelBannedRights{}
			}
			if err := m.ChannelBannedRights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqEditEveryoneQuiet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqEditEveryoneQuiet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqEditEveryoneQuiet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quiet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quiet = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelUserInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelUserInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelUserInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelUserInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelUserInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelUserInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckIsSelfContactReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckIsSelfContactReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckIsSelfContactReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckIsSelfContactResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckIsSelfContactResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckIsSelfContactResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSelfContact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSelfContact = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MomentFollowReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MomentFollowReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MomentFollowReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowId", wireType)
			}
			m.FollowId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFollow", wireType)
			}
			m.IsFollow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFollow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MomentFollowResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MomentFollowResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MomentFollowResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MomentData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MomentData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MomentData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumId", wireType)
			}
			m.ForumId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumType", wireType)
			}
			m.ForumType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForumImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForumText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFollowed", wireType)
			}
			m.IsFollowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFollowed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SysNotifyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SysNotifyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SysNotifyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTitle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTitle = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTime", wireType)
			}
			m.MsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgButtonText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgButtonText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InteractMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InteractMsg == nil {
				m.InteractMsg = &MomentData{}
			}
			if err := m.InteractMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPush", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPush = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotifyMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotifyMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotifyMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartNum", wireType)
			}
			m.PartNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartNum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NotifyText) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotifyText: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotifyText: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMediaSysNotifyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMediaSysNotifyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMediaSysNotifyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCode", wireType)
			}
			m.SourceCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessCode", wireType)
			}
			m.BusinessCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyMedias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifyMedias = append(m.NotifyMedias, &NotifyMedia{})
			if err := m.NotifyMedias[len(m.NotifyMedias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyTexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotifyTexts = append(m.NotifyTexts, &NotifyText{})
			if err := m.NotifyTexts[len(m.NotifyTexts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &SysNotifyData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FailUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FailUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FailUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			m.User = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SucceedUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SucceedUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SucceedUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			m.User = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.User |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMediaSysNotifyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMediaSysNotifyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMediaSysNotifyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailUsers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailUsers = append(m.FailUsers, &FailUser{})
			if err := m.FailUsers[len(m.FailUsers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SucceedUsers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SucceedUsers = append(m.SucceedUsers, &SucceedUser{})
			if err := m.SucceedUsers[len(m.SucceedUsers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUserByNicknameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUserByNicknameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUserByNicknameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUserByNicknameResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUserByNicknameResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUserByNicknameResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserInfos = append(m.UserInfos, &UserInfo{})
			if err := m.UserInfos[len(m.UserInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MomentNotifyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MomentNotifyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MomentNotifyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceCode", wireType)
			}
			m.SourceCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessCode", wireType)
			}
			m.BusinessCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToId", wireType)
			}
			m.ToId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumId", wireType)
			}
			m.ForumId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumType", wireType)
			}
			m.ForumType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForumImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForumText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFollowed", wireType)
			}
			m.IsFollowed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsFollowed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTime", wireType)
			}
			m.MsgTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entites = append(m.Entites, &Entity{})
			if err := m.Entites[len(m.Entites)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MomentNotifyReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MomentNotifyReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MomentNotifyReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MomentNotifyData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MomentNotifyData = append(m.MomentNotifyData, &MomentNotifyData{})
			if err := m.MomentNotifyData[len(m.MomentNotifyData)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MomentNotifyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MomentNotifyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MomentNotifyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckIsMuteContactReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckIsMuteContactReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckIsMuteContactReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckIsMuteContactResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckIsMuteContactResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckIsMuteContactResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (CheckIsMuteContactResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContactInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: contactInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: contactInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactId", wireType)
			}
			m.ContactId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContactId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSelfContacted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSelfContacted = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfIsContacted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SelfIsContacted = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StarMark", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StarMark = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasPhone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasPhone = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContatsGetContactsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContatsGetContactsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContatsGetContactsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contacthash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contacthash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContatsGetContactsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContatsGetContactsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContatsGetContactsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactArr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactArr = append(m.ContactArr, &ContactInfo{})
			if err := m.ContactArr[len(m.ContactArr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfoArr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserInfoArr = append(m.UserInfoArr, &UserInfo{})
			if err := m.UserInfoArr[len(m.UserInfoArr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MomentState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MomentState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MomentState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateMoments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateMoments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateMoments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MomentStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MomentStates = append(m.MomentStates, &MomentState{})
			if err := m.MomentStates[len(m.MomentStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResUpdateMoments) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResUpdateMoments: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResUpdateMoments: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqIntegralUniversalBusiness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqIntegralUniversalBusiness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqIntegralUniversalBusiness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImUserId", wireType)
			}
			m.ImUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImKeyId", wireType)
			}
			m.ImKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImKeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessId", wireType)
			}
			m.BusinessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (MsgFromID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyIntegralUniversalBusiness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyIntegralUniversalBusiness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyIntegralUniversalBusiness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OtherTransReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OtherTransReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OtherTransReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMessagId", wireType)
			}
			m.ReqMessagId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMessagId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqBytes = append(m.ReqBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqBytes == nil {
				m.ReqBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OtherTransResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OtherTransResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OtherTransResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespBytes = append(m.RespBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RespBytes == nil {
				m.RespBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUserDetailReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUserDetailReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUserDetailReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Birthday", wireType)
			}
			m.Birthday = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Birthday |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extend", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extend = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUserDetailResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUserDetailResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUserDetailResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Successful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Successful = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByUsernameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByUsernameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByUsernameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserInfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserInfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserInfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uinfo == nil {
				m.Uinfo = &UserInfo{}
			}
			if err := m.Uinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendGameRedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendGameRedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendGameRedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdpRsp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RdpRsp = append(m.RdpRsp[:0], dAtA[iNdEx:postIndex]...)
			if m.RdpRsp == nil {
				m.RdpRsp = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QryGameRdpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QryGameRdpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QryGameRdpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RcvGameRedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RcvGameRedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RcvGameRedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdpRsp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RdpRsp = append(m.RdpRsp[:0], dAtA[iNdEx:postIndex]...)
			if m.RdpRsp == nil {
				m.RdpRsp = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameRedResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRedResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRedResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRDPReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRDPReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRDPReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMessageId", wireType)
			}
			m.ReqMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqBytes = append(m.ReqBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqBytes == nil {
				m.ReqBytes = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedMessageId", wireType)
			}
			m.RedMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedMessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedChanelId", wireType)
			}
			m.RedChanelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RedChanelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendRDPResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendRDPResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendRDPResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespBytes = append(m.RespBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RespBytes == nil {
				m.RespBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckRDPReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRDPReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRDPReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMessageId", wireType)
			}
			m.ReqMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqBytes = append(m.ReqBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqBytes == nil {
				m.ReqBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckRDPResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckRDPResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckRDPResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespBytes = append(m.RespBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RespBytes == nil {
				m.RespBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveRDPReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveRDPReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveRDPReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMessageId", wireType)
			}
			m.ReqMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqBytes = append(m.ReqBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqBytes == nil {
				m.ReqBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveRDPResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveRDPResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveRDPResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespBytes = append(m.RespBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.RespBytes == nil {
				m.RespBytes = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyEditChannelAbout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyEditChannelAbout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyEditChannelAbout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Succeed = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyEditChannelTitle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyEditChannelTitle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyEditChannelTitle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotUpdateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotUpdateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotUpdateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotInfoVersion", wireType)
			}
			m.BotInfoVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotInfoVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotChatHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotChatHistory = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotNoChat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotNoChat = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BotUpdateInfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BotUpdateInfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BotUpdateInfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyUpdatePinnedChannelMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyUpdatePinnedChannelMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyUpdatePinnedChannelMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyLeaveChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyLeaveChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyLeaveChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetAllChats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetAllChats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetAllChats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetAllChats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetAllChats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetAllChats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Chats = append(m.Chats, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Chats = append(m.Chats, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Chats", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetchannelDifference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetchannelDifference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetchannelDifference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range_MinId", wireType)
			}
			m.Range_MinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Range_MinId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range_MaxId", wireType)
			}
			m.Range_MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Range_MaxId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			m.Device = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Device |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyChannelDiffCommon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyChannelDiffCommon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyChannelDiffCommon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Difference", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Difference = append(m.Difference[:0], dAtA[iNdEx:postIndex]...)
			if m.Difference == nil {
				m.Difference = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqFullchannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqFullchannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqFullchannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyFullChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyFullChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyFullChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates[:0], dAtA[iNdEx:postIndex]...)
			if m.Updates == nil {
				m.Updates = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDeleteMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDeleteMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDeleteMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revoke", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Revoke = bool(v != 0)
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channelid", wireType)
			}
			m.Channelid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channelid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyDeleteMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyDeleteMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyDeleteMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterUserInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterUserInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterUserInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBot = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotInfoVersion", wireType)
			}
			m.BotInfoVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotInfoVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotChatHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotChatHistory = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotNoChats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotNoChats = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dc", wireType)
			}
			m.Dc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dc |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupNow", wireType)
			}
			m.GroupNow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupNow |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sex", wireType)
			}
			m.Sex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Birthday", wireType)
			}
			m.Birthday = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Birthday |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetFullChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetFullChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetFullChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetParticipants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetParticipants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetParticipants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffSet", wireType)
			}
			m.OffSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffSet |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiType", wireType)
			}
			m.PartiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartiType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdatePinnedChannelMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdatePinnedChannelMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdatePinnedChannelMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqEditChannelAbout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqEditChannelAbout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqEditChannelAbout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqEditChannelTitle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqEditChannelTitle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqEditChannelTitle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyChannelData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyChannelData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyChannelData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDelManualBlockList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDelManualBlockList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDelManualBlockList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnBlockUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnBlockUser == nil {
				m.UnBlockUser = &BlockUser{}
			}
			if err := m.UnBlockUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetManualBlockList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetManualBlockList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetManualBlockList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockUser == nil {
				m.BlockUser = &BlockUser{}
			}
			if err := m.BlockUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManualBlockReplyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManualBlockReplyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManualBlockReplyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyData = append(m.ReplyData[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyData == nil {
				m.ReplyData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reply = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreShopStickerSetDocumentsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreShopStickerSetDocumentsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreShopStickerSetDocumentsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Documents = append(m.Documents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Documents = append(m.Documents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Documents", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreShopStickerSetDocumentsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreShopStickerSetDocumentsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreShopStickerSetDocumentsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorStickerSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorStickerSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorStickerSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickersetId", wireType)
			}
			m.StickersetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickersetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Archived = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Installed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Installed = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordered", wireType)
			}
			m.Ordered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordered |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			m.Updated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Updated |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthorAllStickerSetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthorAllStickerSetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthorAllStickerSetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAuthorAllStickerSetResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAuthorAllStickerSetResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAuthorAllStickerSetResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sets = append(m.Sets, &AuthorStickerSet{})
			if err := m.Sets[len(m.Sets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStickerPackDocumentReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStickerPackDocumentReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStickerPackDocumentReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickersetId", wireType)
			}
			m.StickersetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickersetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStickerPackDocumentResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStickerPackDocumentResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStickerPackDocumentResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStickerSetInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStickerSetInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStickerSetInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsId = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickerSetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerSetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerSetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Free = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Official = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Masks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Masks = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emoticon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emoticon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Documents = append(m.Documents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Documents = append(m.Documents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Documents", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStickerSetInfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStickerSetInfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStickerSetInfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSetInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StickerSetInfo == nil {
				m.StickerSetInfo = &StickerSetInfo{}
			}
			if err := m.StickerSetInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStickerSetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStickerSetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStickerSetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerId", wireType)
			}
			m.StickerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickerId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteStickerSetResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteStickerSetResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteStickerSetResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreUserStickerSetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreUserStickerSetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreUserStickerSetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickersetId", wireType)
			}
			m.StickersetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickersetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Installed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Installed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disabled = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archived", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Archived = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreUserStickerSetResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreUserStickerSetResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreUserStickerSetResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStickerPackDcReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStickerPackDcReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStickerPackDcReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickpackbase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stickpackbase == nil {
				m.Stickpackbase = &StickerPackDocumentBase{}
			}
			if err := m.Stickpackbase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStickerPackDcResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStickerPackDcResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStickerPackDcResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreShopStickerSetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreShopStickerSetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreShopStickerSetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Free", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Free = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Official", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Official = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Masks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Masks = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emoticon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emoticon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Documents = append(m.Documents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Documents = append(m.Documents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Documents", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreShopStickerSetResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreShopStickerSetResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreShopStickerSetResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResizeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResizeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResizeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResizeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResizeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResizeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (StatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputWebp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OutputWebp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConstraintReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConstraintReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConstraintReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (StatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginWidth", wireType)
			}
			m.OriginWidth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginWidth |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginHeight", wireType)
			}
			m.OriginHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginHeight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompressImageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompressImageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompressImageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quality", wireType)
			}
			m.Quality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quality |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompressImageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompressImageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompressImageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (StatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoPreviewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPreviewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPreviewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoPreviewReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoPreviewReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoPreviewReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (StatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preview", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Preview = append(m.Preview[:0], dAtA[iNdEx:postIndex]...)
			if m.Preview == nil {
				m.Preview = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioPreviewRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioPreviewRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioPreviewRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioPreviewReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioPreviewReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioPreviewReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (StatusCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cover", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cover = append(m.Cover[:0], dAtA[iNdEx:postIndex]...)
			if m.Cover == nil {
				m.Cover = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Artist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Artist = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqParticipants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqParticipants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqParticipants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffSet", wireType)
			}
			m.OffSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffSet |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiType", wireType)
			}
			m.PartiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartiType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyParticipants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyParticipants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyParticipants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates[:0], dAtA[iNdEx:postIndex]...)
			if m.Updates == nil {
				m.Updates = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqCreateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqCreateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqCreateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatid", wireType)
			}
			m.Chatid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chatid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyCreateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyCreateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyCreateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqMigrateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqMigrateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqMigrateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatid", wireType)
			}
			m.Chatid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chatid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromkeyid", wireType)
			}
			m.Fromkeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromkeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyMigrateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyMigrateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyMigrateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqJoinChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqJoinChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqJoinChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByLink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByLink = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitor", wireType)
			}
			m.Invitor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invitor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteType", wireType)
			}
			m.InviteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviteType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyJoinChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyJoinChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyJoinChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqChangeGroupAndChannelCrator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqChangeGroupAndChannelCrator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqChangeGroupAndChannelCrator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorId", wireType)
			}
			m.OperatorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OperatorId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsChat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsChat = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyChangeGroupAndChannelCrator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyChangeGroupAndChannelCrator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyChangeGroupAndChannelCrator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqBotCallMessageMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqBotCallMessageMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqBotCallMessageMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromBotId", wireType)
			}
			m.FromBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgTxt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgTxt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request[:0], dAtA[iNdEx:postIndex]...)
			if m.Request == nil {
				m.Request = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestDialog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestDialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestDialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetDate", wireType)
			}
			m.OffsetDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetId", wireType)
			}
			m.OffsetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetPeer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffsetPeer = append(m.OffsetPeer[:0], dAtA[iNdEx:postIndex]...)
			if m.OffsetPeer == nil {
				m.OffsetPeer = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyDialog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyDialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyDialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetGameScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetGameScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetGameScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scores = append(m.Scores, &UserScore{})
			if err := m.Scores[len(m.Scores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableEditMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableEditMessage = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			m.ChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InlineMessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InlineMessageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Botid", wireType)
			}
			m.Botid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Botid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplySetGameScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplySetGameScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplySetGameScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Succeed = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyBanChannelUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyBanChannelUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyBanChannelUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates[:0], dAtA[iNdEx:postIndex]...)
			if m.Updates == nil {
				m.Updates = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqBanChannelUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqBanChannelUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqBanChannelUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BannedUserId", wireType)
			}
			m.BannedUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BannedUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilDate", wireType)
			}
			m.UtilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UtilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelBannedRights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelBannedRights == nil {
				m.ChannelBannedRights = &ChannelBannedRights{}
			}
			if err := m.ChannelBannedRights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetChannels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetChannels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetChannels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChannelIds = append(m.ChannelIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChannelIds = append(m.ChannelIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetChannels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetChannels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetChannels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDeleteChatUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDeleteChatUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDeleteChatUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatid", wireType)
			}
			m.Chatid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chatid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyDeleteChatUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyDeleteChatUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyDeleteChatUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelInactiveUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelInactiveUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelInactiveUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelInactiveUsersReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelInactiveUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelInactiveUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelInactiveUsersResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelInactiveUsersResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelInactiveUsersResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &ChannelInactiveUser{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errcode", wireType)
			}
			m.Errcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errcode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqBotInlineCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqBotInlineCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqBotInlineCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyBotInlineCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyBotInlineCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyBotInlineCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inlinecall", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inlinecall == nil {
				m.Inlinecall = &InlineCall{}
			}
			if err := m.Inlinecall.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InlineCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InlineCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InlineCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			m.ChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSendUserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSendUserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSendUserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Toid", wireType)
			}
			m.Toid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Toid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyBool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyBool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyBool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqBotCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqBotCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqBotCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrombotId", wireType)
			}
			m.FrombotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrombotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Request = append(m.Request[:0], dAtA[iNdEx:postIndex]...)
			if m.Request == nil {
				m.Request = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyBotCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyBotCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyBotCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetMessageByUserIdUuid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetMessageByUserIdUuid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetMessageByUserIdUuid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			m.Uuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetMessageByUserIdUuid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetMessageByUserIdUuid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetMessageByUserIdUuid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMessage == nil {
				m.UserMessage = &UserMsg{}
			}
			if err := m.UserMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetChannelMessageByChannelIdMsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetChannelMessageByChannelIdMsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetChannelMessageByChannelIdMsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetChannelMessageByChannelIdMsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetChannelMessageByChannelIdMsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetChannelMessageByChannelIdMsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMessage == nil {
				m.UserMessage = &UserMsg{}
			}
			if err := m.UserMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetMessageByUserIdMsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetMessageByUserIdMsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetMessageByUserIdMsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetMessageByUserIdMsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetMessageByUserIdMsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetMessageByUserIdMsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMessage == nil {
				m.UserMessage = &UserMsg{}
			}
			if err := m.UserMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFileDescReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFileDescReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFileDescReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFileDescResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFileDescResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFileDescResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgServiceLimitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgServiceLimitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgServiceLimitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgServiceLimitResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgServiceLimitResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgServiceLimitResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usfsl", wireType)
			}
			m.Usfsl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usfsl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ubfssl", wireType)
			}
			m.Ubfssl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ubfssl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dssl", wireType)
			}
			m.Dssl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dssl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyid", wireType)
			}
			m.Keyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fileid", wireType)
			}
			m.Fileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartTotal", wireType)
			}
			m.PartTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFidResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFidResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFidResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFilePartsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFilePartsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFilePartsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyid", wireType)
			}
			m.Keyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fileid", wireType)
			}
			m.Fileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartId", wireType)
			}
			m.PartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartTotal", wireType)
			}
			m.PartTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFilePartsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFilePartsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFilePartsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUploadFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUploadFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUploadFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para1 == nil {
				m.Para1 = &storageservice1.UploadReqPara1{}
			}
			if err := m.Para1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para2 == nil {
				m.Para2 = &storageservice1.UploadReqPara2{}
			}
			if err := m.Para2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUploadFileResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUploadFileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUploadFileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para1 == nil {
				m.Para1 = &storageservice1.FileUploadRespPara{}
			}
			if err := m.Para1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para2 == nil {
				m.Para2 = &storageservice.FidPara{}
			}
			if err := m.Para2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDownloadFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDownloadFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDownloadFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileRespPara1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileRespPara1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileRespPara1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileRespPara2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileRespPara2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileRespPara2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDownloadFileResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDownloadFileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDownloadFileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para1 == nil {
				m.Para1 = &DownloadFileRespPara1{}
			}
			if err := m.Para1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para2 == nil {
				m.Para2 = &DownloadFileRespPara2{}
			}
			if err := m.Para2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgQueryObjInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgQueryObjInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgQueryObjInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryObjInfoRespPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryObjInfoRespPara: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryObjInfoRespPara: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgQueryObjInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgQueryObjInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgQueryObjInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &QueryObjInfoRespPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFileDescReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFileDescReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFileDescReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFileDescResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFileDescResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFileDescResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dlog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dlog == nil {
				m.Dlog = &Debug{}
			}
			if err := m.Dlog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseInfo == nil {
				m.BaseInfo = &ChannelInfoBase{}
			}
			if err := m.BaseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resultcode", wireType)
			}
			m.Resultcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resultcode |= (ChatResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetAdminGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetAdminGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetAdminGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerFilter", wireType)
			}
			m.PeerFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerFilter |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerID", wireType)
			}
			m.PeerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetGroups) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetGroups: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetGroups: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Groups = append(m.Groups, &Peer{})
			if err := m.Groups[len(m.Groups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuperGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SuperGroups = append(m.SuperGroups, &Peer{})
			if err := m.SuperGroups[len(m.SuperGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, &Peer{})
			if err := m.Channels[len(m.Channels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDeleteMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDeleteMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDeleteMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			m.ChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatType |= (ChatType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgId = append(m.MsgId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgId = append(m.MsgId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSendChatAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSendChatAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSendChatAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			m.ChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatType |= (ChatType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActionData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActionData = append(m.ActionData[:0], dAtA[iNdEx:postIndex]...)
			if m.ActionData == nil {
				m.ActionData = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			m.ChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatType |= (ChatType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqData = append(m.ReqData[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqData == nil {
				m.ReqData = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetChatMembersCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetChatMembersCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetChatMembersCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			m.ChatType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatType |= (ChatType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetChatMembersCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetChatMembersCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetChatMembersCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatMembersCount", wireType)
			}
			m.ChatMembersCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatMembersCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChatInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChatInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChatInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotGet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RobotGet = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dlog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dlog == nil {
				m.Dlog = &Debug{}
			}
			if err := m.Dlog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUsersChatsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUsersChatsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUsersChatsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Users = append(m.Users, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Users = append(m.Users, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Chatid = append(m.Chatid, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Chatid = append(m.Chatid, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatid", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Channelid = append(m.Channelid, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Channelid = append(m.Channelid, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Channelid", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolLayer", wireType)
			}
			m.ProtocolLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolLayer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dlog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dlog == nil {
				m.Dlog = &Debug{}
			}
			if err := m.Dlog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUsersChatsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUsersChatsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUsersChatsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channels", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channels = append(m.Channels, make([]byte, postIndex-iNdEx))
			copy(m.Channels[len(m.Channels)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Users == nil {
				m.Users = &UserInfoArray{}
			}
			if err := m.Users.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chats", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chats = append(m.Chats, make([]byte, postIndex-iNdEx))
			copy(m.Chats[len(m.Chats)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoChats = append(m.NoChats, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoChats = append(m.NoChats, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChats", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NoChans = append(m.NoChans, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NoChans = append(m.NoChans, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NoChans", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resultcode", wireType)
			}
			m.Resultcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resultcode |= (ChatResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserInfoByIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserInfoByIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserInfoByIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserInfoByIdArrReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserInfoByIdArrReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserInfoByIdArrReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserProfileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserProfileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserProfileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserProfileResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserProfileResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserProfileResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uinfo == nil {
				m.Uinfo = &UserInfo{}
			}
			if err := m.Uinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByphone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByphone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByphone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBotInfoSuppReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBotInfoSuppReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBotInfoSuppReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Placeholder", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Placeholder = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Geo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Geo = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBotInfoSuppResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBotInfoSuppResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBotInfoSuppResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBotPicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBotPicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBotPicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Photo = append(m.Photo[:0], dAtA[iNdEx:postIndex]...)
			if m.Photo == nil {
				m.Photo = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateBotPicResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateBotPicResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateBotPicResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateuserNameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateuserNameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateuserNameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateuserNameResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateuserNameResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateuserNameResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uinfo == nil {
				m.Uinfo = &UserInfo{}
			}
			if err := m.Uinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterUserInfoResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterUserInfoResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterUserInfoResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uinfo == nil {
				m.Uinfo = &UserInfo{}
			}
			if err := m.Uinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAccountByIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAccountByIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAccountByIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelId", wireType)
			}
			m.DelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelAccountResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelAccountResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelAccountResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignUpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignUpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignUpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneCodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBot = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotInfoVersion", wireType)
			}
			m.BotInfoVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotInfoVersion |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotChatHistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotChatHistory = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotNoChats", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BotNoChats = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthSignUpResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthSignUpResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthSignUpResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (AuthSignUpResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserInfo == nil {
				m.UserInfo = &UserInfo{}
			}
			if err := m.UserInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFullUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFullUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFullUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFullUserResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFullUserResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFullUserResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Uinfo == nil {
				m.Uinfo = &UserInfo{}
			}
			if err := m.Uinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isblocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Isblocked = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCallsPrivate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhoneCallsPrivate = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCallsAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PhoneCallsAvailable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonChat", wireType)
			}
			m.CommonChat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommonChat |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extend", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extend = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserByUsername) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserByUsername: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserByUsername: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfId", wireType)
			}
			m.SelfId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SelfId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetFullChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetFullChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetFullChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatid", wireType)
			}
			m.Chatid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chatid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetFullChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetFullChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetFullChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqLeaveChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqLeaveChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqLeaveChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSendMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSendMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSendMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Background = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDraft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearDraft = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = append(m.Peer[:0], dAtA[iNdEx:postIndex]...)
			if m.Peer == nil {
				m.Peer = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMsgId", wireType)
			}
			m.ReplyToMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = append(m.Media[:0], dAtA[iNdEx:postIndex]...)
			if m.Media == nil {
				m.Media = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiMedia", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiMedia = append(m.MultiMedia, make([]byte, postIndex-iNdEx))
			copy(m.MultiMedia[len(m.MultiMedia)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Newfileid", wireType)
			}
			m.Newfileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Newfileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromkeyId", wireType)
			}
			m.FromkeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromkeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Chatmeber = append(m.Chatmeber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Chatmeber = append(m.Chatmeber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatmeber", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqEditChatTitle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqEditChatTitle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqEditChatTitle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatid", wireType)
			}
			m.Chatid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chatid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyEditChatTitle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyEditChatTitle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyEditChatTitle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStickerSetPackDcInfosReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStickerSetPackDcInfosReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStickerSetPackDcInfosReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStickerSetPackDcInfosResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStickerSetPackDcInfosResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStickerSetPackDcInfosResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StPDcInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StPDcInfo = append(m.StPDcInfo, &StickerPackDocumentInfo{})
			if err := m.StPDcInfo[len(m.StPDcInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickerPackDocumentBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerPackDocumentBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerPackDocumentBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesStikerSetId", wireType)
			}
			m.AttributesStikerSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributesStikerSetId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentId", wireType)
			}
			m.DocumentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesImageSizeW", wireType)
			}
			m.AttributesImageSizeW = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributesImageSizeW |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesImageSizeH", wireType)
			}
			m.AttributesImageSizeH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributesImageSizeH |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesStikerAlt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributesStikerAlt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesStikerSetAccessHash", wireType)
			}
			m.AttributesStikerSetAccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributesStikerSetAccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributesFileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttributesFileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StickerPackDocumentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StickerPackDocumentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StickerPackDocumentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfoBase == nil {
				m.InfoBase = &StickerPackDocumentBase{}
			}
			if err := m.InfoBase.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserInfoByIdArrResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserInfoByIdArrResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserInfoByIdArrResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uinfo = append(m.Uinfo, &UserInfo{})
			if err := m.Uinfo[len(m.Uinfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBotVerifiedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBotVerifiedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBotVerifiedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetBotVerifiedReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetBotVerifiedReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetBotVerifiedReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContactsGetCommonContactsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContactsGetCommonContactsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContactsGetCommonContactsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImapigateway
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImapigateway
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContactsGetCommonContactsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContactsGetCommonContactsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContactsGetCommonContactsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImapigateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserInfos = append(m.UserInfos, &UserInfo{})
			if err := m.UserInfos[len(m.UserInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errorcode", wireType)
			}
			m.Errorcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errorcode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImapigateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImapigateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImapigateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImapigateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImapigateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImapigateway
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImapigateway
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImapigateway(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImapigateway = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImapigateway   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imapigateway/imapigateway.proto", fileDescriptorImapigateway)
}

var fileDescriptorImapigateway = []byte{
	// 9846 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x5b, 0x6c, 0x24, 0x49,
	0x72, 0x18, 0xab, 0x1f, 0x64, 0x77, 0x34, 0xc9, 0xe9, 0x29, 0x92, 0x33, 0x1c, 0xce, 0x0c, 0x67,
	0xb6, 0xf6, 0xf6, 0xb4, 0x37, 0x3a, 0xcd, 0xee, 0x52, 0xbb, 0xba, 0x5d, 0x3d, 0xce, 0xc7, 0xc7,
	0x90, 0xc3, 0x9b, 0xe1, 0x0c, 0xb7, 0x7a, 0xb8, 0x23, 0xaf, 0x64, 0xb5, 0x8b, 0x5d, 0xc9, 0xee,
	0x32, 0xab, 0xab, 0x9a, 0x55, 0xd5, 0x9c, 0xe1, 0x9e, 0xfc, 0x00, 0xce, 0x67, 0xe8, 0xce, 0x38,
	0xcb, 0xf7, 0x90, 0x04, 0xff, 0x18, 0xc6, 0xd9, 0x06, 0x2c, 0xdb, 0x1f, 0x36, 0x60, 0xc0, 0x80,
	0x61, 0x40, 0xb6, 0x21, 0x9c, 0x25, 0x4b, 0x06, 0x2c, 0xeb, 0xd7, 0x16, 0x84, 0x93, 0xe1, 0x1f,
	0xc3, 0xfe, 0xf6, 0x9f, 0x8d, 0x8c, 0xcc, 0xac, 0xca, 0xac, 0x47, 0x37, 0x9b, 0x9c, 0x5d, 0xc1,
	0x86, 0x7e, 0xc8, 0x8e, 0xc8, 0xac, 0x7c, 0x44, 0x66, 0x46, 0x44, 0x46, 0x46, 0x46, 0xc2, 0x56,
	0xd7, 0x89, 0x5c, 0xeb, 0xf0, 0x7e, 0xa7, 0x67, 0x45, 0x21, 0x09, 0x4e, 0x49, 0x70, 0xdf, 0xe9,
	0xbf, 0xe5, 0x78, 0x11, 0x09, 0x8e, 0xac, 0x0e, 0x19, 0x04, 0xfe, 0xe1, 0xf0, 0xe8, 0x2d, 0xa7,
	0x6f, 0x0d, 0x9c, 0xae, 0x15, 0x91, 0x17, 0xd6, 0x99, 0x02, 0xdc, 0x1f, 0x04, 0x7e, 0xe4, 0xeb,
	0xb3, 0x32, 0x6e, 0xe5, 0xcb, 0x93, 0x97, 0xd9, 0xf1, 0xfb, 0x7d, 0xdf, 0x63, 0xa5, 0xad, 0x3c,
	0x38, 0xd7, 0xf7, 0x61, 0xe4, 0x07, 0x56, 0x97, 0xd0, 0x0c, 0x4e, 0x87, 0x08, 0xb0, 0x3d, 0x18,
	0x1e, 0xf2, 0x62, 0x76, 0x2e, 0x55, 0x0c, 0x2d, 0x82, 0x15, 0x64, 0x44, 0xa0, 0xef, 0x90, 0x68,
	0x27, 0xf0, 0x87, 0x83, 0x83, 0x90, 0x04, 0xbb, 0x76, 0x68, 0x92, 0x13, 0xfd, 0x1a, 0x4c, 0x77,
	0x7a, 0x96, 0xb7, 0x6b, 0x2f, 0x6b, 0x77, 0xb5, 0x37, 0xab, 0x26, 0x87, 0x28, 0x7e, 0x88, 0xb9,
	0x96, 0x4b, 0x0c, 0xcf, 0x20, 0x8a, 0xf7, 0x8f, 0x8e, 0x42, 0x12, 0x2d, 0x97, 0x19, 0x9e, 0x41,
	0x14, 0xef, 0x12, 0xaf, 0x1b, 0xf5, 0x96, 0x2b, 0x0c, 0xcf, 0x20, 0xe3, 0x6f, 0x69, 0xd9, 0x6a,
	0xc3, 0x81, 0xfe, 0x53, 0x50, 0x35, 0x49, 0xf4, 0xc4, 0xc7, 0x5a, 0xe7, 0xd7, 0xee, 0xde, 0x57,
	0x86, 0x03, 0x73, 0x3f, 0x76, 0x4e, 0x89, 0x49, 0x06, 0xee, 0xd9, 0xa6, 0x6f, 0x13, 0x93, 0x65,
	0xd7, 0x17, 0xa1, 0xfa, 0xcc, 0x8f, 0x2c, 0x97, 0xb7, 0x8a, 0x01, 0x14, 0xbb, 0xe9, 0x0f, 0x3d,
	0xd1, 0x26, 0x06, 0x50, 0x2c, 0xad, 0x31, 0x5c, 0xae, 0xdc, 0x2d, 0x53, 0x2c, 0x02, 0xc6, 0x0f,
	0x4a, 0x30, 0x4b, 0x8b, 0x6e, 0x45, 0x56, 0x10, 0x51, 0x0a, 0x2c, 0xc3, 0xcc, 0x06, 0xe9, 0x3a,
	0xde, 0x7a, 0xc4, 0x49, 0x20, 0x40, 0x9a, 0x82, 0x2d, 0x89, 0x89, 0x20, 0x40, 0x7d, 0x05, 0x6a,
	0xbc, 0x0c, 0x51, 0x67, 0x0c, 0x8b, 0xb4, 0x67, 0x67, 0x03, 0xc2, 0x69, 0x11, 0xc3, 0x22, 0x8d,
	0xb6, 0x64, 0xb9, 0x9a, 0xa4, 0x51, 0x58, 0xa4, 0x99, 0xbe, 0xdf, 0x5f, 0x9e, 0x4e, 0xd2, 0x28,
	0x2c, 0xd2, 0xf6, 0x8f, 0x77, 0xed, 0xe5, 0x99, 0xbb, 0xda, 0x9b, 0x65, 0x33, 0x86, 0x45, 0xda,
	0xb6, 0x6b, 0x75, 0x97, 0x6b, 0x77, 0xb5, 0x37, 0xeb, 0x66, 0x0c, 0x8b, 0xb4, 0x27, 0x56, 0x9f,
	0x2c, 0xd7, 0x93, 0x34, 0x0a, 0x8b, 0xb4, 0xdd, 0x8e, 0xef, 0x2d, 0x43, 0x92, 0x46, 0x61, 0xc3,
	0x95, 0x69, 0x14, 0x0e, 0xf4, 0x2f, 0x43, 0x3d, 0x1e, 0x8a, 0x73, 0x0f, 0x59, 0xf2, 0x89, 0x7e,
	0x0b, 0xea, 0xbb, 0xde, 0xa9, 0x13, 0x91, 0x83, 0x80, 0x0d, 0x5d, 0xdd, 0x4c, 0x10, 0xc6, 0xd7,
	0xa0, 0xc1, 0x6a, 0xf3, 0x07, 0x7c, 0x40, 0x04, 0xd9, 0xb5, 0x5c, 0xb2, 0x23, 0xf9, 0x4a, 0xf9,
	0xe4, 0x1b, 0x35, 0x24, 0xd8, 0xfa, 0x4a, 0xd2, 0x55, 0x0a, 0x1b, 0x1d, 0xa9, 0xf2, 0x70, 0xa0,
	0xff, 0x34, 0xcc, 0x98, 0x24, 0x9a, 0xa8, 0x9f, 0xe2, 0x03, 0xda, 0x70, 0xd6, 0xa9, 0x78, 0xbe,
	0x70, 0xd0, 0x20, 0xb0, 0xb0, 0x43, 0x22, 0x24, 0xaf, 0xe8, 0xf5, 0x25, 0xa7, 0x1e, 0xd2, 0xa0,
	0xac, 0xd2, 0xc0, 0x08, 0x73, 0xaa, 0xf9, 0xd4, 0x47, 0xef, 0x9b, 0x25, 0xb8, 0xf2, 0xc0, 0x76,
	0x78, 0xb5, 0x47, 0xfe, 0xff, 0x63, 0x6b, 0x0a, 0xd7, 0xcd, 0xcc, 0x88, 0x75, 0x53, 0x1b, 0xb1,
	0x6e, 0xea, 0xa9, 0x75, 0xe3, 0xa7, 0x48, 0xf1, 0x6a, 0x88, 0x8f, 0xc0, 0x96, 0x15, 0x59, 0x82,
	0xf8, 0x31, 0xc2, 0xd8, 0x85, 0xab, 0xf1, 0xe7, 0x9b, 0x3d, 0xd2, 0x39, 0xbe, 0xf0, 0x02, 0x32,
	0x4e, 0x32, 0x45, 0x7d, 0xea, 0xad, 0x7f, 0x94, 0x9a, 0xaf, 0x9b, 0x5e, 0x74, 0xf1, 0xf6, 0x1f,
	0xe7, 0x14, 0xf6, 0xa9, 0x2d, 0xe8, 0x1d, 0x58, 0x40, 0x1a, 0xa1, 0x48, 0xf3, 0xb0, 0x8c, 0xd1,
	0x2d, 0xbf, 0x06, 0xd3, 0x07, 0x8a, 0x3c, 0x65, 0x90, 0xf1, 0x56, 0x4e, 0x41, 0xe1, 0x80, 0xd5,
	0x8c, 0x10, 0x16, 0x54, 0x33, 0x05, 0x68, 0x38, 0x8c, 0x5f, 0xed, 0x0f, 0xc3, 0x1e, 0xad, 0xf1,
	0x06, 0xd4, 0xa8, 0x64, 0x6e, 0x3b, 0x76, 0xb8, 0xac, 0xa1, 0x9c, 0x9b, 0x61, 0x92, 0x3a, 0xd4,
	0xaf, 0xc3, 0x4c, 0x48, 0xdc, 0xa3, 0xb6, 0x13, 0xd7, 0x49, 0xc1, 0x5d, 0x5b, 0xd7, 0xa1, 0x12,
	0x91, 0x97, 0x6c, 0x95, 0xd5, 0x4d, 0xfc, 0x8d, 0xb8, 0x64, 0x75, 0xe1, 0x6f, 0xe3, 0x1e, 0xcc,
	0x27, 0x55, 0x85, 0x43, 0x17, 0x57, 0x6f, 0x38, 0xec, 0x74, 0x48, 0x18, 0x8a, 0x66, 0x71, 0xd0,
	0xf8, 0x1b, 0x25, 0xd0, 0x4d, 0x72, 0xf2, 0xc8, 0xe9, 0x1c, 0x6f, 0x07, 0x7e, 0x7f, 0xb3, 0x67,
	0x79, 0x1e, 0x71, 0xe9, 0xf8, 0x77, 0xd8, 0xcf, 0x98, 0x24, 0x09, 0x82, 0x12, 0xe5, 0xd8, 0xe9,
	0x1c, 0xc7, 0x83, 0xc9, 0xa1, 0x18, 0x4f, 0x84, 0x92, 0xc1, 0x20, 0x7d, 0x15, 0x1a, 0x4e, 0xd8,
	0x3e, 0xf4, 0xa3, 0x36, 0xed, 0x23, 0xb6, 0xb5, 0x66, 0xd6, 0x9d, 0x70, 0xc3, 0x8f, 0x70, 0xb9,
	0xdf, 0x84, 0xba, 0x13, 0xb6, 0x31, 0xb3, 0x8d, 0xbc, 0xa0, 0x66, 0xd6, 0x9c, 0xf0, 0x11, 0xc2,
	0x34, 0x91, 0xfd, 0xa2, 0x04, 0xe1, 0xcc, 0x80, 0x21, 0x76, 0x6d, 0xfd, 0x36, 0xc0, 0x51, 0xe0,
	0xf7, 0xdb, 0xc7, 0xe4, 0xcc, 0x11, 0x22, 0xb6, 0x4e, 0x31, 0x8f, 0x28, 0x42, 0xff, 0x02, 0x54,
	0x6d, 0x72, 0x38, 0x64, 0x02, 0xb6, 0xb1, 0xb6, 0xa0, 0x4e, 0xa1, 0x2d, 0x9a, 0x64, 0xb2, 0x1c,
	0xc6, 0x09, 0x34, 0xe3, 0x01, 0xa5, 0xfc, 0x82, 0x2b, 0x59, 0x5c, 0x99, 0xd2, 0x14, 0x65, 0x6a,
	0x85, 0x0d, 0x1e, 0xb2, 0x19, 0xb6, 0x38, 0x62, 0x38, 0xa9, 0xb2, 0x3c, 0xb6, 0xca, 0x2e, 0x5c,
	0x4d, 0x55, 0x19, 0x0e, 0x50, 0x51, 0xeb, 0x74, 0x06, 0xc3, 0x33, 0x3e, 0x52, 0x1c, 0xa2, 0x3d,
	0x25, 0x41, 0xe0, 0x07, 0xed, 0x0e, 0x5d, 0x12, 0xb4, 0xd6, 0x39, 0xb3, 0x8e, 0x18, 0x9c, 0xf2,
	0x37, 0x81, 0x01, 0xed, 0x7e, 0xd8, 0xe5, 0x13, 0xa4, 0x86, 0x88, 0xbd, 0xb0, 0x6b, 0xfc, 0x5d,
	0x0d, 0xe6, 0x4d, 0x72, 0xd2, 0x22, 0x9e, 0x4d, 0x33, 0xef, 0x85, 0x5d, 0xd1, 0x35, 0x47, 0xe9,
	0x9a, 0x63, 0xeb, 0x77, 0xa0, 0x61, 0xe1, 0xcc, 0x68, 0xf7, 0xac, 0xb0, 0x87, 0xf5, 0x94, 0x4d,
	0x60, 0xa8, 0x87, 0x56, 0xd8, 0xa3, 0xda, 0x19, 0x23, 0x36, 0xad, 0xa4, 0x62, 0x32, 0x80, 0x4e,
	0xc3, 0x4e, 0x22, 0xa5, 0xf1, 0x77, 0x42, 0x89, 0xea, 0x58, 0x4a, 0xfc, 0x49, 0x99, 0x2e, 0x27,
	0x9c, 0x5e, 0x1b, 0xf4, 0xaf, 0x6d, 0x3a, 0xdd, 0x5e, 0x14, 0xd2, 0xca, 0x8e, 0x5c, 0xab, 0x1b,
	0xf2, 0x46, 0x32, 0x40, 0x7f, 0x1d, 0xe6, 0x4e, 0x1d, 0xf2, 0xa2, 0xdd, 0x27, 0x61, 0x48, 0x95,
	0x67, 0x6c, 0x65, 0xcd, 0x9c, 0xa5, 0xc8, 0x3d, 0x8e, 0xa3, 0x99, 0x42, 0xe2, 0xd9, 0x49, 0xa6,
	0x32, 0xcb, 0x44, 0x91, 0x71, 0xa6, 0xdb, 0x00, 0x3c, 0x93, 0xed, 0x58, 0x62, 0x5e, 0xb2, 0x1c,
	0xb6, 0x63, 0xc5, 0x65, 0x84, 0x11, 0xce, 0xef, 0x90, 0xcf, 0x4d, 0x2c, 0xa3, 0xc5, 0x71, 0x94,
	0xf2, 0x98, 0xa9, 0xeb, 0x1c, 0x85, 0x38, 0x3f, 0x6b, 0x66, 0x8d, 0x22, 0x76, 0x9c, 0xa3, 0xa4,
	0x82, 0xae, 0xd5, 0x27, 0x21, 0xce, 0x4f, 0x5e, 0xc1, 0x0e, 0x45, 0x50, 0x6a, 0x63, 0xb2, 0xe3,
	0xb9, 0x8e, 0xc7, 0x44, 0x56, 0xcd, 0xc4, 0x2f, 0x76, 0x11, 0x43, 0x33, 0x90, 0xfe, 0x21, 0xb1,
	0xdb, 0xae, 0xe3, 0x1d, 0x87, 0x28, 0xb7, 0x6a, 0x26, 0x20, 0xea, 0x31, 0xc5, 0xd0, 0x0a, 0x86,
	0x5e, 0xe4, 0xb8, 0x6d, 0xdb, 0x8a, 0x08, 0xea, 0x83, 0x55, 0xb3, 0x8e, 0x98, 0x2d, 0x2b, 0xc2,
	0xef, 0x1d, 0x64, 0x7d, 0x6c, 0xe5, 0x35, 0xd8, 0xf7, 0x0c, 0x85, 0x4b, 0xef, 0x0e, 0x34, 0x06,
	0x8e, 0x27, 0xa8, 0xb4, 0x3c, 0xcb, 0x32, 0x0c, 0x1c, 0x8f, 0xd3, 0x48, 0xbf, 0x07, 0x57, 0xe9,
	0xc2, 0xef, 0x92, 0x76, 0x97, 0xf2, 0xb1, 0xb6, 0xe3, 0x1d, 0xf9, 0xcb, 0x73, 0x98, 0xed, 0x0a,
	0x4b, 0x60, 0xac, 0xd2, 0x3b, 0xf2, 0xe3, 0xde, 0x0e, 0x7c, 0xd7, 0x0d, 0x97, 0xe7, 0x93, 0xde,
	0xee, 0x53, 0x84, 0xf1, 0xfb, 0x25, 0x58, 0x32, 0xc9, 0x09, 0x95, 0xb4, 0x1b, 0x96, 0xc7, 0xc7,
	0x1b, 0x5b, 0x71, 0x0d, 0xa6, 0xe9, 0xa2, 0x4d, 0x16, 0x1a, 0x83, 0x28, 0x1b, 0xe2, 0x8b, 0x99,
	0x33, 0xe0, 0x64, 0x75, 0xb3, 0xd4, 0x84, 0x49, 0x95, 0xd3, 0x4c, 0xca, 0x80, 0xd9, 0x43, 0x9c,
	0x4b, 0x9c, 0x7f, 0x33, 0x0e, 0xa9, 0xe0, 0xf4, 0x55, 0x90, 0xa6, 0x36, 0x8e, 0xae, 0x3a, 0xd9,
	0x6f, 0x42, 0x7d, 0x18, 0x13, 0x97, 0xf3, 0x9e, 0xa1, 0xa0, 0x6d, 0x0b, 0x16, 0x3a, 0xd9, 0x39,
	0x8b, 0x83, 0xdc, 0x58, 0x7b, 0x4d, 0x9d, 0xed, 0x39, 0x93, 0xdb, 0xcc, 0xfb, 0x7a, 0x12, 0x8e,
	0xf5, 0x6d, 0x0d, 0x16, 0x39, 0x39, 0x1f, 0x9c, 0x92, 0xe0, 0xcc, 0xf7, 0xc8, 0x87, 0x43, 0x87,
	0xed, 0xe9, 0x0e, 0x14, 0xb6, 0xc5, 0x7b, 0x7b, 0x0b, 0xea, 0x9b, 0x31, 0xbd, 0x18, 0xe7, 0x4e,
	0x10, 0x74, 0xad, 0x9d, 0xd0, 0xcf, 0xf9, 0x42, 0x61, 0x40, 0xd2, 0x9e, 0xca, 0xd8, 0xf6, 0xfc,
	0x33, 0x0d, 0x96, 0x76, 0x48, 0x24, 0x8d, 0xab, 0x50, 0x2b, 0xc7, 0x4a, 0x13, 0x3e, 0xf8, 0x25,
	0x65, 0xf0, 0x13, 0xee, 0x5b, 0x56, 0xb8, 0xaf, 0x3a, 0x68, 0x95, 0xcc, 0xa0, 0x4d, 0xc0, 0x77,
	0xfe, 0xbe, 0x06, 0xd7, 0xf2, 0x9a, 0x1c, 0x0e, 0x28, 0x39, 0x02, 0xaa, 0x59, 0x60, 0x7b, 0x67,
	0x4d, 0x06, 0xd0, 0x9e, 0xc4, 0x3c, 0x57, 0x90, 0x30, 0x61, 0xc2, 0x0a, 0x81, 0xcb, 0x69, 0x02,
	0xa7, 0x58, 0x6b, 0xb6, 0xe1, 0xd7, 0x60, 0x7a, 0x9b, 0x11, 0x82, 0xe9, 0xc3, 0x1c, 0x32, 0x02,
	0x58, 0x42, 0x39, 0xb1, 0x1b, 0xb6, 0x88, 0x7b, 0xb4, 0xe9, 0x7b, 0x91, 0xd5, 0x89, 0xb8, 0x7c,
	0x62, 0xaa, 0x81, 0x18, 0x68, 0xae, 0x28, 0x14, 0x19, 0x01, 0x26, 0x90, 0x4d, 0x2f, 0x60, 0x39,
	0xaf, 0x4e, 0xd4, 0x26, 0x3e, 0x07, 0x73, 0x0a, 0x9a, 0x4b, 0x2a, 0x15, 0xa9, 0xbf, 0x07, 0xf5,
	0x07, 0x94, 0x32, 0xb1, 0xbc, 0x9a, 0x5f, 0xbb, 0xae, 0x56, 0x68, 0x92, 0x07, 0x41, 0xc0, 0x34,
	0xcf, 0x38, 0xa7, 0x61, 0xc3, 0x95, 0x3d, 0xbf, 0x4f, 0xbc, 0x68, 0xdb, 0x77, 0x5d, 0xff, 0x05,
	0xed, 0xe6, 0x75, 0x98, 0xe1, 0xba, 0x12, 0xd6, 0x54, 0x8e, 0xfb, 0x73, 0x13, 0xea, 0x47, 0x98,
	0x4b, 0xe8, 0x4a, 0x65, 0xb3, 0xc6, 0x10, 0x2c, 0xd1, 0x09, 0xdb, 0x0c, 0x14, 0x1b, 0x13, 0x27,
	0x64, 0xa5, 0x1a, 0x6f, 0x43, 0x53, 0xad, 0x25, 0x1c, 0xa8, 0x63, 0xab, 0xa5, 0xc6, 0xd6, 0xf8,
	0xdf, 0x1a, 0x00, 0xfb, 0x84, 0xaa, 0xc0, 0x54, 0x7f, 0x3b, 0xf2, 0x83, 0x61, 0x3f, 0x69, 0xd4,
	0x0c, 0xc2, 0x5c, 0x27, 0xc1, 0x24, 0x54, 0xcc, 0x04, 0xd7, 0xa2, 0x18, 0xdc, 0xf7, 0xdc, 0x81,
	0x06, 0xff, 0xb2, 0x4f, 0x39, 0x2e, 0x93, 0xd5, 0xec, 0x8b, 0x5d, 0x8a, 0x91, 0xbe, 0xa7, 0xca,
	0x1e, 0x93, 0xa8, 0xfc, 0x7b, 0xaa, 0xf1, 0x5d, 0x87, 0x99, 0x17, 0x4e, 0xd4, 0xa3, 0x15, 0xf3,
	0x69, 0x42, 0xc1, 0x5d, 0x5b, 0x5f, 0x82, 0xe9, 0x7e, 0xd8, 0x15, 0x5a, 0x52, 0xd9, 0xac, 0xf6,
	0xc3, 0x2e, 0x9b, 0x76, 0x14, 0xdd, 0xf1, 0xbd, 0x88, 0x78, 0x11, 0xdf, 0x32, 0x41, 0x3f, 0xec,
	0x6e, 0x32, 0x0c, 0xca, 0x08, 0x41, 0x28, 0x62, 0x23, 0xe3, 0x29, 0x9b, 0x20, 0x48, 0x45, 0x6c,
	0xe3, 0x8f, 0x34, 0x98, 0x6b, 0x9d, 0x85, 0x4f, 0xfc, 0xc8, 0x39, 0xc2, 0x0d, 0x00, 0xa5, 0x2d,
	0x2d, 0x33, 0x72, 0x22, 0x97, 0x91, 0xaa, 0x6e, 0xd6, 0xfa, 0x61, 0xf7, 0x19, 0x85, 0x29, 0x69,
	0x58, 0x62, 0x5f, 0xf4, 0x7e, 0x06, 0xd3, 0xfa, 0x84, 0xb6, 0x9d, 0x26, 0x0d, 0x03, 0x97, 0xf7,
	0x9b, 0xb6, 0xf8, 0x20, 0x70, 0xf5, 0xcf, 0xc3, 0x15, 0x9a, 0x70, 0x38, 0x8c, 0x22, 0xdf, 0x93,
	0x3b, 0x3e, 0xd7, 0x0f, 0xbb, 0x1b, 0x88, 0xc5, 0xce, 0xff, 0x0c, 0xcc, 0xa2, 0x09, 0xcd, 0xea,
	0x44, 0xa8, 0xe9, 0xb0, 0x25, 0xbe, 0xac, 0xce, 0xab, 0x64, 0x98, 0xcc, 0x86, 0xc8, 0x4d, 0x75,
	0x9e, 0xeb, 0x30, 0xe3, 0x84, 0xed, 0xc1, 0x30, 0xec, 0x71, 0x39, 0x3d, 0xed, 0x84, 0x54, 0x49,
	0x36, 0x7e, 0x5f, 0x83, 0x06, 0xeb, 0x1d, 0x93, 0xfb, 0x4d, 0x28, 0x87, 0xe4, 0x84, 0x8f, 0x2b,
	0xfd, 0x49, 0x31, 0x47, 0x7c, 0x8e, 0xd5, 0x4d, 0xfa, 0x53, 0x7f, 0x0d, 0x66, 0x39, 0x49, 0xd9,
	0x38, 0xb3, 0xfe, 0x34, 0x38, 0x0e, 0x47, 0xfa, 0x06, 0xd4, 0x06, 0x56, 0x10, 0xb5, 0xbd, 0x61,
	0x9f, 0xaf, 0xf6, 0x19, 0x0a, 0x3f, 0x19, 0xf6, 0x71, 0xe6, 0x3a, 0x2e, 0x69, 0x7b, 0x54, 0x85,
	0xac, 0x32, 0x02, 0x52, 0x04, 0xaa, 0x90, 0x4d, 0x28, 0xf7, 0xed, 0xf7, 0xb0, 0x8d, 0x75, 0x93,
	0xfe, 0xa4, 0xcc, 0xe8, 0x85, 0x63, 0x47, 0x3d, 0x1c, 0xbd, 0xaa, 0xc9, 0x00, 0xba, 0xcc, 0x7b,
	0x84, 0x8a, 0x0d, 0x1c, 0xb3, 0xaa, 0xc9, 0x21, 0x63, 0x0d, 0x80, 0xf5, 0x06, 0x49, 0x96, 0xed,
	0x8c, 0xd8, 0x47, 0x94, 0x92, 0x7d, 0x84, 0xf1, 0x07, 0x25, 0x58, 0x6a, 0x09, 0xc5, 0x27, 0x1e,
	0x6c, 0xba, 0xfa, 0xa8, 0x8e, 0xe2, 0x0f, 0x83, 0x0e, 0x61, 0x9a, 0x27, 0x5b, 0x18, 0xc0, 0x50,
	0xc8, 0xf5, 0x5e, 0x87, 0xb9, 0xc3, 0x61, 0xe8, 0x78, 0x94, 0xb3, 0x75, 0x12, 0xbe, 0x38, 0x2b,
	0x90, 0x98, 0xe9, 0xcb, 0x30, 0xe7, 0x61, 0x91, 0x4c, 0xd7, 0xa2, 0xea, 0x58, 0xf9, 0xcd, 0xc6,
	0xda, 0x0d, 0x75, 0xe4, 0xa4, 0x41, 0x30, 0x67, 0xbd, 0x04, 0x08, 0xe9, 0xc0, 0xf3, 0xef, 0x69,
	0x73, 0x99, 0x6d, 0x30, 0x33, 0xf0, 0x49, 0xaf, 0xcd, 0x86, 0x17, 0xff, 0x46, 0x35, 0x72, 0x18,
	0x32, 0xfd, 0x0d, 0x2d, 0x8a, 0x08, 0xe8, 0x6f, 0x41, 0xc5, 0xa6, 0xdb, 0xdb, 0x69, 0x9c, 0x43,
	0x37, 0xd5, 0xa2, 0x94, 0xf9, 0x6e, 0x62, 0x46, 0x3a, 0x7f, 0x70, 0xb3, 0xc1, 0x77, 0x1a, 0x89,
	0xa4, 0x4a, 0x56, 0x1e, 0x33, 0x3a, 0xb0, 0x95, 0x67, 0xbc, 0x0d, 0xb5, 0x6d, 0xcb, 0x61, 0x1a,
	0x8e, 0x0e, 0x15, 0xd4, 0xc0, 0x18, 0xf9, 0xf0, 0x37, 0x8e, 0x73, 0xd8, 0x15, 0x93, 0xaa, 0x1f,
	0x76, 0x8d, 0x9f, 0x84, 0x46, 0x8b, 0x6e, 0xcc, 0x98, 0x82, 0x72, 0xce, 0x8f, 0x7e, 0x4f, 0x83,
	0xe5, 0xbc, 0xa1, 0x43, 0x5e, 0xad, 0x6e, 0x1b, 0xb4, 0x91, 0xdb, 0x86, 0x92, 0xba, 0x6d, 0xd0,
	0xdf, 0x85, 0xfa, 0x11, 0x6f, 0xbf, 0x18, 0xaf, 0x6b, 0x2a, 0x95, 0x44, 0xf7, 0xcc, 0x24, 0xa3,
	0xfe, 0x73, 0x30, 0x2b, 0xf5, 0x41, 0x8c, 0x54, 0x6a, 0xa0, 0xa5, 0x1c, 0xa6, 0x92, 0xdd, 0xf8,
	0x0d, 0x0d, 0xae, 0xb7, 0x88, 0x15, 0x74, 0x7a, 0x14, 0xde, 0x38, 0x7b, 0xe2, 0x74, 0x8e, 0x3d,
	0xbe, 0x1f, 0x5b, 0x81, 0x9a, 0xc7, 0x41, 0xc1, 0x75, 0x04, 0xac, 0x6c, 0xa8, 0x4b, 0xea, 0x86,
	0xba, 0xc8, 0xf6, 0xbd, 0x08, 0x55, 0xd7, 0xe9, 0x3b, 0x11, 0x57, 0x0d, 0x19, 0x20, 0x6f, 0xbf,
	0xab, 0xb2, 0x54, 0x35, 0xbe, 0xa5, 0xc1, 0x4a, 0x7e, 0xcb, 0x90, 0xd2, 0xef, 0x01, 0xb0, 0x06,
	0x78, 0x47, 0x3e, 0xdb, 0xd3, 0x67, 0xc8, 0x35, 0x14, 0x0a, 0x46, 0x5d, 0xfc, 0x0a, 0x2f, 0x2a,
	0x26, 0x5f, 0xc0, 0xf4, 0x03, 0x2f, 0x72, 0xa2, 0xb3, 0xd8, 0x02, 0xa0, 0x25, 0x16, 0x00, 0xa9,
	0xc7, 0xa5, 0x02, 0x6b, 0x7f, 0x59, 0xb6, 0xf6, 0xcb, 0x12, 0xb6, 0x82, 0x53, 0x44, 0x48, 0xd8,
	0x26, 0x94, 0x29, 0xb3, 0x66, 0x1c, 0x8a, 0xfe, 0x34, 0xfe, 0x41, 0x59, 0x88, 0x4e, 0x49, 0x1e,
	0xbc, 0x1a, 0x1e, 0xb1, 0x00, 0xd5, 0xc8, 0x6f, 0x3b, 0x42, 0x75, 0xaa, 0x44, 0xfe, 0xae, 0x2d,
	0x8b, 0xbb, 0x8a, 0x22, 0xee, 0x64, 0x09, 0x5c, 0x1d, 0x25, 0x81, 0xa7, 0xc7, 0x48, 0xe0, 0x99,
	0x31, 0x12, 0xb8, 0x96, 0x96, 0xc0, 0xc9, 0x72, 0xaf, 0x8f, 0x10, 0xb4, 0x30, 0x4e, 0xd0, 0x36,
	0xd2, 0x82, 0x56, 0x91, 0x9c, 0xb3, 0xaa, 0xe4, 0xbc, 0x0f, 0x33, 0x84, 0x8e, 0x37, 0x09, 0x97,
	0xe7, 0x70, 0x6a, 0x2d, 0xaa, 0x93, 0x84, 0x4d, 0x06, 0x53, 0x64, 0x32, 0xda, 0x42, 0x8d, 0x4a,
	0x18, 0xf9, 0x63, 0xd0, 0xfb, 0x88, 0x6a, 0x73, 0x4e, 0x8a, 0xdc, 0x8f, 0x4d, 0xd4, 0xd5, 0x3c,
	0x09, 0x2a, 0x31, 0xc0, 0x66, 0x3f, 0x85, 0x31, 0xf6, 0x41, 0x57, 0x2b, 0xb8, 0x2c, 0xbb, 0x31,
	0x76, 0x63, 0x35, 0x77, 0x6f, 0x18, 0x11, 0x49, 0xcd, 0x95, 0x56, 0xa4, 0xaa, 0xe7, 0x4a, 0xd3,
	0x56, 0x51, 0x74, 0x8d, 0x7f, 0xae, 0xc5, 0xea, 0xab, 0x52, 0x16, 0xb6, 0xf1, 0x29, 0x5f, 0x71,
	0x92, 0x6d, 0xf1, 0x9d, 0xf4, 0x6e, 0x2d, 0xff, 0xd3, 0xfb, 0xec, 0x9f, 0xb4, 0x16, 0xb1, 0x57,
	0xd7, 0x60, 0x3a, 0xc0, 0x04, 0x6e, 0x88, 0xe0, 0x90, 0xf1, 0x45, 0x80, 0xe4, 0x03, 0xbd, 0x01,
	0x33, 0x2d, 0x66, 0x74, 0x6b, 0x4e, 0xe9, 0x57, 0x61, 0x6e, 0x97, 0x6a, 0x26, 0x9e, 0xe5, 0x62,
	0x39, 0x4d, 0xcd, 0xf8, 0xed, 0x12, 0xa0, 0xf6, 0x60, 0x75, 0x22, 0xdc, 0x4c, 0xa7, 0xb4, 0xde,
	0x44, 0x8b, 0xbf, 0x0d, 0xc0, 0xf3, 0x25, 0x1d, 0xaf, 0x8b, 0x2f, 0xd9, 0xe4, 0x77, 0x82, 0x30,
	0x62, 0xba, 0x45, 0x99, 0x4f, 0x5e, 0x8a, 0x41, 0xe5, 0xe2, 0x26, 0xd4, 0x5d, 0x4b, 0xa4, 0xf2,
	0x43, 0x15, 0x8a, 0xc0, 0xc4, 0x7b, 0x70, 0xd5, 0x09, 0xdb, 0x48, 0x6c, 0x5e, 0x60, 0x6c, 0x90,
	0xbb, 0xe2, 0xc8, 0xda, 0x3d, 0xb1, 0x69, 0x5e, 0x36, 0x2a, 0xa1, 0x94, 0x97, 0xe9, 0x55, 0x57,
	0x70, 0x7c, 0xc2, 0x24, 0xef, 0x4d, 0xa8, 0x87, 0x91, 0x15, 0xb4, 0xfb, 0x56, 0x70, 0xcc, 0xad,
	0x20, 0x35, 0x8a, 0xd8, 0xb3, 0x82, 0x63, 0x9a, 0xd8, 0xb3, 0xc2, 0xf6, 0xa0, 0xe7, 0xc7, 0x26,
	0x90, 0x5a, 0xcf, 0x0a, 0xf7, 0x29, 0x4c, 0x97, 0x04, 0xb7, 0x3b, 0xb0, 0xd5, 0x56, 0x35, 0x67,
	0xba, 0xdc, 0x34, 0xbb, 0x08, 0x55, 0xeb, 0xd0, 0x1f, 0x8a, 0x95, 0xc6, 0x00, 0xe3, 0xbb, 0x1a,
	0x2c, 0x61, 0xc5, 0x51, 0x48, 0x77, 0x76, 0xac, 0x09, 0xe1, 0x28, 0x6b, 0x1e, 0xb3, 0x68, 0xc5,
	0x06, 0x06, 0x06, 0xe8, 0x77, 0xe3, 0xd1, 0xc0, 0xdd, 0x9a, 0xa4, 0xde, 0x71, 0xd4, 0x24, 0x5b,
	0xe3, 0x1f, 0xd2, 0xf9, 0x98, 0xd3, 0x28, 0x9c, 0x8f, 0x1f, 0xc4, 0xe3, 0xb9, 0x1e, 0x04, 0x7c,
	0x3d, 0xa6, 0xc4, 0xa5, 0x34, 0x2f, 0x4c, 0x29, 0xb3, 0xfe, 0x3e, 0x34, 0x84, 0x24, 0xa1, 0xdf,
	0x96, 0x46, 0x0a, 0x1d, 0x39, 0xab, 0x2a, 0x76, 0xca, 0xe7, 0x16, 0x3b, 0x1f, 0x40, 0x83, 0xad,
	0xfa, 0x56, 0x64, 0x45, 0x44, 0x21, 0x69, 0x59, 0x22, 0xa9, 0x90, 0x49, 0x25, 0xc9, 0x2a, 0xed,
	0x40, 0xd3, 0x24, 0x27, 0x07, 0x03, 0xdb, 0x8a, 0x08, 0x2b, 0x03, 0x75, 0x85, 0x7e, 0x52, 0x5c,
	0x98, 0xdf, 0x79, 0xa9, 0x42, 0x53, 0xc9, 0x2e, 0xed, 0x7f, 0x15, 0x43, 0xb9, 0xf1, 0x3e, 0xad,
	0x2a, 0x54, 0xab, 0x12, 0x16, 0x4a, 0x2e, 0x26, 0xd1, 0x42, 0x99, 0xd5, 0xa5, 0x7e, 0x57, 0x83,
	0x5b, 0x26, 0x39, 0xa1, 0x6b, 0xb3, 0x1b, 0x58, 0xee, 0x81, 0xe7, 0x9c, 0x92, 0x20, 0xb4, 0xdc,
	0x0d, 0x2e, 0xa7, 0xf4, 0x79, 0x28, 0x39, 0x03, 0xae, 0x7c, 0x94, 0x9c, 0x01, 0x55, 0x49, 0x9c,
	0xbe, 0x72, 0x42, 0x10, 0xc3, 0xfa, 0x32, 0xcc, 0x38, 0xdc, 0x76, 0xc5, 0x8c, 0xa5, 0x02, 0xd4,
	0x57, 0x01, 0x84, 0xe4, 0x8b, 0x2d, 0x53, 0x12, 0x46, 0x7f, 0x2b, 0x36, 0x89, 0x54, 0xf3, 0x86,
	0x66, 0x2f, 0xec, 0xa2, 0x69, 0x60, 0x2b, 0xd6, 0x40, 0x75, 0x49, 0x97, 0x9d, 0x65, 0xea, 0xaa,
	0xf1, 0x2e, 0xac, 0xe2, 0xd9, 0x48, 0x71, 0x67, 0xc4, 0x57, 0xac, 0x3b, 0xec, 0xab, 0xef, 0x69,
	0x30, 0xf7, 0x34, 0xea, 0x91, 0xe0, 0x59, 0x60, 0x79, 0x62, 0xdd, 0xe4, 0x9a, 0x93, 0x16, 0xa1,
	0x2a, 0x1b, 0xe6, 0x18, 0x40, 0x73, 0xef, 0x0e, 0xd6, 0x6d, 0x3b, 0x10, 0x3b, 0x3c, 0x06, 0xd1,
	0xf5, 0x64, 0x92, 0x13, 0x66, 0x55, 0xe4, 0x7d, 0x2e, 0x9b, 0x32, 0x8a, 0x92, 0xd2, 0x24, 0x27,
	0x1b, 0x67, 0x74, 0x22, 0x54, 0xb1, 0x1f, 0x31, 0x6c, 0xdc, 0x87, 0x79, 0xb9, 0x51, 0x6c, 0xb7,
	0x4e, 0xff, 0xb3, 0xec, 0xcc, 0x46, 0x93, 0x20, 0x8c, 0x7f, 0xad, 0x41, 0xb3, 0x45, 0xf0, 0x74,
	0x61, 0x8b, 0x44, 0x96, 0xe3, 0xe6, 0xd8, 0x11, 0x14, 0x0e, 0xc0, 0xcc, 0xcc, 0x25, 0xd9, 0xcc,
	0x3c, 0x86, 0x91, 0x2e, 0x42, 0x75, 0xd0, 0xf3, 0x23, 0x9f, 0x33, 0x51, 0x06, 0xb0, 0xdd, 0xd6,
	0x4b, 0xae, 0x39, 0xd2, 0x9f, 0xb4, 0x5b, 0x87, 0x4e, 0x10, 0xf5, 0x6c, 0xeb, 0x4c, 0x98, 0x10,
	0x05, 0x4c, 0x89, 0x45, 0x5e, 0x46, 0xc4, 0xb3, 0xb9, 0x12, 0xc2, 0x21, 0xe3, 0x3d, 0x58, 0x48,
	0xb5, 0x1e, 0x39, 0xc5, 0x2a, 0x00, 0x3f, 0xb7, 0x39, 0x1a, 0xba, 0xdc, 0xea, 0x22, 0x61, 0x8c,
	0x47, 0xb0, 0xb8, 0xc3, 0x3e, 0xdb, 0x38, 0xa3, 0x7f, 0x85, 0xde, 0x5c, 0x28, 0x40, 0xf9, 0x41,
	0x86, 0x97, 0x3a, 0xc8, 0xa0, 0xb0, 0xf1, 0x12, 0xae, 0xf2, 0xc2, 0xb8, 0x4d, 0x8c, 0xb6, 0xe0,
	0x8b, 0x50, 0x3d, 0x40, 0x0b, 0xb0, 0x86, 0x3c, 0xaf, 0x88, 0xd5, 0xb0, 0x4c, 0x17, 0xd5, 0x6d,
	0x07, 0x30, 0xdf, 0xe2, 0x26, 0x72, 0x93, 0xd8, 0xdc, 0x80, 0xb8, 0x1d, 0xdb, 0x81, 0xd9, 0x4e,
	0x36, 0x41, 0x48, 0x76, 0x33, 0x76, 0x2c, 0xc2, 0x21, 0x3a, 0x16, 0x26, 0x39, 0xc1, 0x91, 0x9b,
	0x35, 0xcb, 0x7c, 0x2a, 0x9b, 0xf6, 0xc0, 0x0c, 0x07, 0x38, 0x68, 0xb3, 0x26, 0x87, 0x8c, 0xe7,
	0x30, 0xf7, 0x61, 0x70, 0x86, 0x15, 0xda, 0x83, 0x4b, 0x57, 0x58, 0x89, 0x2b, 0x34, 0x7c, 0x98,
	0x33, 0x3b, 0xa7, 0x9f, 0x61, 0x4f, 0x1e, 0x41, 0x23, 0xae, 0x8d, 0x9d, 0x26, 0xb1, 0x91, 0xe3,
	0x4b, 0x84, 0x43, 0x74, 0xe5, 0x4b, 0x26, 0x4c, 0xfc, 0x4d, 0x2b, 0xd9, 0x8b, 0x0f, 0x8f, 0xe8,
	0x4f, 0xe3, 0xdf, 0x68, 0x00, 0x74, 0x24, 0xcc, 0xad, 0x7d, 0x5a, 0xe7, 0x17, 0xa0, 0x8a, 0x52,
	0x8d, 0x0f, 0x7e, 0xbe, 0xc0, 0xc3, 0x7f, 0x54, 0xdf, 0x0f, 0xc8, 0x89, 0x38, 0x56, 0x88, 0x79,
	0xc4, 0x6c, 0x20, 0xd6, 0x3b, 0x49, 0x2d, 0xf8, 0xb2, 0xba, 0xe0, 0x59, 0x01, 0xb6, 0x54, 0x00,
	0x37, 0xdf, 0x07, 0xc4, 0x4e, 0x0a, 0x78, 0x0d, 0x28, 0xdc, 0xee, 0xf4, 0x2c, 0x66, 0x72, 0x65,
	0xab, 0xae, 0x11, 0x10, 0x7b, 0x93, 0xa3, 0x8c, 0xaf, 0x42, 0x23, 0xee, 0xc1, 0x38, 0xae, 0x91,
	0x73, 0xc6, 0xa6, 0x98, 0x00, 0xcf, 0xa0, 0xc1, 0x0e, 0xd8, 0x3f, 0x73, 0x72, 0x18, 0x8f, 0x60,
	0x36, 0xa9, 0xfa, 0xb2, 0xfd, 0xf8, 0x1a, 0xcc, 0x99, 0xa4, 0x43, 0x9c, 0x53, 0xf2, 0xa7, 0xd0,
	0x93, 0x3d, 0x98, 0x97, 0x2b, 0xbf, 0x6c, 0x5f, 0xf6, 0x61, 0x09, 0x85, 0xdc, 0x03, 0xdb, 0x11,
	0x66, 0xfc, 0x75, 0xaa, 0x07, 0xc6, 0x47, 0xde, 0xc4, 0x56, 0x8e, 0xbc, 0x89, 0x3d, 0xae, 0xc4,
	0xc7, 0xd9, 0x12, 0x99, 0x5d, 0x33, 0xff, 0x44, 0x60, 0x4c, 0x69, 0xff, 0x5e, 0x83, 0xb9, 0x0d,
	0x3f, 0x62, 0xba, 0xc8, 0x68, 0xbd, 0xfe, 0x4d, 0x68, 0x1e, 0xfa, 0x11, 0xda, 0x0f, 0xda, 0x54,
	0x50, 0x3b, 0xbe, 0xc7, 0xcb, 0x9b, 0x3f, 0xf4, 0x51, 0xf7, 0xfb, 0x88, 0x61, 0x45, 0xce, 0x4e,
	0xcf, 0x8a, 0xda, 0x3d, 0x27, 0x8c, 0xfc, 0xe0, 0x8c, 0x9f, 0xda, 0xd0, 0x9c, 0x9b, 0x3d, 0x2b,
	0x7a, 0xc8, 0xb0, 0xfa, 0x2a, 0x34, 0x68, 0x4e, 0xcf, 0xc7, 0xcc, 0xe2, 0x84, 0xf3, 0xd0, 0x8f,
	0x9e, 0xf8, 0x34, 0xdb, 0x24, 0x67, 0x25, 0x8f, 0x61, 0x41, 0xe9, 0x48, 0x6c, 0xf6, 0x90, 0x78,
	0xbc, 0x76, 0x6e, 0x1e, 0xff, 0x11, 0xdc, 0x41, 0x2a, 0xb3, 0xf2, 0xf6, 0x1d, 0xcf, 0x63, 0x8b,
	0xd6, 0x23, 0xae, 0x38, 0x79, 0xbc, 0x10, 0xbd, 0x1f, 0xc2, 0x55, 0x2c, 0xf7, 0x31, 0xb1, 0x4e,
	0x89, 0xf0, 0x66, 0xb8, 0x50, 0x49, 0x2d, 0x3c, 0x33, 0xdf, 0x21, 0xd1, 0xba, 0xeb, 0x52, 0x5a,
	0x85, 0xe2, 0xa0, 0xca, 0x51, 0x4e, 0x29, 0x65, 0x2f, 0x83, 0xd2, 0x58, 0x22, 0x7e, 0x99, 0x6a,
	0xa6, 0x03, 0xf7, 0x4c, 0x2e, 0x76, 0x11, 0xaa, 0xe8, 0x24, 0xca, 0x75, 0x68, 0x06, 0x50, 0x2c,
	0xb6, 0x45, 0xe8, 0x24, 0x08, 0x18, 0x3f, 0x2c, 0xc1, 0x75, 0xd6, 0x2a, 0x7e, 0x7e, 0xb6, 0xe5,
	0x1c, 0x1d, 0x91, 0x80, 0x78, 0x1d, 0x72, 0xc1, 0x43, 0xd4, 0x58, 0xf7, 0x29, 0xcb, 0xba, 0x0f,
	0xc5, 0xfa, 0x41, 0x87, 0xf0, 0x19, 0xc3, 0x00, 0xf5, 0x1c, 0xaf, 0x9a, 0x3e, 0xc7, 0x6b, 0x42,
	0x79, 0x10, 0x85, 0x5c, 0xc7, 0xa1, 0x3f, 0x13, 0x03, 0xdb, 0x8c, 0x6c, 0x60, 0xbb, 0x03, 0x8d,
	0x00, 0x0f, 0x94, 0xf7, 0x1c, 0x6f, 0xd7, 0xe6, 0xb6, 0x6b, 0x40, 0x14, 0x62, 0xa4, 0x0c, 0xd6,
	0xcb, 0x5d, 0xb1, 0xed, 0xe3, 0x19, 0x28, 0x86, 0xf6, 0xd4, 0x26, 0xa7, 0x4e, 0x47, 0x1c, 0x78,
	0x73, 0x28, 0x19, 0x88, 0xc6, 0xd8, 0x81, 0x78, 0x0e, 0xd7, 0x98, 0xe3, 0x50, 0x42, 0xc6, 0x4d,
	0xf4, 0x02, 0xa6, 0x4a, 0x96, 0x1d, 0x13, 0x95, 0xcf, 0x18, 0x09, 0x33, 0x6e, 0xda, 0x7c, 0x87,
	0xf9, 0x5a, 0x6c, 0x0f, 0x5d, 0x97, 0x93, 0x66, 0xd4, 0xc0, 0x74, 0xd2, 0xe7, 0xb1, 0x09, 0x39,
	0xd5, 0x63, 0xce, 0x72, 0xf1, 0x31, 0xe7, 0xf8, 0xed, 0xe7, 0x23, 0x3e, 0xeb, 0x68, 0xa3, 0xc4,
	0x9a, 0x58, 0x86, 0x19, 0xb6, 0xf6, 0x04, 0xcf, 0x15, 0xe0, 0xb8, 0x0e, 0xfe, 0x81, 0x46, 0x97,
	0xd8, 0xc9, 0x16, 0x71, 0x49, 0x44, 0x62, 0x4f, 0x8a, 0xa2, 0xb5, 0xa1, 0x3a, 0xe8, 0x94, 0x70,
	0x1b, 0x24, 0x39, 0xe8, 0xe4, 0xcf, 0x3e, 0x34, 0xa8, 0x9c, 0xfa, 0xc7, 0x62, 0xfa, 0x71, 0x08,
	0x37, 0x5f, 0x36, 0x37, 0xe2, 0x97, 0x1c, 0x99, 0x80, 0xb1, 0x6b, 0x50, 0x82, 0x98, 0xe4, 0x28,
	0x7d, 0x13, 0x16, 0x98, 0x77, 0x5b, 0xa6, 0x53, 0x81, 0xa2, 0x3d, 0x31, 0xa8, 0x60, 0x6d, 0xfe,
	0x9f, 0x32, 0x2d, 0xa5, 0xeb, 0x84, 0x11, 0x09, 0xe4, 0xd3, 0xef, 0x42, 0x86, 0x3f, 0xd6, 0xd7,
	0xe6, 0x2e, 0x34, 0xd0, 0x0a, 0xf2, 0x64, 0xd8, 0x3f, 0x24, 0x62, 0x43, 0x25, 0xa3, 0x50, 0x9d,
	0x14, 0x3b, 0x12, 0x71, 0x54, 0x18, 0x23, 0xd0, 0xed, 0x8e, 0x9b, 0x76, 0xc4, 0x21, 0x93, 0x80,
	0xf5, 0x25, 0x98, 0x66, 0x3e, 0x59, 0xdc, 0x66, 0x53, 0x45, 0x77, 0xac, 0x5c, 0x21, 0x34, 0x73,
	0x6e, 0x21, 0x54, 0xcb, 0x15, 0x42, 0x77, 0x61, 0x56, 0x12, 0x42, 0xb1, 0x17, 0x4b, 0x2c, 0x85,
	0x42, 0xda, 0x51, 0xf4, 0xfd, 0x0e, 0x98, 0xc3, 0x22, 0x33, 0xe8, 0xc8, 0x28, 0xba, 0x1a, 0x1e,
	0xfb, 0x1d, 0xcb, 0xc5, 0xce, 0xe3, 0xfa, 0xae, 0x9b, 0x12, 0x86, 0x4e, 0x0d, 0xbb, 0x83, 0x46,
	0xd3, 0xaa, 0x59, 0xb2, 0x3b, 0xb4, 0xeb, 0xe8, 0x97, 0xf2, 0xc4, 0x7f, 0x81, 0xde, 0x2a, 0x55,
	0x33, 0x86, 0x93, 0x89, 0x31, 0x3f, 0x6e, 0x62, 0x50, 0x9e, 0xd6, 0x22, 0x2f, 0x97, 0xaf, 0x30,
	0x9e, 0xd6, 0x4a, 0x6d, 0xe7, 0x9a, 0xea, 0x76, 0xce, 0xf8, 0x3e, 0x5b, 0x1a, 0x3b, 0x24, 0x92,
	0x57, 0xda, 0x9f, 0xfa, 0xf2, 0xff, 0x13, 0x0d, 0x7d, 0xfc, 0x76, 0x48, 0xb4, 0x6f, 0x05, 0x91,
	0xd3, 0x71, 0x06, 0x96, 0x17, 0x89, 0x63, 0x91, 0x16, 0x11, 0xbe, 0xbe, 0x1c, 0x4a, 0xb8, 0x76,
	0x49, 0xe6, 0xda, 0xb7, 0xa0, 0x3e, 0xa0, 0x5f, 0x3f, 0x13, 0x87, 0x9d, 0x55, 0x33, 0x41, 0xa8,
	0x7d, 0xa9, 0x14, 0x7b, 0x78, 0x54, 0x15, 0x0a, 0xcc, 0x82, 0x76, 0xc2, 0x8f, 0x39, 0x35, 0x3c,
	0x96, 0xc4, 0xbe, 0xb2, 0xe9, 0x56, 0x51, 0x7b, 0x39, 0x7e, 0x0d, 0xff, 0x91, 0x06, 0xb7, 0x63,
	0x03, 0x53, 0xae, 0x42, 0x21, 0x9d, 0xdf, 0xa9, 0x23, 0x91, 0xbf, 0xff, 0xbf, 0x06, 0xd3, 0xa1,
	0xe3, 0x12, 0x4f, 0x78, 0xc4, 0x70, 0x68, 0x4c, 0x5f, 0x05, 0x8f, 0xd2, 0x38, 0x8f, 0x52, 0x19,
	0xe0, 0x74, 0xa1, 0x87, 0xe2, 0xcc, 0xd8, 0x0e, 0xfe, 0x9e, 0x46, 0xf9, 0xcb, 0x49, 0x46, 0xd3,
	0x2d, 0xec, 0xd6, 0x65, 0xbc, 0xa7, 0x62, 0xe3, 0x6a, 0x45, 0x32, 0xae, 0x8e, 0xf5, 0x97, 0x8a,
	0x7b, 0x33, 0x3d, 0xb6, 0x37, 0xff, 0x24, 0xd3, 0x1b, 0xa6, 0x65, 0x8f, 0xf6, 0x15, 0x5a, 0x84,
	0x2a, 0x73, 0x3a, 0x60, 0xd6, 0x0a, 0x06, 0x14, 0x7a, 0x0a, 0xa9, 0xb4, 0xaf, 0x14, 0xd2, 0x7e,
	0xbc, 0xf2, 0xfb, 0xcb, 0x5c, 0x82, 0x0a, 0x75, 0xc1, 0x8a, 0xac, 0xcb, 0x7b, 0x08, 0x55, 0xd2,
	0x1e, 0x42, 0x45, 0x0e, 0x40, 0xdf, 0xd7, 0xd0, 0x71, 0x6e, 0x8b, 0xb8, 0x7b, 0x96, 0x37, 0xb4,
	0xdc, 0x0d, 0xd7, 0xef, 0x1c, 0x3f, 0x76, 0xc2, 0x48, 0xff, 0x00, 0x1a, 0x07, 0x1e, 0x82, 0x07,
	0xe2, 0xa0, 0xb8, 0x91, 0xd6, 0xbf, 0xe3, 0x64, 0x53, 0xce, 0x4b, 0x05, 0x00, 0x72, 0x7a, 0xc1,
	0x7b, 0xaa, 0x94, 0xbf, 0x4f, 0xe4, 0x23, 0xf4, 0xb7, 0x59, 0xb3, 0x5a, 0x24, 0x4a, 0x37, 0xeb,
	0x3d, 0xa8, 0x9f, 0xbb, 0x51, 0xf5, 0x57, 0xd9, 0xa4, 0x5f, 0x90, 0x2a, 0x2e, 0x34, 0xf8, 0xdf,
	0x82, 0xfa, 0x21, 0xcd, 0xf4, 0x2c, 0xf1, 0x50, 0x49, 0x10, 0x54, 0x31, 0xe2, 0x27, 0x0c, 0x9c,
	0xeb, 0x0a, 0xd0, 0xe8, 0xc1, 0xa2, 0xd4, 0xd1, 0xd8, 0x1d, 0x9e, 0x96, 0x17, 0xc4, 0xce, 0xf2,
	0x7c, 0x03, 0x1b, 0x23, 0x92, 0x69, 0xc2, 0x0e, 0x87, 0xf2, 0xa6, 0x49, 0x39, 0xad, 0x63, 0x7d,
	0x02, 0x77, 0x5a, 0x91, 0x1f, 0x90, 0x56, 0xcf, 0x1f, 0x70, 0x47, 0xd3, 0x16, 0x89, 0xb6, 0xfc,
	0xce, 0x10, 0x8d, 0xd9, 0x54, 0xab, 0x60, 0x7c, 0x46, 0x8b, 0xf9, 0xcc, 0x2d, 0xa8, 0xdb, 0x22,
	0x9d, 0x1f, 0x80, 0x27, 0x88, 0xc9, 0x48, 0x68, 0x8c, 0xae, 0xfb, 0x32, 0xdb, 0xbe, 0xef, 0x95,
	0xa0, 0xb9, 0x3e, 0x8c, 0x7a, 0x7e, 0x90, 0x14, 0x5d, 0xac, 0x20, 0xbd, 0x0e, 0x73, 0xc2, 0xf5,
	0x96, 0x44, 0x89, 0x8f, 0xd7, 0x6c, 0x82, 0x64, 0x8b, 0x3c, 0xec, 0xf9, 0x81, 0x6a, 0xa6, 0x45,
	0x8c, 0xd0, 0x81, 0xac, 0xa0, 0xd3, 0x73, 0x4e, 0x89, 0xcd, 0xb5, 0xc9, 0x18, 0xa6, 0x34, 0x73,
	0xbc, 0x30, 0xb2, 0x5c, 0x37, 0x3e, 0xe6, 0x4a, 0x10, 0xf4, 0x4b, 0xdb, 0x09, 0xad, 0x43, 0x37,
	0x3e, 0xd7, 0x8a, 0x61, 0x3a, 0x49, 0xfc, 0xc0, 0x26, 0x01, 0x11, 0xae, 0x20, 0x02, 0xa4, 0x29,
	0x9d, 0x80, 0x58, 0x11, 0x11, 0x3b, 0x1b, 0x01, 0xd2, 0x94, 0x21, 0x0a, 0xa7, 0xf8, 0x24, 0x8b,
	0x83, 0xc6, 0xbb, 0x70, 0x83, 0x6e, 0x08, 0x91, 0x2e, 0xeb, 0xae, 0x9b, 0x90, 0x66, 0x94, 0xfa,
	0x68, 0x7c, 0x53, 0x83, 0x5b, 0x45, 0x9f, 0x29, 0x63, 0xb4, 0x79, 0xee, 0x31, 0x42, 0x1e, 0xb5,
	0x06, 0x95, 0x90, 0xf0, 0x49, 0x94, 0x39, 0x19, 0x4e, 0x0f, 0x9e, 0x89, 0x79, 0x8d, 0x16, 0xdc,
	0x62, 0xba, 0x33, 0x4f, 0xd9, 0xb7, 0x3a, 0xc7, 0x62, 0xca, 0xe4, 0xcd, 0xd6, 0xf3, 0x8c, 0xac,
	0xf1, 0xf3, 0x70, 0x67, 0x44, 0xa1, 0x97, 0x99, 0x86, 0xdf, 0xd0, 0xd0, 0x52, 0x9e, 0x74, 0x43,
	0xe8, 0xea, 0xe9, 0x76, 0xaa, 0x93, 0xab, 0x94, 0x9e, 0x5c, 0x0b, 0x50, 0x75, 0x42, 0xe1, 0xb1,
	0x50, 0x33, 0x2b, 0x4e, 0x28, 0xb3, 0xab, 0xf1, 0x9a, 0xd9, 0xdf, 0x2b, 0xc1, 0xbc, 0xda, 0x88,
	0x4c, 0x0b, 0xc6, 0x6e, 0x12, 0x74, 0xa8, 0x1c, 0x05, 0xfc, 0xca, 0x45, 0xcd, 0xc4, 0xdf, 0x74,
	0xea, 0xfa, 0x47, 0x47, 0x4e, 0xc7, 0xb1, 0x5c, 0x31, 0xe9, 0x05, 0x4c, 0xf9, 0x51, 0xdf, 0x0a,
	0x8f, 0x85, 0x33, 0x3b, 0x03, 0x12, 0xc1, 0x3a, 0x2d, 0x0b, 0x56, 0xb5, 0xfb, 0x33, 0xe9, 0xee,
	0x2f, 0x42, 0xb5, 0x83, 0xf7, 0x37, 0xd9, 0x4c, 0x67, 0x00, 0x6d, 0x10, 0x36, 0x95, 0x39, 0x47,
	0xe0, 0x6f, 0xda, 0x20, 0xd2, 0xf7, 0x23, 0x47, 0xba, 0xb4, 0x28, 0x60, 0x95, 0x73, 0x35, 0x52,
	0x9c, 0xcb, 0xf8, 0x75, 0x0d, 0xae, 0xe7, 0x0c, 0x15, 0x8e, 0xfe, 0x16, 0xcc, 0x87, 0x0a, 0x9e,
	0xcb, 0x9a, 0x5b, 0x29, 0x67, 0x23, 0xf5, 0xdb, 0xd4, 0x37, 0x17, 0xf7, 0xc0, 0x59, 0x50, 0x66,
	0x27, 0x5f, 0xae, 0xb7, 0xa0, 0xce, 0xcb, 0x4f, 0xf4, 0x97, 0x18, 0x31, 0x81, 0xa9, 0x48, 0x5e,
	0xf7, 0x8a, 0x56, 0x63, 0x3c, 0x85, 0x6b, 0xd9, 0x8a, 0x2f, 0xb3, 0x1a, 0xfe, 0xa7, 0x06, 0xd7,
	0x90, 0xe5, 0x53, 0xa9, 0x79, 0x3e, 0xe6, 0x93, 0xbf, 0x80, 0xab, 0x29, 0xd6, 0xac, 0xf0, 0xd7,
	0xf2, 0x28, 0xfe, 0x5a, 0x49, 0xf1, 0xd7, 0x45, 0xa8, 0x22, 0x43, 0xe5, 0x8a, 0x10, 0x03, 0x14,
	0x5e, 0x3e, 0x9d, 0xe2, 0xe5, 0x13, 0x28, 0xd2, 0x26, 0xdc, 0xc8, 0xed, 0x6e, 0x96, 0x86, 0xe7,
	0x9f, 0x0d, 0xbf, 0xaa, 0xc1, 0x12, 0x13, 0x9b, 0x12, 0xaf, 0xea, 0x50, 0x12, 0x3e, 0xe2, 0x94,
	0x1a, 0x58, 0x9d, 0xe3, 0x43, 0x2b, 0x24, 0x7c, 0x8e, 0xbe, 0x91, 0x3b, 0x47, 0x65, 0x16, 0xb7,
	0x61, 0x85, 0xc4, 0x54, 0xbf, 0x9d, 0xc4, 0xd4, 0x68, 0xc1, 0x72, 0x5e, 0x83, 0xb0, 0x93, 0x69,
	0x26, 0x73, 0xc1, 0x4e, 0xff, 0x97, 0x12, 0x9f, 0x38, 0xaa, 0xae, 0xc0, 0xbd, 0x46, 0x65, 0xb6,
	0xa5, 0x15, 0xb2, 0xad, 0x52, 0x01, 0xdb, 0x2a, 0x17, 0xb1, 0xad, 0x4a, 0x2e, 0xdb, 0xaa, 0x16,
	0xb3, 0xad, 0xe9, 0x42, 0xb6, 0x35, 0x93, 0xc7, 0xb6, 0x6a, 0x05, 0x6c, 0xab, 0x3e, 0x8a, 0x6d,
	0x41, 0xa1, 0xc2, 0xd5, 0x98, 0x64, 0xa1, 0xcf, 0x2a, 0x0b, 0xfd, 0x90, 0xcf, 0xd3, 0x34, 0x75,
	0x5f, 0xe5, 0x10, 0x7e, 0x08, 0x73, 0x26, 0x09, 0x9d, 0x4f, 0x88, 0x49, 0x4e, 0x86, 0x24, 0x8c,
	0x14, 0x9f, 0x00, 0xee, 0x49, 0x90, 0xb8, 0x1f, 0xb3, 0x53, 0xc9, 0x8c, 0xfb, 0x71, 0x99, 0x1d,
	0x56, 0x72, 0xf7, 0xe3, 0x16, 0x34, 0x44, 0x91, 0x54, 0xd3, 0x7d, 0x1b, 0xa6, 0xc3, 0xc8, 0x8a,
	0x86, 0x21, 0xe7, 0x48, 0xcb, 0xe9, 0x89, 0x4f, 0xd3, 0xb0, 0x59, 0x3c, 0x5f, 0xdc, 0x84, 0x92,
	0xe4, 0xcc, 0xd0, 0x81, 0xab, 0x9b, 0xbe, 0x17, 0x46, 0x81, 0xe5, 0xa0, 0x46, 0x51, 0xd8, 0xd6,
	0x1b, 0x50, 0xeb, 0x5b, 0x2f, 0xdb, 0xb4, 0x7e, 0xde, 0xdc, 0x99, 0xbe, 0xf5, 0xb2, 0xe5, 0x7c,
	0x82, 0x7e, 0x7f, 0xfe, 0x30, 0x1a, 0x0c, 0xa3, 0xf6, 0x0b, 0x72, 0x38, 0xe0, 0x33, 0x0c, 0x18,
	0xea, 0x39, 0x39, 0x1c, 0x18, 0xff, 0x51, 0x83, 0x2b, 0x72, 0x2d, 0xaf, 0xac, 0xf9, 0x09, 0x05,
	0xcb, 0xf9, 0x14, 0xac, 0xc8, 0x14, 0xd4, 0x5f, 0x83, 0x59, 0x3f, 0x70, 0xba, 0x8e, 0xd7, 0x66,
	0x1f, 0x55, 0x31, 0xb5, 0xc1, 0x70, 0xcf, 0xf1, 0xd3, 0xd7, 0x61, 0x8e, 0x67, 0xe1, 0x25, 0x4c,
	0x63, 0x1e, 0xfe, 0xdd, 0x43, 0x36, 0x12, 0x5b, 0xb0, 0xb8, 0xe9, 0xf7, 0x07, 0x01, 0x09, 0x43,
	0x74, 0x6c, 0x1c, 0x45, 0xb7, 0x65, 0x98, 0x39, 0x19, 0x5a, 0xae, 0x13, 0x9d, 0x09, 0xb2, 0x71,
	0xd0, 0xf8, 0x18, 0xf4, 0x54, 0x29, 0xaf, 0x6e, 0x58, 0xb7, 0x60, 0xe1, 0x23, 0xc7, 0x26, 0xfe,
	0x7e, 0x40, 0x4e, 0x1d, 0xf2, 0xe2, 0x62, 0x03, 0x6b, 0xfc, 0xa6, 0x06, 0x57, 0xd5, 0x62, 0x2e,
	0xd6, 0x42, 0x2a, 0x91, 0x86, 0x81, 0x15, 0x89, 0x93, 0xb7, 0x39, 0x33, 0x86, 0x29, 0x7d, 0x06,
	0xac, 0x74, 0x7e, 0xa4, 0x29, 0xc0, 0x64, 0x6c, 0x2b, 0xf9, 0x63, 0x5b, 0x55, 0x56, 0xc7, 0x16,
	0x2c, 0xac, 0x0f, 0x6d, 0xe7, 0x92, 0x3d, 0xfe, 0x43, 0x0d, 0xae, 0xaa, 0xc5, 0xbc, 0xfa, 0x1e,
	0x23, 0x9b, 0x3c, 0xe5, 0x76, 0xe7, 0x59, 0x93, 0x01, 0x09, 0xc7, 0xad, 0xa4, 0x2c, 0x30, 0x56,
	0x10, 0x39, 0x61, 0xc4, 0x19, 0x31, 0x87, 0x12, 0xda, 0x4c, 0xe7, 0xd3, 0x66, 0x46, 0xa1, 0xcd,
	0x1f, 0x6b, 0x70, 0xc5, 0x24, 0x27, 0xff, 0x3f, 0x5b, 0x29, 0x1f, 0xf3, 0xf3, 0x49, 0xa5, 0x8f,
	0x17, 0x3e, 0x8b, 0xf9, 0x97, 0x1a, 0x65, 0xdf, 0x27, 0x9b, 0xb8, 0xc3, 0xc4, 0x03, 0x5d, 0x16,
	0x17, 0x26, 0x72, 0xe4, 0xb8, 0x30, 0x91, 0x53, 0x64, 0x38, 0x13, 0x9b, 0x55, 0x5f, 0xc4, 0xa4,
	0x10, 0x60, 0x72, 0x65, 0xa2, 0x22, 0x5f, 0x99, 0x50, 0x0d, 0x6a, 0xd5, 0xf4, 0x69, 0xce, 0x04,
	0xe6, 0xbf, 0x3f, 0x47, 0x47, 0x7a, 0xe0, 0x9e, 0xa9, 0x4d, 0x1f, 0x7d, 0xda, 0x52, 0x95, 0x4f,
	0x5b, 0xbe, 0xc9, 0xce, 0xd9, 0xf6, 0x9c, 0x6e, 0x20, 0x15, 0x90, 0x7b, 0x06, 0x95, 0xd0, 0xa4,
	0xa4, 0xd0, 0x84, 0xdb, 0x47, 0xe5, 0xeb, 0xcc, 0x09, 0x62, 0x92, 0x6d, 0xdc, 0x57, 0xb8, 0x75,
	0x30, 0xd5, 0x18, 0xde, 0x9b, 0x99, 0xfc, 0xde, 0xd4, 0xe4, 0xde, 0x7c, 0xbd, 0x84, 0xbd, 0xf9,
	0xaa, 0xef, 0x78, 0xe7, 0xbe, 0x82, 0x7f, 0x0e, 0x93, 0x67, 0x35, 0x6d, 0xf2, 0x54, 0x0d, 0xb8,
	0xd3, 0x79, 0x57, 0x10, 0x0f, 0xcf, 0x1e, 0x3b, 0x9e, 0xf0, 0xd2, 0xe5, 0x10, 0xba, 0x32, 0x7a,
	0xa7, 0x4e, 0x14, 0xb7, 0x5b, 0x80, 0xd2, 0x0d, 0x63, 0xf4, 0xf8, 0xe4, 0x87, 0xb5, 0x0c, 0x85,
	0x8b, 0x2e, 0xa6, 0x23, 0x8c, 0xa5, 0xe3, 0x0e, 0xa7, 0xa3, 0x4c, 0x86, 0x0b, 0x9d, 0xdd, 0x7f,
	0x4b, 0x83, 0x55, 0xba, 0x2e, 0x92, 0xfb, 0xc9, 0xeb, 0x9e, 0x38, 0x0d, 0xd8, 0x0c, 0x70, 0x82,
	0x8f, 0x0c, 0xf9, 0x90, 0x7b, 0x1f, 0x75, 0x15, 0xe0, 0xe9, 0x80, 0xe0, 0xd7, 0x31, 0xd9, 0x25,
	0x0c, 0x7a, 0x3e, 0x86, 0x9b, 0x89, 0x9b, 0x05, 0x87, 0x8c, 0xe7, 0x70, 0x37, 0xb6, 0x1d, 0x17,
	0xb5, 0x66, 0x11, 0xaa, 0xa7, 0x96, 0xeb, 0x08, 0x5f, 0x15, 0x06, 0x8c, 0xeb, 0xe5, 0x6f, 0x6a,
	0x70, 0xcd, 0x24, 0x27, 0x1b, 0x7e, 0xb4, 0x69, 0xb9, 0xe2, 0x94, 0x83, 0xdd, 0x60, 0xe3, 0x53,
	0x7b, 0xc3, 0x8f, 0x92, 0xc9, 0x13, 0x23, 0x68, 0x4b, 0xf7, 0xc2, 0xee, 0xb3, 0xf8, 0x0a, 0x18,
	0x87, 0x28, 0x4d, 0x02, 0x26, 0x8f, 0x84, 0x8c, 0xe3, 0x20, 0x72, 0x5b, 0xeb, 0x8c, 0xc7, 0x6e,
	0xa0, 0xdc, 0x96, 0x02, 0x93, 0x18, 0xd0, 0xff, 0x2b, 0xe3, 0x54, 0xb4, 0xb0, 0x2d, 0xc7, 0x72,
	0xfd, 0xe2, 0x08, 0x04, 0xf9, 0x87, 0x31, 0x54, 0x77, 0xc3, 0x3b, 0x2c, 0xec, 0x2e, 0x36, 0xa7,
	0x3e, 0x43, 0xe1, 0x6d, 0xec, 0x9b, 0x50, 0xe7, 0x19, 0xe2, 0x9b, 0x22, 0x35, 0x86, 0x60, 0x27,
	0xad, 0x3c, 0x71, 0x40, 0xf8, 0xa6, 0x72, 0x56, 0x7c, 0xbd, 0x4f, 0x98, 0x54, 0x63, 0xd2, 0x64,
	0x5a, 0x96, 0x26, 0x13, 0xec, 0x29, 0x7f, 0x86, 0x2a, 0xbd, 0x03, 0xf7, 0x2c, 0xe9, 0xdc, 0x04,
	0x27, 0xc7, 0x1f, 0x40, 0x1d, 0xf7, 0xa2, 0x1d, 0x3f, 0x20, 0xa3, 0xe8, 0x12, 0xd2, 0x0c, 0xe2,
	0x53, 0x04, 0x8c, 0xff, 0x56, 0x42, 0x91, 0xd9, 0x22, 0xd1, 0x8e, 0xd5, 0x27, 0xa3, 0x4b, 0x78,
	0x0b, 0xa6, 0xf1, 0x23, 0x61, 0xda, 0x4b, 0xed, 0x0f, 0xe2, 0x26, 0x98, 0x3c, 0x5b, 0xe2, 0x05,
	0x52, 0x96, 0xbd, 0x40, 0xde, 0x86, 0x45, 0xbe, 0x4f, 0x6f, 0x13, 0xdb, 0x89, 0xe2, 0xd8, 0x01,
	0x6c, 0xd6, 0xeb, 0x3c, 0xed, 0x81, 0xed, 0x44, 0xd2, 0xc1, 0x1b, 0x1e, 0x13, 0x27, 0x57, 0xaa,
	0x28, 0xc8, 0xee, 0xe8, 0x62, 0x42, 0x7c, 0x4f, 0xa7, 0x6a, 0xd6, 0x28, 0x02, 0x19, 0xc7, 0x6d,
	0x00, 0x5e, 0x74, 0x72, 0xe3, 0xae, 0x1e, 0x3b, 0x9e, 0xe1, 0x5d, 0x05, 0x0c, 0x92, 0xd0, 0x96,
	0x72, 0xb1, 0xbb, 0x3a, 0x57, 0x58, 0x42, 0xe2, 0x90, 0xb6, 0x08, 0xd5, 0x43, 0x3f, 0x8a, 0xaf,
	0x10, 0x30, 0x60, 0x12, 0xce, 0x64, 0x71, 0xb1, 0xad, 0xd0, 0xb9, 0xd8, 0xc5, 0x4c, 0x19, 0xe6,
	0x3a, 0x1f, 0xe6, 0xd8, 0xe6, 0xdf, 0x49, 0xdb, 0xfc, 0x71, 0x27, 0xf6, 0x84, 0xfb, 0x20, 0xa4,
	0x42, 0x23, 0x5c, 0x58, 0x37, 0xf8, 0x9d, 0x12, 0x1e, 0x46, 0xff, 0x59, 0xa4, 0x85, 0xcb, 0x47,
	0x5a, 0x08, 0x85, 0x2b, 0x18, 0x2f, 0x3c, 0xa4, 0xdd, 0x89, 0xfb, 0x2f, 0x1c, 0xb7, 0x24, 0x4c,
	0xa1, 0x0c, 0x99, 0xe0, 0x1c, 0x66, 0x27, 0x71, 0x15, 0x8b, 0xab, 0xbd, 0x90, 0x30, 0xfc, 0x87,
	0xb2, 0xc3, 0x0e, 0x95, 0x48, 0xf2, 0x44, 0x38, 0xb7, 0xb2, 0x94, 0x30, 0x95, 0xb2, 0xc2, 0x54,
	0xb2, 0x67, 0xac, 0x17, 0x55, 0x09, 0x55, 0x27, 0x1c, 0xb9, 0xa1, 0x13, 0xb0, 0xd2, 0x6e, 0x1c,
	0x48, 0x66, 0xd7, 0xb3, 0x3a, 0x91, 0x08, 0x28, 0x96, 0xb6, 0x96, 0xe8, 0x50, 0x91, 0x2c, 0xfa,
	0xf8, 0x1b, 0x2f, 0xad, 0x38, 0x7d, 0x12, 0xdf, 0x3e, 0xe4, 0x87, 0x81, 0xf4, 0x7f, 0x2b, 0x0a,
	0xf8, 0x7e, 0x47, 0x80, 0x46, 0x0f, 0x56, 0x92, 0x91, 0x91, 0xeb, 0x0a, 0xc7, 0x47, 0xbc, 0xc8,
	0xdf, 0xbb, 0x14, 0x50, 0xd8, 0xf8, 0x15, 0x0d, 0x6e, 0x17, 0x56, 0x85, 0xa4, 0xf8, 0x92, 0x50,
	0xd6, 0xd9, 0xfd, 0x99, 0xfc, 0x15, 0x21, 0x7f, 0x28, 0xf4, 0xf9, 0xd8, 0x12, 0x56, 0x92, 0x2d,
	0x61, 0xcb, 0x30, 0x43, 0x02, 0x99, 0x4b, 0x09, 0xd0, 0xf8, 0xef, 0x1a, 0x5e, 0xe2, 0xa1, 0x5a,
	0x04, 0x72, 0x58, 0xaa, 0x77, 0x24, 0x43, 0xac, 0x4d, 0x62, 0xea, 0x52, 0x23, 0x53, 0x24, 0x27,
	0xbf, 0x65, 0xf9, 0xe4, 0x57, 0x15, 0x01, 0x7c, 0x72, 0x25, 0x22, 0x60, 0x09, 0xa6, 0x8f, 0xc9,
	0x59, 0x3b, 0xde, 0x8a, 0xf0, 0xab, 0x5b, 0x18, 0x86, 0x26, 0x0c, 0x1d, 0xdf, 0x13, 0xc1, 0x10,
	0x2a, 0x66, 0x9d, 0x63, 0xa4, 0xbb, 0x32, 0x33, 0xd2, 0x56, 0x9b, 0xcd, 0x8f, 0x1a, 0xbf, 0xd6,
	0x63, 0x1b, 0x5f, 0x47, 0x97, 0x19, 0xca, 0x8d, 0x95, 0xae, 0xde, 0x80, 0x1a, 0x09, 0x02, 0xf9,
	0x92, 0x2b, 0x25, 0x8d, 0x88, 0x39, 0x26, 0x04, 0x21, 0x9b, 0x54, 0x02, 0xd4, 0xdf, 0x07, 0x60,
	0xf2, 0xa8, 0x63, 0xb9, 0x2e, 0x5f, 0xf8, 0xa9, 0x9d, 0x79, 0x52, 0x85, 0x29, 0xe5, 0x35, 0xfe,
	0xba, 0x06, 0x20, 0xd5, 0xbe, 0x08, 0xd5, 0xbd, 0xb0, 0x1b, 0x4f, 0x28, 0x06, 0xa4, 0xee, 0x0c,
	0xc4, 0x4e, 0x03, 0x14, 0xbf, 0x89, 0x52, 0x56, 0x4c, 0x27, 0x06, 0xd1, 0x2d, 0xff, 0x26, 0x17,
	0xb1, 0x42, 0x4f, 0x12, 0x30, 0xad, 0x81, 0xa9, 0x8c, 0x7c, 0xab, 0x85, 0x80, 0xf1, 0x77, 0x92,
	0xf0, 0x51, 0x74, 0xf2, 0xf0, 0xf0, 0x51, 0xb9, 0xdc, 0x63, 0xb4, 0x18, 0xa1, 0x2b, 0xcc, 0x97,
	0xef, 0xf7, 0x3a, 0xc9, 0x68, 0x54, 0xa4, 0xd1, 0x98, 0x40, 0xaf, 0xfc, 0x80, 0x07, 0xaa, 0xdb,
	0xf0, 0x7d, 0x37, 0xc5, 0x2a, 0x6a, 0x63, 0x58, 0xc5, 0x37, 0x34, 0x80, 0x44, 0x7d, 0x16, 0x4d,
	0x3f, 0x4c, 0xab, 0xcc, 0x6c, 0x26, 0x4a, 0xaa, 0x71, 0xa9, 0x40, 0x35, 0x2e, 0xe7, 0xaa, 0xc6,
	0xe3, 0x77, 0x8f, 0x3f, 0x0b, 0xb3, 0x62, 0xaa, 0x61, 0x43, 0x26, 0x63, 0x78, 0x01, 0xdc, 0x60,
	0xb2, 0x89, 0x6b, 0x3b, 0xec, 0xe6, 0xcf, 0xae, 0x7d, 0x30, 0x74, 0xec, 0xc2, 0xab, 0x5b, 0x3a,
	0x54, 0x68, 0x3a, 0x1f, 0x21, 0xfc, 0x3d, 0x89, 0x68, 0x1a, 0xc2, 0x4d, 0x21, 0x9a, 0xf2, 0x6a,
	0xfd, 0x12, 0x34, 0x70, 0x9e, 0xf0, 0xe5, 0xc0, 0xd8, 0xc2, 0x52, 0x56, 0xd9, 0xdc, 0x0b, 0xbb,
	0xa6, 0x9c, 0x73, 0x9c, 0x20, 0xfb, 0x86, 0x06, 0x9f, 0x53, 0xe4, 0x70, 0x5c, 0x79, 0xec, 0x42,
	0xc3, 0x96, 0x84, 0xe2, 0x65, 0xa3, 0xe5, 0x04, 0x3a, 0x62, 0xcb, 0xa8, 0x24, 0x2f, 0xa3, 0x09,
	0xba, 0xff, 0xd7, 0x34, 0xf8, 0x7c, 0x4a, 0x34, 0x17, 0xb5, 0xe4, 0xd3, 0x22, 0xc5, 0x10, 0x56,
	0x72, 0x47, 0x3d, 0x66, 0x09, 0x45, 0x37, 0xf6, 0x2e, 0xd7, 0xf3, 0x53, 0xb8, 0x55, 0x30, 0xf0,
	0x9f, 0x6e, 0x77, 0x9f, 0xc3, 0xfc, 0x5e, 0xd8, 0xdd, 0x76, 0x5c, 0xb2, 0x45, 0x42, 0x3c, 0x55,
	0xe3, 0x01, 0x59, 0x34, 0x64, 0xee, 0x18, 0x90, 0x25, 0xe7, 0xa0, 0xbc, 0x92, 0x3e, 0x71, 0x42,
	0x4e, 0x53, 0x96, 0xec, 0xcf, 0x3b, 0x70, 0x45, 0x29, 0x38, 0x1c, 0xe8, 0xef, 0x2a, 0xcb, 0x6f,
	0x3e, 0x7d, 0x98, 0xfc, 0xc0, 0x1c, 0x74, 0xa4, 0x6b, 0xe0, 0xe2, 0xae, 0xf7, 0xdb, 0xa0, 0xef,
	0x85, 0xdd, 0x16, 0x8b, 0xe3, 0xfc, 0x98, 0xca, 0x73, 0x1e, 0xb0, 0x22, 0xc0, 0xe0, 0xce, 0x7c,
	0x8b, 0x30, 0x67, 0xc6, 0xb0, 0xf1, 0x1c, 0x16, 0x32, 0x5f, 0xb0, 0xb8, 0x53, 0xc3, 0xf0, 0x28,
	0x74, 0x79, 0x7e, 0x06, 0xa0, 0x6e, 0x70, 0x78, 0x14, 0x86, 0xae, 0xb8, 0x18, 0xc6, 0x20, 0xec,
	0x13, 0xc5, 0xb2, 0x63, 0x05, 0xfc, 0x6d, 0x7c, 0x4b, 0x83, 0xd9, 0xbd, 0xb0, 0xbb, 0x43, 0xa2,
	0x6d, 0x07, 0xef, 0x9c, 0xc5, 0x21, 0xfb, 0x34, 0x39, 0x64, 0x1f, 0x65, 0xe1, 0x8e, 0x4b, 0x62,
	0x2e, 0xc0, 0xa1, 0x38, 0x34, 0x4d, 0x1c, 0xd5, 0x66, 0x8e, 0x85, 0xa6, 0x41, 0x01, 0xc1, 0x43,
	0xd3, 0x54, 0x92, 0xd0, 0x34, 0xb7, 0x01, 0x30, 0xc8, 0x4d, 0x84, 0xe1, 0x9d, 0x99, 0xad, 0x1b,
	0x4d, 0xae, 0x18, 0xe2, 0xd9, 0xf8, 0x35, 0x0d, 0xe6, 0xa4, 0xc6, 0x84, 0x83, 0x8b, 0x8c, 0x9c,
	0x68, 0x12, 0x5a, 0xc2, 0x99, 0xa1, 0x0e, 0x9b, 0x84, 0xa7, 0x3a, 0xc9, 0x78, 0x55, 0x26, 0x18,
	0xaf, 0x7f, 0xa4, 0xc5, 0x23, 0xbf, 0x6f, 0x05, 0xcc, 0xa5, 0x6a, 0x32, 0x3a, 0x5d, 0x07, 0x8c,
	0xe6, 0x23, 0x74, 0x96, 0x39, 0x73, 0x9a, 0x82, 0xbb, 0x29, 0x02, 0x56, 0x52, 0x04, 0x1c, 0x4d,
	0xae, 0xdc, 0x7b, 0xbc, 0x0f, 0xa1, 0xa9, 0xb6, 0xf4, 0xc2, 0x93, 0xf4, 0xbb, 0x1a, 0x16, 0x75,
	0x30, 0x70, 0x7d, 0xcb, 0xa6, 0x05, 0xd2, 0x5e, 0xbf, 0x0b, 0xd5, 0x81, 0x15, 0x58, 0xef, 0xf0,
	0xd5, 0xba, 0x7a, 0x5f, 0x8d, 0x49, 0x7e, 0x9f, 0xe5, 0x66, 0x66, 0x79, 0xeb, 0x1d, 0x93, 0x65,
	0x16, 0x5f, 0xad, 0xf1, 0x83, 0xe8, 0xd1, 0x5f, 0xad, 0xb1, 0xaf, 0xd6, 0x72, 0x97, 0xe0, 0x1f,
	0x6a, 0x70, 0x35, 0xd5, 0xa8, 0x8b, 0x76, 0x50, 0x7f, 0x5f, 0xf4, 0x85, 0xb5, 0xca, 0x48, 0xb7,
	0x8a, 0x16, 0x2f, 0x5a, 0x16, 0x0e, 0x68, 0xd3, 0x44, 0x7f, 0x7e, 0x42, 0xf4, 0xa7, 0xcc, 0xbd,
	0x15, 0x33, 0x5f, 0xda, 0x49, 0xf6, 0xb5, 0xbc, 0x58, 0x6e, 0xca, 0x94, 0x35, 0x5e, 0x20, 0x3f,
	0xd8, 0xf2, 0x5f, 0x78, 0x32, 0xad, 0x2f, 0x30, 0xf7, 0xd5, 0xe0, 0x35, 0x73, 0x05, 0x81, 0xdb,
	0xe7, 0xe2, 0xc0, 0xed, 0xbf, 0x04, 0x4b, 0x6a, 0xad, 0xac, 0x9f, 0xef, 0xe4, 0xd4, 0xad, 0x46,
	0x89, 0x49, 0x8a, 0x56, 0x82, 0x53, 0x95, 0xd5, 0xe0, 0x54, 0xc6, 0x66, 0x7e, 0xf9, 0x6b, 0x52,
	0x83, 0x4a, 0x72, 0x83, 0x72, 0xc7, 0xfc, 0xdf, 0x6a, 0xc8, 0xfc, 0xd2, 0x05, 0x5d, 0x70, 0xd4,
	0x3f, 0x50, 0x47, 0xfd, 0xf5, 0x94, 0x00, 0xcb, 0xa3, 0x86, 0x18, 0xf6, 0x0f, 0xd4, 0x61, 0x3f,
	0xc7, 0xa7, 0x62, 0x2e, 0x1b, 0x9f, 0xc7, 0x11, 0xfe, 0x70, 0x48, 0x82, 0xb3, 0xa7, 0x87, 0x7f,
	0x49, 0x38, 0x90, 0x65, 0xa8, 0x6c, 0xb4, 0x61, 0x51, 0xcd, 0xc4, 0xca, 0x89, 0xb7, 0xa0, 0x9a,
	0xba, 0x05, 0x8d, 0x4f, 0xfb, 0x2a, 0x26, 0xfe, 0x4e, 0xcf, 0x90, 0x72, 0x66, 0xaa, 0x7d, 0x9d,
	0x11, 0x33, 0x5d, 0x89, 0xfe, 0x53, 0x50, 0xa1, 0x2d, 0xe5, 0xeb, 0xda, 0x50, 0xbb, 0x96, 0xd7,
	0x24, 0x13, 0xf3, 0x4b, 0x83, 0x50, 0x9a, 0x80, 0xb7, 0x6c, 0xe3, 0x2a, 0x46, 0x3e, 0x7f, 0x19,
	0x29, 0x6d, 0xfc, 0x12, 0x92, 0x55, 0x29, 0xe7, 0xc2, 0x13, 0x23, 0xef, 0xc4, 0xf9, 0x97, 0xf1,
	0x5a, 0x7b, 0xbc, 0x27, 0x66, 0xa3, 0x76, 0x3b, 0x36, 0xe7, 0x24, 0x9e, 0x4e, 0xd2, 0x7e, 0x7d,
	0xac, 0x0f, 0xde, 0x8f, 0x41, 0x65, 0xcb, 0xf5, 0x47, 0x6a, 0x50, 0x98, 0xc1, 0xf8, 0x36, 0x7b,
	0x56, 0x41, 0xa9, 0x3e, 0x1c, 0xe8, 0x1f, 0x40, 0xed, 0xd0, 0x0a, 0x89, 0xe4, 0xc2, 0x76, 0xbb,
	0x60, 0x0f, 0x7f, 0xe4, 0xa3, 0x5b, 0x50, 0x9c, 0x5d, 0xff, 0x59, 0x00, 0xd6, 0x5b, 0xc9, 0xf1,
	0xe3, 0x56, 0xe6, 0xe3, 0x48, 0xa2, 0x8e, 0x94, 0xdf, 0xf8, 0x48, 0x5c, 0x58, 0x59, 0xb7, 0xfb,
	0x0e, 0x8b, 0x54, 0x1d, 0xc6, 0xea, 0xe3, 0x96, 0xa2, 0x3e, 0x6e, 0x4d, 0xe2, 0x7c, 0xb4, 0x4d,
	0xf7, 0x34, 0x27, 0xe2, 0x01, 0x89, 0xe2, 0x22, 0x57, 0x01, 0xf6, 0x09, 0x09, 0xb6, 0x1d, 0x37,
	0x8a, 0xa3, 0x49, 0x4b, 0x18, 0xe3, 0xa7, 0xa1, 0x82, 0xf6, 0xf9, 0x6b, 0x30, 0x4d, 0xff, 0x27,
	0xdf, 0x33, 0x88, 0x2a, 0x58, 0xf4, 0x97, 0x1c, 0x89, 0x59, 0xc0, 0xc6, 0x0f, 0x70, 0xdb, 0xca,
	0xb4, 0x55, 0xde, 0x8c, 0x7b, 0x30, 0xcd, 0x7e, 0x71, 0x4b, 0x89, 0xae, 0x76, 0x81, 0x7e, 0x6a,
	0xf2, 0x1c, 0xfa, 0xbb, 0xd0, 0x68, 0x0d, 0x07, 0x24, 0xe0, 0x1f, 0x94, 0x0a, 0x3f, 0x90, 0xb3,
	0xe9, 0xf7, 0x71, 0x77, 0x8d, 0xd6, 0x3a, 0x1e, 0x32, 0x2d, 0xef, 0x93, 0x38, 0x8f, 0xf1, 0xaf,
	0x98, 0x45, 0x45, 0xb9, 0x78, 0xa6, 0xaf, 0x49, 0x5b, 0x74, 0x36, 0xdf, 0xaf, 0x65, 0x47, 0x94,
	0xa6, 0x4a, 0x5b, 0xf7, 0x42, 0xd3, 0x8a, 0x64, 0x7c, 0x2f, 0x2b, 0xc6, 0xf7, 0x24, 0x8c, 0x15,
	0x3f, 0xe3, 0xed, 0xab, 0xdb, 0x81, 0xf1, 0x9b, 0xef, 0xdf, 0x66, 0x96, 0x45, 0x8c, 0x2b, 0xdd,
	0xb3, 0xa2, 0xf5, 0x0e, 0xfa, 0x0d, 0x7c, 0x36, 0xad, 0x47, 0x83, 0x32, 0xad, 0x6f, 0x2b, 0xb1,
	0x1e, 0x48, 0x98, 0x49, 0xba, 0xe1, 0xc1, 0x0c, 0x1d, 0x02, 0xfa, 0xd5, 0x45, 0xda, 0xce, 0x4c,
	0x03, 0x5b, 0x09, 0xa3, 0x11, 0x60, 0x81, 0x55, 0xcb, 0xf8, 0x92, 0x14, 0x5c, 0xbf, 0xc0, 0xa4,
	0x9b, 0xbf, 0xd7, 0xe7, 0x07, 0x7e, 0x8c, 0x81, 0x44, 0x7b, 0xa4, 0x7f, 0x48, 0x82, 0x90, 0x3d,
	0x9a, 0xf2, 0xd9, 0x10, 0x7d, 0x02, 0xab, 0x86, 0x0d, 0xcb, 0xd2, 0x1e, 0x59, 0x6d, 0xec, 0x3d,
	0x68, 0xa6, 0x71, 0x7c, 0x5d, 0x67, 0xf0, 0x74, 0x2f, 0xff, 0x20, 0x7d, 0x9f, 0x26, 0x46, 0x18,
	0xbf, 0xa2, 0xc1, 0x3c, 0xaf, 0x41, 0xba, 0x6e, 0x29, 0x1a, 0xaf, 0x29, 0x8d, 0x2f, 0xec, 0xee,
	0x4d, 0xa8, 0x07, 0x3e, 0x1d, 0xa8, 0x6e, 0x1c, 0xfd, 0xb8, 0x86, 0x88, 0x1d, 0x12, 0xc5, 0xac,
	0xbd, 0x32, 0x8e, 0xb5, 0xff, 0x50, 0x83, 0x26, 0x0f, 0x98, 0x82, 0xe7, 0xbe, 0x72, 0xcc, 0xa9,
	0xbc, 0xc3, 0x3c, 0x66, 0xb1, 0x2d, 0xc9, 0xee, 0x15, 0x89, 0xed, 0xbd, 0xcc, 0xc2, 0x29, 0x25,
	0x8e, 0x0a, 0xc9, 0x3d, 0x57, 0xb6, 0x58, 0xa5, 0x7b, 0xae, 0x6f, 0xc0, 0x3c, 0xbe, 0x14, 0xd4,
	0xf1, 0xdd, 0x36, 0xb3, 0x44, 0x31, 0xeb, 0xdd, 0x9c, 0xc0, 0x3e, 0x46, 0x8b, 0x94, 0xe8, 0xc8,
	0xf4, 0xb8, 0x8e, 0xfc, 0x2f, 0x0d, 0x5f, 0x64, 0x90, 0x3b, 0x82, 0xd2, 0x74, 0x05, 0x6a, 0x1d,
	0xc1, 0xda, 0x28, 0xfb, 0x9c, 0x35, 0x63, 0x58, 0x7f, 0x27, 0xe9, 0x4f, 0x4e, 0x30, 0xcd, 0x83,
	0x24, 0xf0, 0x94, 0x75, 0x26, 0xdb, 0x9e, 0xf1, 0x3a, 0x68, 0x19, 0xcb, 0xe2, 0xd7, 0xde, 0x6f,
	0x40, 0x2d, 0xbe, 0x27, 0xca, 0x7a, 0x3a, 0xe3, 0xf1, 0x4b, 0xa2, 0x71, 0x92, 0x27, 0x02, 0x79,
	0xb2, 0x24, 0x2f, 0x4c, 0x09, 0xc1, 0xe9, 0x09, 0x85, 0xe0, 0x09, 0xca, 0x64, 0xd1, 0xc8, 0x8d,
	0xb3, 0x5d, 0xfb, 0x42, 0x51, 0xe7, 0x26, 0x33, 0xa4, 0x2c, 0xa5, 0xaa, 0x5c, 0x0f, 0x82, 0x91,
	0xb5, 0x8e, 0x88, 0x6f, 0x39, 0x41, 0xbd, 0xff, 0x4e, 0x83, 0x45, 0x76, 0x7e, 0x48, 0xeb, 0xde,
	0x0f, 0xfc, 0x23, 0xbe, 0x33, 0x79, 0xb5, 0xb1, 0x91, 0x46, 0x06, 0x99, 0x8b, 0xaf, 0x16, 0x56,
	0xe5, 0xab, 0x85, 0x13, 0x1c, 0x14, 0xfd, 0x15, 0xb8, 0x9e, 0xd3, 0x87, 0xcf, 0x2e, 0x3e, 0xd1,
	0x87, 0xc8, 0x73, 0x58, 0x98, 0x25, 0x8c, 0x5a, 0xc7, 0x63, 0x41, 0x79, 0x42, 0x99, 0x67, 0xc0,
	0x24, 0xfa, 0xd2, 0xb7, 0xe3, 0x71, 0xd9, 0x60, 0xb7, 0xac, 0x5b, 0xc3, 0xc1, 0x60, 0x54, 0xf0,
	0xad, 0xbb, 0xd0, 0xd8, 0x77, 0xad, 0x0e, 0xe9, 0xf9, 0xae, 0x4d, 0xc4, 0x39, 0xb3, 0x8c, 0xa2,
	0xba, 0x77, 0x97, 0xf8, 0x9c, 0x9f, 0xd1, 0x9f, 0x93, 0x70, 0xef, 0x7d, 0x41, 0x62, 0xa5, 0x39,
	0x97, 0xb9, 0x64, 0xd0, 0x87, 0x85, 0xb8, 0xc4, 0x7d, 0xa7, 0x23, 0xfc, 0x1e, 0x13, 0x11, 0xa9,
	0xc9, 0x07, 0x3f, 0x71, 0x70, 0x2d, 0x26, 0x51, 0x79, 0x70, 0xad, 0x09, 0x26, 0xfa, 0x23, 0xd0,
	0xd5, 0xea, 0x2e, 0xe3, 0xdc, 0xff, 0x2d, 0x0d, 0xae, 0xb2, 0xd2, 0x86, 0xd2, 0xeb, 0x20, 0x85,
	0x4b, 0xe6, 0xd5, 0x3c, 0x0f, 0x22, 0x9d, 0x6e, 0x55, 0xa4, 0xc0, 0x84, 0xc6, 0xd7, 0xc4, 0x4c,
	0x49, 0xda, 0xf2, 0xd9, 0x4d, 0xfd, 0xbf, 0x4c, 0x15, 0x90, 0x74, 0x88, 0x03, 0x51, 0xfd, 0xf0,
	0x3c, 0xd5, 0x0f, 0x2f, 0x53, 0xfd, 0x09, 0x2c, 0x32, 0x4d, 0x79, 0xbd, 0x83, 0x47, 0x95, 0x12,
	0xaf, 0xce, 0x1f, 0x8a, 0x25, 0x98, 0xb6, 0xd9, 0xa6, 0x8e, 0xb3, 0x2f, 0x1b, 0x37, 0x74, 0x13,
	0x4c, 0xa4, 0x5d, 0x68, 0x6e, 0x11, 0x97, 0xd7, 0x77, 0xb9, 0x25, 0xf0, 0x9f, 0xcb, 0x50, 0x6f,
	0x39, 0x5d, 0xef, 0x00, 0x57, 0x76, 0x2a, 0xb8, 0x83, 0x96, 0x0d, 0xee, 0xf0, 0x39, 0x98, 0x43,
	0x90, 0x96, 0xf3, 0x50, 0x6c, 0x3c, 0xeb, 0xa6, 0x8a, 0xa4, 0xca, 0x41, 0x8c, 0x10, 0x9c, 0x38,
	0x46, 0x24, 0xc1, 0x2d, 0xab, 0x72, 0x70, 0x4b, 0x25, 0x6c, 0xc4, 0xf4, 0xa8, 0xb0, 0x11, 0x33,
	0x85, 0x61, 0x23, 0x6a, 0xe3, 0xc2, 0x46, 0xd4, 0xcf, 0x1d, 0x36, 0x02, 0xce, 0x15, 0x36, 0xa2,
	0x91, 0x09, 0x1b, 0xb1, 0x00, 0x55, 0xbb, 0x93, 0xdc, 0x9b, 0xa8, 0xd8, 0x1d, 0x79, 0x6c, 0xe7,
	0xc6, 0xae, 0x30, 0x8c, 0xe1, 0x8e, 0x31, 0x26, 0xd8, 0xb9, 0xc3, 0xbc, 0x08, 0xf2, 0x99, 0xc4,
	0x9d, 0xb8, 0x03, 0x0d, 0xd7, 0xef, 0x58, 0x2e, 0x0f, 0x4f, 0x7a, 0x85, 0x05, 0x9e, 0x70, 0xe3,
	0xc0, 0x13, 0xc6, 0xbf, 0xe0, 0x37, 0x5a, 0xc5, 0xc0, 0xe2, 0x04, 0xf9, 0x39, 0x29, 0xd8, 0xe4,
	0xfc, 0xda, 0x17, 0xb2, 0x57, 0x28, 0xe5, 0xdc, 0x72, 0x54, 0x59, 0x16, 0x97, 0x72, 0x8d, 0x31,
	0x10, 0x34, 0x07, 0x94, 0x46, 0x2e, 0xa7, 0x38, 0x9f, 0xf1, 0x4f, 0xb5, 0x49, 0xa2, 0xcd, 0xea,
	0xd7, 0x40, 0x97, 0xa6, 0xda, 0xae, 0x87, 0x0e, 0x87, 0xcd, 0x92, 0x7e, 0x1d, 0x16, 0x24, 0xfc,
	0xd3, 0x4e, 0x67, 0x38, 0x70, 0x88, 0xdd, 0x2c, 0xeb, 0x3a, 0xcc, 0x6f, 0x5a, 0x83, 0xa8, 0xd3,
	0xb3, 0x1e, 0xbc, 0x1c, 0x38, 0x01, 0xb1, 0x9b, 0x15, 0x09, 0x27, 0x0a, 0xa8, 0xea, 0x73, 0x50,
	0xdf, 0x76, 0x7d, 0xdf, 0x7e, 0x6e, 0x39, 0x51, 0x73, 0x9a, 0xd6, 0xc3, 0xfb, 0x4a, 0x15, 0x6a,
	0xbc, 0x38, 0x4d, 0xec, 0xe6, 0x8c, 0xf1, 0x37, 0x99, 0xe2, 0xbe, 0x3d, 0x74, 0x59, 0x00, 0xf1,
	0xd1, 0xaf, 0x59, 0xe4, 0x3d, 0xc1, 0x45, 0x77, 0x80, 0xeb, 0x99, 0x08, 0x19, 0xeb, 0x17, 0x8a,
	0x90, 0xf1, 0xbb, 0x25, 0xb4, 0x0a, 0x25, 0xad, 0xb9, 0x00, 0x4b, 0xbb, 0x05, 0x75, 0x27, 0x3c,
	0x64, 0x1d, 0xe4, 0xb7, 0x9a, 0x12, 0x84, 0x7e, 0x1f, 0x16, 0x70, 0x06, 0xb5, 0x3b, 0x96, 0xeb,
	0x86, 0xed, 0x41, 0xe0, 0x9c, 0x0a, 0x3f, 0xc6, 0x9a, 0x79, 0x15, 0x93, 0x36, 0x69, 0xca, 0x3e,
	0x4b, 0xd0, 0xd7, 0x60, 0x49, 0xce, 0x6f, 0x9d, 0x5a, 0x8e, 0x6b, 0x1d, 0xba, 0xc2, 0xcb, 0x6e,
	0x21, 0xf9, 0x62, 0x5d, 0x24, 0x15, 0x28, 0x56, 0x77, 0xa0, 0xc1, 0xde, 0x37, 0x65, 0x21, 0xc0,
	0x98, 0x6f, 0x15, 0x30, 0x94, 0xf0, 0x54, 0xce, 0x0b, 0x42, 0xa9, 0x72, 0xb9, 0xda, 0xb9, 0xb9,
	0x5c, 0x18, 0xc7, 0x8d, 0x4c, 0x82, 0x50, 0x5e, 0x28, 0x02, 0xe5, 0x24, 0x5c, 0xfa, 0x58, 0x78,
	0x68, 0xf1, 0xc0, 0x2b, 0x93, 0x3b, 0x83, 0x4f, 0x50, 0xd9, 0x57, 0x12, 0xcf, 0x2c, 0xb9, 0xba,
	0x09, 0x0e, 0xed, 0xbf, 0xc3, 0x2e, 0x3a, 0x28, 0x41, 0xca, 0xce, 0xeb, 0xef, 0x5d, 0x1a, 0xe1,
	0xef, 0x5d, 0x2e, 0x0c, 0x71, 0x31, 0x7e, 0x0d, 0xfc, 0x8f, 0x32, 0xda, 0xec, 0xe2, 0x97, 0x04,
	0x0a, 0x29, 0x38, 0x59, 0xb4, 0x94, 0x55, 0x80, 0x43, 0xab, 0x73, 0xdc, 0x0d, 0xfc, 0xa1, 0x27,
	0xee, 0x79, 0x4a, 0x18, 0x9c, 0x9e, 0x2e, 0xb1, 0x82, 0xb6, 0x1d, 0x58, 0x47, 0x11, 0xbf, 0x94,
	0x0c, 0x88, 0xda, 0xa2, 0x18, 0x5d, 0x87, 0x0a, 0x3a, 0xed, 0xf2, 0x23, 0x31, 0xfa, 0x5b, 0x7f,
	0x03, 0xae, 0xa0, 0x9d, 0xa4, 0x1d, 0xf9, 0x6d, 0x6e, 0xc3, 0x9a, 0x11, 0xf1, 0x21, 0x07, 0xee,
	0xd9, 0x33, 0x9f, 0x1d, 0x47, 0x2f, 0x42, 0x95, 0xbd, 0xec, 0x55, 0x63, 0x5a, 0x24, 0x02, 0x18,
	0xa7, 0x7d, 0xe8, 0x46, 0x0e, 0x7f, 0xf5, 0xab, 0x8e, 0xdb, 0x4f, 0x40, 0x14, 0xeb, 0xf8, 0x4d,
	0xa8, 0x07, 0x96, 0x67, 0xb3, 0x90, 0x2a, 0xc0, 0x9e, 0x95, 0x61, 0x08, 0x11, 0x73, 0x92, 0x56,
	0xdd, 0xb7, 0x82, 0xe3, 0xe1, 0x00, 0xa5, 0xd2, 0xac, 0xd9, 0x40, 0xdc, 0x1e, 0xa2, 0xe8, 0x48,
	0x7a, 0xe4, 0x05, 0x3f, 0x34, 0x64, 0x71, 0xdc, 0x13, 0x84, 0x18, 0x31, 0xae, 0xda, 0xcd, 0x29,
	0xd7, 0x0e, 0x62, 0x57, 0xcb, 0xa8, 0x4f, 0xa8, 0x52, 0x30, 0x1f, 0xef, 0xf5, 0x19, 0x22, 0x19,
	0xcf, 0x2b, 0x63, 0x85, 0xdb, 0x2d, 0x80, 0x53, 0xc7, 0x6a, 0x73, 0xed, 0x9a, 0x87, 0x2a, 0x3a,
	0x75, 0x2c, 0xe6, 0xd3, 0x23, 0xfc, 0x95, 0x39, 0xab, 0x9b, 0x6c, 0xfa, 0xfe, 0x80, 0x19, 0x2d,
	0x79, 0xec, 0x96, 0xe8, 0x99, 0xb8, 0x02, 0x34, 0xd1, 0x82, 0x8b, 0x6f, 0xa4, 0x94, 0x53, 0x57,
	0x37, 0xcf, 0xe5, 0x4e, 0x38, 0xde, 0xaa, 0xb7, 0xc1, 0x3d, 0xb8, 0x32, 0xad, 0x9c, 0xe0, 0x92,
	0xc9, 0xcf, 0xc3, 0x4d, 0xe5, 0xee, 0x39, 0xbb, 0x44, 0x8b, 0x0f, 0x37, 0xe4, 0x45, 0x0b, 0x98,
	0x60, 0xc3, 0x47, 0x60, 0xb5, 0xb8, 0x64, 0x6c, 0xd1, 0x26, 0xd4, 0x5b, 0xd1, 0x3e, 0xc3, 0x71,
	0x73, 0xf5, 0xf8, 0x3b, 0xc3, 0xec, 0x75, 0x89, 0xf8, 0x3b, 0xe3, 0x07, 0x15, 0xb8, 0x5e, 0x70,
	0xb5, 0x58, 0xff, 0x12, 0x2c, 0x5b, 0x51, 0x14, 0x38, 0x87, 0xc3, 0x88, 0x84, 0xed, 0x30, 0x72,
	0x8e, 0x49, 0xd0, 0xe6, 0x0e, 0xf4, 0xec, 0xbe, 0xee, 0x52, 0x92, 0xde, 0xc2, 0xe4, 0x96, 0xf0,
	0xa6, 0x17, 0x17, 0x5d, 0xdb, 0x71, 0x50, 0x37, 0x10, 0xa8, 0xec, 0x79, 0x49, 0x39, 0xcf, 0xdb,
	0xb7, 0xef, 0xf4, 0xa5, 0x23, 0xf2, 0xba, 0x59, 0xa3, 0x08, 0x34, 0x4b, 0x8a, 0x43, 0x30, 0x36,
	0x12, 0xec, 0x10, 0x8c, 0x4e, 0x96, 0xde, 0xb0, 0x7f, 0x18, 0x87, 0x27, 0xa0, 0x40, 0xa2, 0xff,
	0xcd, 0x48, 0xfa, 0x1f, 0x3b, 0xf4, 0x21, 0xfc, 0x9e, 0x0a, 0xfe, 0xd6, 0xdf, 0x83, 0xeb, 0x52,
	0x57, 0xf1, 0xd9, 0x07, 0x74, 0x26, 0x68, 0xbf, 0xe0, 0x5a, 0xea, 0x62, 0x92, 0x8c, 0x77, 0x1c,
	0x5b, 0xce, 0x27, 0xe4, 0x79, 0xf1, 0x67, 0x3d, 0x1e, 0x78, 0x30, 0xef, 0xb3, 0x87, 0x54, 0x76,
	0x67, 0x09, 0x6b, 0xb9, 0x11, 0x0f, 0x5b, 0xb6, 0x90, 0xa6, 0xea, 0xba, 0x1b, 0xe9, 0x0f, 0xe1,
	0xb5, 0xfc, 0xc1, 0x90, 0x09, 0xc9, 0x78, 0xc9, 0xed, 0x9c, 0x51, 0x91, 0xd4, 0x9e, 0xb7, 0x41,
	0x6a, 0x55, 0x3b, 0x39, 0xc8, 0x9d, 0xc3, 0xca, 0xf5, 0x24, 0x6d, 0x5b, 0x1c, 0xe9, 0xba, 0xb9,
	0x73, 0x24, 0x37, 0x1a, 0xc5, 0x3a, 0xd4, 0x1c, 0x7e, 0x06, 0xc5, 0x27, 0xf9, 0x39, 0xef, 0xb1,
	0xc7, 0x9f, 0x19, 0x7f, 0x15, 0x96, 0xf3, 0x4c, 0x5f, 0xe9, 0x3d, 0x6c, 0xf9, 0x53, 0xdb, 0xc3,
	0x3e, 0x84, 0xab, 0x2d, 0x12, 0x6d, 0xf8, 0xd1, 0x47, 0x24, 0x70, 0x8e, 0x1c, 0x62, 0x8f, 0xdb,
	0xcc, 0x9f, 0xf2, 0x7c, 0x5c, 0xab, 0x8b, 0x61, 0xe3, 0x31, 0x86, 0xe9, 0x56, 0x4a, 0x1a, 0xb8,
	0x67, 0x17, 0x6d, 0xd7, 0x07, 0x70, 0x4b, 0xbc, 0x0c, 0x80, 0x8f, 0x04, 0xa0, 0x82, 0x26, 0xbd,
	0x5f, 0x50, 0xfc, 0x64, 0xac, 0xf1, 0xab, 0x1a, 0xdc, 0x19, 0xf1, 0xed, 0x67, 0xff, 0x3e, 0xcd,
	0xbd, 0x7f, 0xac, 0x81, 0x9e, 0x7d, 0xa2, 0x57, 0xbf, 0xc2, 0x1f, 0x38, 0xc2, 0x78, 0xe5, 0x67,
	0xb8, 0x35, 0x41, 0x3f, 0xb0, 0x03, 0xef, 0xd8, 0xf3, 0x5f, 0x78, 0xcd, 0xef, 0xfc, 0x56, 0x95,
	0xa2, 0xa8, 0x4e, 0x24, 0x50, 0xdf, 0x65, 0x28, 0x7c, 0x2f, 0x98, 0xa3, 0xbe, 0x97, 0xa0, 0x9e,
	0x7a, 0x3b, 0xbe, 0xe3, 0x75, 0x9b, 0xdf, 0x67, 0xa8, 0x87, 0xd6, 0x29, 0x79, 0xe2, 0xef, 0xfb,
	0x2f, 0x48, 0xd0, 0xfc, 0x35, 0x86, 0xda, 0x75, 0x5d, 0xd2, 0xb5, 0xdc, 0xf5, 0xa0, 0x1b, 0x36,
	0x7f, 0x9d, 0xa3, 0x92, 0xcd, 0x50, 0xf3, 0x37, 0x7e, 0xab, 0x7a, 0x6f, 0x37, 0x39, 0x3c, 0xd1,
	0x9b, 0x30, 0x2b, 0x7e, 0x7f, 0x4c, 0x02, 0xbf, 0x39, 0xa5, 0xcf, 0xb2, 0x33, 0x46, 0xda, 0xcc,
	0xa6, 0x26, 0x20, 0x9a, 0xa7, 0x59, 0xa2, 0xfd, 0x11, 0x17, 0xb9, 0x28, 0xa2, 0x7c, 0x6f, 0x1f,
	0xea, 0x71, 0x74, 0x7e, 0x9a, 0xba, 0xb7, 0xbd, 0xdb, 0x3e, 0x78, 0xf2, 0xe8, 0xc9, 0xd3, 0xe7,
	0x4f, 0x9a, 0x53, 0x3a, 0xc0, 0x34, 0x45, 0xec, 0xee, 0x35, 0x35, 0x7d, 0x09, 0xae, 0xe2, 0x6f,
	0x1e, 0x9d, 0xbf, 0xbd, 0x67, 0xb9, 0x2e, 0x2b, 0x91, 0xa2, 0x77, 0xac, 0x3e, 0x59, 0x1f, 0x38,
	0xcd, 0xf2, 0xbd, 0x35, 0x80, 0xe4, 0xe2, 0x2e, 0x6d, 0x5e, 0x02, 0x3d, 0x7d, 0xd4, 0x9c, 0xa2,
	0x9b, 0xb0, 0x04, 0xb3, 0x6d, 0x39, 0x6e, 0x53, 0xbb, 0xf7, 0xbe, 0x74, 0x68, 0x42, 0x4b, 0x8c,
	0x81, 0xa7, 0xc7, 0xcd, 0x29, 0x7d, 0x05, 0x96, 0x62, 0x04, 0xbe, 0x3d, 0xeb, 0x47, 0x0f, 0x5e,
	0x3a, 0x61, 0xd4, 0xfc, 0xce, 0x93, 0xb5, 0xff, 0xf0, 0xe3, 0x70, 0x75, 0x7d, 0xe0, 0xec, 0xb0,
	0xb1, 0xe5, 0xde, 0x69, 0xfa, 0x5f, 0xa0, 0xf2, 0x5e, 0x35, 0xfb, 0xe8, 0xaf, 0xa5, 0x67, 0x41,
	0x26, 0xf2, 0xe5, 0xca, 0xe7, 0xc6, 0x65, 0x41, 0xcf, 0x81, 0x29, 0xbd, 0x4d, 0x45, 0x35, 0x4b,
	0x33, 0x89, 0xcd, 0x4d, 0x8e, 0xaf, 0xb2, 0x82, 0xe7, 0x30, 0x9f, 0x58, 0x8c, 0xd1, 0x8e, 0x71,
	0x27, 0x75, 0x42, 0x91, 0xb6, 0xee, 0xad, 0x18, 0xa3, 0x33, 0xf0, 0x82, 0x3f, 0x06, 0x9d, 0x19,
	0xa4, 0x64, 0x7e, 0xa6, 0x1b, 0x69, 0xc1, 0x9f, 0x35, 0x59, 0xad, 0xac, 0x66, 0xf2, 0x28, 0x36,
	0x26, 0x63, 0x4a, 0xff, 0x08, 0xe6, 0x53, 0xf1, 0x48, 0xef, 0xa4, 0xbb, 0x9b, 0x8a, 0xc2, 0xba,
	0x92, 0x21, 0x59, 0x26, 0xa6, 0xa9, 0x31, 0xa5, 0xaf, 0xc3, 0x8c, 0x70, 0x35, 0x5e, 0xce, 0x14,
	0xc8, 0x53, 0x56, 0x56, 0x72, 0x4a, 0xe2, 0x69, 0xc6, 0x94, 0x7e, 0x82, 0x31, 0x79, 0x72, 0x5d,
	0x40, 0xdf, 0xcc, 0x14, 0x59, 0x90, 0x73, 0xe5, 0x5e, 0x4e, 0x15, 0x05, 0x79, 0x8d, 0x29, 0x7d,
	0x3f, 0xb6, 0x17, 0xc4, 0x1b, 0xa6, 0x4c, 0x4d, 0x52, 0xd0, 0xdd, 0x34, 0x7d, 0xd3, 0xf1, 0x6f,
	0x8d, 0x29, 0x9d, 0x60, 0x0c, 0xa8, 0xcd, 0x4c, 0x1c, 0xe5, 0x37, 0xf2, 0x7a, 0x90, 0x09, 0xb7,
	0x9c, 0x9d, 0x7b, 0x79, 0xd1, 0x84, 0x8d, 0x29, 0xbd, 0x05, 0x57, 0xd2, 0x91, 0x37, 0x6f, 0x67,
	0x6a, 0x90, 0x93, 0x57, 0xee, 0xe4, 0x94, 0x2c, 0x67, 0x30, 0xa6, 0xf4, 0x3d, 0x68, 0xc8, 0x21,
	0xa4, 0x6f, 0xe5, 0x35, 0x59, 0xa4, 0xe6, 0x92, 0x42, 0x4a, 0x47, 0xe2, 0xce, 0x2a, 0x7b, 0xd1,
	0x6c, 0x03, 0xe5, 0xe4, 0xdc, 0x06, 0xca, 0x19, 0x8c, 0x29, 0xfd, 0x13, 0x58, 0x19, 0x11, 0x89,
	0xf3, 0xc7, 0x33, 0xe5, 0x17, 0x67, 0x5e, 0xf9, 0x89, 0x9c, 0xda, 0x8a, 0xb3, 0x1b, 0x53, 0xfa,
	0x5f, 0x14, 0xd6, 0x7a, 0xe9, 0x7c, 0x48, 0xcf, 0x5d, 0xcf, 0xea, 0x21, 0xd8, 0xca, 0x1b, 0x63,
	0xf3, 0xf0, 0xa5, 0xf9, 0x21, 0xcc, 0x29, 0xc7, 0x23, 0x7a, 0xea, 0xc0, 0x53, 0x09, 0x94, 0x9e,
	0x5e, 0x95, 0x39, 0x51, 0xd4, 0x8d, 0x29, 0xfd, 0x17, 0xa1, 0x99, 0x89, 0x85, 0x99, 0x59, 0xce,
	0x99, 0x70, 0x99, 0x2b, 0xaf, 0xe7, 0x10, 0x27, 0x9d, 0x29, 0x53, 0x3a, 0x8b, 0x1b, 0x3a, 0xb2,
	0x74, 0xcc, 0x32, 0xae, 0x74, 0xcc, 0x64, 0x4c, 0xe9, 0x4f, 0x01, 0x12, 0xf7, 0x4d, 0x7d, 0x35,
	0xf3, 0x58, 0x8d, 0xe2, 0x70, 0x9a, 0x9e, 0x3d, 0x19, 0xdf, 0x4f, 0x64, 0x7d, 0x4b, 0x5c, 0x02,
	0x25, 0x49, 0x5b, 0x24, 0xec, 0xa4, 0x27, 0xba, 0xea, 0x14, 0xbe, 0x72, 0x7b, 0x44, 0x2a, 0x96,
	0xfb, 0x15, 0x98, 0xe1, 0xaf, 0x41, 0xa4, 0x59, 0x5f, 0xf2, 0xcc, 0xc5, 0xca, 0x8d, 0x82, 0x14,
	0x2c, 0x61, 0x93, 0xaa, 0x0a, 0xec, 0x21, 0x06, 0xfd, 0x46, 0xce, 0xab, 0x61, 0xbc, 0x8c, 0x95,
	0xa2, 0x24, 0x2c, 0x64, 0x17, 0x20, 0x79, 0x03, 0x21, 0x3d, 0x77, 0x94, 0xa7, 0x19, 0x56, 0x6e,
	0x15, 0x27, 0x62, 0x51, 0x4f, 0x90, 0x11, 0x08, 0xc3, 0x65, 0x9a, 0x3e, 0xaa, 0x85, 0x35, 0x4d,
	0xf9, 0x8c, 0xc5, 0x13, 0x29, 0x7f, 0x25, 0xa5, 0x9d, 0xeb, 0x77, 0x33, 0x5f, 0xa5, 0x8e, 0xca,
	0x73, 0xca, 0xcd, 0x48, 0xe0, 0x87, 0xfc, 0x1d, 0x0e, 0x82, 0xcf, 0xba, 0xa4, 0xdb, 0xa9, 0x3e,
	0xf7, 0x92, 0x1e, 0x01, 0xe9, 0x41, 0x13, 0x63, 0x4a, 0xff, 0x6a, 0xf2, 0x80, 0x04, 0x2f, 0x2c,
	0x4d, 0x40, 0xf9, 0xc1, 0x95, 0xd1, 0x65, 0x3d, 0x84, 0x59, 0x74, 0x84, 0x2c, 0x28, 0x49, 0x79,
	0x13, 0x66, 0x74, 0x49, 0xbf, 0x18, 0xfb, 0x4c, 0xec, 0xda, 0x4c, 0x74, 0xa1, 0x9a, 0x61, 0xe4,
	0x52, 0x46, 0x79, 0x9d, 0xe7, 0x3c, 0xd4, 0x7b, 0x06, 0x73, 0xca, 0x7b, 0x40, 0xe9, 0x35, 0x96,
	0x7e, 0xea, 0x28, 0xcd, 0x72, 0x72, 0x1e, 0x13, 0x32, 0xa6, 0xf4, 0x03, 0x98, 0x95, 0xcf, 0x48,
	0xd3, 0x0c, 0x21, 0xe7, 0xb8, 0x76, 0xe5, 0xee, 0xa8, 0x2c, 0x49, 0xb1, 0xb2, 0xe3, 0x6c, 0x7a,
	0xfe, 0x64, 0xdd, 0xa2, 0xd3, 0xad, 0xcd, 0xf1, 0x0c, 0x66, 0x8b, 0x26, 0x79, 0x02, 0x2a, 0x3d,
	0x52, 0xca, 0x8b, 0x55, 0xe9, 0x45, 0xa3, 0xbe, 0x1c, 0x65, 0x4c, 0xe9, 0x2f, 0xe0, 0x46, 0xf1,
	0xa3, 0x58, 0x19, 0xb5, 0xa4, 0xf8, 0x35, 0xb0, 0x95, 0x2f, 0xe6, 0xf0, 0xc7, 0xc2, 0xdc, 0xc6,
	0x94, 0xfe, 0x35, 0x98, 0x93, 0xee, 0x0c, 0x85, 0x5d, 0x7d, 0x2d, 0x4f, 0x70, 0x8f, 0xbe, 0x53,
	0xb4, 0xf2, 0x6e, 0xbe, 0x38, 0x1f, 0xfd, 0x15, 0xd3, 0x27, 0xd5, 0xdd, 0x6a, 0x5a, 0x9f, 0xcc,
	0xec, 0x8a, 0x73, 0xa6, 0x51, 0x7a, 0xb3, 0x6b, 0x4c, 0xe9, 0x1e, 0xbe, 0xa1, 0x9e, 0x77, 0x11,
	0xec, 0xc7, 0xce, 0xa1, 0x0b, 0xd2, 0x8c, 0x2b, 0x5f, 0x38, 0x97, 0x2a, 0x48, 0xb3, 0x1a, 0x53,
	0xfa, 0x4b, 0xb8, 0x51, 0xb8, 0xd7, 0x4d, 0x8f, 0xde, 0xa8, 0x0d, 0x75, 0x5a, 0xb1, 0x18, 0xb3,
	0x81, 0x96, 0xc5, 0xbe, 0x78, 0x54, 0x6e, 0xb5, 0x40, 0x8f, 0xe1, 0xe9, 0x59, 0xcd, 0x4b, 0x7d,
	0x94, 0xce, 0x98, 0xd2, 0x6d, 0x58, 0x50, 0xea, 0xe5, 0xdd, 0x78, 0x3d, 0xa7, 0x69, 0xe9, 0x07,
	0x0d, 0x57, 0x3e, 0x3f, 0x3e, 0x13, 0x6f, 0x78, 0x07, 0xf4, 0xec, 0x9b, 0x96, 0x99, 0x4a, 0xf2,
	0x1e, 0xdf, 0xcc, 0x54, 0x52, 0xf0, 0x34, 0x26, 0x52, 0x67, 0x56, 0x7e, 0x11, 0x34, 0xad, 0x44,
	0xa6, 0x9e, 0x23, 0x4d, 0xb3, 0x92, 0xec, 0x63, 0xa2, 0xc6, 0x94, 0xee, 0xc0, 0x62, 0xde, 0x8b,
	0xbb, 0x69, 0x15, 0xbd, 0xe0, 0xbd, 0xe0, 0x95, 0x37, 0xcf, 0x93, 0x2d, 0x21, 0x51, 0xf6, 0x11,
	0xe5, 0x34, 0x89, 0x72, 0x5f, 0xc8, 0x4e, 0x93, 0xa8, 0xe8, 0x2d, 0x66, 0x54, 0x94, 0x66, 0xe5,
	0x67, 0xe7, 0xf3, 0x49, 0x14, 0x3f, 0x7c, 0xbf, 0xb2, 0x3a, 0x2a, 0x19, 0x39, 0x59, 0x32, 0xb0,
	0xf2, 0xd3, 0xfb, 0xf9, 0x03, 0xab, 0x3c, 0xe4, 0x5f, 0x34, 0xb0, 0x99, 0xd7, 0xfe, 0x59, 0x25,
	0x59, 0x8b, 0x5d, 0xba, 0x92, 0x5c, 0x77, 0xb6, 0x74, 0x25, 0x45, 0x86, 0x3f, 0x63, 0x4a, 0xb7,
	0x64, 0xc7, 0xf8, 0xd8, 0xc8, 0x90, 0xad, 0x24, 0x95, 0x23, 0xc7, 0x0a, 0x90, 0x97, 0x09, 0x89,
	0xf5, 0xe7, 0xe1, 0x2a, 0x55, 0x5e, 0x1f, 0x9c, 0x92, 0xe0, 0xcc, 0xf7, 0xc8, 0x87, 0x43, 0x87,
	0x44, 0x69, 0x09, 0xcd, 0xb5, 0x60, 0x25, 0x4f, 0xee, 0x06, 0x4a, 0x8a, 0x04, 0x6f, 0x4c, 0xe9,
	0xbf, 0x00, 0x3a, 0xfd, 0x2c, 0x15, 0x6c, 0xe3, 0xf5, 0xdc, 0xb2, 0xd5, 0x4c, 0xe7, 0x28, 0xfc,
	0x20, 0x45, 0x7f, 0xf6, 0xe2, 0xc5, 0xad, 0x02, 0xd5, 0x02, 0x4f, 0x86, 0xcf, 0xa3, 0x54, 0x6c,
	0x33, 0x95, 0x6c, 0xd3, 0xb7, 0x09, 0x15, 0x45, 0xd9, 0x3d, 0xa4, 0x94, 0xba, 0x72, 0x3d, 0xd7,
	0x1e, 0xe0, 0xbb, 0x4c, 0x21, 0x8b, 0x2d, 0x7d, 0xad, 0xc8, 0x0a, 0x22, 0x3d, 0xa5, 0xfd, 0xc6,
	0x09, 0x39, 0x9a, 0x71, 0x92, 0x86, 0x43, 0xb4, 0x03, 0x73, 0x52, 0x59, 0xfe, 0x20, 0xad, 0x63,
	0x0b, 0x7c, 0x8e, 0x3e, 0x16, 0x27, 0x61, 0x41, 0x1f, 0xa3, 0x33, 0x2e, 0xc5, 0xed, 0x62, 0x28,
	0xaa, 0x83, 0xc0, 0x4d, 0xeb, 0x37, 0xe9, 0xf4, 0x1c, 0x81, 0x97, 0xc9, 0x82, 0x65, 0x9b, 0x30,
	0x87, 0xab, 0x25, 0xd6, 0xf2, 0x56, 0x73, 0x96, 0xd2, 0x81, 0x64, 0x4b, 0xba, 0x33, 0x32, 0x9d,
	0xeb, 0xf1, 0xb3, 0x74, 0x6e, 0xb0, 0xda, 0x8e, 0xfc, 0x34, 0x67, 0x90, 0xd3, 0x72, 0x76, 0x3a,
	0x4a, 0x32, 0x96, 0xf7, 0x4c, 0x1a, 0x14, 0xac, 0x2f, 0x2d, 0xec, 0xd5, 0xd4, 0x3c, 0x3d, 0x54,
	0xcd, 0x90, 0x4b, 0xd5, 0x4d, 0x2f, 0x1a, 0x49, 0xd5, 0x4d, 0x8c, 0xd5, 0xb9, 0x32, 0x2e, 0x0b,
	0x96, 0x7d, 0x00, 0x57, 0x1e, 0x39, 0x9d, 0xe3, 0xed, 0xc0, 0xef, 0x0b, 0x33, 0xc4, 0xdd, 0xcc,
	0x94, 0x4c, 0xe5, 0x38, 0xc7, 0xe2, 0xf9, 0x18, 0x9a, 0x31, 0xbd, 0x77, 0xd9, 0x0d, 0x17, 0xfd,
	0xb5, 0x82, 0xf1, 0xe0, 0xe9, 0x39, 0x4d, 0xce, 0x64, 0xc1, 0x26, 0x3f, 0x80, 0x1a, 0xed, 0xc8,
	0xfe, 0x30, 0xec, 0xe5, 0x4d, 0x54, 0x8a, 0xcf, 0x51, 0x47, 0x93, 0xa4, 0xd8, 0x3a, 0x79, 0x45,
	0x5c, 0x51, 0x39, 0xe0, 0x2e, 0xbd, 0xd9, 0x3d, 0x97, 0x9c, 0x9c, 0x23, 0x3e, 0xd3, 0x39, 0x68,
	0xfb, 0x36, 0x66, 0x7f, 0xe7, 0x47, 0xab, 0xda, 0x7f, 0xfa, 0xd1, 0xaa, 0xf6, 0xc7, 0x3f, 0x5a,
	0xd5, 0x0e, 0xa7, 0xd1, 0x1f, 0xfc, 0x27, 0xff, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2a, 0x6e,
	0x03, 0x26, 0x75, 0x97, 0x00, 0x00,
}
