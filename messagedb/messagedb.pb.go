// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/messagedb/messagedb.proto
// DO NOT EDIT!

/*
Package messagedb is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/messagedb/messagedb.proto

It has these top-level messages:

	GetMessageByMsgIDsReq
	GetMessageByMsgIDsResp
	ReplyNull
	ReplyErr
	ReqHeartBeating
	ReplyHeartBeating
	ReqInsertOrUpdateUserMsg
	DialogIsCreated
	ReqGetForwardUserMsg
	ForWardUserMsg
	ForWardUserMsgList
	ReqGetUserMsgHistory
	UserMsgList
	ReqGetUserMsgUUID
	UUID
	ReqGetUserMsgIdByUUID
	MsgId
	ReqGetUserMsgListByUUIDs
	ReqDeleteUserMsg
	ReqBatchDeleteUserMsg
	ReqGetOneUserMsgByUserIdAndMsgId
	ReqDeleteUserMsgByUserIdAndWithIdAndEncry
	ReqClearHistory
	MsgIDList
	GetMessageHistoryPageByMediaConfig
	ReqGetMessageHistoryPageByMedia
	ReplyGetMessageHistoryPageByMedia
	ReqGetUserMediaMessageStatisticsByMedia
	UserMediaMessageStatistics
	ReplyGetUserMediaMessageStatisticsByMedia
	ReqGetLastLimitDialog
	UserRating
	ReplyGetLastLimitDialog
	ReqGetRandomStatus
	ReplyGetRandomStatus
	ReqSetSuperGroupMsg
	ReplySetSuperGroupMsg
	ReqGetSuperGroupMsg
	ReplyGetSuperGroupMsg
	ReqUserDialogSetUnreadMetionsCount
	ReplyUserDialogSetUnreadMetionsCount
	ReqUserDialogGetUnreadMetionsCount
	ReplyUserDialogGetUnreadMetionsCount
	ReqUserDialogChangeUnreadMetionsCount
	ReplyUserDialogChangeUnreadMetionsCount
	ReqUserMessageAtAdd
	ReplyUserMessageAtAdd
	ReqUserMessageAtGet
	ReplyUserMessageAtGet
	ReqUserMessageAtDel
	ReplyUserMessageAtDel
	ReqUpdateMessageMediaUnread
	ReqGetUserMessageByUserIDRandomID
	ReqSearch
	ReplySearch
	ReqGetUserMsgByUserIDMsgIDs
	ReplyGetUserMsgByUserIDMsgIDs
	ReqGetUserMsgByUserIDMsgIDsHotData
*/
package messagedb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"
import pbcomm1 "gitlab.chatserver.im/interfaceprobuf/pbcomm"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type HeartBeating int32

const (
	HeartBeating_RpcExcept      HeartBeating = 0
	HeartBeating_PackageType    HeartBeating = 1
	HeartBeating_Identification HeartBeating = 2
	HeartBeating_ResultSuccess  HeartBeating = 3
)

var HeartBeating_name = map[int32]string{
	0: "RpcExcept",
	1: "PackageType",
	2: "Identification",
	3: "ResultSuccess",
}
var HeartBeating_value = map[string]int32{
	"RpcExcept":      0,
	"PackageType":    1,
	"Identification": 2,
	"ResultSuccess":  3,
}

func (x HeartBeating) String() string {
	return proto.EnumName(HeartBeating_name, int32(x))
}
func (HeartBeating) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{0} }

type GetMessageByMsgIDsReq struct {
	UserID int32   `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgIDs []int32 `protobuf:"varint,2,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
}

func (m *GetMessageByMsgIDsReq) Reset()                    { *m = GetMessageByMsgIDsReq{} }
func (m *GetMessageByMsgIDsReq) String() string            { return proto.CompactTextString(m) }
func (*GetMessageByMsgIDsReq) ProtoMessage()               {}
func (*GetMessageByMsgIDsReq) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{0} }

func (m *GetMessageByMsgIDsReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetMessageByMsgIDsReq) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

type GetMessageByMsgIDsResp struct {
	Messages []*pbcomm1.UserMsg `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *GetMessageByMsgIDsResp) Reset()                    { *m = GetMessageByMsgIDsResp{} }
func (m *GetMessageByMsgIDsResp) String() string            { return proto.CompactTextString(m) }
func (*GetMessageByMsgIDsResp) ProtoMessage()               {}
func (*GetMessageByMsgIDsResp) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{1} }

func (m *GetMessageByMsgIDsResp) GetMessages() []*pbcomm1.UserMsg {
	if m != nil {
		return m.Messages
	}
	return nil
}

// 返回空结构体
type ReplyNull struct {
}

func (m *ReplyNull) Reset()                    { *m = ReplyNull{} }
func (m *ReplyNull) String() string            { return proto.CompactTextString(m) }
func (*ReplyNull) ProtoMessage()               {}
func (*ReplyNull) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{2} }

type ReplyErr struct {
	ErrCode uint32 `protobuf:"varint,1,opt,name=ErrCode,proto3" json:"ErrCode,omitempty"`
	ErrMsg  string `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
}

func (m *ReplyErr) Reset()                    { *m = ReplyErr{} }
func (m *ReplyErr) String() string            { return proto.CompactTextString(m) }
func (*ReplyErr) ProtoMessage()               {}
func (*ReplyErr) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{3} }

func (m *ReplyErr) GetErrCode() uint32 {
	if m != nil {
		return m.ErrCode
	}
	return 0
}

func (m *ReplyErr) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type ReqHeartBeating struct {
	Type           HeartBeating `protobuf:"varint,1,opt,name=Type,proto3,enum=messagedb.HeartBeating" json:"Type,omitempty"`
	Identification HeartBeating `protobuf:"varint,2,opt,name=Identification,proto3,enum=messagedb.HeartBeating" json:"Identification,omitempty"`
}

func (m *ReqHeartBeating) Reset()                    { *m = ReqHeartBeating{} }
func (m *ReqHeartBeating) String() string            { return proto.CompactTextString(m) }
func (*ReqHeartBeating) ProtoMessage()               {}
func (*ReqHeartBeating) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{4} }

func (m *ReqHeartBeating) GetType() HeartBeating {
	if m != nil {
		return m.Type
	}
	return HeartBeating_RpcExcept
}

func (m *ReqHeartBeating) GetIdentification() HeartBeating {
	if m != nil {
		return m.Identification
	}
	return HeartBeating_RpcExcept
}

type ReplyHeartBeating struct {
	Type   HeartBeating `protobuf:"varint,1,opt,name=Type,proto3,enum=messagedb.HeartBeating" json:"Type,omitempty"`
	Result HeartBeating `protobuf:"varint,2,opt,name=Result,proto3,enum=messagedb.HeartBeating" json:"Result,omitempty"`
}

func (m *ReplyHeartBeating) Reset()                    { *m = ReplyHeartBeating{} }
func (m *ReplyHeartBeating) String() string            { return proto.CompactTextString(m) }
func (*ReplyHeartBeating) ProtoMessage()               {}
func (*ReplyHeartBeating) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{5} }

func (m *ReplyHeartBeating) GetType() HeartBeating {
	if m != nil {
		return m.Type
	}
	return HeartBeating_RpcExcept
}

func (m *ReplyHeartBeating) GetResult() HeartBeating {
	if m != nil {
		return m.Result
	}
	return HeartBeating_RpcExcept
}

type ReqInsertOrUpdateUserMsg struct {
	UserMsg *pbcomm1.UserMsg `protobuf:"bytes,1,opt,name=UserMsg" json:"UserMsg,omitempty"`
	Debug   *pbcomm.Debug    `protobuf:"bytes,2,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqInsertOrUpdateUserMsg) Reset()         { *m = ReqInsertOrUpdateUserMsg{} }
func (m *ReqInsertOrUpdateUserMsg) String() string { return proto.CompactTextString(m) }
func (*ReqInsertOrUpdateUserMsg) ProtoMessage()    {}
func (*ReqInsertOrUpdateUserMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{6}
}

func (m *ReqInsertOrUpdateUserMsg) GetUserMsg() *pbcomm1.UserMsg {
	if m != nil {
		return m.UserMsg
	}
	return nil
}

func (m *ReqInsertOrUpdateUserMsg) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type DialogIsCreated struct {
	DialogIdCreated bool `protobuf:"varint,1,opt,name=DialogIdCreated,proto3" json:"DialogIdCreated,omitempty"`
}

func (m *DialogIsCreated) Reset()                    { *m = DialogIsCreated{} }
func (m *DialogIsCreated) String() string            { return proto.CompactTextString(m) }
func (*DialogIsCreated) ProtoMessage()               {}
func (*DialogIsCreated) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{7} }

func (m *DialogIsCreated) GetDialogIdCreated() bool {
	if m != nil {
		return m.DialogIdCreated
	}
	return false
}

type ReqGetForwardUserMsg struct {
	UserId     int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId     int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithIdType int32         `protobuf:"varint,3,opt,name=WithIdType,proto3" json:"WithIdType,omitempty"`
	Encry      int32         `protobuf:"varint,4,opt,name=Encry,proto3" json:"Encry,omitempty"`
	MsgIds     []int32       `protobuf:"varint,5,rep,packed,name=MsgIds" json:"MsgIds,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,11,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetForwardUserMsg) Reset()                    { *m = ReqGetForwardUserMsg{} }
func (m *ReqGetForwardUserMsg) String() string            { return proto.CompactTextString(m) }
func (*ReqGetForwardUserMsg) ProtoMessage()               {}
func (*ReqGetForwardUserMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{8} }

func (m *ReqGetForwardUserMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetForwardUserMsg) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqGetForwardUserMsg) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *ReqGetForwardUserMsg) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ReqGetForwardUserMsg) GetMsgIds() []int32 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

func (m *ReqGetForwardUserMsg) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ForWardUserMsg struct {
	Date        int32    `protobuf:"varint,1,opt,name=Date,proto3" json:"Date,omitempty"`
	Message     string   `protobuf:"bytes,2,opt,name=Message,proto3" json:"Message,omitempty"`
	Media       int64    `protobuf:"varint,3,opt,name=Media,proto3" json:"Media,omitempty"`
	MediaData   []byte   `protobuf:"bytes,4,opt,name=MediaData,proto3" json:"MediaData,omitempty"`
	ReplyMarkup []byte   `protobuf:"bytes,5,opt,name=ReplyMarkup,proto3" json:"ReplyMarkup,omitempty"`
	Entities    [][]byte `protobuf:"bytes,6,rep,name=Entities" json:"Entities,omitempty"`
	FromId      int32    `protobuf:"varint,7,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Encry       int32    `protobuf:"varint,8,opt,name=Encry,proto3" json:"Encry,omitempty"`
	FwdFrom     []byte   `protobuf:"bytes,9,opt,name=FwdFrom,proto3" json:"FwdFrom,omitempty"`
	GroupId     int64    `protobuf:"varint,10,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	ViaBotId    int32    `protobuf:"varint,11,opt,name=ViaBotId,proto3" json:"ViaBotId,omitempty"`
	MsgID       int32    `protobuf:"varint,12,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
}

func (m *ForWardUserMsg) Reset()                    { *m = ForWardUserMsg{} }
func (m *ForWardUserMsg) String() string            { return proto.CompactTextString(m) }
func (*ForWardUserMsg) ProtoMessage()               {}
func (*ForWardUserMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{9} }

func (m *ForWardUserMsg) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ForWardUserMsg) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ForWardUserMsg) GetMedia() int64 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *ForWardUserMsg) GetMediaData() []byte {
	if m != nil {
		return m.MediaData
	}
	return nil
}

func (m *ForWardUserMsg) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *ForWardUserMsg) GetEntities() [][]byte {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *ForWardUserMsg) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ForWardUserMsg) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ForWardUserMsg) GetFwdFrom() []byte {
	if m != nil {
		return m.FwdFrom
	}
	return nil
}

func (m *ForWardUserMsg) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ForWardUserMsg) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

func (m *ForWardUserMsg) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

type ForWardUserMsgList struct {
	ForWardUserMsg []*ForWardUserMsg `protobuf:"bytes,1,rep,name=ForWardUserMsg" json:"ForWardUserMsg,omitempty"`
}

func (m *ForWardUserMsgList) Reset()                    { *m = ForWardUserMsgList{} }
func (m *ForWardUserMsgList) String() string            { return proto.CompactTextString(m) }
func (*ForWardUserMsgList) ProtoMessage()               {}
func (*ForWardUserMsgList) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{10} }

func (m *ForWardUserMsgList) GetForWardUserMsg() []*ForWardUserMsg {
	if m != nil {
		return m.ForWardUserMsg
	}
	return nil
}

type ReqGetUserMsgHistory struct {
	Selfid     int32         `protobuf:"varint,1,opt,name=Selfid,proto3" json:"Selfid,omitempty"`
	Withid     int32         `protobuf:"varint,2,opt,name=Withid,proto3" json:"Withid,omitempty"`
	Type       int32         `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	OffsetId   int32         `protobuf:"varint,4,opt,name=OffsetId,proto3" json:"OffsetId,omitempty"`
	OffsetDate int32         `protobuf:"varint,5,opt,name=OffsetDate,proto3" json:"OffsetDate,omitempty"`
	AddOffset  int32         `protobuf:"varint,6,opt,name=AddOffset,proto3" json:"AddOffset,omitempty"`
	MinId      int32         `protobuf:"varint,7,opt,name=MinId,proto3" json:"MinId,omitempty"`
	MaxId      int32         `protobuf:"varint,8,opt,name=MaxId,proto3" json:"MaxId,omitempty"`
	Limit      int32         `protobuf:"varint,9,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Encry      int32         `protobuf:"varint,10,opt,name=Encry,proto3" json:"Encry,omitempty"`
	DeletMark  int32         `protobuf:"varint,11,opt,name=DeletMark,proto3" json:"DeletMark,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,12,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetUserMsgHistory) Reset()                    { *m = ReqGetUserMsgHistory{} }
func (m *ReqGetUserMsgHistory) String() string            { return proto.CompactTextString(m) }
func (*ReqGetUserMsgHistory) ProtoMessage()               {}
func (*ReqGetUserMsgHistory) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{11} }

func (m *ReqGetUserMsgHistory) GetSelfid() int32 {
	if m != nil {
		return m.Selfid
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetWithid() int32 {
	if m != nil {
		return m.Withid
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetOffsetId() int32 {
	if m != nil {
		return m.OffsetId
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetOffsetDate() int32 {
	if m != nil {
		return m.OffsetDate
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetAddOffset() int32 {
	if m != nil {
		return m.AddOffset
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetMinId() int32 {
	if m != nil {
		return m.MinId
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetDeletMark() int32 {
	if m != nil {
		return m.DeletMark
	}
	return 0
}

func (m *ReqGetUserMsgHistory) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UserMsgList struct {
	UserMsgs []*pbcomm1.UserMsg `protobuf:"bytes,1,rep,name=UserMsgs" json:"UserMsgs,omitempty"`
	Pts      int32              `protobuf:"varint,2,opt,name=pts,proto3" json:"pts,omitempty"`
}

func (m *UserMsgList) Reset()                    { *m = UserMsgList{} }
func (m *UserMsgList) String() string            { return proto.CompactTextString(m) }
func (*UserMsgList) ProtoMessage()               {}
func (*UserMsgList) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{12} }

func (m *UserMsgList) GetUserMsgs() []*pbcomm1.UserMsg {
	if m != nil {
		return m.UserMsgs
	}
	return nil
}

func (m *UserMsgList) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

type ReqGetUserMsgUUID struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	MsgId  int32         `protobuf:"varint,2,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,3,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetUserMsgUUID) Reset()                    { *m = ReqGetUserMsgUUID{} }
func (m *ReqGetUserMsgUUID) String() string            { return proto.CompactTextString(m) }
func (*ReqGetUserMsgUUID) ProtoMessage()               {}
func (*ReqGetUserMsgUUID) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{13} }

func (m *ReqGetUserMsgUUID) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetUserMsgUUID) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqGetUserMsgUUID) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UUID struct {
	Userid int32 `protobuf:"varint,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	UUID   int64 `protobuf:"varint,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
}

func (m *UUID) Reset()                    { *m = UUID{} }
func (m *UUID) String() string            { return proto.CompactTextString(m) }
func (*UUID) ProtoMessage()               {}
func (*UUID) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{14} }

func (m *UUID) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *UUID) GetUUID() int64 {
	if m != nil {
		return m.UUID
	}
	return 0
}

type ReqGetUserMsgIdByUUID struct {
	Userid int32         `protobuf:"varint,1,opt,name=Userid,proto3" json:"Userid,omitempty"`
	UUID   int64         `protobuf:"varint,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,3,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetUserMsgIdByUUID) Reset()                    { *m = ReqGetUserMsgIdByUUID{} }
func (m *ReqGetUserMsgIdByUUID) String() string            { return proto.CompactTextString(m) }
func (*ReqGetUserMsgIdByUUID) ProtoMessage()               {}
func (*ReqGetUserMsgIdByUUID) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{15} }

func (m *ReqGetUserMsgIdByUUID) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *ReqGetUserMsgIdByUUID) GetUUID() int64 {
	if m != nil {
		return m.UUID
	}
	return 0
}

func (m *ReqGetUserMsgIdByUUID) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type MsgId struct {
	MsgId int32 `protobuf:"varint,1,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
}

func (m *MsgId) Reset()                    { *m = MsgId{} }
func (m *MsgId) String() string            { return proto.CompactTextString(m) }
func (*MsgId) ProtoMessage()               {}
func (*MsgId) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{16} }

func (m *MsgId) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

type ReqGetUserMsgListByUUIDs struct {
	Userid int32         `protobuf:"varint,1,opt,name=userid,proto3" json:"userid,omitempty"`
	UUIDS  []int64       `protobuf:"varint,2,rep,packed,name=UUIDS" json:"UUIDS,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,3,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetUserMsgListByUUIDs) Reset()         { *m = ReqGetUserMsgListByUUIDs{} }
func (m *ReqGetUserMsgListByUUIDs) String() string { return proto.CompactTextString(m) }
func (*ReqGetUserMsgListByUUIDs) ProtoMessage()    {}
func (*ReqGetUserMsgListByUUIDs) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{17}
}

func (m *ReqGetUserMsgListByUUIDs) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

func (m *ReqGetUserMsgListByUUIDs) GetUUIDS() []int64 {
	if m != nil {
		return m.UUIDS
	}
	return nil
}

func (m *ReqGetUserMsgListByUUIDs) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqDeleteUserMsg struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	MsgId  int32         `protobuf:"varint,2,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,3,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqDeleteUserMsg) Reset()                    { *m = ReqDeleteUserMsg{} }
func (m *ReqDeleteUserMsg) String() string            { return proto.CompactTextString(m) }
func (*ReqDeleteUserMsg) ProtoMessage()               {}
func (*ReqDeleteUserMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{18} }

func (m *ReqDeleteUserMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqDeleteUserMsg) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqDeleteUserMsg) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqBatchDeleteUserMsg struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	MsgIds []int32       `protobuf:"varint,3,rep,packed,name=MsgIds" json:"MsgIds,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,4,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqBatchDeleteUserMsg) Reset()                    { *m = ReqBatchDeleteUserMsg{} }
func (m *ReqBatchDeleteUserMsg) String() string            { return proto.CompactTextString(m) }
func (*ReqBatchDeleteUserMsg) ProtoMessage()               {}
func (*ReqBatchDeleteUserMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{19} }

func (m *ReqBatchDeleteUserMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqBatchDeleteUserMsg) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqBatchDeleteUserMsg) GetMsgIds() []int32 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

func (m *ReqBatchDeleteUserMsg) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqGetOneUserMsgByUserIdAndMsgId struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	MsgId  int32         `protobuf:"varint,2,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,3,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetOneUserMsgByUserIdAndMsgId) Reset()         { *m = ReqGetOneUserMsgByUserIdAndMsgId{} }
func (m *ReqGetOneUserMsgByUserIdAndMsgId) String() string { return proto.CompactTextString(m) }
func (*ReqGetOneUserMsgByUserIdAndMsgId) ProtoMessage()    {}
func (*ReqGetOneUserMsgByUserIdAndMsgId) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{20}
}

func (m *ReqGetOneUserMsgByUserIdAndMsgId) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetOneUserMsgByUserIdAndMsgId) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqGetOneUserMsgByUserIdAndMsgId) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqDeleteUserMsgByUserIdAndWithIdAndEncry struct {
	UserId     int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId     int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithIdType int32         `protobuf:"varint,3,opt,name=WithIdType,proto3" json:"WithIdType,omitempty"`
	Encry      int32         `protobuf:"varint,4,opt,name=Encry,proto3" json:"Encry,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,5,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) Reset() {
	*m = ReqDeleteUserMsgByUserIdAndWithIdAndEncry{}
}
func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) String() string {
	return proto.CompactTextString(m)
}
func (*ReqDeleteUserMsgByUserIdAndWithIdAndEncry) ProtoMessage() {}
func (*ReqDeleteUserMsgByUserIdAndWithIdAndEncry) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{21}
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqClearHistory struct {
	UserId     int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId     int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithIdType int32         `protobuf:"varint,3,opt,name=WithIdType,proto3" json:"WithIdType,omitempty"`
	Encry      int32         `protobuf:"varint,4,opt,name=Encry,proto3" json:"Encry,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,5,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqClearHistory) Reset()                    { *m = ReqClearHistory{} }
func (m *ReqClearHistory) String() string            { return proto.CompactTextString(m) }
func (*ReqClearHistory) ProtoMessage()               {}
func (*ReqClearHistory) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{22} }

func (m *ReqClearHistory) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqClearHistory) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqClearHistory) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *ReqClearHistory) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ReqClearHistory) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type MsgIDList struct {
	MsgId     []int32 `protobuf:"varint,1,rep,packed,name=MsgId" json:"MsgId,omitempty"`
	Pts       []int32 `protobuf:"varint,2,rep,packed,name=Pts" json:"Pts,omitempty"`
	LastMsgId int32   `protobuf:"varint,3,opt,name=LastMsgId,proto3" json:"LastMsgId,omitempty"`
	Count     int32   `protobuf:"varint,4,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *MsgIDList) Reset()                    { *m = MsgIDList{} }
func (m *MsgIDList) String() string            { return proto.CompactTextString(m) }
func (*MsgIDList) ProtoMessage()               {}
func (*MsgIDList) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{23} }

func (m *MsgIDList) GetMsgId() []int32 {
	if m != nil {
		return m.MsgId
	}
	return nil
}

func (m *MsgIDList) GetPts() []int32 {
	if m != nil {
		return m.Pts
	}
	return nil
}

func (m *MsgIDList) GetLastMsgId() int32 {
	if m != nil {
		return m.LastMsgId
	}
	return 0
}

func (m *MsgIDList) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// 查询打电话历史消息记录config 当 withid == withtype == 0 时 只搜索userid
type GetMessageHistoryPageByMediaConfig struct {
	UserId   int32   `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId   int32   `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithType int32   `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	MaxId    int32   `protobuf:"varint,4,opt,name=MaxId,proto3" json:"MaxId,omitempty"`
	Encry    int32   `protobuf:"varint,5,opt,name=Encry,proto3" json:"Encry,omitempty"`
	Medias   []int32 `protobuf:"varint,6,rep,packed,name=Medias" json:"Medias,omitempty"`
	Limit    int32   `protobuf:"varint,7,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *GetMessageHistoryPageByMediaConfig) Reset()         { *m = GetMessageHistoryPageByMediaConfig{} }
func (m *GetMessageHistoryPageByMediaConfig) String() string { return proto.CompactTextString(m) }
func (*GetMessageHistoryPageByMediaConfig) ProtoMessage()    {}
func (*GetMessageHistoryPageByMediaConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{24}
}

func (m *GetMessageHistoryPageByMediaConfig) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetMedias() []int32 {
	if m != nil {
		return m.Medias
	}
	return nil
}

func (m *GetMessageHistoryPageByMediaConfig) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ReqGetMessageHistoryPageByMedia struct {
	GetMessageHistoryPageByMediaConfig *GetMessageHistoryPageByMediaConfig `protobuf:"bytes,1,opt,name=GetMessageHistoryPageByMediaConfig" json:"GetMessageHistoryPageByMediaConfig,omitempty"`
	Debug                              *pbcomm.Debug                       `protobuf:"bytes,2,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetMessageHistoryPageByMedia) Reset()         { *m = ReqGetMessageHistoryPageByMedia{} }
func (m *ReqGetMessageHistoryPageByMedia) String() string { return proto.CompactTextString(m) }
func (*ReqGetMessageHistoryPageByMedia) ProtoMessage()    {}
func (*ReqGetMessageHistoryPageByMedia) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{25}
}

func (m *ReqGetMessageHistoryPageByMedia) GetGetMessageHistoryPageByMediaConfig() *GetMessageHistoryPageByMediaConfig {
	if m != nil {
		return m.GetMessageHistoryPageByMediaConfig
	}
	return nil
}

func (m *ReqGetMessageHistoryPageByMedia) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetMessageHistoryPageByMedia struct {
	UserMsgs []*pbcomm1.UserMsg `protobuf:"bytes,1,rep,name=UserMsgs" json:"UserMsgs,omitempty"`
}

func (m *ReplyGetMessageHistoryPageByMedia) Reset()         { *m = ReplyGetMessageHistoryPageByMedia{} }
func (m *ReplyGetMessageHistoryPageByMedia) String() string { return proto.CompactTextString(m) }
func (*ReplyGetMessageHistoryPageByMedia) ProtoMessage()    {}
func (*ReplyGetMessageHistoryPageByMedia) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{26}
}

func (m *ReplyGetMessageHistoryPageByMedia) GetUserMsgs() []*pbcomm1.UserMsg {
	if m != nil {
		return m.UserMsgs
	}
	return nil
}

type ReqGetUserMediaMessageStatisticsByMedia struct {
	UserId   int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId   int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithType int32         `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	Media    int32         `protobuf:"varint,4,opt,name=Media,proto3" json:"Media,omitempty"`
	Debug    *pbcomm.Debug `protobuf:"bytes,5,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) Reset() {
	*m = ReqGetUserMediaMessageStatisticsByMedia{}
}
func (m *ReqGetUserMediaMessageStatisticsByMedia) String() string { return proto.CompactTextString(m) }
func (*ReqGetUserMediaMessageStatisticsByMedia) ProtoMessage()    {}
func (*ReqGetUserMediaMessageStatisticsByMedia) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{27}
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) GetMedia() int32 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UserMediaMessageStatistics struct {
	UserId   int32 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId   int32 `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithType int32 `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	Media    int32 `protobuf:"varint,4,opt,name=Media,proto3" json:"Media,omitempty"`
	Count    int32 `protobuf:"varint,5,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *UserMediaMessageStatistics) Reset()         { *m = UserMediaMessageStatistics{} }
func (m *UserMediaMessageStatistics) String() string { return proto.CompactTextString(m) }
func (*UserMediaMessageStatistics) ProtoMessage()    {}
func (*UserMediaMessageStatistics) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{28}
}

func (m *UserMediaMessageStatistics) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserMediaMessageStatistics) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *UserMediaMessageStatistics) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *UserMediaMessageStatistics) GetMedia() int32 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *UserMediaMessageStatistics) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ReplyGetUserMediaMessageStatisticsByMedia struct {
	UserMediaMessageStatistics *UserMediaMessageStatistics `protobuf:"bytes,1,opt,name=UserMediaMessageStatistics" json:"UserMediaMessageStatistics,omitempty"`
}

func (m *ReplyGetUserMediaMessageStatisticsByMedia) Reset() {
	*m = ReplyGetUserMediaMessageStatisticsByMedia{}
}
func (m *ReplyGetUserMediaMessageStatisticsByMedia) String() string {
	return proto.CompactTextString(m)
}
func (*ReplyGetUserMediaMessageStatisticsByMedia) ProtoMessage() {}
func (*ReplyGetUserMediaMessageStatisticsByMedia) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{29}
}

func (m *ReplyGetUserMediaMessageStatisticsByMedia) GetUserMediaMessageStatistics() *UserMediaMessageStatistics {
	if m != nil {
		return m.UserMediaMessageStatistics
	}
	return nil
}

type ReqGetLastLimitDialog struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Limit  int32         `protobuf:"varint,2,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,3,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetLastLimitDialog) Reset()                    { *m = ReqGetLastLimitDialog{} }
func (m *ReqGetLastLimitDialog) String() string            { return proto.CompactTextString(m) }
func (*ReqGetLastLimitDialog) ProtoMessage()               {}
func (*ReqGetLastLimitDialog) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{30} }

func (m *ReqGetLastLimitDialog) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetLastLimitDialog) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqGetLastLimitDialog) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UserRating struct {
	UserId int32   `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Rating float64 `protobuf:"fixed64,2,opt,name=Rating,proto3" json:"Rating,omitempty"`
}

func (m *UserRating) Reset()                    { *m = UserRating{} }
func (m *UserRating) String() string            { return proto.CompactTextString(m) }
func (*UserRating) ProtoMessage()               {}
func (*UserRating) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{31} }

func (m *UserRating) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserRating) GetRating() float64 {
	if m != nil {
		return m.Rating
	}
	return 0
}

type ReplyGetLastLimitDialog struct {
	UserRatingList []*UserRating `protobuf:"bytes,1,rep,name=UserRatingList" json:"UserRatingList,omitempty"`
}

func (m *ReplyGetLastLimitDialog) Reset()         { *m = ReplyGetLastLimitDialog{} }
func (m *ReplyGetLastLimitDialog) String() string { return proto.CompactTextString(m) }
func (*ReplyGetLastLimitDialog) ProtoMessage()    {}
func (*ReplyGetLastLimitDialog) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{32}
}

func (m *ReplyGetLastLimitDialog) GetUserRatingList() []*UserRating {
	if m != nil {
		return m.UserRatingList
	}
	return nil
}

type ReqGetRandomStatus struct {
	KeyID    uint64        `protobuf:"varint,1,opt,name=KeyID,proto3" json:"KeyID,omitempty"`
	RandomID int64         `protobuf:"varint,2,opt,name=RandomID,proto3" json:"RandomID,omitempty"`
	Debug    *pbcomm.Debug `protobuf:"bytes,4,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetRandomStatus) Reset()                    { *m = ReqGetRandomStatus{} }
func (m *ReqGetRandomStatus) String() string            { return proto.CompactTextString(m) }
func (*ReqGetRandomStatus) ProtoMessage()               {}
func (*ReqGetRandomStatus) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{33} }

func (m *ReqGetRandomStatus) GetKeyID() uint64 {
	if m != nil {
		return m.KeyID
	}
	return 0
}

func (m *ReqGetRandomStatus) GetRandomID() int64 {
	if m != nil {
		return m.RandomID
	}
	return 0
}

func (m *ReqGetRandomStatus) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetRandomStatus struct {
	Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *ReplyGetRandomStatus) Reset()                    { *m = ReplyGetRandomStatus{} }
func (m *ReplyGetRandomStatus) String() string            { return proto.CompactTextString(m) }
func (*ReplyGetRandomStatus) ProtoMessage()               {}
func (*ReplyGetRandomStatus) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{34} }

func (m *ReplyGetRandomStatus) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type ReqSetSuperGroupMsg struct {
	Date   int64         `protobuf:"varint,1,opt,name=Date,proto3" json:"Date,omitempty"`
	Msg    []byte        `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	UserId int32         `protobuf:"varint,3,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,4,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqSetSuperGroupMsg) Reset()                    { *m = ReqSetSuperGroupMsg{} }
func (m *ReqSetSuperGroupMsg) String() string            { return proto.CompactTextString(m) }
func (*ReqSetSuperGroupMsg) ProtoMessage()               {}
func (*ReqSetSuperGroupMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{35} }

func (m *ReqSetSuperGroupMsg) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ReqSetSuperGroupMsg) GetMsg() []byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ReqSetSuperGroupMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqSetSuperGroupMsg) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplySetSuperGroupMsg struct {
}

func (m *ReplySetSuperGroupMsg) Reset()                    { *m = ReplySetSuperGroupMsg{} }
func (m *ReplySetSuperGroupMsg) String() string            { return proto.CompactTextString(m) }
func (*ReplySetSuperGroupMsg) ProtoMessage()               {}
func (*ReplySetSuperGroupMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{36} }

type ReqGetSuperGroupMsg struct {
	Date   int64         `protobuf:"varint,1,opt,name=Date,proto3" json:"Date,omitempty"`
	UserId int32         `protobuf:"varint,2,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Limit  int32         `protobuf:"varint,3,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,4,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqGetSuperGroupMsg) Reset()                    { *m = ReqGetSuperGroupMsg{} }
func (m *ReqGetSuperGroupMsg) String() string            { return proto.CompactTextString(m) }
func (*ReqGetSuperGroupMsg) ProtoMessage()               {}
func (*ReqGetSuperGroupMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{37} }

func (m *ReqGetSuperGroupMsg) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ReqGetSuperGroupMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetSuperGroupMsg) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqGetSuperGroupMsg) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyGetSuperGroupMsg struct {
	Msg    [][]byte `protobuf:"bytes,1,rep,name=Msg" json:"Msg,omitempty"`
	Date   int64    `protobuf:"varint,2,opt,name=Date,proto3" json:"Date,omitempty"`
	GetAll bool     `protobuf:"varint,3,opt,name=GetAll,proto3" json:"GetAll,omitempty"`
}

func (m *ReplyGetSuperGroupMsg) Reset()                    { *m = ReplyGetSuperGroupMsg{} }
func (m *ReplyGetSuperGroupMsg) String() string            { return proto.CompactTextString(m) }
func (*ReplyGetSuperGroupMsg) ProtoMessage()               {}
func (*ReplyGetSuperGroupMsg) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{38} }

func (m *ReplyGetSuperGroupMsg) GetMsg() [][]byte {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *ReplyGetSuperGroupMsg) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ReplyGetSuperGroupMsg) GetGetAll() bool {
	if m != nil {
		return m.GetAll
	}
	return false
}

type ReqUserDialogSetUnreadMetionsCount struct {
	UserId             int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	ChannelID          int32         `protobuf:"varint,2,opt,name=ChannelID,proto3" json:"ChannelID,omitempty"`
	Type               int32         `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	UnreadMetionsCount int32         `protobuf:"varint,4,opt,name=UnreadMetionsCount,proto3" json:"UnreadMetionsCount,omitempty"`
	Debug              *pbcomm.Debug `protobuf:"bytes,5,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqUserDialogSetUnreadMetionsCount) Reset()         { *m = ReqUserDialogSetUnreadMetionsCount{} }
func (m *ReqUserDialogSetUnreadMetionsCount) String() string { return proto.CompactTextString(m) }
func (*ReqUserDialogSetUnreadMetionsCount) ProtoMessage()    {}
func (*ReqUserDialogSetUnreadMetionsCount) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{39}
}

func (m *ReqUserDialogSetUnreadMetionsCount) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUserDialogSetUnreadMetionsCount) GetChannelID() int32 {
	if m != nil {
		return m.ChannelID
	}
	return 0
}

func (m *ReqUserDialogSetUnreadMetionsCount) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ReqUserDialogSetUnreadMetionsCount) GetUnreadMetionsCount() int32 {
	if m != nil {
		return m.UnreadMetionsCount
	}
	return 0
}

func (m *ReqUserDialogSetUnreadMetionsCount) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyUserDialogSetUnreadMetionsCount struct {
	ReplyErr *ReplyErr `protobuf:"bytes,1,opt,name=ReplyErr" json:"ReplyErr,omitempty"`
}

func (m *ReplyUserDialogSetUnreadMetionsCount) Reset()         { *m = ReplyUserDialogSetUnreadMetionsCount{} }
func (m *ReplyUserDialogSetUnreadMetionsCount) String() string { return proto.CompactTextString(m) }
func (*ReplyUserDialogSetUnreadMetionsCount) ProtoMessage()    {}
func (*ReplyUserDialogSetUnreadMetionsCount) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{40}
}

func (m *ReplyUserDialogSetUnreadMetionsCount) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type ReqUserDialogGetUnreadMetionsCount struct {
	UserId    int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	ChannelID int32         `protobuf:"varint,2,opt,name=ChannelID,proto3" json:"ChannelID,omitempty"`
	Type      int32         `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,4,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqUserDialogGetUnreadMetionsCount) Reset()         { *m = ReqUserDialogGetUnreadMetionsCount{} }
func (m *ReqUserDialogGetUnreadMetionsCount) String() string { return proto.CompactTextString(m) }
func (*ReqUserDialogGetUnreadMetionsCount) ProtoMessage()    {}
func (*ReqUserDialogGetUnreadMetionsCount) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{41}
}

func (m *ReqUserDialogGetUnreadMetionsCount) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUserDialogGetUnreadMetionsCount) GetChannelID() int32 {
	if m != nil {
		return m.ChannelID
	}
	return 0
}

func (m *ReqUserDialogGetUnreadMetionsCount) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ReqUserDialogGetUnreadMetionsCount) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyUserDialogGetUnreadMetionsCount struct {
	UnreadMetionsCount int32     `protobuf:"varint,1,opt,name=UnreadMetionsCount,proto3" json:"UnreadMetionsCount,omitempty"`
	ReplyErr           *ReplyErr `protobuf:"bytes,2,opt,name=ReplyErr" json:"ReplyErr,omitempty"`
}

func (m *ReplyUserDialogGetUnreadMetionsCount) Reset()         { *m = ReplyUserDialogGetUnreadMetionsCount{} }
func (m *ReplyUserDialogGetUnreadMetionsCount) String() string { return proto.CompactTextString(m) }
func (*ReplyUserDialogGetUnreadMetionsCount) ProtoMessage()    {}
func (*ReplyUserDialogGetUnreadMetionsCount) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{42}
}

func (m *ReplyUserDialogGetUnreadMetionsCount) GetUnreadMetionsCount() int32 {
	if m != nil {
		return m.UnreadMetionsCount
	}
	return 0
}

func (m *ReplyUserDialogGetUnreadMetionsCount) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type ReqUserDialogChangeUnreadMetionsCount struct {
	UserId                        int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	ChannelID                     int32         `protobuf:"varint,2,opt,name=ChannelID,proto3" json:"ChannelID,omitempty"`
	Type                          int32         `protobuf:"varint,3,opt,name=Type,proto3" json:"Type,omitempty"`
	UnreadMetionsCountChangeValue int32         `protobuf:"varint,4,opt,name=UnreadMetionsCountChangeValue,proto3" json:"UnreadMetionsCountChangeValue,omitempty"`
	Debug                         *pbcomm.Debug `protobuf:"bytes,5,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqUserDialogChangeUnreadMetionsCount) Reset()         { *m = ReqUserDialogChangeUnreadMetionsCount{} }
func (m *ReqUserDialogChangeUnreadMetionsCount) String() string { return proto.CompactTextString(m) }
func (*ReqUserDialogChangeUnreadMetionsCount) ProtoMessage()    {}
func (*ReqUserDialogChangeUnreadMetionsCount) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{43}
}

func (m *ReqUserDialogChangeUnreadMetionsCount) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUserDialogChangeUnreadMetionsCount) GetChannelID() int32 {
	if m != nil {
		return m.ChannelID
	}
	return 0
}

func (m *ReqUserDialogChangeUnreadMetionsCount) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ReqUserDialogChangeUnreadMetionsCount) GetUnreadMetionsCountChangeValue() int32 {
	if m != nil {
		return m.UnreadMetionsCountChangeValue
	}
	return 0
}

func (m *ReqUserDialogChangeUnreadMetionsCount) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyUserDialogChangeUnreadMetionsCount struct {
	ReplyErr *ReplyErr `protobuf:"bytes,1,opt,name=ReplyErr" json:"ReplyErr,omitempty"`
}

func (m *ReplyUserDialogChangeUnreadMetionsCount) Reset() {
	*m = ReplyUserDialogChangeUnreadMetionsCount{}
}
func (m *ReplyUserDialogChangeUnreadMetionsCount) String() string { return proto.CompactTextString(m) }
func (*ReplyUserDialogChangeUnreadMetionsCount) ProtoMessage()    {}
func (*ReplyUserDialogChangeUnreadMetionsCount) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{44}
}

func (m *ReplyUserDialogChangeUnreadMetionsCount) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type ReqUserMessageAtAdd struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	MsgId  int32         `protobuf:"varint,3,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	Encry  int32         `protobuf:"varint,4,opt,name=Encry,proto3" json:"Encry,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,5,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqUserMessageAtAdd) Reset()                    { *m = ReqUserMessageAtAdd{} }
func (m *ReqUserMessageAtAdd) String() string            { return proto.CompactTextString(m) }
func (*ReqUserMessageAtAdd) ProtoMessage()               {}
func (*ReqUserMessageAtAdd) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{45} }

func (m *ReqUserMessageAtAdd) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUserMessageAtAdd) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqUserMessageAtAdd) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqUserMessageAtAdd) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ReqUserMessageAtAdd) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyUserMessageAtAdd struct {
	ReplyErr *ReplyErr `protobuf:"bytes,1,opt,name=ReplyErr" json:"ReplyErr,omitempty"`
}

func (m *ReplyUserMessageAtAdd) Reset()                    { *m = ReplyUserMessageAtAdd{} }
func (m *ReplyUserMessageAtAdd) String() string            { return proto.CompactTextString(m) }
func (*ReplyUserMessageAtAdd) ProtoMessage()               {}
func (*ReplyUserMessageAtAdd) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{46} }

func (m *ReplyUserMessageAtAdd) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type ReqUserMessageAtGet struct {
	UserId    int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId    int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	MsgId     int32         `protobuf:"varint,3,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	AddOffset int32         `protobuf:"varint,4,opt,name=AddOffset,proto3" json:"AddOffset,omitempty"`
	Limit     int32         `protobuf:"varint,5,opt,name=Limit,proto3" json:"Limit,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,6,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqUserMessageAtGet) Reset()                    { *m = ReqUserMessageAtGet{} }
func (m *ReqUserMessageAtGet) String() string            { return proto.CompactTextString(m) }
func (*ReqUserMessageAtGet) ProtoMessage()               {}
func (*ReqUserMessageAtGet) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{47} }

func (m *ReqUserMessageAtGet) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUserMessageAtGet) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqUserMessageAtGet) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqUserMessageAtGet) GetAddOffset() int32 {
	if m != nil {
		return m.AddOffset
	}
	return 0
}

func (m *ReqUserMessageAtGet) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqUserMessageAtGet) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyUserMessageAtGet struct {
	Messages []*pbcomm1.UserMsg `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
	ReplyErr *ReplyErr          `protobuf:"bytes,2,opt,name=ReplyErr" json:"ReplyErr,omitempty"`
}

func (m *ReplyUserMessageAtGet) Reset()                    { *m = ReplyUserMessageAtGet{} }
func (m *ReplyUserMessageAtGet) String() string            { return proto.CompactTextString(m) }
func (*ReplyUserMessageAtGet) ProtoMessage()               {}
func (*ReplyUserMessageAtGet) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{48} }

func (m *ReplyUserMessageAtGet) GetMessages() []*pbcomm1.UserMsg {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *ReplyUserMessageAtGet) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type ReqUserMessageAtDel struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId int32         `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	MsgId  int32         `protobuf:"varint,3,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,4,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *ReqUserMessageAtDel) Reset()                    { *m = ReqUserMessageAtDel{} }
func (m *ReqUserMessageAtDel) String() string            { return proto.CompactTextString(m) }
func (*ReqUserMessageAtDel) ProtoMessage()               {}
func (*ReqUserMessageAtDel) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{49} }

func (m *ReqUserMessageAtDel) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUserMessageAtDel) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqUserMessageAtDel) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ReqUserMessageAtDel) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyUserMessageAtDel struct {
	ReplyErr *ReplyErr `protobuf:"bytes,1,opt,name=ReplyErr" json:"ReplyErr,omitempty"`
}

func (m *ReplyUserMessageAtDel) Reset()                    { *m = ReplyUserMessageAtDel{} }
func (m *ReplyUserMessageAtDel) String() string            { return proto.CompactTextString(m) }
func (*ReplyUserMessageAtDel) ProtoMessage()               {}
func (*ReplyUserMessageAtDel) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{50} }

func (m *ReplyUserMessageAtDel) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

// =================================================== search =======================================================
type ReqUpdateMessageMediaUnread struct {
	UserID int32   `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgIDs []int32 `protobuf:"varint,2,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
	Encry  int32   `protobuf:"varint,3,opt,name=Encry,proto3" json:"Encry,omitempty"`
}

func (m *ReqUpdateMessageMediaUnread) Reset()         { *m = ReqUpdateMessageMediaUnread{} }
func (m *ReqUpdateMessageMediaUnread) String() string { return proto.CompactTextString(m) }
func (*ReqUpdateMessageMediaUnread) ProtoMessage()    {}
func (*ReqUpdateMessageMediaUnread) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{51}
}

func (m *ReqUpdateMessageMediaUnread) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ReqUpdateMessageMediaUnread) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

func (m *ReqUpdateMessageMediaUnread) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

type ReqGetUserMessageByUserIDRandomID struct {
	UserID   int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	RandomID int64 `protobuf:"varint,2,opt,name=RandomID,proto3" json:"RandomID,omitempty"`
	Encry    int32 `protobuf:"varint,3,opt,name=Encry,proto3" json:"Encry,omitempty"`
}

func (m *ReqGetUserMessageByUserIDRandomID) Reset()         { *m = ReqGetUserMessageByUserIDRandomID{} }
func (m *ReqGetUserMessageByUserIDRandomID) String() string { return proto.CompactTextString(m) }
func (*ReqGetUserMessageByUserIDRandomID) ProtoMessage()    {}
func (*ReqGetUserMessageByUserIDRandomID) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{52}
}

func (m *ReqGetUserMessageByUserIDRandomID) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ReqGetUserMessageByUserIDRandomID) GetRandomID() int64 {
	if m != nil {
		return m.RandomID
	}
	return 0
}

func (m *ReqGetUserMessageByUserIDRandomID) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

type ReqSearch struct {
	UserID    int32   `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID    int32   `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType  int32   `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	FromID    int32   `protobuf:"varint,4,opt,name=FromID,proto3" json:"FromID,omitempty"`
	Medias    []int32 `protobuf:"varint,5,rep,packed,name=Medias" json:"Medias,omitempty"`
	OffsetID  int32   `protobuf:"varint,6,opt,name=OffsetID,proto3" json:"OffsetID,omitempty"`
	AddOffset int32   `protobuf:"varint,7,opt,name=AddOffset,proto3" json:"AddOffset,omitempty"`
	Encry     int32   `protobuf:"varint,8,opt,name=Encry,proto3" json:"Encry,omitempty"`
	Limit     int32   `protobuf:"varint,9,opt,name=Limit,proto3" json:"Limit,omitempty"`
	MinDate   int32   `protobuf:"varint,10,opt,name=MinDate,proto3" json:"MinDate,omitempty"`
	MaxDate   int32   `protobuf:"varint,11,opt,name=MaxDate,proto3" json:"MaxDate,omitempty"`
	MinID     int32   `protobuf:"varint,12,opt,name=MinID,proto3" json:"MinID,omitempty"`
	MaxID     int32   `protobuf:"varint,13,opt,name=MaxID,proto3" json:"MaxID,omitempty"`
}

func (m *ReqSearch) Reset()                    { *m = ReqSearch{} }
func (m *ReqSearch) String() string            { return proto.CompactTextString(m) }
func (*ReqSearch) ProtoMessage()               {}
func (*ReqSearch) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{53} }

func (m *ReqSearch) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ReqSearch) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *ReqSearch) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *ReqSearch) GetFromID() int32 {
	if m != nil {
		return m.FromID
	}
	return 0
}

func (m *ReqSearch) GetMedias() []int32 {
	if m != nil {
		return m.Medias
	}
	return nil
}

func (m *ReqSearch) GetOffsetID() int32 {
	if m != nil {
		return m.OffsetID
	}
	return 0
}

func (m *ReqSearch) GetAddOffset() int32 {
	if m != nil {
		return m.AddOffset
	}
	return 0
}

func (m *ReqSearch) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ReqSearch) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqSearch) GetMinDate() int32 {
	if m != nil {
		return m.MinDate
	}
	return 0
}

func (m *ReqSearch) GetMaxDate() int32 {
	if m != nil {
		return m.MaxDate
	}
	return 0
}

func (m *ReqSearch) GetMinID() int32 {
	if m != nil {
		return m.MinID
	}
	return 0
}

func (m *ReqSearch) GetMaxID() int32 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

type ReplySearch struct {
	Messages []*pbcomm1.UserMsg `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *ReplySearch) Reset()                    { *m = ReplySearch{} }
func (m *ReplySearch) String() string            { return proto.CompactTextString(m) }
func (*ReplySearch) ProtoMessage()               {}
func (*ReplySearch) Descriptor() ([]byte, []int) { return fileDescriptorMessagedb, []int{54} }

func (m *ReplySearch) GetMessages() []*pbcomm1.UserMsg {
	if m != nil {
		return m.Messages
	}
	return nil
}

type ReqGetUserMsgByUserIDMsgIDs struct {
	UserID   int32   `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32   `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32   `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	MsgIDs   []int32 `protobuf:"varint,4,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
	Encry    int32   `protobuf:"varint,5,opt,name=Encry,proto3" json:"Encry,omitempty"`
}

func (m *ReqGetUserMsgByUserIDMsgIDs) Reset()         { *m = ReqGetUserMsgByUserIDMsgIDs{} }
func (m *ReqGetUserMsgByUserIDMsgIDs) String() string { return proto.CompactTextString(m) }
func (*ReqGetUserMsgByUserIDMsgIDs) ProtoMessage()    {}
func (*ReqGetUserMsgByUserIDMsgIDs) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{55}
}

func (m *ReqGetUserMsgByUserIDMsgIDs) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ReqGetUserMsgByUserIDMsgIDs) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *ReqGetUserMsgByUserIDMsgIDs) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *ReqGetUserMsgByUserIDMsgIDs) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

func (m *ReqGetUserMsgByUserIDMsgIDs) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

type ReplyGetUserMsgByUserIDMsgIDs struct {
	UserMsgs []*pbcomm1.UserMsg `protobuf:"bytes,1,rep,name=UserMsgs" json:"UserMsgs,omitempty"`
}

func (m *ReplyGetUserMsgByUserIDMsgIDs) Reset()         { *m = ReplyGetUserMsgByUserIDMsgIDs{} }
func (m *ReplyGetUserMsgByUserIDMsgIDs) String() string { return proto.CompactTextString(m) }
func (*ReplyGetUserMsgByUserIDMsgIDs) ProtoMessage()    {}
func (*ReplyGetUserMsgByUserIDMsgIDs) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{56}
}

func (m *ReplyGetUserMsgByUserIDMsgIDs) GetUserMsgs() []*pbcomm1.UserMsg {
	if m != nil {
		return m.UserMsgs
	}
	return nil
}

type ReqGetUserMsgByUserIDMsgIDsHotData struct {
	UserID   int32   `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32   `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32   `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	MsgIDs   []int32 `protobuf:"varint,4,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
	Encry    int32   `protobuf:"varint,5,opt,name=Encry,proto3" json:"Encry,omitempty"`
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) Reset()         { *m = ReqGetUserMsgByUserIDMsgIDsHotData{} }
func (m *ReqGetUserMsgByUserIDMsgIDsHotData) String() string { return proto.CompactTextString(m) }
func (*ReqGetUserMsgByUserIDMsgIDsHotData) ProtoMessage()    {}
func (*ReqGetUserMsgByUserIDMsgIDsHotData) Descriptor() ([]byte, []int) {
	return fileDescriptorMessagedb, []int{57}
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func init() {
	proto.RegisterType((*GetMessageByMsgIDsReq)(nil), "messagedb.GetMessageByMsgIDsReq")
	proto.RegisterType((*GetMessageByMsgIDsResp)(nil), "messagedb.GetMessageByMsgIDsResp")
	proto.RegisterType((*ReplyNull)(nil), "messagedb.ReplyNull")
	proto.RegisterType((*ReplyErr)(nil), "messagedb.ReplyErr")
	proto.RegisterType((*ReqHeartBeating)(nil), "messagedb.ReqHeartBeating")
	proto.RegisterType((*ReplyHeartBeating)(nil), "messagedb.ReplyHeartBeating")
	proto.RegisterType((*ReqInsertOrUpdateUserMsg)(nil), "messagedb.ReqInsertOrUpdateUserMsg")
	proto.RegisterType((*DialogIsCreated)(nil), "messagedb.DialogIsCreated")
	proto.RegisterType((*ReqGetForwardUserMsg)(nil), "messagedb.ReqGetForwardUserMsg")
	proto.RegisterType((*ForWardUserMsg)(nil), "messagedb.ForWardUserMsg")
	proto.RegisterType((*ForWardUserMsgList)(nil), "messagedb.ForWardUserMsgList")
	proto.RegisterType((*ReqGetUserMsgHistory)(nil), "messagedb.ReqGetUserMsgHistory")
	proto.RegisterType((*UserMsgList)(nil), "messagedb.UserMsgList")
	proto.RegisterType((*ReqGetUserMsgUUID)(nil), "messagedb.ReqGetUserMsgUUID")
	proto.RegisterType((*UUID)(nil), "messagedb.UUID")
	proto.RegisterType((*ReqGetUserMsgIdByUUID)(nil), "messagedb.ReqGetUserMsgIdByUUID")
	proto.RegisterType((*MsgId)(nil), "messagedb.MsgId")
	proto.RegisterType((*ReqGetUserMsgListByUUIDs)(nil), "messagedb.ReqGetUserMsgListByUUIDs")
	proto.RegisterType((*ReqDeleteUserMsg)(nil), "messagedb.ReqDeleteUserMsg")
	proto.RegisterType((*ReqBatchDeleteUserMsg)(nil), "messagedb.ReqBatchDeleteUserMsg")
	proto.RegisterType((*ReqGetOneUserMsgByUserIdAndMsgId)(nil), "messagedb.ReqGetOneUserMsgByUserIdAndMsgId")
	proto.RegisterType((*ReqDeleteUserMsgByUserIdAndWithIdAndEncry)(nil), "messagedb.ReqDeleteUserMsgByUserIdAndWithIdAndEncry")
	proto.RegisterType((*ReqClearHistory)(nil), "messagedb.ReqClearHistory")
	proto.RegisterType((*MsgIDList)(nil), "messagedb.MsgIDList")
	proto.RegisterType((*GetMessageHistoryPageByMediaConfig)(nil), "messagedb.GetMessageHistoryPageByMediaConfig")
	proto.RegisterType((*ReqGetMessageHistoryPageByMedia)(nil), "messagedb.ReqGetMessageHistoryPageByMedia")
	proto.RegisterType((*ReplyGetMessageHistoryPageByMedia)(nil), "messagedb.ReplyGetMessageHistoryPageByMedia")
	proto.RegisterType((*ReqGetUserMediaMessageStatisticsByMedia)(nil), "messagedb.ReqGetUserMediaMessageStatisticsByMedia")
	proto.RegisterType((*UserMediaMessageStatistics)(nil), "messagedb.UserMediaMessageStatistics")
	proto.RegisterType((*ReplyGetUserMediaMessageStatisticsByMedia)(nil), "messagedb.ReplyGetUserMediaMessageStatisticsByMedia")
	proto.RegisterType((*ReqGetLastLimitDialog)(nil), "messagedb.ReqGetLastLimitDialog")
	proto.RegisterType((*UserRating)(nil), "messagedb.UserRating")
	proto.RegisterType((*ReplyGetLastLimitDialog)(nil), "messagedb.ReplyGetLastLimitDialog")
	proto.RegisterType((*ReqGetRandomStatus)(nil), "messagedb.ReqGetRandomStatus")
	proto.RegisterType((*ReplyGetRandomStatus)(nil), "messagedb.ReplyGetRandomStatus")
	proto.RegisterType((*ReqSetSuperGroupMsg)(nil), "messagedb.ReqSetSuperGroupMsg")
	proto.RegisterType((*ReplySetSuperGroupMsg)(nil), "messagedb.ReplySetSuperGroupMsg")
	proto.RegisterType((*ReqGetSuperGroupMsg)(nil), "messagedb.ReqGetSuperGroupMsg")
	proto.RegisterType((*ReplyGetSuperGroupMsg)(nil), "messagedb.ReplyGetSuperGroupMsg")
	proto.RegisterType((*ReqUserDialogSetUnreadMetionsCount)(nil), "messagedb.ReqUserDialogSetUnreadMetionsCount")
	proto.RegisterType((*ReplyUserDialogSetUnreadMetionsCount)(nil), "messagedb.ReplyUserDialogSetUnreadMetionsCount")
	proto.RegisterType((*ReqUserDialogGetUnreadMetionsCount)(nil), "messagedb.ReqUserDialogGetUnreadMetionsCount")
	proto.RegisterType((*ReplyUserDialogGetUnreadMetionsCount)(nil), "messagedb.ReplyUserDialogGetUnreadMetionsCount")
	proto.RegisterType((*ReqUserDialogChangeUnreadMetionsCount)(nil), "messagedb.ReqUserDialogChangeUnreadMetionsCount")
	proto.RegisterType((*ReplyUserDialogChangeUnreadMetionsCount)(nil), "messagedb.ReplyUserDialogChangeUnreadMetionsCount")
	proto.RegisterType((*ReqUserMessageAtAdd)(nil), "messagedb.ReqUserMessageAtAdd")
	proto.RegisterType((*ReplyUserMessageAtAdd)(nil), "messagedb.ReplyUserMessageAtAdd")
	proto.RegisterType((*ReqUserMessageAtGet)(nil), "messagedb.ReqUserMessageAtGet")
	proto.RegisterType((*ReplyUserMessageAtGet)(nil), "messagedb.ReplyUserMessageAtGet")
	proto.RegisterType((*ReqUserMessageAtDel)(nil), "messagedb.ReqUserMessageAtDel")
	proto.RegisterType((*ReplyUserMessageAtDel)(nil), "messagedb.ReplyUserMessageAtDel")
	proto.RegisterType((*ReqUpdateMessageMediaUnread)(nil), "messagedb.ReqUpdateMessageMediaUnread")
	proto.RegisterType((*ReqGetUserMessageByUserIDRandomID)(nil), "messagedb.ReqGetUserMessageByUserIDRandomID")
	proto.RegisterType((*ReqSearch)(nil), "messagedb.ReqSearch")
	proto.RegisterType((*ReplySearch)(nil), "messagedb.ReplySearch")
	proto.RegisterType((*ReqGetUserMsgByUserIDMsgIDs)(nil), "messagedb.ReqGetUserMsgByUserIDMsgIDs")
	proto.RegisterType((*ReplyGetUserMsgByUserIDMsgIDs)(nil), "messagedb.ReplyGetUserMsgByUserIDMsgIDs")
	proto.RegisterType((*ReqGetUserMsgByUserIDMsgIDsHotData)(nil), "messagedb.ReqGetUserMsgByUserIDMsgIDsHotData")
	proto.RegisterEnum("messagedb.HeartBeating", HeartBeating_name, HeartBeating_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MessageDb service

type MessageDbClient interface {
	// =========================================== HeartBeating =========================================================
	// HeartBeating
	HeartBeating(ctx context.Context, in *ReqHeartBeating, opts ...grpc.CallOption) (*ReplyHeartBeating, error)
	// =========================================== UserMsg =========================================================
	// 插入单条 usermsg 内容
	InsertOrUpdateUserMsg(ctx context.Context, in *ReqInsertOrUpdateUserMsg, opts ...grpc.CallOption) (*DialogIsCreated, error)
	// 查询转发消息
	GetForwardUserMsg(ctx context.Context, in *ReqGetForwardUserMsg, opts ...grpc.CallOption) (*ForWardUserMsgList, error)
	// 查询历史消息
	GetUserMsgHistory(ctx context.Context, in *ReqGetUserMsgHistory, opts ...grpc.CallOption) (*UserMsgList, error)
	// 查询用户消息UUID
	GetUserMsgUUID(ctx context.Context, in *ReqGetUserMsgUUID, opts ...grpc.CallOption) (*UUID, error)
	// 查询用户消息 通过 UUID
	GetUserMsgIdByUUID(ctx context.Context, in *ReqGetUserMsgIdByUUID, opts ...grpc.CallOption) (*MsgId, error)
	// 获取 消息UUID数组
	GetUserMsgListByUUIDs(ctx context.Context, in *ReqGetUserMsgListByUUIDs, opts ...grpc.CallOption) (*UserMsgList, error)
	// 删除用户信息
	DeleteUserMsg(ctx context.Context, in *ReqDeleteUserMsg, opts ...grpc.CallOption) (*ReplyNull, error)
	// 批量删除用户信息
	BatchDeleteUserMsg(ctx context.Context, in *ReqBatchDeleteUserMsg, opts ...grpc.CallOption) (*ReplyNull, error)
	// 查询一条用户信息通过ID
	GetOneUserMsgByUserIdAndMsgId(ctx context.Context, in *ReqGetOneUserMsgByUserIdAndMsgId, opts ...grpc.CallOption) (*pbcomm1.UserMsg, error)
	// 删除信息
	DeleteUserMsgByUserIdAndWithIdAndEncry(ctx context.Context, in *ReqDeleteUserMsgByUserIdAndWithIdAndEncry, opts ...grpc.CallOption) (*ReplyNull, error)
	// 清除历史  用于清楚历史每次从最底部删除消息 每次删除100条 如果仍然有消息将最新的消息id返回 如没有消息将0返回 count=本次删除的消息条数
	ClearHistory(ctx context.Context, in *ReqClearHistory, opts ...grpc.CallOption) (*MsgIDList, error)
	// 查询打电话消息历史记录
	GetMessageHistoryPageByMedia(ctx context.Context, in *ReqGetMessageHistoryPageByMedia, opts ...grpc.CallOption) (*ReplyGetMessageHistoryPageByMedia, error)
	// =========================================== UserMediaMessageStatistics =========================================================
	// 根据userId、withId、withType、media获取UserMediaMessageStatistics
	GetUserMediaMessageStatisticsByMedia(ctx context.Context, in *ReqGetUserMediaMessageStatisticsByMedia, opts ...grpc.CallOption) (*ReplyGetUserMediaMessageStatisticsByMedia, error)
	// 获取最近操作的对话框 limit 个
	GetLastLimitDialog(ctx context.Context, in *ReqGetLastLimitDialog, opts ...grpc.CallOption) (*ReplyGetLastLimitDialog, error)
	// =========================================== msg_random(发消息去重) =================================================
	// 获取random 状态 如果有则返回true 没有就插入缓存 并且 返回false
	GetRandomStatus(ctx context.Context, in *ReqGetRandomStatus, opts ...grpc.CallOption) (*ReplyGetRandomStatus, error)
	// 设置超级群消息
	SetSuperGroupMsg(ctx context.Context, in *ReqSetSuperGroupMsg, opts ...grpc.CallOption) (*ReplySetSuperGroupMsg, error)
	// 获取超级群消息
	GetSuperGroupMsg(ctx context.Context, in *ReqGetSuperGroupMsg, opts ...grpc.CallOption) (*ReplyGetSuperGroupMsg, error)
	// 设置messagedb.user_dialog.unread_metions_count
	UserDialogSetUnreadMetionsCount(ctx context.Context, in *ReqUserDialogSetUnreadMetionsCount, opts ...grpc.CallOption) (*ReplyUserDialogSetUnreadMetionsCount, error)
	// 获取messagedb.user_dialog.unread_metions_count
	UserDialogGetUnreadMetionsCount(ctx context.Context, in *ReqUserDialogGetUnreadMetionsCount, opts ...grpc.CallOption) (*ReplyUserDialogGetUnreadMetionsCount, error)
	// 改变messagedb.user_dialog.unread_metions_count
	UserDialogChangeUnreadMetionsCount(ctx context.Context, in *ReqUserDialogChangeUnreadMetionsCount, opts ...grpc.CallOption) (*ReplyUserDialogChangeUnreadMetionsCount, error)
	// add for messagedb.user_message_at
	UserMessageAtAdd(ctx context.Context, in *ReqUserMessageAtAdd, opts ...grpc.CallOption) (*ReplyUserMessageAtAdd, error)
	// get for messagedb.user_message_at
	UserMessageAtGet(ctx context.Context, in *ReqUserMessageAtGet, opts ...grpc.CallOption) (*ReplyUserMessageAtGet, error)
	// delete for messagedb.user_message_at
	UserMessageAtDel(ctx context.Context, in *ReqUserMessageAtDel, opts ...grpc.CallOption) (*ReplyUserMessageAtDel, error)
	// GetMessageByMsgIDs 根据 UserID、MsgIDs 查询消息
	GetMessageByMsgIDs(ctx context.Context, in *GetMessageByMsgIDsReq, opts ...grpc.CallOption) (*GetMessageByMsgIDsResp, error)
	// =================================================== search =======================================================
	UpdateMessageMediaUnread(ctx context.Context, in *ReqUpdateMessageMediaUnread, opts ...grpc.CallOption) (*ReplyNull, error)
	GetUserMessageByUserIDRandomID(ctx context.Context, in *ReqGetUserMessageByUserIDRandomID, opts ...grpc.CallOption) (*pbcomm1.UserMsg, error)
	SearchMessage(ctx context.Context, in *ReqSearch, opts ...grpc.CallOption) (*ReplySearch, error)
	GetUserMsgByUserIDMsgIDs(ctx context.Context, in *ReqGetUserMsgByUserIDMsgIDs, opts ...grpc.CallOption) (*ReplyGetUserMsgByUserIDMsgIDs, error)
	GetUserMsgByUserIDMsgIDsHotData(ctx context.Context, in *ReqGetUserMsgByUserIDMsgIDsHotData, opts ...grpc.CallOption) (*ReplyGetUserMsgByUserIDMsgIDs, error)
}

type messageDbClient struct {
	cc *grpc.ClientConn
}

func NewMessageDbClient(cc *grpc.ClientConn) MessageDbClient {
	return &messageDbClient{cc}
}

func (c *messageDbClient) HeartBeating(ctx context.Context, in *ReqHeartBeating, opts ...grpc.CallOption) (*ReplyHeartBeating, error) {
	out := new(ReplyHeartBeating)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/HeartBeating", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) InsertOrUpdateUserMsg(ctx context.Context, in *ReqInsertOrUpdateUserMsg, opts ...grpc.CallOption) (*DialogIsCreated, error) {
	out := new(DialogIsCreated)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/InsertOrUpdateUserMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetForwardUserMsg(ctx context.Context, in *ReqGetForwardUserMsg, opts ...grpc.CallOption) (*ForWardUserMsgList, error) {
	out := new(ForWardUserMsgList)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetForwardUserMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMsgHistory(ctx context.Context, in *ReqGetUserMsgHistory, opts ...grpc.CallOption) (*UserMsgList, error) {
	out := new(UserMsgList)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMsgHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMsgUUID(ctx context.Context, in *ReqGetUserMsgUUID, opts ...grpc.CallOption) (*UUID, error) {
	out := new(UUID)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMsgUUID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMsgIdByUUID(ctx context.Context, in *ReqGetUserMsgIdByUUID, opts ...grpc.CallOption) (*MsgId, error) {
	out := new(MsgId)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMsgIdByUUID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMsgListByUUIDs(ctx context.Context, in *ReqGetUserMsgListByUUIDs, opts ...grpc.CallOption) (*UserMsgList, error) {
	out := new(UserMsgList)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMsgListByUUIDs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) DeleteUserMsg(ctx context.Context, in *ReqDeleteUserMsg, opts ...grpc.CallOption) (*ReplyNull, error) {
	out := new(ReplyNull)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/DeleteUserMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) BatchDeleteUserMsg(ctx context.Context, in *ReqBatchDeleteUserMsg, opts ...grpc.CallOption) (*ReplyNull, error) {
	out := new(ReplyNull)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/BatchDeleteUserMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetOneUserMsgByUserIdAndMsgId(ctx context.Context, in *ReqGetOneUserMsgByUserIdAndMsgId, opts ...grpc.CallOption) (*pbcomm1.UserMsg, error) {
	out := new(pbcomm1.UserMsg)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetOneUserMsgByUserIdAndMsgId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) DeleteUserMsgByUserIdAndWithIdAndEncry(ctx context.Context, in *ReqDeleteUserMsgByUserIdAndWithIdAndEncry, opts ...grpc.CallOption) (*ReplyNull, error) {
	out := new(ReplyNull)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/DeleteUserMsgByUserIdAndWithIdAndEncry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) ClearHistory(ctx context.Context, in *ReqClearHistory, opts ...grpc.CallOption) (*MsgIDList, error) {
	out := new(MsgIDList)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/ClearHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetMessageHistoryPageByMedia(ctx context.Context, in *ReqGetMessageHistoryPageByMedia, opts ...grpc.CallOption) (*ReplyGetMessageHistoryPageByMedia, error) {
	out := new(ReplyGetMessageHistoryPageByMedia)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetMessageHistoryPageByMedia", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMediaMessageStatisticsByMedia(ctx context.Context, in *ReqGetUserMediaMessageStatisticsByMedia, opts ...grpc.CallOption) (*ReplyGetUserMediaMessageStatisticsByMedia, error) {
	out := new(ReplyGetUserMediaMessageStatisticsByMedia)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMediaMessageStatisticsByMedia", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetLastLimitDialog(ctx context.Context, in *ReqGetLastLimitDialog, opts ...grpc.CallOption) (*ReplyGetLastLimitDialog, error) {
	out := new(ReplyGetLastLimitDialog)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetLastLimitDialog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetRandomStatus(ctx context.Context, in *ReqGetRandomStatus, opts ...grpc.CallOption) (*ReplyGetRandomStatus, error) {
	out := new(ReplyGetRandomStatus)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetRandomStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) SetSuperGroupMsg(ctx context.Context, in *ReqSetSuperGroupMsg, opts ...grpc.CallOption) (*ReplySetSuperGroupMsg, error) {
	out := new(ReplySetSuperGroupMsg)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/SetSuperGroupMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetSuperGroupMsg(ctx context.Context, in *ReqGetSuperGroupMsg, opts ...grpc.CallOption) (*ReplyGetSuperGroupMsg, error) {
	out := new(ReplyGetSuperGroupMsg)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetSuperGroupMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) UserDialogSetUnreadMetionsCount(ctx context.Context, in *ReqUserDialogSetUnreadMetionsCount, opts ...grpc.CallOption) (*ReplyUserDialogSetUnreadMetionsCount, error) {
	out := new(ReplyUserDialogSetUnreadMetionsCount)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/UserDialogSetUnreadMetionsCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) UserDialogGetUnreadMetionsCount(ctx context.Context, in *ReqUserDialogGetUnreadMetionsCount, opts ...grpc.CallOption) (*ReplyUserDialogGetUnreadMetionsCount, error) {
	out := new(ReplyUserDialogGetUnreadMetionsCount)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/UserDialogGetUnreadMetionsCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) UserDialogChangeUnreadMetionsCount(ctx context.Context, in *ReqUserDialogChangeUnreadMetionsCount, opts ...grpc.CallOption) (*ReplyUserDialogChangeUnreadMetionsCount, error) {
	out := new(ReplyUserDialogChangeUnreadMetionsCount)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/UserDialogChangeUnreadMetionsCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) UserMessageAtAdd(ctx context.Context, in *ReqUserMessageAtAdd, opts ...grpc.CallOption) (*ReplyUserMessageAtAdd, error) {
	out := new(ReplyUserMessageAtAdd)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/UserMessageAtAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) UserMessageAtGet(ctx context.Context, in *ReqUserMessageAtGet, opts ...grpc.CallOption) (*ReplyUserMessageAtGet, error) {
	out := new(ReplyUserMessageAtGet)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/UserMessageAtGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) UserMessageAtDel(ctx context.Context, in *ReqUserMessageAtDel, opts ...grpc.CallOption) (*ReplyUserMessageAtDel, error) {
	out := new(ReplyUserMessageAtDel)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/UserMessageAtDel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetMessageByMsgIDs(ctx context.Context, in *GetMessageByMsgIDsReq, opts ...grpc.CallOption) (*GetMessageByMsgIDsResp, error) {
	out := new(GetMessageByMsgIDsResp)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetMessageByMsgIDs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) UpdateMessageMediaUnread(ctx context.Context, in *ReqUpdateMessageMediaUnread, opts ...grpc.CallOption) (*ReplyNull, error) {
	out := new(ReplyNull)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/UpdateMessageMediaUnread", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMessageByUserIDRandomID(ctx context.Context, in *ReqGetUserMessageByUserIDRandomID, opts ...grpc.CallOption) (*pbcomm1.UserMsg, error) {
	out := new(pbcomm1.UserMsg)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMessageByUserIDRandomID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) SearchMessage(ctx context.Context, in *ReqSearch, opts ...grpc.CallOption) (*ReplySearch, error) {
	out := new(ReplySearch)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/SearchMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMsgByUserIDMsgIDs(ctx context.Context, in *ReqGetUserMsgByUserIDMsgIDs, opts ...grpc.CallOption) (*ReplyGetUserMsgByUserIDMsgIDs, error) {
	out := new(ReplyGetUserMsgByUserIDMsgIDs)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMsgByUserIDMsgIDs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageDbClient) GetUserMsgByUserIDMsgIDsHotData(ctx context.Context, in *ReqGetUserMsgByUserIDMsgIDsHotData, opts ...grpc.CallOption) (*ReplyGetUserMsgByUserIDMsgIDs, error) {
	out := new(ReplyGetUserMsgByUserIDMsgIDs)
	err := grpc.Invoke(ctx, "/messagedb.MessageDb/GetUserMsgByUserIDMsgIDsHotData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MessageDb service

type MessageDbServer interface {
	// =========================================== HeartBeating =========================================================
	// HeartBeating
	HeartBeating(context.Context, *ReqHeartBeating) (*ReplyHeartBeating, error)
	// =========================================== UserMsg =========================================================
	// 插入单条 usermsg 内容
	InsertOrUpdateUserMsg(context.Context, *ReqInsertOrUpdateUserMsg) (*DialogIsCreated, error)
	// 查询转发消息
	GetForwardUserMsg(context.Context, *ReqGetForwardUserMsg) (*ForWardUserMsgList, error)
	// 查询历史消息
	GetUserMsgHistory(context.Context, *ReqGetUserMsgHistory) (*UserMsgList, error)
	// 查询用户消息UUID
	GetUserMsgUUID(context.Context, *ReqGetUserMsgUUID) (*UUID, error)
	// 查询用户消息 通过 UUID
	GetUserMsgIdByUUID(context.Context, *ReqGetUserMsgIdByUUID) (*MsgId, error)
	// 获取 消息UUID数组
	GetUserMsgListByUUIDs(context.Context, *ReqGetUserMsgListByUUIDs) (*UserMsgList, error)
	// 删除用户信息
	DeleteUserMsg(context.Context, *ReqDeleteUserMsg) (*ReplyNull, error)
	// 批量删除用户信息
	BatchDeleteUserMsg(context.Context, *ReqBatchDeleteUserMsg) (*ReplyNull, error)
	// 查询一条用户信息通过ID
	GetOneUserMsgByUserIdAndMsgId(context.Context, *ReqGetOneUserMsgByUserIdAndMsgId) (*pbcomm1.UserMsg, error)
	// 删除信息
	DeleteUserMsgByUserIdAndWithIdAndEncry(context.Context, *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) (*ReplyNull, error)
	// 清除历史  用于清楚历史每次从最底部删除消息 每次删除100条 如果仍然有消息将最新的消息id返回 如没有消息将0返回 count=本次删除的消息条数
	ClearHistory(context.Context, *ReqClearHistory) (*MsgIDList, error)
	// 查询打电话消息历史记录
	GetMessageHistoryPageByMedia(context.Context, *ReqGetMessageHistoryPageByMedia) (*ReplyGetMessageHistoryPageByMedia, error)
	// =========================================== UserMediaMessageStatistics =========================================================
	// 根据userId、withId、withType、media获取UserMediaMessageStatistics
	GetUserMediaMessageStatisticsByMedia(context.Context, *ReqGetUserMediaMessageStatisticsByMedia) (*ReplyGetUserMediaMessageStatisticsByMedia, error)
	// 获取最近操作的对话框 limit 个
	GetLastLimitDialog(context.Context, *ReqGetLastLimitDialog) (*ReplyGetLastLimitDialog, error)
	// =========================================== msg_random(发消息去重) =================================================
	// 获取random 状态 如果有则返回true 没有就插入缓存 并且 返回false
	GetRandomStatus(context.Context, *ReqGetRandomStatus) (*ReplyGetRandomStatus, error)
	// 设置超级群消息
	SetSuperGroupMsg(context.Context, *ReqSetSuperGroupMsg) (*ReplySetSuperGroupMsg, error)
	// 获取超级群消息
	GetSuperGroupMsg(context.Context, *ReqGetSuperGroupMsg) (*ReplyGetSuperGroupMsg, error)
	// 设置messagedb.user_dialog.unread_metions_count
	UserDialogSetUnreadMetionsCount(context.Context, *ReqUserDialogSetUnreadMetionsCount) (*ReplyUserDialogSetUnreadMetionsCount, error)
	// 获取messagedb.user_dialog.unread_metions_count
	UserDialogGetUnreadMetionsCount(context.Context, *ReqUserDialogGetUnreadMetionsCount) (*ReplyUserDialogGetUnreadMetionsCount, error)
	// 改变messagedb.user_dialog.unread_metions_count
	UserDialogChangeUnreadMetionsCount(context.Context, *ReqUserDialogChangeUnreadMetionsCount) (*ReplyUserDialogChangeUnreadMetionsCount, error)
	// add for messagedb.user_message_at
	UserMessageAtAdd(context.Context, *ReqUserMessageAtAdd) (*ReplyUserMessageAtAdd, error)
	// get for messagedb.user_message_at
	UserMessageAtGet(context.Context, *ReqUserMessageAtGet) (*ReplyUserMessageAtGet, error)
	// delete for messagedb.user_message_at
	UserMessageAtDel(context.Context, *ReqUserMessageAtDel) (*ReplyUserMessageAtDel, error)
	// GetMessageByMsgIDs 根据 UserID、MsgIDs 查询消息
	GetMessageByMsgIDs(context.Context, *GetMessageByMsgIDsReq) (*GetMessageByMsgIDsResp, error)
	// =================================================== search =======================================================
	UpdateMessageMediaUnread(context.Context, *ReqUpdateMessageMediaUnread) (*ReplyNull, error)
	GetUserMessageByUserIDRandomID(context.Context, *ReqGetUserMessageByUserIDRandomID) (*pbcomm1.UserMsg, error)
	SearchMessage(context.Context, *ReqSearch) (*ReplySearch, error)
	GetUserMsgByUserIDMsgIDs(context.Context, *ReqGetUserMsgByUserIDMsgIDs) (*ReplyGetUserMsgByUserIDMsgIDs, error)
	GetUserMsgByUserIDMsgIDsHotData(context.Context, *ReqGetUserMsgByUserIDMsgIDsHotData) (*ReplyGetUserMsgByUserIDMsgIDs, error)
}

func RegisterMessageDbServer(s *grpc.Server, srv MessageDbServer) {
	s.RegisterService(&_MessageDb_serviceDesc, srv)
}

func _MessageDb_HeartBeating_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqHeartBeating)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).HeartBeating(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/HeartBeating",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).HeartBeating(ctx, req.(*ReqHeartBeating))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_InsertOrUpdateUserMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqInsertOrUpdateUserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).InsertOrUpdateUserMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/InsertOrUpdateUserMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).InsertOrUpdateUserMsg(ctx, req.(*ReqInsertOrUpdateUserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetForwardUserMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetForwardUserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetForwardUserMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetForwardUserMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetForwardUserMsg(ctx, req.(*ReqGetForwardUserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMsgHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMsgHistory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMsgHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMsgHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMsgHistory(ctx, req.(*ReqGetUserMsgHistory))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMsgUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMsgUUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMsgUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMsgUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMsgUUID(ctx, req.(*ReqGetUserMsgUUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMsgIdByUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMsgIdByUUID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMsgIdByUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMsgIdByUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMsgIdByUUID(ctx, req.(*ReqGetUserMsgIdByUUID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMsgListByUUIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMsgListByUUIDs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMsgListByUUIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMsgListByUUIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMsgListByUUIDs(ctx, req.(*ReqGetUserMsgListByUUIDs))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_DeleteUserMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqDeleteUserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).DeleteUserMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/DeleteUserMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).DeleteUserMsg(ctx, req.(*ReqDeleteUserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_BatchDeleteUserMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqBatchDeleteUserMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).BatchDeleteUserMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/BatchDeleteUserMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).BatchDeleteUserMsg(ctx, req.(*ReqBatchDeleteUserMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetOneUserMsgByUserIdAndMsgId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetOneUserMsgByUserIdAndMsgId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetOneUserMsgByUserIdAndMsgId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetOneUserMsgByUserIdAndMsgId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetOneUserMsgByUserIdAndMsgId(ctx, req.(*ReqGetOneUserMsgByUserIdAndMsgId))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_DeleteUserMsgByUserIdAndWithIdAndEncry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqDeleteUserMsgByUserIdAndWithIdAndEncry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).DeleteUserMsgByUserIdAndWithIdAndEncry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/DeleteUserMsgByUserIdAndWithIdAndEncry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).DeleteUserMsgByUserIdAndWithIdAndEncry(ctx, req.(*ReqDeleteUserMsgByUserIdAndWithIdAndEncry))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_ClearHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqClearHistory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).ClearHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/ClearHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).ClearHistory(ctx, req.(*ReqClearHistory))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetMessageHistoryPageByMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetMessageHistoryPageByMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetMessageHistoryPageByMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetMessageHistoryPageByMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetMessageHistoryPageByMedia(ctx, req.(*ReqGetMessageHistoryPageByMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMediaMessageStatisticsByMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMediaMessageStatisticsByMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMediaMessageStatisticsByMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMediaMessageStatisticsByMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMediaMessageStatisticsByMedia(ctx, req.(*ReqGetUserMediaMessageStatisticsByMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetLastLimitDialog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetLastLimitDialog)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetLastLimitDialog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetLastLimitDialog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetLastLimitDialog(ctx, req.(*ReqGetLastLimitDialog))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetRandomStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetRandomStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetRandomStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetRandomStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetRandomStatus(ctx, req.(*ReqGetRandomStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_SetSuperGroupMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqSetSuperGroupMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).SetSuperGroupMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/SetSuperGroupMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).SetSuperGroupMsg(ctx, req.(*ReqSetSuperGroupMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetSuperGroupMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetSuperGroupMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetSuperGroupMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetSuperGroupMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetSuperGroupMsg(ctx, req.(*ReqGetSuperGroupMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_UserDialogSetUnreadMetionsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUserDialogSetUnreadMetionsCount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).UserDialogSetUnreadMetionsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/UserDialogSetUnreadMetionsCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).UserDialogSetUnreadMetionsCount(ctx, req.(*ReqUserDialogSetUnreadMetionsCount))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_UserDialogGetUnreadMetionsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUserDialogGetUnreadMetionsCount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).UserDialogGetUnreadMetionsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/UserDialogGetUnreadMetionsCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).UserDialogGetUnreadMetionsCount(ctx, req.(*ReqUserDialogGetUnreadMetionsCount))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_UserDialogChangeUnreadMetionsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUserDialogChangeUnreadMetionsCount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).UserDialogChangeUnreadMetionsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/UserDialogChangeUnreadMetionsCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).UserDialogChangeUnreadMetionsCount(ctx, req.(*ReqUserDialogChangeUnreadMetionsCount))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_UserMessageAtAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUserMessageAtAdd)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).UserMessageAtAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/UserMessageAtAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).UserMessageAtAdd(ctx, req.(*ReqUserMessageAtAdd))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_UserMessageAtGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUserMessageAtGet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).UserMessageAtGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/UserMessageAtGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).UserMessageAtGet(ctx, req.(*ReqUserMessageAtGet))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_UserMessageAtDel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUserMessageAtDel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).UserMessageAtDel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/UserMessageAtDel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).UserMessageAtDel(ctx, req.(*ReqUserMessageAtDel))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetMessageByMsgIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessageByMsgIDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetMessageByMsgIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetMessageByMsgIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetMessageByMsgIDs(ctx, req.(*GetMessageByMsgIDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_UpdateMessageMediaUnread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUpdateMessageMediaUnread)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).UpdateMessageMediaUnread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/UpdateMessageMediaUnread",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).UpdateMessageMediaUnread(ctx, req.(*ReqUpdateMessageMediaUnread))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMessageByUserIDRandomID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMessageByUserIDRandomID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMessageByUserIDRandomID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMessageByUserIDRandomID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMessageByUserIDRandomID(ctx, req.(*ReqGetUserMessageByUserIDRandomID))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_SearchMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqSearch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).SearchMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/SearchMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).SearchMessage(ctx, req.(*ReqSearch))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMsgByUserIDMsgIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMsgByUserIDMsgIDs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMsgByUserIDMsgIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMsgByUserIDMsgIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMsgByUserIDMsgIDs(ctx, req.(*ReqGetUserMsgByUserIDMsgIDs))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageDb_GetUserMsgByUserIDMsgIDsHotData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserMsgByUserIDMsgIDsHotData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageDbServer).GetUserMsgByUserIDMsgIDsHotData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedb.MessageDb/GetUserMsgByUserIDMsgIDsHotData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageDbServer).GetUserMsgByUserIDMsgIDsHotData(ctx, req.(*ReqGetUserMsgByUserIDMsgIDsHotData))
	}
	return interceptor(ctx, in, info, handler)
}

var _MessageDb_serviceDesc = grpc.ServiceDesc{
	ServiceName: "messagedb.MessageDb",
	HandlerType: (*MessageDbServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HeartBeating",
			Handler:    _MessageDb_HeartBeating_Handler,
		},
		{
			MethodName: "InsertOrUpdateUserMsg",
			Handler:    _MessageDb_InsertOrUpdateUserMsg_Handler,
		},
		{
			MethodName: "GetForwardUserMsg",
			Handler:    _MessageDb_GetForwardUserMsg_Handler,
		},
		{
			MethodName: "GetUserMsgHistory",
			Handler:    _MessageDb_GetUserMsgHistory_Handler,
		},
		{
			MethodName: "GetUserMsgUUID",
			Handler:    _MessageDb_GetUserMsgUUID_Handler,
		},
		{
			MethodName: "GetUserMsgIdByUUID",
			Handler:    _MessageDb_GetUserMsgIdByUUID_Handler,
		},
		{
			MethodName: "GetUserMsgListByUUIDs",
			Handler:    _MessageDb_GetUserMsgListByUUIDs_Handler,
		},
		{
			MethodName: "DeleteUserMsg",
			Handler:    _MessageDb_DeleteUserMsg_Handler,
		},
		{
			MethodName: "BatchDeleteUserMsg",
			Handler:    _MessageDb_BatchDeleteUserMsg_Handler,
		},
		{
			MethodName: "GetOneUserMsgByUserIdAndMsgId",
			Handler:    _MessageDb_GetOneUserMsgByUserIdAndMsgId_Handler,
		},
		{
			MethodName: "DeleteUserMsgByUserIdAndWithIdAndEncry",
			Handler:    _MessageDb_DeleteUserMsgByUserIdAndWithIdAndEncry_Handler,
		},
		{
			MethodName: "ClearHistory",
			Handler:    _MessageDb_ClearHistory_Handler,
		},
		{
			MethodName: "GetMessageHistoryPageByMedia",
			Handler:    _MessageDb_GetMessageHistoryPageByMedia_Handler,
		},
		{
			MethodName: "GetUserMediaMessageStatisticsByMedia",
			Handler:    _MessageDb_GetUserMediaMessageStatisticsByMedia_Handler,
		},
		{
			MethodName: "GetLastLimitDialog",
			Handler:    _MessageDb_GetLastLimitDialog_Handler,
		},
		{
			MethodName: "GetRandomStatus",
			Handler:    _MessageDb_GetRandomStatus_Handler,
		},
		{
			MethodName: "SetSuperGroupMsg",
			Handler:    _MessageDb_SetSuperGroupMsg_Handler,
		},
		{
			MethodName: "GetSuperGroupMsg",
			Handler:    _MessageDb_GetSuperGroupMsg_Handler,
		},
		{
			MethodName: "UserDialogSetUnreadMetionsCount",
			Handler:    _MessageDb_UserDialogSetUnreadMetionsCount_Handler,
		},
		{
			MethodName: "UserDialogGetUnreadMetionsCount",
			Handler:    _MessageDb_UserDialogGetUnreadMetionsCount_Handler,
		},
		{
			MethodName: "UserDialogChangeUnreadMetionsCount",
			Handler:    _MessageDb_UserDialogChangeUnreadMetionsCount_Handler,
		},
		{
			MethodName: "UserMessageAtAdd",
			Handler:    _MessageDb_UserMessageAtAdd_Handler,
		},
		{
			MethodName: "UserMessageAtGet",
			Handler:    _MessageDb_UserMessageAtGet_Handler,
		},
		{
			MethodName: "UserMessageAtDel",
			Handler:    _MessageDb_UserMessageAtDel_Handler,
		},
		{
			MethodName: "GetMessageByMsgIDs",
			Handler:    _MessageDb_GetMessageByMsgIDs_Handler,
		},
		{
			MethodName: "UpdateMessageMediaUnread",
			Handler:    _MessageDb_UpdateMessageMediaUnread_Handler,
		},
		{
			MethodName: "GetUserMessageByUserIDRandomID",
			Handler:    _MessageDb_GetUserMessageByUserIDRandomID_Handler,
		},
		{
			MethodName: "SearchMessage",
			Handler:    _MessageDb_SearchMessage_Handler,
		},
		{
			MethodName: "GetUserMsgByUserIDMsgIDs",
			Handler:    _MessageDb_GetUserMsgByUserIDMsgIDs_Handler,
		},
		{
			MethodName: "GetUserMsgByUserIDMsgIDsHotData",
			Handler:    _MessageDb_GetUserMsgByUserIDMsgIDsHotData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/messagedb/messagedb.proto",
}

func (m *GetMessageByMsgIDsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessageByMsgIDsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserID))
	}
	if len(m.MsgIDs) > 0 {
		dAtA2 := make([]byte, len(m.MsgIDs)*10)
		var j1 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *GetMessageByMsgIDsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessageByMsgIDsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplyNull) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyNull) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReplyErr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyErr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrMsg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(len(m.ErrMsg)))
		i += copy(dAtA[i:], m.ErrMsg)
	}
	return i, nil
}

func (m *ReqHeartBeating) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqHeartBeating) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Type))
	}
	if m.Identification != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Identification))
	}
	return i, nil
}

func (m *ReplyHeartBeating) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyHeartBeating) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Type))
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *ReqInsertOrUpdateUserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqInsertOrUpdateUserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMsg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserMsg.Size()))
		n3, err := m.UserMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n4, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *DialogIsCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DialogIsCreated) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DialogIdCreated {
		dAtA[i] = 0x8
		i++
		if m.DialogIdCreated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReqGetForwardUserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetForwardUserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithIdType))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if len(m.MsgIds) > 0 {
		dAtA6 := make([]byte, len(m.MsgIds)*10)
		var j5 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n7, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *ForWardUserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForWardUserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Date))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Media != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Media))
	}
	if len(m.MediaData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(len(m.MediaData)))
		i += copy(dAtA[i:], m.MediaData)
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.FromId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.FromId))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if len(m.FwdFrom) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(len(m.FwdFrom)))
		i += copy(dAtA[i:], m.FwdFrom)
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.GroupId))
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ViaBotId))
	}
	if m.MsgID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgID))
	}
	return i, nil
}

func (m *ForWardUserMsgList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForWardUserMsgList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ForWardUserMsg) > 0 {
		for _, msg := range m.ForWardUserMsg {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqGetUserMsgHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMsgHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Selfid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Selfid))
	}
	if m.Withid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Withid))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Type))
	}
	if m.OffsetId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.OffsetId))
	}
	if m.OffsetDate != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.OffsetDate))
	}
	if m.AddOffset != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.AddOffset))
	}
	if m.MinId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MinId))
	}
	if m.MaxId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MaxId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Limit))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if m.DeletMark != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.DeletMark))
	}
	if m.Debug != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n8, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *UserMsgList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMsgList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, msg := range m.UserMsgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Pts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Pts))
	}
	return i, nil
}

func (m *ReqGetUserMsgUUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMsgUUID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n9, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *UUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UUID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Userid))
	}
	if m.UUID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UUID))
	}
	return i, nil
}

func (m *ReqGetUserMsgIdByUUID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMsgIdByUUID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Userid))
	}
	if m.UUID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UUID))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n10, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *MsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgId))
	}
	return i, nil
}

func (m *ReqGetUserMsgListByUUIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMsgListByUUIDs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Userid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Userid))
	}
	if len(m.UUIDS) > 0 {
		dAtA12 := make([]byte, len(m.UUIDS)*10)
		var j11 int
		for _, num1 := range m.UUIDS {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n13, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ReqDeleteUserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDeleteUserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n14, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *ReqBatchDeleteUserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqBatchDeleteUserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if len(m.MsgIds) > 0 {
		dAtA16 := make([]byte, len(m.MsgIds)*10)
		var j15 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n17, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *ReqGetOneUserMsgByUserIdAndMsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetOneUserMsgByUserIdAndMsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n18, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithIdType))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n19, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *ReqClearHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqClearHistory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithIdType))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n20, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *MsgIDList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgIDList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MsgId) > 0 {
		dAtA22 := make([]byte, len(m.MsgId)*10)
		var j21 int
		for _, num1 := range m.MsgId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	if len(m.Pts) > 0 {
		dAtA24 := make([]byte, len(m.Pts)*10)
		var j23 int
		for _, num1 := range m.Pts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j23))
		i += copy(dAtA[i:], dAtA24[:j23])
	}
	if m.LastMsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.LastMsgId))
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *GetMessageHistoryPageByMediaConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessageHistoryPageByMediaConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithType))
	}
	if m.MaxId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MaxId))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if len(m.Medias) > 0 {
		dAtA26 := make([]byte, len(m.Medias)*10)
		var j25 int
		for _, num1 := range m.Medias {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	if m.Limit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *ReqGetMessageHistoryPageByMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetMessageHistoryPageByMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GetMessageHistoryPageByMediaConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.GetMessageHistoryPageByMediaConfig.Size()))
		n27, err := m.GetMessageHistoryPageByMediaConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n28, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *ReplyGetMessageHistoryPageByMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetMessageHistoryPageByMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, msg := range m.UserMsgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithType))
	}
	if m.Media != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Media))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n29, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *UserMediaMessageStatistics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMediaMessageStatistics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithType))
	}
	if m.Media != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Media))
	}
	if m.Count != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *ReplyGetUserMediaMessageStatisticsByMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetUserMediaMessageStatisticsByMedia) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMediaMessageStatistics != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserMediaMessageStatistics.Size()))
		n30, err := m.UserMediaMessageStatistics.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *ReqGetLastLimitDialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetLastLimitDialog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Limit))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n31, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *UserRating) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRating) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.Rating != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Messagedb(dAtA, i, uint64(math.Float64bits(float64(m.Rating))))
	}
	return i, nil
}

func (m *ReplyGetLastLimitDialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetLastLimitDialog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserRatingList) > 0 {
		for _, msg := range m.UserRatingList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqGetRandomStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetRandomStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.KeyID))
	}
	if m.RandomID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.RandomID))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n32, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *ReplyGetRandomStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetRandomStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status {
		dAtA[i] = 0x8
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReqSetSuperGroupMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetSuperGroupMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Date))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n33, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *ReplySetSuperGroupMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplySetSuperGroupMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReqGetSuperGroupMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetSuperGroupMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Date))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Limit))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n34, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *ReplyGetSuperGroupMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetSuperGroupMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, b := range m.Msg {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Date != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Date))
	}
	if m.GetAll {
		dAtA[i] = 0x18
		i++
		if m.GetAll {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReqUserDialogSetUnreadMetionsCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUserDialogSetUnreadMetionsCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.ChannelID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ChannelID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Type))
	}
	if m.UnreadMetionsCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UnreadMetionsCount))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n35, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	return i, nil
}

func (m *ReplyUserDialogSetUnreadMetionsCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyUserDialogSetUnreadMetionsCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyErr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ReplyErr.Size()))
		n36, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *ReqUserDialogGetUnreadMetionsCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUserDialogGetUnreadMetionsCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.ChannelID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ChannelID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Type))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n37, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *ReplyUserDialogGetUnreadMetionsCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyUserDialogGetUnreadMetionsCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UnreadMetionsCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UnreadMetionsCount))
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ReplyErr.Size()))
		n38, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func (m *ReqUserDialogChangeUnreadMetionsCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUserDialogChangeUnreadMetionsCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.ChannelID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ChannelID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Type))
	}
	if m.UnreadMetionsCountChangeValue != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UnreadMetionsCountChangeValue))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n39, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *ReplyUserDialogChangeUnreadMetionsCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyUserDialogChangeUnreadMetionsCount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyErr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ReplyErr.Size()))
		n40, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *ReqUserMessageAtAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUserMessageAtAdd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgId))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n41, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *ReplyUserMessageAtAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyUserMessageAtAdd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyErr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ReplyErr.Size()))
		n42, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *ReqUserMessageAtGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUserMessageAtGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgId))
	}
	if m.AddOffset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.AddOffset))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Limit))
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n43, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *ReplyUserMessageAtGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyUserMessageAtGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ReplyErr.Size()))
		n44, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	return i, nil
}

func (m *ReqUserMessageAtDel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUserMessageAtDel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MsgId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Debug.Size()))
		n45, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	return i, nil
}

func (m *ReplyUserMessageAtDel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyUserMessageAtDel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyErr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.ReplyErr.Size()))
		n46, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}

func (m *ReqUpdateMessageMediaUnread) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateMessageMediaUnread) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserID))
	}
	if len(m.MsgIDs) > 0 {
		dAtA48 := make([]byte, len(m.MsgIDs)*10)
		var j47 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j47))
		i += copy(dAtA[i:], dAtA48[:j47])
	}
	if m.Encry != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	return i, nil
}

func (m *ReqGetUserMessageByUserIDRandomID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMessageByUserIDRandomID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserID))
	}
	if m.RandomID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.RandomID))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	return i, nil
}

func (m *ReqSearch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSearch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithType))
	}
	if m.FromID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.FromID))
	}
	if len(m.Medias) > 0 {
		dAtA50 := make([]byte, len(m.Medias)*10)
		var j49 int
		for _, num1 := range m.Medias {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j49))
		i += copy(dAtA[i:], dAtA50[:j49])
	}
	if m.OffsetID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.OffsetID))
	}
	if m.AddOffset != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.AddOffset))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Limit))
	}
	if m.MinDate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MaxDate))
	}
	if m.MinID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MinID))
	}
	if m.MaxID != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.MaxID))
	}
	return i, nil
}

func (m *ReplySearch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplySearch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqGetUserMsgByUserIDMsgIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMsgByUserIDMsgIDs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		dAtA52 := make([]byte, len(m.MsgIDs)*10)
		var j51 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j51))
		i += copy(dAtA[i:], dAtA52[:j51])
	}
	if m.Encry != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	return i, nil
}

func (m *ReplyGetUserMsgByUserIDMsgIDs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetUserMsgByUserIDMsgIDs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, msg := range m.UserMsgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMessagedb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		dAtA54 := make([]byte, len(m.MsgIDs)*10)
		var j53 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(j53))
		i += copy(dAtA[i:], dAtA54[:j53])
	}
	if m.Encry != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMessagedb(dAtA, i, uint64(m.Encry))
	}
	return i, nil
}

func encodeFixed64Messagedb(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Messagedb(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMessagedb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetMessageByMsgIDsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMessagedb(uint64(m.UserID))
	}
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	return n
}

func (m *GetMessageByMsgIDsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	return n
}

func (m *ReplyNull) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReplyErr) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovMessagedb(uint64(m.ErrCode))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqHeartBeating) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessagedb(uint64(m.Type))
	}
	if m.Identification != 0 {
		n += 1 + sovMessagedb(uint64(m.Identification))
	}
	return n
}

func (m *ReplyHeartBeating) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessagedb(uint64(m.Type))
	}
	if m.Result != 0 {
		n += 1 + sovMessagedb(uint64(m.Result))
	}
	return n
}

func (m *ReqInsertOrUpdateUserMsg) Size() (n int) {
	var l int
	_ = l
	if m.UserMsg != nil {
		l = m.UserMsg.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *DialogIsCreated) Size() (n int) {
	var l int
	_ = l
	if m.DialogIdCreated {
		n += 2
	}
	return n
}

func (m *ReqGetForwardUserMsg) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithIdType))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ForWardUserMsg) Size() (n int) {
	var l int
	_ = l
	if m.Date != 0 {
		n += 1 + sovMessagedb(uint64(m.Date))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessagedb(uint64(l))
	}
	if m.Media != 0 {
		n += 1 + sovMessagedb(uint64(m.Media))
	}
	l = len(m.MediaData)
	if l > 0 {
		n += 1 + l + sovMessagedb(uint64(l))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 1 + l + sovMessagedb(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			l = len(b)
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	if m.FromId != 0 {
		n += 1 + sovMessagedb(uint64(m.FromId))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	l = len(m.FwdFrom)
	if l > 0 {
		n += 1 + l + sovMessagedb(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovMessagedb(uint64(m.GroupId))
	}
	if m.ViaBotId != 0 {
		n += 1 + sovMessagedb(uint64(m.ViaBotId))
	}
	if m.MsgID != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgID))
	}
	return n
}

func (m *ForWardUserMsgList) Size() (n int) {
	var l int
	_ = l
	if len(m.ForWardUserMsg) > 0 {
		for _, e := range m.ForWardUserMsg {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	return n
}

func (m *ReqGetUserMsgHistory) Size() (n int) {
	var l int
	_ = l
	if m.Selfid != 0 {
		n += 1 + sovMessagedb(uint64(m.Selfid))
	}
	if m.Withid != 0 {
		n += 1 + sovMessagedb(uint64(m.Withid))
	}
	if m.Type != 0 {
		n += 1 + sovMessagedb(uint64(m.Type))
	}
	if m.OffsetId != 0 {
		n += 1 + sovMessagedb(uint64(m.OffsetId))
	}
	if m.OffsetDate != 0 {
		n += 1 + sovMessagedb(uint64(m.OffsetDate))
	}
	if m.AddOffset != 0 {
		n += 1 + sovMessagedb(uint64(m.AddOffset))
	}
	if m.MinId != 0 {
		n += 1 + sovMessagedb(uint64(m.MinId))
	}
	if m.MaxId != 0 {
		n += 1 + sovMessagedb(uint64(m.MaxId))
	}
	if m.Limit != 0 {
		n += 1 + sovMessagedb(uint64(m.Limit))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	if m.DeletMark != 0 {
		n += 1 + sovMessagedb(uint64(m.DeletMark))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *UserMsgList) Size() (n int) {
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, e := range m.UserMsgs {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	if m.Pts != 0 {
		n += 1 + sovMessagedb(uint64(m.Pts))
	}
	return n
}

func (m *ReqGetUserMsgUUID) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.MsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *UUID) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovMessagedb(uint64(m.Userid))
	}
	if m.UUID != 0 {
		n += 1 + sovMessagedb(uint64(m.UUID))
	}
	return n
}

func (m *ReqGetUserMsgIdByUUID) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovMessagedb(uint64(m.Userid))
	}
	if m.UUID != 0 {
		n += 1 + sovMessagedb(uint64(m.UUID))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *MsgId) Size() (n int) {
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgId))
	}
	return n
}

func (m *ReqGetUserMsgListByUUIDs) Size() (n int) {
	var l int
	_ = l
	if m.Userid != 0 {
		n += 1 + sovMessagedb(uint64(m.Userid))
	}
	if len(m.UUIDS) > 0 {
		l = 0
		for _, e := range m.UUIDS {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqDeleteUserMsg) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.MsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqBatchDeleteUserMsg) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqGetOneUserMsgByUserIdAndMsgId) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.MsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithIdType))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqClearHistory) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithIdType))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *MsgIDList) Size() (n int) {
	var l int
	_ = l
	if len(m.MsgId) > 0 {
		l = 0
		for _, e := range m.MsgId {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if len(m.Pts) > 0 {
		l = 0
		for _, e := range m.Pts {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.LastMsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.LastMsgId))
	}
	if m.Count != 0 {
		n += 1 + sovMessagedb(uint64(m.Count))
	}
	return n
}

func (m *GetMessageHistoryPageByMediaConfig) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.WithType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithType))
	}
	if m.MaxId != 0 {
		n += 1 + sovMessagedb(uint64(m.MaxId))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	if len(m.Medias) > 0 {
		l = 0
		for _, e := range m.Medias {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.Limit != 0 {
		n += 1 + sovMessagedb(uint64(m.Limit))
	}
	return n
}

func (m *ReqGetMessageHistoryPageByMedia) Size() (n int) {
	var l int
	_ = l
	if m.GetMessageHistoryPageByMediaConfig != nil {
		l = m.GetMessageHistoryPageByMediaConfig.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyGetMessageHistoryPageByMedia) Size() (n int) {
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, e := range m.UserMsgs {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	return n
}

func (m *ReqGetUserMediaMessageStatisticsByMedia) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.WithType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithType))
	}
	if m.Media != 0 {
		n += 1 + sovMessagedb(uint64(m.Media))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *UserMediaMessageStatistics) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.WithType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithType))
	}
	if m.Media != 0 {
		n += 1 + sovMessagedb(uint64(m.Media))
	}
	if m.Count != 0 {
		n += 1 + sovMessagedb(uint64(m.Count))
	}
	return n
}

func (m *ReplyGetUserMediaMessageStatisticsByMedia) Size() (n int) {
	var l int
	_ = l
	if m.UserMediaMessageStatistics != nil {
		l = m.UserMediaMessageStatistics.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqGetLastLimitDialog) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.Limit != 0 {
		n += 1 + sovMessagedb(uint64(m.Limit))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *UserRating) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.Rating != 0 {
		n += 9
	}
	return n
}

func (m *ReplyGetLastLimitDialog) Size() (n int) {
	var l int
	_ = l
	if len(m.UserRatingList) > 0 {
		for _, e := range m.UserRatingList {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	return n
}

func (m *ReqGetRandomStatus) Size() (n int) {
	var l int
	_ = l
	if m.KeyID != 0 {
		n += 1 + sovMessagedb(uint64(m.KeyID))
	}
	if m.RandomID != 0 {
		n += 1 + sovMessagedb(uint64(m.RandomID))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyGetRandomStatus) Size() (n int) {
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *ReqSetSuperGroupMsg) Size() (n int) {
	var l int
	_ = l
	if m.Date != 0 {
		n += 1 + sovMessagedb(uint64(m.Date))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovMessagedb(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplySetSuperGroupMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReqGetSuperGroupMsg) Size() (n int) {
	var l int
	_ = l
	if m.Date != 0 {
		n += 1 + sovMessagedb(uint64(m.Date))
	}
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.Limit != 0 {
		n += 1 + sovMessagedb(uint64(m.Limit))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyGetSuperGroupMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for _, b := range m.Msg {
			l = len(b)
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	if m.Date != 0 {
		n += 1 + sovMessagedb(uint64(m.Date))
	}
	if m.GetAll {
		n += 2
	}
	return n
}

func (m *ReqUserDialogSetUnreadMetionsCount) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.ChannelID != 0 {
		n += 1 + sovMessagedb(uint64(m.ChannelID))
	}
	if m.Type != 0 {
		n += 1 + sovMessagedb(uint64(m.Type))
	}
	if m.UnreadMetionsCount != 0 {
		n += 1 + sovMessagedb(uint64(m.UnreadMetionsCount))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyUserDialogSetUnreadMetionsCount) Size() (n int) {
	var l int
	_ = l
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqUserDialogGetUnreadMetionsCount) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.ChannelID != 0 {
		n += 1 + sovMessagedb(uint64(m.ChannelID))
	}
	if m.Type != 0 {
		n += 1 + sovMessagedb(uint64(m.Type))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyUserDialogGetUnreadMetionsCount) Size() (n int) {
	var l int
	_ = l
	if m.UnreadMetionsCount != 0 {
		n += 1 + sovMessagedb(uint64(m.UnreadMetionsCount))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqUserDialogChangeUnreadMetionsCount) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.ChannelID != 0 {
		n += 1 + sovMessagedb(uint64(m.ChannelID))
	}
	if m.Type != 0 {
		n += 1 + sovMessagedb(uint64(m.Type))
	}
	if m.UnreadMetionsCountChangeValue != 0 {
		n += 1 + sovMessagedb(uint64(m.UnreadMetionsCountChangeValue))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyUserDialogChangeUnreadMetionsCount) Size() (n int) {
	var l int
	_ = l
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqUserMessageAtAdd) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.MsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgId))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyUserMessageAtAdd) Size() (n int) {
	var l int
	_ = l
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqUserMessageAtGet) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.MsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgId))
	}
	if m.AddOffset != 0 {
		n += 1 + sovMessagedb(uint64(m.AddOffset))
	}
	if m.Limit != 0 {
		n += 1 + sovMessagedb(uint64(m.Limit))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyUserMessageAtGet) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqUserMessageAtDel) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovMessagedb(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovMessagedb(uint64(m.WithId))
	}
	if m.MsgId != 0 {
		n += 1 + sovMessagedb(uint64(m.MsgId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReplyUserMessageAtDel) Size() (n int) {
	var l int
	_ = l
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovMessagedb(uint64(l))
	}
	return n
}

func (m *ReqUpdateMessageMediaUnread) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMessagedb(uint64(m.UserID))
	}
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	return n
}

func (m *ReqGetUserMessageByUserIDRandomID) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMessagedb(uint64(m.UserID))
	}
	if m.RandomID != 0 {
		n += 1 + sovMessagedb(uint64(m.RandomID))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	return n
}

func (m *ReqSearch) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMessagedb(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovMessagedb(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithType))
	}
	if m.FromID != 0 {
		n += 1 + sovMessagedb(uint64(m.FromID))
	}
	if len(m.Medias) > 0 {
		l = 0
		for _, e := range m.Medias {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.OffsetID != 0 {
		n += 1 + sovMessagedb(uint64(m.OffsetID))
	}
	if m.AddOffset != 0 {
		n += 1 + sovMessagedb(uint64(m.AddOffset))
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	if m.Limit != 0 {
		n += 1 + sovMessagedb(uint64(m.Limit))
	}
	if m.MinDate != 0 {
		n += 1 + sovMessagedb(uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		n += 1 + sovMessagedb(uint64(m.MaxDate))
	}
	if m.MinID != 0 {
		n += 1 + sovMessagedb(uint64(m.MinID))
	}
	if m.MaxID != 0 {
		n += 1 + sovMessagedb(uint64(m.MaxID))
	}
	return n
}

func (m *ReplySearch) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	return n
}

func (m *ReqGetUserMsgByUserIDMsgIDs) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMessagedb(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovMessagedb(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	return n
}

func (m *ReplyGetUserMsgByUserIDMsgIDs) Size() (n int) {
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, e := range m.UserMsgs {
			l = e.Size()
			n += 1 + l + sovMessagedb(uint64(l))
		}
	}
	return n
}

func (m *ReqGetUserMsgByUserIDMsgIDsHotData) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMessagedb(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovMessagedb(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovMessagedb(uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovMessagedb(uint64(e))
		}
		n += 1 + sovMessagedb(uint64(l)) + l
	}
	if m.Encry != 0 {
		n += 1 + sovMessagedb(uint64(m.Encry))
	}
	return n
}

func sovMessagedb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessagedb(x uint64) (n int) {
	return sovMessagedb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetMessageByMsgIDsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessageByMsgIDsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessageByMsgIDsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMessageByMsgIDsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessageByMsgIDsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessageByMsgIDsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &pbcomm1.UserMsg{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyNull) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyNull: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyNull: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyErr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyErr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyErr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqHeartBeating) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqHeartBeating: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqHeartBeating: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (HeartBeating(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identification", wireType)
			}
			m.Identification = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Identification |= (HeartBeating(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyHeartBeating) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyHeartBeating: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyHeartBeating: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (HeartBeating(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (HeartBeating(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqInsertOrUpdateUserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqInsertOrUpdateUserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqInsertOrUpdateUserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMsg == nil {
				m.UserMsg = &pbcomm1.UserMsg{}
			}
			if err := m.UserMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DialogIsCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DialogIsCreated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DialogIsCreated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialogIdCreated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DialogIdCreated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetForwardUserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetForwardUserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetForwardUserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForWardUserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForWardUserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForWardUserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaData = append(m.MediaData[:0], dAtA[iNdEx:postIndex]...)
			if m.MediaData == nil {
				m.MediaData = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, make([]byte, postIndex-iNdEx))
			copy(m.Entities[len(m.Entities)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdFrom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwdFrom = append(m.FwdFrom[:0], dAtA[iNdEx:postIndex]...)
			if m.FwdFrom == nil {
				m.FwdFrom = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForWardUserMsgList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForWardUserMsgList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForWardUserMsgList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForWardUserMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ForWardUserMsg = append(m.ForWardUserMsg, &ForWardUserMsg{})
			if err := m.ForWardUserMsg[len(m.ForWardUserMsg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMsgHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMsgHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMsgHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selfid", wireType)
			}
			m.Selfid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Selfid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Withid", wireType)
			}
			m.Withid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Withid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetId", wireType)
			}
			m.OffsetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetDate", wireType)
			}
			m.OffsetDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOffset", wireType)
			}
			m.AddOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinId", wireType)
			}
			m.MinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletMark", wireType)
			}
			m.DeletMark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletMark |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMsgList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMsgList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMsgList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMsgs = append(m.UserMsgs, &pbcomm1.UserMsg{})
			if err := m.UserMsgs[len(m.UserMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMsgUUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMsgUUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMsgUUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			m.UUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMsgIdByUUID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMsgIdByUUID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMsgIdByUUID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			m.UUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMsgListByUUIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMsgListByUUIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMsgListByUUIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UUIDS = append(m.UUIDS, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UUIDS = append(m.UUIDS, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UUIDS", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDeleteUserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDeleteUserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDeleteUserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqBatchDeleteUserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqBatchDeleteUserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqBatchDeleteUserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetOneUserMsgByUserIdAndMsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetOneUserMsgByUserIdAndMsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetOneUserMsgByUserIdAndMsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDeleteUserMsgByUserIdAndWithIdAndEncry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDeleteUserMsgByUserIdAndWithIdAndEncry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDeleteUserMsgByUserIdAndWithIdAndEncry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqClearHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqClearHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqClearHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgIDList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgIDList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgIDList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgId = append(m.MsgId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgId = append(m.MsgId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Pts = append(m.Pts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Pts = append(m.Pts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMsgId", wireType)
			}
			m.LastMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMessageHistoryPageByMediaConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessageHistoryPageByMediaConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessageHistoryPageByMediaConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medias = append(m.Medias, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medias = append(m.Medias, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetMessageHistoryPageByMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetMessageHistoryPageByMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetMessageHistoryPageByMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetMessageHistoryPageByMediaConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetMessageHistoryPageByMediaConfig == nil {
				m.GetMessageHistoryPageByMediaConfig = &GetMessageHistoryPageByMediaConfig{}
			}
			if err := m.GetMessageHistoryPageByMediaConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetMessageHistoryPageByMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetMessageHistoryPageByMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetMessageHistoryPageByMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMsgs = append(m.UserMsgs, &pbcomm1.UserMsg{})
			if err := m.UserMsgs[len(m.UserMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMediaMessageStatisticsByMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMediaMessageStatisticsByMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMediaMessageStatisticsByMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMediaMessageStatistics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMediaMessageStatistics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMediaMessageStatistics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetUserMediaMessageStatisticsByMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetUserMediaMessageStatisticsByMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetUserMediaMessageStatisticsByMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMediaMessageStatistics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMediaMessageStatistics == nil {
				m.UserMediaMessageStatistics = &UserMediaMessageStatistics{}
			}
			if err := m.UserMediaMessageStatistics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetLastLimitDialog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetLastLimitDialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetLastLimitDialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRating) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRating: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRating: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rating", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Rating = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetLastLimitDialog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetLastLimitDialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetLastLimitDialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserRatingList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserRatingList = append(m.UserRatingList, &UserRating{})
			if err := m.UserRatingList[len(m.UserRatingList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetRandomStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetRandomStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetRandomStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
			m.KeyID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomID", wireType)
			}
			m.RandomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetRandomStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetRandomStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetRandomStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetSuperGroupMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetSuperGroupMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetSuperGroupMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplySetSuperGroupMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplySetSuperGroupMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplySetSuperGroupMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetSuperGroupMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetSuperGroupMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetSuperGroupMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetSuperGroupMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetSuperGroupMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetSuperGroupMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg, make([]byte, postIndex-iNdEx))
			copy(m.Msg[len(m.Msg)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetAll = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUserDialogSetUnreadMetionsCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUserDialogSetUnreadMetionsCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUserDialogSetUnreadMetionsCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			m.ChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadMetionsCount", wireType)
			}
			m.UnreadMetionsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadMetionsCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyUserDialogSetUnreadMetionsCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyUserDialogSetUnreadMetionsCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyUserDialogSetUnreadMetionsCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUserDialogGetUnreadMetionsCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUserDialogGetUnreadMetionsCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUserDialogGetUnreadMetionsCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			m.ChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyUserDialogGetUnreadMetionsCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyUserDialogGetUnreadMetionsCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyUserDialogGetUnreadMetionsCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadMetionsCount", wireType)
			}
			m.UnreadMetionsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadMetionsCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUserDialogChangeUnreadMetionsCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUserDialogChangeUnreadMetionsCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUserDialogChangeUnreadMetionsCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			m.ChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadMetionsCountChangeValue", wireType)
			}
			m.UnreadMetionsCountChangeValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadMetionsCountChangeValue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyUserDialogChangeUnreadMetionsCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyUserDialogChangeUnreadMetionsCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyUserDialogChangeUnreadMetionsCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUserMessageAtAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUserMessageAtAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUserMessageAtAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyUserMessageAtAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyUserMessageAtAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyUserMessageAtAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUserMessageAtGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUserMessageAtGet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUserMessageAtGet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOffset", wireType)
			}
			m.AddOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyUserMessageAtGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyUserMessageAtGet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyUserMessageAtGet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &pbcomm1.UserMsg{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUserMessageAtDel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUserMessageAtDel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUserMessageAtDel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyUserMessageAtDel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyUserMessageAtDel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyUserMessageAtDel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateMessageMediaUnread) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateMessageMediaUnread: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateMessageMediaUnread: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMessageByUserIDRandomID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMessageByUserIDRandomID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMessageByUserIDRandomID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomID", wireType)
			}
			m.RandomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSearch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSearch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSearch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromID", wireType)
			}
			m.FromID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medias = append(m.Medias, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medias = append(m.Medias, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetID", wireType)
			}
			m.OffsetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOffset", wireType)
			}
			m.AddOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDate", wireType)
			}
			m.MinDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDate", wireType)
			}
			m.MaxDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinID", wireType)
			}
			m.MinID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplySearch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplySearch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplySearch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &pbcomm1.UserMsg{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMsgByUserIDMsgIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMsgByUserIDMsgIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMsgByUserIDMsgIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetUserMsgByUserIDMsgIDs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetUserMsgByUserIDMsgIDs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetUserMsgByUserIDMsgIDs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessagedb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMsgs = append(m.UserMsgs, &pbcomm1.UserMsg{})
			if err := m.UserMsgs[len(m.UserMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserMsgByUserIDMsgIDsHotData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserMsgByUserIDMsgIDsHotData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserMsgByUserIDMsgIDsHotData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMessagedb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMessagedb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessagedb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessagedb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessagedb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessagedb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessagedb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessagedb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessagedb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessagedb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessagedb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessagedb   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/messagedb/messagedb.proto", fileDescriptorMessagedb)
}

var fileDescriptorMessagedb = []byte{
	// 2411 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x1a, 0x4d, 0x6f, 0x24, 0x47,
	0x75, 0x7a, 0xda, 0x63, 0x7b, 0x9e, 0xed, 0xf5, 0x6c, 0x65, 0x3f, 0x9a, 0x8e, 0xbf, 0x52, 0x9b,
	0x2c, 0x4e, 0x36, 0x6b, 0x23, 0x93, 0x03, 0x1f, 0x81, 0xc8, 0x76, 0x7b, 0x67, 0x27, 0xd8, 0xd9,
	0x55, 0x1b, 0xef, 0xa2, 0x80, 0x84, 0xda, 0xd3, 0xe5, 0x71, 0x67, 0x67, 0x7a, 0xc6, 0xdd, 0x35,
	0xc9, 0x1a, 0x05, 0x81, 0x04, 0x12, 0x17, 0x4e, 0x01, 0xc1, 0x05, 0xf1, 0x1b, 0x38, 0x20, 0x24,
	0xce, 0x80, 0x84, 0x90, 0x10, 0x9c, 0x38, 0x71, 0x40, 0xfb, 0x4b, 0x50, 0x7d, 0xf4, 0xf7, 0xc7,
	0xf4, 0x90, 0xdd, 0x90, 0xd3, 0xf4, 0xab, 0x7a, 0xfd, 0xbe, 0xeb, 0xd5, 0x7b, 0xaf, 0x07, 0xbe,
	0xd9, 0x73, 0x68, 0xdf, 0x3a, 0xdd, 0xea, 0x9e, 0x5b, 0xd4, 0x27, 0xde, 0x87, 0xc4, 0xdb, 0x72,
	0x06, 0xdb, 0x8e, 0x4b, 0x89, 0x77, 0x66, 0x75, 0xc9, 0xc8, 0x1b, 0x9e, 0x8e, 0xcf, 0xb6, 0x07,
	0xc4, 0xf7, 0xad, 0x1e, 0xb1, 0x4f, 0xa3, 0xa7, 0xad, 0x91, 0x37, 0xa4, 0x43, 0xd4, 0x0c, 0x17,
	0xf4, 0xaf, 0x54, 0x22, 0x35, 0x3a, 0xed, 0x0e, 0x07, 0x03, 0xf9, 0x23, 0x88, 0xe8, 0x5f, 0x9d,
	0xe6, 0xcd, 0xb1, 0x4f, 0xbc, 0x81, 0xdf, 0x13, 0xaf, 0xe2, 0x36, 0x5c, 0x6f, 0x13, 0x7a, 0x24,
	0x84, 0xd8, 0xbb, 0x3c, 0xf2, 0x7b, 0x1d, 0xc3, 0x37, 0xc9, 0x05, 0xba, 0x01, 0xb3, 0x27, 0x3e,
	0xf1, 0x3a, 0x86, 0xa6, 0x6c, 0x28, 0x9b, 0x0d, 0x53, 0x42, 0x6c, 0x5d, 0x20, 0x69, 0xf5, 0x0d,
	0x95, 0xad, 0x0b, 0x08, 0x1f, 0xc0, 0x8d, 0x3c, 0x42, 0xfe, 0x08, 0xdd, 0x81, 0x79, 0xb9, 0xec,
	0x6b, 0xca, 0x86, 0xba, 0xb9, 0xb0, 0xb3, 0xbc, 0x25, 0xc5, 0x67, 0x34, 0x8f, 0xfc, 0x9e, 0x19,
	0x22, 0xe0, 0x05, 0x68, 0x9a, 0x64, 0xd4, 0xbf, 0x7c, 0x6f, 0xdc, 0xef, 0xe3, 0xb7, 0x61, 0x9e,
	0x03, 0x07, 0x9e, 0x87, 0x34, 0x98, 0x3b, 0xf0, 0xbc, 0xfd, 0xa1, 0x4d, 0xb8, 0x40, 0x4b, 0x66,
	0x00, 0x32, 0x89, 0x0e, 0x3c, 0x46, 0x46, 0xab, 0x6f, 0x28, 0x9b, 0x4d, 0x53, 0x42, 0xf8, 0x47,
	0xb0, 0x6c, 0x92, 0x8b, 0xfb, 0xc4, 0xf2, 0xe8, 0x1e, 0xb1, 0xa8, 0xe3, 0xf6, 0xd0, 0x1d, 0x98,
	0xf9, 0xf6, 0xe5, 0x48, 0x50, 0xb8, 0xb2, 0x73, 0x73, 0x2b, 0xf2, 0x46, 0x1c, 0xcd, 0xe4, 0x48,
	0xe8, 0x1d, 0xb8, 0xd2, 0xb1, 0x89, 0x4b, 0x9d, 0x33, 0xa7, 0x6b, 0x51, 0x67, 0xe8, 0x72, 0xfa,
	0x25, 0xaf, 0xa5, 0xd0, 0xf1, 0x05, 0x5c, 0xe5, 0xe2, 0xff, 0xef, 0x22, 0x6c, 0xc3, 0xac, 0x49,
	0xfc, 0x71, 0x9f, 0x4e, 0x62, 0x2d, 0xd1, 0xf0, 0x07, 0xa0, 0x99, 0xe4, 0xa2, 0xe3, 0xfa, 0xc4,
	0xa3, 0x0f, 0xbc, 0x93, 0x91, 0x6d, 0x51, 0x22, 0x8d, 0x8c, 0x5e, 0x87, 0x39, 0xf9, 0xc8, 0x99,
	0xe7, 0xb8, 0x21, 0xd8, 0x47, 0xb7, 0xa0, 0x61, 0x90, 0xd3, 0xb1, 0xb0, 0xe8, 0xc2, 0xce, 0x52,
	0x80, 0xc8, 0x17, 0x4d, 0xb1, 0x87, 0xbf, 0x0e, 0xcb, 0x86, 0x63, 0xf5, 0x87, 0xbd, 0x8e, 0xbf,
	0xef, 0x11, 0x8b, 0x12, 0x1b, 0x6d, 0x86, 0x4b, 0xb6, 0x5c, 0xe2, 0xac, 0xe6, 0xcd, 0xf4, 0x32,
	0xfe, 0xa3, 0x02, 0xd7, 0x4c, 0x72, 0xd1, 0x26, 0xf4, 0xde, 0xd0, 0xfb, 0xc8, 0xf2, 0xec, 0x80,
	0x75, 0x10, 0x77, 0x76, 0x22, 0xee, 0x6c, 0xb6, 0xfe, 0xd8, 0xa1, 0xe7, 0x1d, 0x9b, 0xcb, 0xd4,
	0x30, 0x25, 0x84, 0xd6, 0x00, 0xc4, 0x13, 0xb7, 0xaa, 0xca, 0xf7, 0x62, 0x2b, 0xe8, 0x1a, 0x34,
	0x0e, 0xdc, 0xae, 0x77, 0xa9, 0xcd, 0xf0, 0x2d, 0x01, 0x04, 0x51, 0x6c, 0xfb, 0x5a, 0x23, 0x8a,
	0x62, 0xdb, 0x8f, 0x14, 0x5f, 0x28, 0x51, 0xfc, 0xcf, 0x75, 0xb8, 0x72, 0x6f, 0xe8, 0x3d, 0x8e,
	0x49, 0x8d, 0x60, 0xc6, 0xb0, 0x28, 0x91, 0x32, 0xf3, 0x67, 0x16, 0xb1, 0x32, 0xac, 0x65, 0x60,
	0x06, 0x20, 0x93, 0xe9, 0x88, 0xd8, 0x8e, 0xc5, 0xc5, 0x55, 0x4d, 0x01, 0xa0, 0x15, 0x68, 0xf2,
	0x07, 0xc3, 0xa2, 0x16, 0x97, 0x76, 0xd1, 0x8c, 0x16, 0xd0, 0x06, 0x2c, 0xf0, 0x60, 0x3a, 0xb2,
	0xbc, 0x27, 0xe3, 0x91, 0xd6, 0xe0, 0xfb, 0xf1, 0x25, 0xa4, 0xc3, 0xfc, 0x81, 0x4b, 0x1d, 0xea,
	0x10, 0x5f, 0x9b, 0xdd, 0x50, 0x37, 0x17, 0xcd, 0x10, 0x66, 0xfa, 0xde, 0xf3, 0x86, 0x83, 0x8e,
	0xad, 0xcd, 0x09, 0xeb, 0x09, 0x28, 0xb2, 0xce, 0x7c, 0xdc, 0x3a, 0x1a, 0xcc, 0xdd, 0xfb, 0xc8,
	0x66, 0x28, 0x5a, 0x93, 0xf3, 0x09, 0x40, 0xb6, 0xd3, 0xf6, 0x86, 0xe3, 0x51, 0xc7, 0xd6, 0x80,
	0xcb, 0x1e, 0x80, 0x8c, 0xfb, 0x23, 0xc7, 0xda, 0x1b, 0xd2, 0x8e, 0xcd, 0x8d, 0xd7, 0x30, 0x43,
	0x98, 0xeb, 0xcb, 0xf2, 0x81, 0xb6, 0x28, 0xb8, 0x70, 0x00, 0x3f, 0x06, 0x94, 0xb4, 0xe2, 0xa1,
	0xe3, 0x53, 0xb4, 0x9b, 0xb6, 0xad, 0xcc, 0x19, 0x5f, 0x88, 0x85, 0x7e, 0x12, 0xc1, 0x4c, 0xbd,
	0x80, 0xff, 0x51, 0x0f, 0x62, 0x4b, 0xae, 0xdc, 0x77, 0x7c, 0x3a, 0x14, 0x5e, 0x3f, 0x26, 0xfd,
	0x33, 0x27, 0x8c, 0x2d, 0x01, 0x05, 0xb1, 0xe5, 0x24, 0x62, 0xcb, 0xb1, 0x99, 0x57, 0x63, 0x51,
	0x25, 0x8e, 0xa4, 0x0e, 0xf3, 0x0f, 0xce, 0xce, 0x7c, 0xc2, 0xf4, 0x14, 0x21, 0x15, 0xc2, 0x2c,
	0x16, 0xc5, 0x33, 0x8f, 0x85, 0x86, 0x88, 0xc5, 0x68, 0x85, 0x79, 0x78, 0xd7, 0xb6, 0xc5, 0x82,
	0x36, 0xcb, 0xb7, 0xa3, 0x05, 0x6e, 0x25, 0xc7, 0x0d, 0x5d, 0x24, 0x00, 0xbe, 0x6a, 0x3d, 0xed,
	0xd8, 0x81, 0x87, 0x38, 0xc0, 0x56, 0x0f, 0x9d, 0x81, 0x43, 0xb9, 0x7f, 0x1a, 0xa6, 0x00, 0x22,
	0x6f, 0x42, 0xdc, 0x9b, 0x2b, 0xd0, 0x34, 0x48, 0x9f, 0x50, 0x16, 0x26, 0xd2, 0x35, 0xd1, 0x42,
	0x14, 0xf1, 0x8b, 0x25, 0x11, 0x7f, 0x08, 0x0b, 0x71, 0x1f, 0xdd, 0x81, 0x79, 0x09, 0x16, 0x67,
	0xf4, 0x00, 0x01, 0xb5, 0x40, 0x1d, 0x51, 0x5f, 0x5a, 0x96, 0x3d, 0xe2, 0x33, 0x96, 0x17, 0x63,
	0xee, 0x39, 0x39, 0x11, 0xf7, 0x4a, 0xee, 0xb9, 0x97, 0xb1, 0x13, 0xb8, 0x46, 0x00, 0x91, 0xd4,
	0x6a, 0x89, 0xd4, 0x3b, 0x30, 0x13, 0x27, 0xed, 0x24, 0x48, 0x0b, 0xf7, 0xb2, 0x7d, 0x4e, 0x59,
	0x35, 0xf9, 0x33, 0x3e, 0x87, 0xeb, 0x09, 0xd9, 0x3a, 0xf6, 0xde, 0xe5, 0xb4, 0x44, 0xaa, 0x49,
	0xb7, 0x2a, 0x15, 0x8b, 0x34, 0x54, 0x62, 0x1a, 0xe2, 0x01, 0xcf, 0xe4, 0x91, 0x20, 0xcc, 0xf0,
	0x42, 0x14, 0x7e, 0x9a, 0xc7, 0x09, 0x59, 0x04, 0xc4, 0x28, 0x31, 0x84, 0x63, 0x7e, 0x35, 0xab,
	0xa6, 0x00, 0xaa, 0x49, 0x43, 0xa0, 0x65, 0x92, 0x0b, 0x1e, 0x16, 0x64, 0x52, 0x2a, 0xfe, 0x14,
	0x2e, 0xf9, 0xa9, 0xc2, 0xed, 0xbb, 0x67, 0xd1, 0xee, 0x79, 0x35, 0x66, 0x45, 0x79, 0x3f, 0xca,
	0xe0, 0x6a, 0x7e, 0x06, 0x9f, 0x29, 0x11, 0x63, 0x0c, 0x1b, 0xc2, 0xb8, 0x0f, 0xdc, 0x40, 0x80,
	0xbd, 0x4b, 0xc1, 0x70, 0xd7, 0xb5, 0x85, 0x3e, 0x2f, 0x40, 0xfb, 0x3f, 0x28, 0xf0, 0x7a, 0xda,
	0xca, 0x31, 0xbe, 0x42, 0xb3, 0x5d, 0xd7, 0x0e, 0xef, 0xa8, 0xcf, 0xe0, 0x26, 0x0c, 0x05, 0x6f,
	0x94, 0x08, 0xfe, 0x1b, 0x85, 0xd7, 0x52, 0xfb, 0x7d, 0x62, 0x79, 0xb1, 0x64, 0xfa, 0x79, 0x11,
	0xaf, 0x07, 0x4d, 0x7e, 0xa5, 0xf0, 0xe4, 0x14, 0x3b, 0x4e, 0x6a, 0xe4, 0x9f, 0x16, 0xa8, 0x0f,
	0x69, 0x50, 0xb3, 0xb2, 0x47, 0x96, 0x16, 0x0f, 0x2d, 0x9f, 0x0a, 0x5c, 0x21, 0x4e, 0xb4, 0xc0,
	0xa8, 0xec, 0x0f, 0xc7, 0x2e, 0x0d, 0xa4, 0xe1, 0x00, 0xfe, 0x9b, 0x02, 0x38, 0xaa, 0x72, 0xa5,
	0x25, 0x1e, 0x8a, 0x82, 0x97, 0xdd, 0xd4, 0xfb, 0x43, 0xf7, 0xcc, 0x99, 0x3e, 0x96, 0x75, 0x98,
	0x67, 0x4f, 0x31, 0xc3, 0x84, 0x70, 0x94, 0xff, 0x67, 0x52, 0xf9, 0x5f, 0x18, 0xab, 0x91, 0xae,
	0x6a, 0x98, 0x18, 0xe2, 0xfe, 0x67, 0x67, 0x82, 0x43, 0xd1, 0x6d, 0x31, 0x17, 0xbb, 0x2d, 0xf0,
	0x5f, 0x14, 0x58, 0x17, 0xa7, 0xa0, 0x50, 0x1f, 0xf4, 0xc3, 0x2a, 0xfa, 0xca, 0x72, 0xf2, 0x6e,
	0xec, 0x86, 0x9e, 0xfc, 0x92, 0x59, 0xc5, 0x90, 0x95, 0xea, 0xd0, 0x87, 0xf0, 0x0a, 0x2f, 0x83,
	0x4a, 0x15, 0x99, 0xe6, 0xca, 0xc2, 0xbf, 0x53, 0xe0, 0x8b, 0xb1, 0xe4, 0xcb, 0x08, 0x48, 0xca,
	0xc7, 0xd4, 0xa2, 0x8e, 0x4f, 0x9d, 0xae, 0x1f, 0x10, 0x7e, 0xde, 0xbe, 0xe6, 0x75, 0x61, 0xe0,
	0x6b, 0xce, 0xa1, 0xd2, 0x11, 0xf8, 0xa5, 0x02, 0x7a, 0xb1, 0xb0, 0x9f, 0x81, 0x94, 0xe1, 0x81,
	0x69, 0xc4, 0x0f, 0xcc, 0x27, 0x3c, 0xe3, 0x09, 0xe7, 0x4c, 0xb6, 0x25, 0x29, 0xd3, 0x41, 0x46,
	0xd9, 0x6b, 0xb1, 0x28, 0x2b, 0x46, 0x36, 0x4b, 0x08, 0xe1, 0x0f, 0x82, 0x3b, 0x9e, 0x1d, 0x77,
	0x7e, 0x16, 0x44, 0x77, 0x52, 0x96, 0xf2, 0xc5, 0xf9, 0xa9, 0xc7, 0xab, 0xad, 0x4a, 0x29, 0xff,
	0x6d, 0x00, 0x46, 0xc4, 0x14, 0xcd, 0x5f, 0x89, 0x1b, 0x04, 0x06, 0xe7, 0xa0, 0x98, 0x12, 0xc2,
	0xdf, 0x81, 0x9b, 0x81, 0xf5, 0xd2, 0xb2, 0x7e, 0x03, 0xae, 0x44, 0x84, 0x59, 0xe2, 0x93, 0x61,
	0x7d, 0x3d, 0x65, 0x1f, 0x53, 0xf6, 0xa6, 0x49, 0x64, 0xfc, 0x04, 0x90, 0xb0, 0x81, 0x69, 0xb9,
	0xf6, 0x70, 0xc0, 0xac, 0x33, 0xe6, 0x89, 0xe2, 0x5b, 0xe4, 0x52, 0xf6, 0xfc, 0x33, 0xa6, 0x00,
	0x58, 0x30, 0x08, 0xac, 0xb0, 0xcc, 0x09, 0xe1, 0x6a, 0xd7, 0xed, 0x16, 0xab, 0xc7, 0x85, 0x1a,
	0x09, 0x76, 0x37, 0x60, 0xd6, 0xe7, 0x4f, 0xb2, 0x4b, 0x94, 0x10, 0x7e, 0x0a, 0x2f, 0x99, 0xe4,
	0xe2, 0x98, 0xd0, 0xe3, 0xf1, 0x88, 0x78, 0xbc, 0xc3, 0x48, 0x37, 0x59, 0xaa, 0x6c, 0xb2, 0x5a,
	0xa0, 0x06, 0x9d, 0xff, 0xa2, 0xa9, 0x26, 0x0b, 0x09, 0x35, 0x61, 0xe3, 0x4a, 0x92, 0xde, 0x64,
	0xa1, 0x31, 0xea, 0x5f, 0xa6, 0x79, 0xe3, 0x8f, 0xb9, 0x48, 0xed, 0x2a, 0x22, 0x45, 0x02, 0xd4,
	0xf3, 0xa3, 0x48, 0xcd, 0x8d, 0xa2, 0x32, 0xb1, 0x4e, 0xa4, 0x58, 0x19, 0xfe, 0x52, 0x7d, 0x85,
	0xb7, 0x7b, 0x6a, 0x5c, 0xa2, 0x7a, 0x52, 0xa2, 0x36, 0xa1, 0xbb, 0xfd, 0x3e, 0x67, 0x3d, 0x6f,
	0x4a, 0x08, 0xff, 0x49, 0x01, 0x6c, 0x92, 0x0b, 0x26, 0x9f, 0x88, 0xaa, 0x63, 0x42, 0x4f, 0x5c,
	0x8f, 0x58, 0xf6, 0x11, 0xa1, 0xce, 0xd0, 0xf5, 0xf9, 0x21, 0x2e, 0x8c, 0xda, 0x15, 0x68, 0xee,
	0x9f, 0x5b, 0xae, 0x4b, 0xfa, 0x32, 0x30, 0x1a, 0x66, 0xb4, 0x90, 0xdb, 0x3c, 0x6d, 0x01, 0xca,
	0xd2, 0x97, 0x79, 0x24, 0x67, 0xa7, 0x5a, 0xea, 0x7b, 0x0c, 0xaf, 0x72, 0xe3, 0x4c, 0x52, 0x63,
	0x3b, 0x9a, 0x26, 0xc9, 0x5c, 0xf2, 0x52, 0xec, 0xac, 0x04, 0x5b, 0x66, 0x88, 0x84, 0x7f, 0x91,
	0x36, 0x4f, 0xfb, 0x05, 0x9b, 0xa7, 0x52, 0x2c, 0xfc, 0x4c, 0xc9, 0xe8, 0x9b, 0x2f, 0x57, 0xbe,
	0xb1, 0x95, 0x42, 0x63, 0xc7, 0xed, 0x53, 0xaf, 0x62, 0x9f, 0x7f, 0x2b, 0xf0, 0x5a, 0xc2, 0x3e,
	0x4c, 0xbb, 0x1e, 0x79, 0xa1, 0x26, 0x32, 0x60, 0x35, 0x4b, 0x5f, 0xf0, 0x7d, 0x64, 0xf5, 0xc7,
	0x44, 0x06, 0x53, 0x39, 0x52, 0xb5, 0xb8, 0x7a, 0x9f, 0x15, 0x01, 0x09, 0x3b, 0x17, 0xea, 0x37,
	0x75, 0x68, 0xfd, 0x4a, 0xe1, 0xf9, 0x44, 0x5c, 0x52, 0x1c, 0x6f, 0x97, 0xee, 0xda, 0xf6, 0xd4,
	0xf7, 0x74, 0x58, 0xec, 0xaa, 0xf1, 0x66, 0xe4, 0x53, 0x94, 0xd2, 0xf7, 0x65, 0xa6, 0xc9, 0x48,
	0x36, 0xb5, 0x8a, 0xbf, 0xcf, 0x51, 0xb1, 0x4d, 0xe8, 0x73, 0x52, 0x31, 0x31, 0x4a, 0x99, 0xc9,
	0x19, 0xa5, 0x88, 0x54, 0xdb, 0xc8, 0x4d, 0xb5, 0xb3, 0xa5, 0xad, 0x61, 0x8e, 0x01, 0x98, 0xdc,
	0xd3, 0x8c, 0xb1, 0xa7, 0x3f, 0x4b, 0x3f, 0xce, 0xb1, 0x96, 0x41, 0xfa, 0xcf, 0xc9, 0x5a, 0x95,
	0x12, 0x4b, 0xae, 0xeb, 0x99, 0x0c, 0x53, 0xbb, 0xbe, 0x0b, 0x2f, 0x33, 0x5d, 0xf8, 0xf4, 0x59,
	0x52, 0xe2, 0xa5, 0x98, 0x38, 0x39, 0xd3, 0x7e, 0x5a, 0x88, 0xc2, 0x59, 0x8d, 0x85, 0x33, 0x1e,
	0xb0, 0xb2, 0x3f, 0xaa, 0xd1, 0xe5, 0x77, 0x07, 0x41, 0x2a, 0x2c, 0x4f, 0x8a, 0x58, 0x95, 0x95,
	0x34, 0xf9, 0xec, 0xfe, 0x5e, 0x87, 0x26, 0x2f, 0x4a, 0x2c, 0xaf, 0x7b, 0x5e, 0xa6, 0x02, 0x77,
	0x84, 0x91, 0x70, 0x8b, 0x51, 0x5a, 0x4f, 0x07, 0xb3, 0x59, 0x43, 0xc6, 0xb1, 0x84, 0x62, 0xdd,
	0x5c, 0x23, 0xd1, 0xcd, 0x45, 0x13, 0x48, 0x43, 0x0e, 0x11, 0x43, 0x38, 0x79, 0x2c, 0xe6, 0x72,
	0x8e, 0x45, 0xce, 0xb4, 0x37, 0x7f, 0x96, 0xa8, 0xc1, 0xdc, 0x91, 0xe3, 0xf2, 0x52, 0x42, 0x4c,
	0x13, 0x03, 0x90, 0xef, 0x58, 0x4f, 0xf9, 0xce, 0x82, 0xdc, 0x11, 0x60, 0x30, 0xc1, 0x8c, 0xe6,
	0xbc, 0x0c, 0x08, 0x3a, 0x58, 0x43, 0x5b, 0x8a, 0x3a, 0x58, 0x03, 0x7f, 0x4d, 0xce, 0xb3, 0xa5,
	0x41, 0xa7, 0xfa, 0x48, 0xf4, 0x6b, 0x85, 0x07, 0x58, 0x34, 0x1c, 0x0b, 0xfc, 0x2e, 0x03, 0xe6,
	0x39, 0x7b, 0x47, 0x06, 0xe5, 0x4c, 0x7e, 0x50, 0xc6, 0x3b, 0x70, 0x7c, 0x08, 0xab, 0x89, 0x76,
	0x27, 0x23, 0xda, 0x54, 0x7d, 0xe8, 0x6f, 0x45, 0x01, 0x52, 0x44, 0xec, 0xfe, 0x90, 0xf2, 0x4f,
	0x03, 0xff, 0x37, 0x75, 0xdf, 0x38, 0x81, 0xc5, 0xc4, 0xc7, 0xad, 0x25, 0x68, 0x9a, 0xa3, 0xee,
	0xc1, 0xd3, 0x2e, 0x19, 0xd1, 0x56, 0x0d, 0x2d, 0xc3, 0xc2, 0x43, 0xab, 0xfb, 0xc4, 0xea, 0x11,
	0x46, 0xbb, 0xa5, 0x20, 0x94, 0xfe, 0xa4, 0xd6, 0xaa, 0xa3, 0xab, 0xb0, 0x24, 0x3e, 0x5e, 0x1d,
	0x8f, 0xbb, 0x5d, 0xe2, 0xfb, 0x2d, 0x75, 0xe7, 0x5f, 0x37, 0xa0, 0x29, 0x9d, 0x6d, 0x9c, 0xa2,
	0x77, 0x53, 0x4c, 0xf4, 0x44, 0xf2, 0x49, 0x7c, 0xe0, 0xd3, 0x57, 0xd2, 0x89, 0x29, 0xbe, 0x8b,
	0x6b, 0xe8, 0x7d, 0xb8, 0x9e, 0xff, 0x71, 0xec, 0x56, 0x92, 0x68, 0x2e, 0x92, 0x1e, 0xe7, 0x9c,
	0xfa, 0xf4, 0x85, 0x6b, 0xe8, 0x04, 0xae, 0x66, 0x3f, 0x67, 0xad, 0x27, 0xe9, 0x66, 0x10, 0xf4,
	0xd5, 0xc2, 0xef, 0x1a, 0xbc, 0x4f, 0xab, 0xa1, 0xf7, 0x38, 0xd9, 0xd4, 0x97, 0x8c, 0x2c, 0xd9,
	0x24, 0x82, 0x7e, 0x23, 0xdd, 0x26, 0x87, 0xf4, 0x76, 0xe1, 0x4a, 0x6a, 0xf4, 0xbe, 0x52, 0x44,
	0x8c, 0xed, 0xea, 0xcb, 0x71, 0x4a, 0x27, 0x1d, 0x03, 0xd7, 0xd0, 0xbb, 0x80, 0x72, 0x26, 0xe4,
	0x1b, 0x45, 0x64, 0x02, 0x0c, 0xbd, 0x15, 0xc3, 0x10, 0x53, 0xee, 0x1a, 0x7a, 0xc4, 0x3f, 0x40,
	0xe7, 0x0c, 0xb9, 0x6f, 0x15, 0x91, 0x8b, 0x21, 0x95, 0xa8, 0x69, 0xc0, 0x52, 0x72, 0xc0, 0xfc,
	0x72, 0x92, 0x5e, 0x62, 0x53, 0xbf, 0x96, 0x8e, 0x1b, 0xfe, 0xfd, 0x99, 0x19, 0x1f, 0xe5, 0xcc,
	0xaa, 0x53, 0x9a, 0x66, 0x31, 0x0a, 0xe9, 0x7d, 0x1f, 0x56, 0xcb, 0xa7, 0xce, 0x77, 0x32, 0x5a,
	0x17, 0x23, 0xeb, 0xe9, 0xd4, 0x81, 0x6b, 0xe8, 0x43, 0xb8, 0x5d, 0x71, 0xbc, 0xfc, 0x56, 0x89,
	0x3d, 0x0a, 0xdf, 0x2a, 0x54, 0x6c, 0x0f, 0x16, 0x13, 0xd3, 0xe1, 0xd4, 0x21, 0x8d, 0xef, 0x25,
	0x68, 0x84, 0x73, 0x5b, 0x5c, 0x43, 0x3f, 0x80, 0x95, 0xd2, 0x19, 0xde, 0x1b, 0x19, 0xdb, 0x14,
	0xe2, 0xea, 0x6f, 0xa6, 0xe5, 0x2c, 0xc3, 0xc6, 0x35, 0xf4, 0x89, 0x02, 0xaf, 0x56, 0x9a, 0x51,
	0xed, 0xe4, 0x87, 0x65, 0xd9, 0x3b, 0xfa, 0x5b, 0x39, 0xc2, 0x4c, 0x7c, 0x0b, 0xd7, 0xd0, 0xf7,
	0xf8, 0x39, 0x4b, 0x4f, 0x7e, 0xb2, 0xe7, 0x2c, 0x85, 0xa1, 0xe3, 0x1c, 0x7e, 0x29, 0x1c, 0x5c,
	0x43, 0xc7, 0xb0, 0x9c, 0x1e, 0xc8, 0xac, 0x66, 0x48, 0xc7, 0xb7, 0xf5, 0xf5, 0x1c, 0xba, 0x71,
	0x04, 0x7e, 0x9c, 0x5b, 0x99, 0xb9, 0xcd, 0x5a, 0x92, 0x6a, 0x7a, 0x5f, 0xdf, 0x48, 0x93, 0xcd,
	0x4c, 0x5f, 0x38, 0xdd, 0xf6, 0x04, 0xba, 0xed, 0x89, 0x74, 0xdb, 0x59, 0xba, 0x3f, 0x51, 0x60,
	0x7d, 0xd2, 0xe0, 0xe0, 0x6e, 0x92, 0xcf, 0x04, 0x74, 0x7d, 0x3b, 0xcd, 0x76, 0xc2, 0x0b, 0x19,
	0x29, 0xda, 0xd3, 0x49, 0xd1, 0x9e, 0x56, 0x8a, 0x76, 0x81, 0x14, 0x3f, 0x57, 0x00, 0x57, 0x68,
	0x76, 0xbf, 0x54, 0x24, 0x48, 0xd1, 0x1b, 0xfa, 0x4e, 0xb1, 0x2c, 0x45, 0xef, 0x08, 0x97, 0x67,
	0xba, 0xd0, 0xb5, 0x2c, 0xef, 0xf8, 0x7e, 0xd6, 0xe5, 0x69, 0x8c, 0x1c, 0xba, 0xac, 0xb9, 0x2b,
	0xa3, 0xdb, 0x26, 0x74, 0x02, 0xdd, 0x36, 0xc9, 0x93, 0x97, 0xb5, 0x4e, 0x65, 0x74, 0x0d, 0xd2,
	0x9f, 0x40, 0xd7, 0x20, 0x2c, 0xb5, 0x7e, 0x97, 0x67, 0x81, 0xd4, 0x3f, 0xab, 0x12, 0x59, 0x20,
	0xf7, 0x1f, 0x5c, 0xfa, 0x2b, 0x13, 0x30, 0xfc, 0x11, 0x2f, 0x88, 0xb4, 0xc2, 0x3e, 0xed, 0x76,
	0x4a, 0xf8, 0x02, 0xbc, 0xc2, 0x3b, 0xc1, 0x82, 0xb5, 0x09, 0xed, 0xd9, 0x9b, 0x05, 0xc9, 0x34,
	0x17, 0x3b, 0xef, 0xba, 0x7b, 0x07, 0x96, 0x44, 0x03, 0x11, 0xfe, 0xb5, 0x26, 0x9d, 0x6b, 0xd8,
	0x66, 0xa2, 0x4c, 0x88, 0x75, 0x1d, 0xb8, 0x86, 0x5c, 0xd0, 0x0a, 0x6b, 0xf5, 0xdb, 0x45, 0x15,
	0x48, 0x12, 0x4f, 0xdf, 0x2c, 0x4a, 0xef, 0x69, 0x4c, 0x5c, 0x43, 0x1f, 0xc3, 0xfa, 0xa4, 0x72,
	0xfe, 0x6e, 0x35, 0xb6, 0x12, 0x7d, 0x1a, 0xee, 0x7b, 0x8b, 0x7f, 0x7d, 0xb6, 0xa6, 0xfc, 0xf3,
	0xd9, 0x9a, 0xf2, 0x9f, 0x67, 0x6b, 0xca, 0xe9, 0x2c, 0xff, 0x0b, 0xe0, 0x97, 0xff, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x0d, 0x1d, 0xf3, 0x46, 0xc4, 0x28, 0x00, 0x00,
}
