// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hbase.proto

/*
Package messagedbold is a generated protocol buffer package.

It is generated from these files:

	hbase.proto

It has these top-level messages:

	GetMsgIDPtsByDateReq
	GetMsgIDPtsByDateResp
	ClearHistoryReq
	ClearHistoryResp
	DeleteUserMsgByUserIDWithIDWithTypeReq
	DeleteUserMsgByUserIDWithIDWithTypeResp
	BatchDeleteUserMsgReq
	BatchDeleteUserMsgResp
	DeleteUserMsgReq
	DeleteUserMsgResp
	GetMediaMsgHistoryReq
	GetMediaMsgHistoryResp
	GetUserMsgListByUUIDSReq
	GetUserMsgListByUUIDSResp
	GetUserMsgIDByUUIDReq
	GetUserMsgIDByUUIDResp
	GetUserMsgByUserIDMsgIDReq
	GetUserMsgByUserIDMsgIDResp
	GetUserMsgByUserIDMsgIDsReq
	GetUserMsgByUserIDMsgIDsResp
	GetUserMsgUUIDReq
	GetUserMsgUUIDResp
	GetTopMessageReq
	GetTopMessageResp
	SearchMessageReq
	SearchMessageResp
	GetUserMessageHistoryReq
	GetUserMessageHistoryResp
	FindForwardUserMsgReq
	FindForwardUserMsgResp
	ForwardUserMsg
	UserMessage
	Combination
	MentionStatus
*/
package messagedbold

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 数据库类型
type DATABASETYPE int32

const (
	DATABASETYPE__        DATABASETYPE = 0
	DATABASETYPE_UN_ENCRY DATABASETYPE = 1
	DATABASETYPE_ENCRY    DATABASETYPE = 2
	DATABASETYPE_VIP      DATABASETYPE = 4
)

var DATABASETYPE_name = map[int32]string{
	0: "_",
	1: "UN_ENCRY",
	2: "ENCRY",
	4: "VIP",
}
var DATABASETYPE_value = map[string]int32{
	"_":        0,
	"UN_ENCRY": 1,
	"ENCRY":    2,
	"VIP":      4,
}

func (x DATABASETYPE) String() string {
	return proto.EnumName(DATABASETYPE_name, int32(x))
}
func (DATABASETYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorHbase, []int{0} }

type GetMsgIDPtsByDateReq struct {
	UserID int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Date   int32        `protobuf:"varint,2,opt,name=Date,proto3" json:"Date,omitempty"`
	DType  DATABASETYPE `protobuf:"varint,3,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetMsgIDPtsByDateReq) Reset()                    { *m = GetMsgIDPtsByDateReq{} }
func (m *GetMsgIDPtsByDateReq) String() string            { return proto.CompactTextString(m) }
func (*GetMsgIDPtsByDateReq) ProtoMessage()               {}
func (*GetMsgIDPtsByDateReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{0} }

func (m *GetMsgIDPtsByDateReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetMsgIDPtsByDateReq) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *GetMsgIDPtsByDateReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetMsgIDPtsByDateResp struct {
	MsgID int32 `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Pts   int32 `protobuf:"varint,2,opt,name=Pts,proto3" json:"Pts,omitempty"`
}

func (m *GetMsgIDPtsByDateResp) Reset()                    { *m = GetMsgIDPtsByDateResp{} }
func (m *GetMsgIDPtsByDateResp) String() string            { return proto.CompactTextString(m) }
func (*GetMsgIDPtsByDateResp) ProtoMessage()               {}
func (*GetMsgIDPtsByDateResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{1} }

func (m *GetMsgIDPtsByDateResp) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *GetMsgIDPtsByDateResp) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

type ClearHistoryReq struct {
	UserID   int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	Limit    int32        `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
	DType    DATABASETYPE `protobuf:"varint,5,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *ClearHistoryReq) Reset()                    { *m = ClearHistoryReq{} }
func (m *ClearHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*ClearHistoryReq) ProtoMessage()               {}
func (*ClearHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{2} }

func (m *ClearHistoryReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *ClearHistoryReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *ClearHistoryReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *ClearHistoryReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ClearHistoryReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type ClearHistoryResp struct {
	MsgIDs    []int32 `protobuf:"varint,1,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
	Pts       []int32 `protobuf:"varint,2,rep,packed,name=Pts" json:"Pts,omitempty"`
	LastMsgID int32   `protobuf:"varint,3,opt,name=LastMsgID,proto3" json:"LastMsgID,omitempty"`
	Count     int32   `protobuf:"varint,4,opt,name=Count,proto3" json:"Count,omitempty"`
}

func (m *ClearHistoryResp) Reset()                    { *m = ClearHistoryResp{} }
func (m *ClearHistoryResp) String() string            { return proto.CompactTextString(m) }
func (*ClearHistoryResp) ProtoMessage()               {}
func (*ClearHistoryResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{3} }

func (m *ClearHistoryResp) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

func (m *ClearHistoryResp) GetPts() []int32 {
	if m != nil {
		return m.Pts
	}
	return nil
}

func (m *ClearHistoryResp) GetLastMsgID() int32 {
	if m != nil {
		return m.LastMsgID
	}
	return 0
}

func (m *ClearHistoryResp) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type DeleteUserMsgByUserIDWithIDWithTypeReq struct {
	UserID   int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	DType    DATABASETYPE `protobuf:"varint,4,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) Reset() {
	*m = DeleteUserMsgByUserIDWithIDWithTypeReq{}
}
func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) String() string { return proto.CompactTextString(m) }
func (*DeleteUserMsgByUserIDWithIDWithTypeReq) ProtoMessage()    {}
func (*DeleteUserMsgByUserIDWithIDWithTypeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{4}
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type DeleteUserMsgByUserIDWithIDWithTypeResp struct {
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeResp) Reset() {
	*m = DeleteUserMsgByUserIDWithIDWithTypeResp{}
}
func (m *DeleteUserMsgByUserIDWithIDWithTypeResp) String() string { return proto.CompactTextString(m) }
func (*DeleteUserMsgByUserIDWithIDWithTypeResp) ProtoMessage()    {}
func (*DeleteUserMsgByUserIDWithIDWithTypeResp) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{5}
}

type BatchDeleteUserMsgReq struct {
	UserID int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgIDs []int32      `protobuf:"varint,2,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
	DType  DATABASETYPE `protobuf:"varint,3,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *BatchDeleteUserMsgReq) Reset()                    { *m = BatchDeleteUserMsgReq{} }
func (m *BatchDeleteUserMsgReq) String() string            { return proto.CompactTextString(m) }
func (*BatchDeleteUserMsgReq) ProtoMessage()               {}
func (*BatchDeleteUserMsgReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{6} }

func (m *BatchDeleteUserMsgReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *BatchDeleteUserMsgReq) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

func (m *BatchDeleteUserMsgReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type BatchDeleteUserMsgResp struct {
}

func (m *BatchDeleteUserMsgResp) Reset()                    { *m = BatchDeleteUserMsgResp{} }
func (m *BatchDeleteUserMsgResp) String() string            { return proto.CompactTextString(m) }
func (*BatchDeleteUserMsgResp) ProtoMessage()               {}
func (*BatchDeleteUserMsgResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{7} }

type DeleteUserMsgReq struct {
	UserID int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgID  int32        `protobuf:"varint,2,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	DType  DATABASETYPE `protobuf:"varint,3,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *DeleteUserMsgReq) Reset()                    { *m = DeleteUserMsgReq{} }
func (m *DeleteUserMsgReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteUserMsgReq) ProtoMessage()               {}
func (*DeleteUserMsgReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{8} }

func (m *DeleteUserMsgReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *DeleteUserMsgReq) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *DeleteUserMsgReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type DeleteUserMsgResp struct {
}

func (m *DeleteUserMsgResp) Reset()                    { *m = DeleteUserMsgResp{} }
func (m *DeleteUserMsgResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteUserMsgResp) ProtoMessage()               {}
func (*DeleteUserMsgResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{9} }

type GetMediaMsgHistoryReq struct {
	UserID   int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	MaxMsgID int32        `protobuf:"varint,4,opt,name=MaxMsgID,proto3" json:"MaxMsgID,omitempty"`
	Medias   []int32      `protobuf:"varint,5,rep,packed,name=Medias" json:"Medias,omitempty"`
	Limit    int32        `protobuf:"varint,6,opt,name=Limit,proto3" json:"Limit,omitempty"`
	DType    DATABASETYPE `protobuf:"varint,7,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetMediaMsgHistoryReq) Reset()                    { *m = GetMediaMsgHistoryReq{} }
func (m *GetMediaMsgHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*GetMediaMsgHistoryReq) ProtoMessage()               {}
func (*GetMediaMsgHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{10} }

func (m *GetMediaMsgHistoryReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetMediaMsgHistoryReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *GetMediaMsgHistoryReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *GetMediaMsgHistoryReq) GetMaxMsgID() int32 {
	if m != nil {
		return m.MaxMsgID
	}
	return 0
}

func (m *GetMediaMsgHistoryReq) GetMedias() []int32 {
	if m != nil {
		return m.Medias
	}
	return nil
}

func (m *GetMediaMsgHistoryReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetMediaMsgHistoryReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetMediaMsgHistoryResp struct {
	Messages []*UserMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *GetMediaMsgHistoryResp) Reset()                    { *m = GetMediaMsgHistoryResp{} }
func (m *GetMediaMsgHistoryResp) String() string            { return proto.CompactTextString(m) }
func (*GetMediaMsgHistoryResp) ProtoMessage()               {}
func (*GetMediaMsgHistoryResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{11} }

func (m *GetMediaMsgHistoryResp) GetMessages() []*UserMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type GetUserMsgListByUUIDSReq struct {
	UserID int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	DType  DATABASETYPE `protobuf:"varint,2,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
	UUIDs  []int64      `protobuf:"varint,3,rep,packed,name=UUIDs" json:"UUIDs,omitempty"`
}

func (m *GetUserMsgListByUUIDSReq) Reset()                    { *m = GetUserMsgListByUUIDSReq{} }
func (m *GetUserMsgListByUUIDSReq) String() string            { return proto.CompactTextString(m) }
func (*GetUserMsgListByUUIDSReq) ProtoMessage()               {}
func (*GetUserMsgListByUUIDSReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{12} }

func (m *GetUserMsgListByUUIDSReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetUserMsgListByUUIDSReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

func (m *GetUserMsgListByUUIDSReq) GetUUIDs() []int64 {
	if m != nil {
		return m.UUIDs
	}
	return nil
}

type GetUserMsgListByUUIDSResp struct {
	Messages []*UserMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *GetUserMsgListByUUIDSResp) Reset()                    { *m = GetUserMsgListByUUIDSResp{} }
func (m *GetUserMsgListByUUIDSResp) String() string            { return proto.CompactTextString(m) }
func (*GetUserMsgListByUUIDSResp) ProtoMessage()               {}
func (*GetUserMsgListByUUIDSResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{13} }

func (m *GetUserMsgListByUUIDSResp) GetMessages() []*UserMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type GetUserMsgIDByUUIDReq struct {
	UserID int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	UUID   int64        `protobuf:"varint,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	DType  DATABASETYPE `protobuf:"varint,3,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetUserMsgIDByUUIDReq) Reset()                    { *m = GetUserMsgIDByUUIDReq{} }
func (m *GetUserMsgIDByUUIDReq) String() string            { return proto.CompactTextString(m) }
func (*GetUserMsgIDByUUIDReq) ProtoMessage()               {}
func (*GetUserMsgIDByUUIDReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{14} }

func (m *GetUserMsgIDByUUIDReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetUserMsgIDByUUIDReq) GetUUID() int64 {
	if m != nil {
		return m.UUID
	}
	return 0
}

func (m *GetUserMsgIDByUUIDReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetUserMsgIDByUUIDResp struct {
	WithID int32 `protobuf:"varint,1,opt,name=WithID,proto3" json:"WithID,omitempty"`
	MsgID  int32 `protobuf:"varint,2,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
}

func (m *GetUserMsgIDByUUIDResp) Reset()                    { *m = GetUserMsgIDByUUIDResp{} }
func (m *GetUserMsgIDByUUIDResp) String() string            { return proto.CompactTextString(m) }
func (*GetUserMsgIDByUUIDResp) ProtoMessage()               {}
func (*GetUserMsgIDByUUIDResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{15} }

func (m *GetUserMsgIDByUUIDResp) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *GetUserMsgIDByUUIDResp) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

type GetUserMsgByUserIDMsgIDReq struct {
	UserID int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgID  int32        `protobuf:"varint,2,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	DType  DATABASETYPE `protobuf:"varint,3,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetUserMsgByUserIDMsgIDReq) Reset()         { *m = GetUserMsgByUserIDMsgIDReq{} }
func (m *GetUserMsgByUserIDMsgIDReq) String() string { return proto.CompactTextString(m) }
func (*GetUserMsgByUserIDMsgIDReq) ProtoMessage()    {}
func (*GetUserMsgByUserIDMsgIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{16}
}

func (m *GetUserMsgByUserIDMsgIDReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetUserMsgByUserIDMsgIDReq) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *GetUserMsgByUserIDMsgIDReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetUserMsgByUserIDMsgIDResp struct {
	Message *UserMessage `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
}

func (m *GetUserMsgByUserIDMsgIDResp) Reset()         { *m = GetUserMsgByUserIDMsgIDResp{} }
func (m *GetUserMsgByUserIDMsgIDResp) String() string { return proto.CompactTextString(m) }
func (*GetUserMsgByUserIDMsgIDResp) ProtoMessage()    {}
func (*GetUserMsgByUserIDMsgIDResp) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{17}
}

func (m *GetUserMsgByUserIDMsgIDResp) GetMessage() *UserMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type GetUserMsgByUserIDMsgIDsReq struct {
	UserID   int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	MsgIDs   []int32      `protobuf:"varint,4,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
	DType    DATABASETYPE `protobuf:"varint,5,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetUserMsgByUserIDMsgIDsReq) Reset()         { *m = GetUserMsgByUserIDMsgIDsReq{} }
func (m *GetUserMsgByUserIDMsgIDsReq) String() string { return proto.CompactTextString(m) }
func (*GetUserMsgByUserIDMsgIDsReq) ProtoMessage()    {}
func (*GetUserMsgByUserIDMsgIDsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{18}
}

func (m *GetUserMsgByUserIDMsgIDsReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetUserMsgByUserIDMsgIDsReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *GetUserMsgByUserIDMsgIDsReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *GetUserMsgByUserIDMsgIDsReq) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

func (m *GetUserMsgByUserIDMsgIDsReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetUserMsgByUserIDMsgIDsResp struct {
	Messages []*UserMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *GetUserMsgByUserIDMsgIDsResp) Reset()         { *m = GetUserMsgByUserIDMsgIDsResp{} }
func (m *GetUserMsgByUserIDMsgIDsResp) String() string { return proto.CompactTextString(m) }
func (*GetUserMsgByUserIDMsgIDsResp) ProtoMessage()    {}
func (*GetUserMsgByUserIDMsgIDsResp) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{19}
}

func (m *GetUserMsgByUserIDMsgIDsResp) GetMessages() []*UserMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type GetUserMsgUUIDReq struct {
	UserID int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgID  int32        `protobuf:"varint,2,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	DType  DATABASETYPE `protobuf:"varint,3,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetUserMsgUUIDReq) Reset()                    { *m = GetUserMsgUUIDReq{} }
func (m *GetUserMsgUUIDReq) String() string            { return proto.CompactTextString(m) }
func (*GetUserMsgUUIDReq) ProtoMessage()               {}
func (*GetUserMsgUUIDReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{20} }

func (m *GetUserMsgUUIDReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetUserMsgUUIDReq) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *GetUserMsgUUIDReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetUserMsgUUIDResp struct {
	UUID   int64 `protobuf:"varint,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	WithID int32 `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
}

func (m *GetUserMsgUUIDResp) Reset()                    { *m = GetUserMsgUUIDResp{} }
func (m *GetUserMsgUUIDResp) String() string            { return proto.CompactTextString(m) }
func (*GetUserMsgUUIDResp) ProtoMessage()               {}
func (*GetUserMsgUUIDResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{21} }

func (m *GetUserMsgUUIDResp) GetUUID() int64 {
	if m != nil {
		return m.UUID
	}
	return 0
}

func (m *GetUserMsgUUIDResp) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

type GetTopMessageReq struct {
	UserID   int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	DType    DATABASETYPE `protobuf:"varint,4,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetTopMessageReq) Reset()                    { *m = GetTopMessageReq{} }
func (m *GetTopMessageReq) String() string            { return proto.CompactTextString(m) }
func (*GetTopMessageReq) ProtoMessage()               {}
func (*GetTopMessageReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{22} }

func (m *GetTopMessageReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetTopMessageReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *GetTopMessageReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *GetTopMessageReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetTopMessageResp struct {
	Message *UserMessage `protobuf:"bytes,1,opt,name=Message" json:"Message,omitempty"`
}

func (m *GetTopMessageResp) Reset()                    { *m = GetTopMessageResp{} }
func (m *GetTopMessageResp) String() string            { return proto.CompactTextString(m) }
func (*GetTopMessageResp) ProtoMessage()               {}
func (*GetTopMessageResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{23} }

func (m *GetTopMessageResp) GetMessage() *UserMessage {
	if m != nil {
		return m.Message
	}
	return nil
}

type SearchMessageReq struct {
	UserID    int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID    int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType  int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	FromID    int32        `protobuf:"varint,4,opt,name=FromID,proto3" json:"FromID,omitempty"`
	Medias    []int32      `protobuf:"varint,5,rep,packed,name=Medias" json:"Medias,omitempty"`
	OffsetID  int32        `protobuf:"varint,6,opt,name=OffsetID,proto3" json:"OffsetID,omitempty"`
	AddOffset int32        `protobuf:"varint,7,opt,name=AddOffset,proto3" json:"AddOffset,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,8,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
	Limit     int32        `protobuf:"varint,9,opt,name=Limit,proto3" json:"Limit,omitempty"`
	MinDate   int32        `protobuf:"varint,10,opt,name=MinDate,proto3" json:"MinDate,omitempty"`
	MaxDate   int32        `protobuf:"varint,11,opt,name=MaxDate,proto3" json:"MaxDate,omitempty"`
	MinID     int32        `protobuf:"varint,12,opt,name=MinID,proto3" json:"MinID,omitempty"`
	MaxID     int32        `protobuf:"varint,13,opt,name=MaxID,proto3" json:"MaxID,omitempty"`
}

func (m *SearchMessageReq) Reset()                    { *m = SearchMessageReq{} }
func (m *SearchMessageReq) String() string            { return proto.CompactTextString(m) }
func (*SearchMessageReq) ProtoMessage()               {}
func (*SearchMessageReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{24} }

func (m *SearchMessageReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *SearchMessageReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *SearchMessageReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *SearchMessageReq) GetFromID() int32 {
	if m != nil {
		return m.FromID
	}
	return 0
}

func (m *SearchMessageReq) GetMedias() []int32 {
	if m != nil {
		return m.Medias
	}
	return nil
}

func (m *SearchMessageReq) GetOffsetID() int32 {
	if m != nil {
		return m.OffsetID
	}
	return 0
}

func (m *SearchMessageReq) GetAddOffset() int32 {
	if m != nil {
		return m.AddOffset
	}
	return 0
}

func (m *SearchMessageReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

func (m *SearchMessageReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchMessageReq) GetMinDate() int32 {
	if m != nil {
		return m.MinDate
	}
	return 0
}

func (m *SearchMessageReq) GetMaxDate() int32 {
	if m != nil {
		return m.MaxDate
	}
	return 0
}

func (m *SearchMessageReq) GetMinID() int32 {
	if m != nil {
		return m.MinID
	}
	return 0
}

func (m *SearchMessageReq) GetMaxID() int32 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

type SearchMessageResp struct {
	Messages []*UserMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *SearchMessageResp) Reset()                    { *m = SearchMessageResp{} }
func (m *SearchMessageResp) String() string            { return proto.CompactTextString(m) }
func (*SearchMessageResp) ProtoMessage()               {}
func (*SearchMessageResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{25} }

func (m *SearchMessageResp) GetMessages() []*UserMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type GetUserMessageHistoryReq struct {
	UserID     int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID     int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType   int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	OffsetID   int32        `protobuf:"varint,4,opt,name=OffsetID,proto3" json:"OffsetID,omitempty"`
	OffsetDate int32        `protobuf:"varint,5,opt,name=OffsetDate,proto3" json:"OffsetDate,omitempty"`
	AddOffset  int32        `protobuf:"varint,6,opt,name=AddOffset,proto3" json:"AddOffset,omitempty"`
	DType      DATABASETYPE `protobuf:"varint,7,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
	Limit      int32        `protobuf:"varint,8,opt,name=Limit,proto3" json:"Limit,omitempty"`
	MinID      int32        `protobuf:"varint,9,opt,name=MinID,proto3" json:"MinID,omitempty"`
	MaxID      int32        `protobuf:"varint,10,opt,name=MaxID,proto3" json:"MaxID,omitempty"`
}

func (m *GetUserMessageHistoryReq) Reset()                    { *m = GetUserMessageHistoryReq{} }
func (m *GetUserMessageHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*GetUserMessageHistoryReq) ProtoMessage()               {}
func (*GetUserMessageHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{26} }

func (m *GetUserMessageHistoryReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetOffsetID() int32 {
	if m != nil {
		return m.OffsetID
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetOffsetDate() int32 {
	if m != nil {
		return m.OffsetDate
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetAddOffset() int32 {
	if m != nil {
		return m.AddOffset
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

func (m *GetUserMessageHistoryReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetMinID() int32 {
	if m != nil {
		return m.MinID
	}
	return 0
}

func (m *GetUserMessageHistoryReq) GetMaxID() int32 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

type GetUserMessageHistoryResp struct {
	Messages []*UserMessage `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *GetUserMessageHistoryResp) Reset()                    { *m = GetUserMessageHistoryResp{} }
func (m *GetUserMessageHistoryResp) String() string            { return proto.CompactTextString(m) }
func (*GetUserMessageHistoryResp) ProtoMessage()               {}
func (*GetUserMessageHistoryResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{27} }

func (m *GetUserMessageHistoryResp) GetMessages() []*UserMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type FindForwardUserMsgReq struct {
	UserID   int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID   int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	MsgIDs   []int32      `protobuf:"varint,4,rep,packed,name=MsgIDs" json:"MsgIDs,omitempty"`
	DType    DATABASETYPE `protobuf:"varint,5,opt,name=DType,proto3,enum=messagedbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *FindForwardUserMsgReq) Reset()                    { *m = FindForwardUserMsgReq{} }
func (m *FindForwardUserMsgReq) String() string            { return proto.CompactTextString(m) }
func (*FindForwardUserMsgReq) ProtoMessage()               {}
func (*FindForwardUserMsgReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{28} }

func (m *FindForwardUserMsgReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *FindForwardUserMsgReq) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *FindForwardUserMsgReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *FindForwardUserMsgReq) GetMsgIDs() []int32 {
	if m != nil {
		return m.MsgIDs
	}
	return nil
}

func (m *FindForwardUserMsgReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type FindForwardUserMsgResp struct {
	Messages []*ForwardUserMsg `protobuf:"bytes,1,rep,name=Messages" json:"Messages,omitempty"`
}

func (m *FindForwardUserMsgResp) Reset()                    { *m = FindForwardUserMsgResp{} }
func (m *FindForwardUserMsgResp) String() string            { return proto.CompactTextString(m) }
func (*FindForwardUserMsgResp) ProtoMessage()               {}
func (*FindForwardUserMsgResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{29} }

func (m *FindForwardUserMsgResp) GetMessages() []*ForwardUserMsg {
	if m != nil {
		return m.Messages
	}
	return nil
}

type ForwardUserMsg struct {
	FromId      int32    `protobuf:"varint,1,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Encry       int32    `protobuf:"varint,2,opt,name=Encry,proto3" json:"Encry,omitempty"`
	GroupId     int64    `protobuf:"varint,3,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	MsgID       int32    `protobuf:"varint,4,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Media       int32    `protobuf:"varint,5,opt,name=Media,proto3" json:"Media,omitempty"`
	Date        int32    `protobuf:"varint,6,opt,name=Date,proto3" json:"Date,omitempty"`
	ViaBotID    int32    `protobuf:"varint,7,opt,name=ViaBotID,proto3" json:"ViaBotID,omitempty"`
	Message     string   `protobuf:"bytes,8,opt,name=Message,proto3" json:"Message,omitempty"`
	MediaData   []byte   `protobuf:"bytes,9,opt,name=MediaData,proto3" json:"MediaData,omitempty"`
	ReplyMarkup []byte   `protobuf:"bytes,10,opt,name=ReplyMarkup,proto3" json:"ReplyMarkup,omitempty"`
	FwdFrom     []byte   `protobuf:"bytes,11,opt,name=FwdFrom,proto3" json:"FwdFrom,omitempty"`
	Entities    [][]byte `protobuf:"bytes,12,rep,name=Entities" json:"Entities,omitempty"`
}

func (m *ForwardUserMsg) Reset()                    { *m = ForwardUserMsg{} }
func (m *ForwardUserMsg) String() string            { return proto.CompactTextString(m) }
func (*ForwardUserMsg) ProtoMessage()               {}
func (*ForwardUserMsg) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{30} }

func (m *ForwardUserMsg) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ForwardUserMsg) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *ForwardUserMsg) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ForwardUserMsg) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *ForwardUserMsg) GetMedia() int32 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *ForwardUserMsg) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ForwardUserMsg) GetViaBotID() int32 {
	if m != nil {
		return m.ViaBotID
	}
	return 0
}

func (m *ForwardUserMsg) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ForwardUserMsg) GetMediaData() []byte {
	if m != nil {
		return m.MediaData
	}
	return nil
}

func (m *ForwardUserMsg) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *ForwardUserMsg) GetFwdFrom() []byte {
	if m != nil {
		return m.FwdFrom
	}
	return nil
}

func (m *ForwardUserMsg) GetEntities() [][]byte {
	if m != nil {
		return m.Entities
	}
	return nil
}

type UserMessage struct {
	UserID       int32        `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	WithID       int32        `protobuf:"varint,2,opt,name=WithID,proto3" json:"WithID,omitempty"`
	WithType     int32        `protobuf:"varint,3,opt,name=WithType,proto3" json:"WithType,omitempty"`
	MessageType  int32        `protobuf:"varint,4,opt,name=MessageType,proto3" json:"MessageType,omitempty"`
	Flags        int32        `protobuf:"varint,5,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Out          bool         `protobuf:"varint,6,opt,name=Out,proto3" json:"Out,omitempty"`
	Mentioned    bool         `protobuf:"varint,7,opt,name=Mentioned,proto3" json:"Mentioned,omitempty"`
	MediaUnread  bool         `protobuf:"varint,8,opt,name=MediaUnread,proto3" json:"MediaUnread,omitempty"`
	Silent       bool         `protobuf:"varint,9,opt,name=Silent,proto3" json:"Silent,omitempty"`
	Post         bool         `protobuf:"varint,10,opt,name=Post,proto3" json:"Post,omitempty"`
	GroupID      int64        `protobuf:"varint,11,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	MsgID        int32        `protobuf:"varint,12,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	ToID         int32        `protobuf:"varint,13,opt,name=ToID,proto3" json:"ToID,omitempty"`
	Pts          int32        `protobuf:"varint,14,opt,name=Pts,proto3" json:"Pts,omitempty"`
	FwdFrom      []byte       `protobuf:"bytes,15,opt,name=FwdFrom,proto3" json:"FwdFrom,omitempty"`
	ViaBotID     int32        `protobuf:"varint,16,opt,name=ViaBotID,proto3" json:"ViaBotID,omitempty"`
	ReplyToMsgID int32        `protobuf:"varint,17,opt,name=ReplyToMsgID,proto3" json:"ReplyToMsgID,omitempty"`
	Date         int32        `protobuf:"varint,18,opt,name=Date,proto3" json:"Date,omitempty"`
	Message      string       `protobuf:"bytes,19,opt,name=Message,proto3" json:"Message,omitempty"`
	Media        int64        `protobuf:"varint,20,opt,name=Media,proto3" json:"Media,omitempty"`
	MediaData    []byte       `protobuf:"bytes,21,opt,name=MediaData,proto3" json:"MediaData,omitempty"`
	ReplyMarkup  []byte       `protobuf:"bytes,22,opt,name=ReplyMarkup,proto3" json:"ReplyMarkup,omitempty"`
	Entities     [][]byte     `protobuf:"bytes,23,rep,name=Entities" json:"Entities,omitempty"`
	FromID       int32        `protobuf:"varint,24,opt,name=FromID,proto3" json:"FromID,omitempty"`
	Views        int32        `protobuf:"varint,25,opt,name=Views,proto3" json:"Views,omitempty"`
	EditDate     int32        `protobuf:"varint,26,opt,name=EditDate,proto3" json:"EditDate,omitempty"`
	Action       []byte       `protobuf:"bytes,27,opt,name=Action,proto3" json:"Action,omitempty"`
	RandomID     int64        `protobuf:"varint,28,opt,name=RandomID,proto3" json:"RandomID,omitempty"`
	UUID         int64        `protobuf:"varint,29,opt,name=UUID,proto3" json:"UUID,omitempty"`
	InsertDate   int32        `protobuf:"varint,30,opt,name=InsertDate,proto3" json:"InsertDate,omitempty"`
	UpdateDate   int32        `protobuf:"varint,31,opt,name=UpdateDate,proto3" json:"UpdateDate,omitempty"`
	Encry        int32        `protobuf:"varint,32,opt,name=Encry,proto3" json:"Encry,omitempty"`
	Combination  *Combination `protobuf:"bytes,33,opt,name=Combination" json:"Combination,omitempty"`
}

func (m *UserMessage) Reset()                    { *m = UserMessage{} }
func (m *UserMessage) String() string            { return proto.CompactTextString(m) }
func (*UserMessage) ProtoMessage()               {}
func (*UserMessage) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{31} }

func (m *UserMessage) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserMessage) GetWithID() int32 {
	if m != nil {
		return m.WithID
	}
	return 0
}

func (m *UserMessage) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *UserMessage) GetMessageType() int32 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMessage) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UserMessage) GetOut() bool {
	if m != nil {
		return m.Out
	}
	return false
}

func (m *UserMessage) GetMentioned() bool {
	if m != nil {
		return m.Mentioned
	}
	return false
}

func (m *UserMessage) GetMediaUnread() bool {
	if m != nil {
		return m.MediaUnread
	}
	return false
}

func (m *UserMessage) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *UserMessage) GetPost() bool {
	if m != nil {
		return m.Post
	}
	return false
}

func (m *UserMessage) GetGroupID() int64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *UserMessage) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *UserMessage) GetToID() int32 {
	if m != nil {
		return m.ToID
	}
	return 0
}

func (m *UserMessage) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *UserMessage) GetFwdFrom() []byte {
	if m != nil {
		return m.FwdFrom
	}
	return nil
}

func (m *UserMessage) GetViaBotID() int32 {
	if m != nil {
		return m.ViaBotID
	}
	return 0
}

func (m *UserMessage) GetReplyToMsgID() int32 {
	if m != nil {
		return m.ReplyToMsgID
	}
	return 0
}

func (m *UserMessage) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *UserMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *UserMessage) GetMedia() int64 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *UserMessage) GetMediaData() []byte {
	if m != nil {
		return m.MediaData
	}
	return nil
}

func (m *UserMessage) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *UserMessage) GetEntities() [][]byte {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *UserMessage) GetFromID() int32 {
	if m != nil {
		return m.FromID
	}
	return 0
}

func (m *UserMessage) GetViews() int32 {
	if m != nil {
		return m.Views
	}
	return 0
}

func (m *UserMessage) GetEditDate() int32 {
	if m != nil {
		return m.EditDate
	}
	return 0
}

func (m *UserMessage) GetAction() []byte {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *UserMessage) GetRandomID() int64 {
	if m != nil {
		return m.RandomID
	}
	return 0
}

func (m *UserMessage) GetUUID() int64 {
	if m != nil {
		return m.UUID
	}
	return 0
}

func (m *UserMessage) GetInsertDate() int32 {
	if m != nil {
		return m.InsertDate
	}
	return 0
}

func (m *UserMessage) GetUpdateDate() int32 {
	if m != nil {
		return m.UpdateDate
	}
	return 0
}

func (m *UserMessage) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *UserMessage) GetCombination() *Combination {
	if m != nil {
		return m.Combination
	}
	return nil
}

type Combination struct {
	MentionedSlice []*MentionStatus `protobuf:"bytes,1,rep,name=MentionedSlice" json:"MentionedSlice,omitempty"`
	KeyID          []int64          `protobuf:"varint,2,rep,packed,name=KeyID" json:"KeyID,omitempty"`
}

func (m *Combination) Reset()                    { *m = Combination{} }
func (m *Combination) String() string            { return proto.CompactTextString(m) }
func (*Combination) ProtoMessage()               {}
func (*Combination) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{32} }

func (m *Combination) GetMentionedSlice() []*MentionStatus {
	if m != nil {
		return m.MentionedSlice
	}
	return nil
}

func (m *Combination) GetKeyID() []int64 {
	if m != nil {
		return m.KeyID
	}
	return nil
}

type MentionStatus struct {
	UserID int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Status int32 `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MentionStatus) Reset()                    { *m = MentionStatus{} }
func (m *MentionStatus) String() string            { return proto.CompactTextString(m) }
func (*MentionStatus) ProtoMessage()               {}
func (*MentionStatus) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{33} }

func (m *MentionStatus) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *MentionStatus) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func init() {
	proto.RegisterType((*GetMsgIDPtsByDateReq)(nil), "messagedbold.GetMsgIDPtsByDateReq")
	proto.RegisterType((*GetMsgIDPtsByDateResp)(nil), "messagedbold.GetMsgIDPtsByDateResp")
	proto.RegisterType((*ClearHistoryReq)(nil), "messagedbold.ClearHistoryReq")
	proto.RegisterType((*ClearHistoryResp)(nil), "messagedbold.ClearHistoryResp")
	proto.RegisterType((*DeleteUserMsgByUserIDWithIDWithTypeReq)(nil), "messagedbold.DeleteUserMsgByUserIDWithIDWithTypeReq")
	proto.RegisterType((*DeleteUserMsgByUserIDWithIDWithTypeResp)(nil), "messagedbold.DeleteUserMsgByUserIDWithIDWithTypeResp")
	proto.RegisterType((*BatchDeleteUserMsgReq)(nil), "messagedbold.BatchDeleteUserMsgReq")
	proto.RegisterType((*BatchDeleteUserMsgResp)(nil), "messagedbold.BatchDeleteUserMsgResp")
	proto.RegisterType((*DeleteUserMsgReq)(nil), "messagedbold.DeleteUserMsgReq")
	proto.RegisterType((*DeleteUserMsgResp)(nil), "messagedbold.DeleteUserMsgResp")
	proto.RegisterType((*GetMediaMsgHistoryReq)(nil), "messagedbold.GetMediaMsgHistoryReq")
	proto.RegisterType((*GetMediaMsgHistoryResp)(nil), "messagedbold.GetMediaMsgHistoryResp")
	proto.RegisterType((*GetUserMsgListByUUIDSReq)(nil), "messagedbold.GetUserMsgListByUUIDSReq")
	proto.RegisterType((*GetUserMsgListByUUIDSResp)(nil), "messagedbold.GetUserMsgListByUUIDSResp")
	proto.RegisterType((*GetUserMsgIDByUUIDReq)(nil), "messagedbold.GetUserMsgIDByUUIDReq")
	proto.RegisterType((*GetUserMsgIDByUUIDResp)(nil), "messagedbold.GetUserMsgIDByUUIDResp")
	proto.RegisterType((*GetUserMsgByUserIDMsgIDReq)(nil), "messagedbold.GetUserMsgByUserIDMsgIDReq")
	proto.RegisterType((*GetUserMsgByUserIDMsgIDResp)(nil), "messagedbold.GetUserMsgByUserIDMsgIDResp")
	proto.RegisterType((*GetUserMsgByUserIDMsgIDsReq)(nil), "messagedbold.GetUserMsgByUserIDMsgIDsReq")
	proto.RegisterType((*GetUserMsgByUserIDMsgIDsResp)(nil), "messagedbold.GetUserMsgByUserIDMsgIDsResp")
	proto.RegisterType((*GetUserMsgUUIDReq)(nil), "messagedbold.GetUserMsgUUIDReq")
	proto.RegisterType((*GetUserMsgUUIDResp)(nil), "messagedbold.GetUserMsgUUIDResp")
	proto.RegisterType((*GetTopMessageReq)(nil), "messagedbold.GetTopMessageReq")
	proto.RegisterType((*GetTopMessageResp)(nil), "messagedbold.GetTopMessageResp")
	proto.RegisterType((*SearchMessageReq)(nil), "messagedbold.SearchMessageReq")
	proto.RegisterType((*SearchMessageResp)(nil), "messagedbold.SearchMessageResp")
	proto.RegisterType((*GetUserMessageHistoryReq)(nil), "messagedbold.GetUserMessageHistoryReq")
	proto.RegisterType((*GetUserMessageHistoryResp)(nil), "messagedbold.GetUserMessageHistoryResp")
	proto.RegisterType((*FindForwardUserMsgReq)(nil), "messagedbold.FindForwardUserMsgReq")
	proto.RegisterType((*FindForwardUserMsgResp)(nil), "messagedbold.FindForwardUserMsgResp")
	proto.RegisterType((*ForwardUserMsg)(nil), "messagedbold.ForwardUserMsg")
	proto.RegisterType((*UserMessage)(nil), "messagedbold.UserMessage")
	proto.RegisterType((*Combination)(nil), "messagedbold.Combination")
	proto.RegisterType((*MentionStatus)(nil), "messagedbold.MentionStatus")
	proto.RegisterEnum("messagedbold.DATABASETYPE", DATABASETYPE_name, DATABASETYPE_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MessagedbOldService service

type MessagedbOldServiceClient interface {
	// FindForwardUserMsg 查询转发消息
	FindForwardUserMsg(ctx context.Context, in *FindForwardUserMsgReq, opts ...grpc.CallOption) (*FindForwardUserMsgResp, error)
	// GetUserMessageHistory 查询历史
	GetUserMessageHistory(ctx context.Context, in *GetUserMessageHistoryReq, opts ...grpc.CallOption) (*GetUserMessageHistoryResp, error)
	// SearchMessage 搜索消息（主要是导出历史指定人发送的搜索协议重定向，以后导出历史有改动这块可以看业务需求是否能去掉
	SearchMessage(ctx context.Context, in *SearchMessageReq, opts ...grpc.CallOption) (*SearchMessageResp, error)
	// GetTopMessage 查询符合条件的最新的一条消息
	GetTopMessage(ctx context.Context, in *GetTopMessageReq, opts ...grpc.CallOption) (*GetTopMessageResp, error)
	// GetUserMsgUUID 查询消息的uuid 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgUUID(ctx context.Context, in *GetUserMsgUUIDReq, opts ...grpc.CallOption) (*GetUserMsgUUIDResp, error)
	// GetUserMsgByUserIDMsgID 查询单条消息 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgByUserIDMsgID(ctx context.Context, in *GetUserMsgByUserIDMsgIDReq, opts ...grpc.CallOption) (*GetUserMsgByUserIDMsgIDResp, error)
	// GetUserMsgByUserIDMsgIDs 获取多条消息
	GetUserMsgByUserIDMsgIDs(ctx context.Context, in *GetUserMsgByUserIDMsgIDsReq, opts ...grpc.CallOption) (*GetUserMsgByUserIDMsgIDsResp, error)
	// GetUserMsgIdByUUID 根据UUID 查询消息ID 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgIDByUUID(ctx context.Context, in *GetUserMsgIDByUUIDReq, opts ...grpc.CallOption) (*GetUserMsgIDByUUIDResp, error)
	// GetUserMsgListByUUIDS 根据UUDIs 查询消息 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgListByUUIDS(ctx context.Context, in *GetUserMsgListByUUIDSReq, opts ...grpc.CallOption) (*GetUserMsgListByUUIDSResp, error)
	// GetMediaMsgHistory 获取媒体消息历史 查询 < msgID 的消息
	GetMediaMsgHistory(ctx context.Context, in *GetMediaMsgHistoryReq, opts ...grpc.CallOption) (*GetMediaMsgHistoryResp, error)
	// DeleteUserMsg 删除单条消息
	DeleteUserMsg(ctx context.Context, in *DeleteUserMsgReq, opts ...grpc.CallOption) (*DeleteUserMsgResp, error)
	// BatchDeleteUserMsg 批量删除消息
	BatchDeleteUserMsg(ctx context.Context, in *BatchDeleteUserMsgReq, opts ...grpc.CallOption) (*BatchDeleteUserMsgResp, error)
	// DeleteUserMsgByUserIDWithIDWithType 删除对话框消息
	DeleteUserMsgByUserIDWithIDWithType(ctx context.Context, in *DeleteUserMsgByUserIDWithIDWithTypeReq, opts ...grpc.CallOption) (*DeleteUserMsgByUserIDWithIDWithTypeResp, error)
	// ClearHistory 分页清除对话框消息
	ClearHistory(ctx context.Context, in *ClearHistoryReq, opts ...grpc.CallOption) (*ClearHistoryResp, error)
	// GetMsgIDPtsByDate 获取大于时间戳的最小的msgID 返回各个库中比较小的值 删除vip用户数据是调用（暂时不实现）
	GetMsgIDPtsByDate(ctx context.Context, in *GetMsgIDPtsByDateReq, opts ...grpc.CallOption) (*GetMsgIDPtsByDateResp, error)
}

type messagedbOldServiceClient struct {
	cc *grpc.ClientConn
}

func NewMessagedbOldServiceClient(cc *grpc.ClientConn) MessagedbOldServiceClient {
	return &messagedbOldServiceClient{cc}
}

func (c *messagedbOldServiceClient) FindForwardUserMsg(ctx context.Context, in *FindForwardUserMsgReq, opts ...grpc.CallOption) (*FindForwardUserMsgResp, error) {
	out := new(FindForwardUserMsgResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/FindForwardUserMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetUserMessageHistory(ctx context.Context, in *GetUserMessageHistoryReq, opts ...grpc.CallOption) (*GetUserMessageHistoryResp, error) {
	out := new(GetUserMessageHistoryResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetUserMessageHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) SearchMessage(ctx context.Context, in *SearchMessageReq, opts ...grpc.CallOption) (*SearchMessageResp, error) {
	out := new(SearchMessageResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/SearchMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetTopMessage(ctx context.Context, in *GetTopMessageReq, opts ...grpc.CallOption) (*GetTopMessageResp, error) {
	out := new(GetTopMessageResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetTopMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetUserMsgUUID(ctx context.Context, in *GetUserMsgUUIDReq, opts ...grpc.CallOption) (*GetUserMsgUUIDResp, error) {
	out := new(GetUserMsgUUIDResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetUserMsgUUID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetUserMsgByUserIDMsgID(ctx context.Context, in *GetUserMsgByUserIDMsgIDReq, opts ...grpc.CallOption) (*GetUserMsgByUserIDMsgIDResp, error) {
	out := new(GetUserMsgByUserIDMsgIDResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetUserMsgByUserIDMsgID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetUserMsgByUserIDMsgIDs(ctx context.Context, in *GetUserMsgByUserIDMsgIDsReq, opts ...grpc.CallOption) (*GetUserMsgByUserIDMsgIDsResp, error) {
	out := new(GetUserMsgByUserIDMsgIDsResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetUserMsgByUserIDMsgIDs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetUserMsgIDByUUID(ctx context.Context, in *GetUserMsgIDByUUIDReq, opts ...grpc.CallOption) (*GetUserMsgIDByUUIDResp, error) {
	out := new(GetUserMsgIDByUUIDResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetUserMsgIDByUUID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetUserMsgListByUUIDS(ctx context.Context, in *GetUserMsgListByUUIDSReq, opts ...grpc.CallOption) (*GetUserMsgListByUUIDSResp, error) {
	out := new(GetUserMsgListByUUIDSResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetUserMsgListByUUIDS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetMediaMsgHistory(ctx context.Context, in *GetMediaMsgHistoryReq, opts ...grpc.CallOption) (*GetMediaMsgHistoryResp, error) {
	out := new(GetMediaMsgHistoryResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetMediaMsgHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) DeleteUserMsg(ctx context.Context, in *DeleteUserMsgReq, opts ...grpc.CallOption) (*DeleteUserMsgResp, error) {
	out := new(DeleteUserMsgResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/DeleteUserMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) BatchDeleteUserMsg(ctx context.Context, in *BatchDeleteUserMsgReq, opts ...grpc.CallOption) (*BatchDeleteUserMsgResp, error) {
	out := new(BatchDeleteUserMsgResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/BatchDeleteUserMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) DeleteUserMsgByUserIDWithIDWithType(ctx context.Context, in *DeleteUserMsgByUserIDWithIDWithTypeReq, opts ...grpc.CallOption) (*DeleteUserMsgByUserIDWithIDWithTypeResp, error) {
	out := new(DeleteUserMsgByUserIDWithIDWithTypeResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/DeleteUserMsgByUserIDWithIDWithType", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) ClearHistory(ctx context.Context, in *ClearHistoryReq, opts ...grpc.CallOption) (*ClearHistoryResp, error) {
	out := new(ClearHistoryResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/ClearHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messagedbOldServiceClient) GetMsgIDPtsByDate(ctx context.Context, in *GetMsgIDPtsByDateReq, opts ...grpc.CallOption) (*GetMsgIDPtsByDateResp, error) {
	out := new(GetMsgIDPtsByDateResp)
	err := grpc.Invoke(ctx, "/messagedbold.MessagedbOldService/GetMsgIDPtsByDate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MessagedbOldService service

type MessagedbOldServiceServer interface {
	// FindForwardUserMsg 查询转发消息
	FindForwardUserMsg(context.Context, *FindForwardUserMsgReq) (*FindForwardUserMsgResp, error)
	// GetUserMessageHistory 查询历史
	GetUserMessageHistory(context.Context, *GetUserMessageHistoryReq) (*GetUserMessageHistoryResp, error)
	// SearchMessage 搜索消息（主要是导出历史指定人发送的搜索协议重定向，以后导出历史有改动这块可以看业务需求是否能去掉
	SearchMessage(context.Context, *SearchMessageReq) (*SearchMessageResp, error)
	// GetTopMessage 查询符合条件的最新的一条消息
	GetTopMessage(context.Context, *GetTopMessageReq) (*GetTopMessageResp, error)
	// GetUserMsgUUID 查询消息的uuid 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgUUID(context.Context, *GetUserMsgUUIDReq) (*GetUserMsgUUIDResp, error)
	// GetUserMsgByUserIDMsgID 查询单条消息 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgByUserIDMsgID(context.Context, *GetUserMsgByUserIDMsgIDReq) (*GetUserMsgByUserIDMsgIDResp, error)
	// GetUserMsgByUserIDMsgIDs 获取多条消息
	GetUserMsgByUserIDMsgIDs(context.Context, *GetUserMsgByUserIDMsgIDsReq) (*GetUserMsgByUserIDMsgIDsResp, error)
	// GetUserMsgIdByUUID 根据UUID 查询消息ID 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgIDByUUID(context.Context, *GetUserMsgIDByUUIDReq) (*GetUserMsgIDByUUIDResp, error)
	// GetUserMsgListByUUIDS 根据UUDIs 查询消息 注意 DATABASETYPE 类型，要特殊处理
	GetUserMsgListByUUIDS(context.Context, *GetUserMsgListByUUIDSReq) (*GetUserMsgListByUUIDSResp, error)
	// GetMediaMsgHistory 获取媒体消息历史 查询 < msgID 的消息
	GetMediaMsgHistory(context.Context, *GetMediaMsgHistoryReq) (*GetMediaMsgHistoryResp, error)
	// DeleteUserMsg 删除单条消息
	DeleteUserMsg(context.Context, *DeleteUserMsgReq) (*DeleteUserMsgResp, error)
	// BatchDeleteUserMsg 批量删除消息
	BatchDeleteUserMsg(context.Context, *BatchDeleteUserMsgReq) (*BatchDeleteUserMsgResp, error)
	// DeleteUserMsgByUserIDWithIDWithType 删除对话框消息
	DeleteUserMsgByUserIDWithIDWithType(context.Context, *DeleteUserMsgByUserIDWithIDWithTypeReq) (*DeleteUserMsgByUserIDWithIDWithTypeResp, error)
	// ClearHistory 分页清除对话框消息
	ClearHistory(context.Context, *ClearHistoryReq) (*ClearHistoryResp, error)
	// GetMsgIDPtsByDate 获取大于时间戳的最小的msgID 返回各个库中比较小的值 删除vip用户数据是调用（暂时不实现）
	GetMsgIDPtsByDate(context.Context, *GetMsgIDPtsByDateReq) (*GetMsgIDPtsByDateResp, error)
}

func RegisterMessagedbOldServiceServer(s *grpc.Server, srv MessagedbOldServiceServer) {
	s.RegisterService(&_MessagedbOldService_serviceDesc, srv)
}

func _MessagedbOldService_FindForwardUserMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindForwardUserMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).FindForwardUserMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/FindForwardUserMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).FindForwardUserMsg(ctx, req.(*FindForwardUserMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetUserMessageHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMessageHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetUserMessageHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetUserMessageHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetUserMessageHistory(ctx, req.(*GetUserMessageHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_SearchMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).SearchMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/SearchMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).SearchMessage(ctx, req.(*SearchMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetTopMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetTopMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetTopMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetTopMessage(ctx, req.(*GetTopMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetUserMsgUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMsgUUIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetUserMsgUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetUserMsgUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetUserMsgUUID(ctx, req.(*GetUserMsgUUIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetUserMsgByUserIDMsgID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMsgByUserIDMsgIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetUserMsgByUserIDMsgID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetUserMsgByUserIDMsgID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetUserMsgByUserIDMsgID(ctx, req.(*GetUserMsgByUserIDMsgIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetUserMsgByUserIDMsgIDs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMsgByUserIDMsgIDsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetUserMsgByUserIDMsgIDs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetUserMsgByUserIDMsgIDs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetUserMsgByUserIDMsgIDs(ctx, req.(*GetUserMsgByUserIDMsgIDsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetUserMsgIDByUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMsgIDByUUIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetUserMsgIDByUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetUserMsgIDByUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetUserMsgIDByUUID(ctx, req.(*GetUserMsgIDByUUIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetUserMsgListByUUIDS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserMsgListByUUIDSReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetUserMsgListByUUIDS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetUserMsgListByUUIDS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetUserMsgListByUUIDS(ctx, req.(*GetUserMsgListByUUIDSReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetMediaMsgHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMediaMsgHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetMediaMsgHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetMediaMsgHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetMediaMsgHistory(ctx, req.(*GetMediaMsgHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_DeleteUserMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).DeleteUserMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/DeleteUserMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).DeleteUserMsg(ctx, req.(*DeleteUserMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_BatchDeleteUserMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDeleteUserMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).BatchDeleteUserMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/BatchDeleteUserMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).BatchDeleteUserMsg(ctx, req.(*BatchDeleteUserMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_DeleteUserMsgByUserIDWithIDWithType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserMsgByUserIDWithIDWithTypeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).DeleteUserMsgByUserIDWithIDWithType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/DeleteUserMsgByUserIDWithIDWithType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).DeleteUserMsgByUserIDWithIDWithType(ctx, req.(*DeleteUserMsgByUserIDWithIDWithTypeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_ClearHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).ClearHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/ClearHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).ClearHistory(ctx, req.(*ClearHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessagedbOldService_GetMsgIDPtsByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMsgIDPtsByDateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessagedbOldServiceServer).GetMsgIDPtsByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/messagedbold.MessagedbOldService/GetMsgIDPtsByDate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessagedbOldServiceServer).GetMsgIDPtsByDate(ctx, req.(*GetMsgIDPtsByDateReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _MessagedbOldService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "messagedbold.MessagedbOldService",
	HandlerType: (*MessagedbOldServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindForwardUserMsg",
			Handler:    _MessagedbOldService_FindForwardUserMsg_Handler,
		},
		{
			MethodName: "GetUserMessageHistory",
			Handler:    _MessagedbOldService_GetUserMessageHistory_Handler,
		},
		{
			MethodName: "SearchMessage",
			Handler:    _MessagedbOldService_SearchMessage_Handler,
		},
		{
			MethodName: "GetTopMessage",
			Handler:    _MessagedbOldService_GetTopMessage_Handler,
		},
		{
			MethodName: "GetUserMsgUUID",
			Handler:    _MessagedbOldService_GetUserMsgUUID_Handler,
		},
		{
			MethodName: "GetUserMsgByUserIDMsgID",
			Handler:    _MessagedbOldService_GetUserMsgByUserIDMsgID_Handler,
		},
		{
			MethodName: "GetUserMsgByUserIDMsgIDs",
			Handler:    _MessagedbOldService_GetUserMsgByUserIDMsgIDs_Handler,
		},
		{
			MethodName: "GetUserMsgIDByUUID",
			Handler:    _MessagedbOldService_GetUserMsgIDByUUID_Handler,
		},
		{
			MethodName: "GetUserMsgListByUUIDS",
			Handler:    _MessagedbOldService_GetUserMsgListByUUIDS_Handler,
		},
		{
			MethodName: "GetMediaMsgHistory",
			Handler:    _MessagedbOldService_GetMediaMsgHistory_Handler,
		},
		{
			MethodName: "DeleteUserMsg",
			Handler:    _MessagedbOldService_DeleteUserMsg_Handler,
		},
		{
			MethodName: "BatchDeleteUserMsg",
			Handler:    _MessagedbOldService_BatchDeleteUserMsg_Handler,
		},
		{
			MethodName: "DeleteUserMsgByUserIDWithIDWithType",
			Handler:    _MessagedbOldService_DeleteUserMsgByUserIDWithIDWithType_Handler,
		},
		{
			MethodName: "ClearHistory",
			Handler:    _MessagedbOldService_ClearHistory_Handler,
		},
		{
			MethodName: "GetMsgIDPtsByDate",
			Handler:    _MessagedbOldService_GetMsgIDPtsByDate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hbase.proto",
}

func (m *GetMsgIDPtsByDateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMsgIDPtsByDateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.Date != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Date))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetMsgIDPtsByDateResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMsgIDPtsByDateResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgID))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Pts))
	}
	return i, nil
}

func (m *ClearHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	if m.DType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *ClearHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MsgIDs) > 0 {
		dAtA2 := make([]byte, len(m.MsgIDs)*10)
		var j1 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.Pts) > 0 {
		dAtA4 := make([]byte, len(m.Pts)*10)
		var j3 int
		for _, num1 := range m.Pts {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.LastMsgID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.LastMsgID))
	}
	if m.Count != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.DType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BatchDeleteUserMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchDeleteUserMsgReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if len(m.MsgIDs) > 0 {
		dAtA6 := make([]byte, len(m.MsgIDs)*10)
		var j5 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *BatchDeleteUserMsgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchDeleteUserMsgResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DeleteUserMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMsgReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.MsgID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgID))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *DeleteUserMsgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMsgResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GetMediaMsgHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMediaMsgHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.MaxMsgID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxMsgID))
	}
	if len(m.Medias) > 0 {
		dAtA8 := make([]byte, len(m.Medias)*10)
		var j7 int
		for _, num1 := range m.Medias {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.Limit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	if m.DType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetMediaMsgHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMediaMsgHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetUserMsgListByUUIDSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgListByUUIDSReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.DType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	if len(m.UUIDs) > 0 {
		dAtA10 := make([]byte, len(m.UUIDs)*10)
		var j9 int
		for _, num1 := range m.UUIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *GetUserMsgListByUUIDSResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgListByUUIDSResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetUserMsgIDByUUIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgIDByUUIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.UUID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UUID))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetUserMsgIDByUUIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgIDByUUIDResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WithID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.MsgID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgID))
	}
	return i, nil
}

func (m *GetUserMsgByUserIDMsgIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgByUserIDMsgIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.MsgID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgID))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetUserMsgByUserIDMsgIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgByUserIDMsgIDResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Message.Size()))
		n11, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *GetUserMsgByUserIDMsgIDsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgByUserIDMsgIDsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		dAtA13 := make([]byte, len(m.MsgIDs)*10)
		var j12 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if m.DType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetUserMsgByUserIDMsgIDsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgByUserIDMsgIDsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetUserMsgUUIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgUUIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.MsgID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgID))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetUserMsgUUIDResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMsgUUIDResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UUID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UUID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	return i, nil
}

func (m *GetTopMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.DType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetTopMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopMessageResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Message.Size()))
		n14, err := m.Message.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *SearchMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.FromID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.FromID))
	}
	if len(m.Medias) > 0 {
		dAtA16 := make([]byte, len(m.Medias)*10)
		var j15 int
		for _, num1 := range m.Medias {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.OffsetID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.OffsetID))
	}
	if m.AddOffset != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.AddOffset))
	}
	if m.DType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	if m.MinDate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxDate))
	}
	if m.MinID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MinID))
	}
	if m.MaxID != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxID))
	}
	return i, nil
}

func (m *SearchMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMessageResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetUserMessageHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMessageHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.OffsetID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.OffsetID))
	}
	if m.OffsetDate != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.OffsetDate))
	}
	if m.AddOffset != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.AddOffset))
	}
	if m.DType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	if m.MinID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MinID))
	}
	if m.MaxID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxID))
	}
	return i, nil
}

func (m *GetUserMessageHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUserMessageHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FindForwardUserMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindForwardUserMsgReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		dAtA18 := make([]byte, len(m.MsgIDs)*10)
		var j17 int
		for _, num1 := range m.MsgIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if m.DType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *FindForwardUserMsgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindForwardUserMsgResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ForwardUserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ForwardUserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.FromId))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Encry))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.GroupId))
	}
	if m.MsgID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgID))
	}
	if m.Media != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Media))
	}
	if m.Date != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Date))
	}
	if m.ViaBotID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ViaBotID))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.MediaData) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.MediaData)))
		i += copy(dAtA[i:], m.MediaData)
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.FwdFrom) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.FwdFrom)))
		i += copy(dAtA[i:], m.FwdFrom)
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			dAtA[i] = 0x62
			i++
			i = encodeVarintHbase(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *UserMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.WithID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithID))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.MessageType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MessageType))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Flags))
	}
	if m.Out {
		dAtA[i] = 0x30
		i++
		if m.Out {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mentioned {
		dAtA[i] = 0x38
		i++
		if m.Mentioned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MediaUnread {
		dAtA[i] = 0x40
		i++
		if m.MediaUnread {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Silent {
		dAtA[i] = 0x48
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Post {
		dAtA[i] = 0x50
		i++
		if m.Post {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.GroupID))
	}
	if m.MsgID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgID))
	}
	if m.ToID != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ToID))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Pts))
	}
	if len(m.FwdFrom) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.FwdFrom)))
		i += copy(dAtA[i:], m.FwdFrom)
	}
	if m.ViaBotID != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ViaBotID))
	}
	if m.ReplyToMsgID != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyToMsgID))
	}
	if m.Date != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Date))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Media != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Media))
	}
	if len(m.MediaData) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.MediaData)))
		i += copy(dAtA[i:], m.MediaData)
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			dAtA[i] = 0xba
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintHbase(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.FromID != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.FromID))
	}
	if m.Views != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Views))
	}
	if m.EditDate != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.EditDate))
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if m.RandomID != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.RandomID))
	}
	if m.UUID != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UUID))
	}
	if m.InsertDate != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UpdateDate))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Encry))
	}
	if m.Combination != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Combination.Size()))
		n19, err := m.Combination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *Combination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Combination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MentionedSlice) > 0 {
		for _, msg := range m.MentionedSlice {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.KeyID) > 0 {
		dAtA21 := make([]byte, len(m.KeyID)*10)
		var j20 int
		for _, num1 := range m.KeyID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	return i, nil
}

func (m *MentionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MentionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func encodeVarintHbase(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetMsgIDPtsByDateReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.Date != 0 {
		n += 1 + sovHbase(uint64(m.Date))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetMsgIDPtsByDateResp) Size() (n int) {
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovHbase(uint64(m.MsgID))
	}
	if m.Pts != 0 {
		n += 1 + sovHbase(uint64(m.Pts))
	}
	return n
}

func (m *ClearHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *ClearHistoryResp) Size() (n int) {
	var l int
	_ = l
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if len(m.Pts) > 0 {
		l = 0
		for _, e := range m.Pts {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.LastMsgID != 0 {
		n += 1 + sovHbase(uint64(m.LastMsgID))
	}
	if m.Count != 0 {
		n += 1 + sovHbase(uint64(m.Count))
	}
	return n
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *DeleteUserMsgByUserIDWithIDWithTypeResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *BatchDeleteUserMsgReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *BatchDeleteUserMsgResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DeleteUserMsgReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.MsgID != 0 {
		n += 1 + sovHbase(uint64(m.MsgID))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *DeleteUserMsgResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GetMediaMsgHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.MaxMsgID != 0 {
		n += 1 + sovHbase(uint64(m.MaxMsgID))
	}
	if len(m.Medias) > 0 {
		l = 0
		for _, e := range m.Medias {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetMediaMsgHistoryResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func (m *GetUserMsgListByUUIDSReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	if len(m.UUIDs) > 0 {
		l = 0
		for _, e := range m.UUIDs {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	return n
}

func (m *GetUserMsgListByUUIDSResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func (m *GetUserMsgIDByUUIDReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.UUID != 0 {
		n += 1 + sovHbase(uint64(m.UUID))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetUserMsgIDByUUIDResp) Size() (n int) {
	var l int
	_ = l
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.MsgID != 0 {
		n += 1 + sovHbase(uint64(m.MsgID))
	}
	return n
}

func (m *GetUserMsgByUserIDMsgIDReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.MsgID != 0 {
		n += 1 + sovHbase(uint64(m.MsgID))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetUserMsgByUserIDMsgIDResp) Size() (n int) {
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *GetUserMsgByUserIDMsgIDsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetUserMsgByUserIDMsgIDsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func (m *GetUserMsgUUIDReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.MsgID != 0 {
		n += 1 + sovHbase(uint64(m.MsgID))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetUserMsgUUIDResp) Size() (n int) {
	var l int
	_ = l
	if m.UUID != 0 {
		n += 1 + sovHbase(uint64(m.UUID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	return n
}

func (m *GetTopMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetTopMessageResp) Size() (n int) {
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *SearchMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.FromID != 0 {
		n += 1 + sovHbase(uint64(m.FromID))
	}
	if len(m.Medias) > 0 {
		l = 0
		for _, e := range m.Medias {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.OffsetID != 0 {
		n += 1 + sovHbase(uint64(m.OffsetID))
	}
	if m.AddOffset != 0 {
		n += 1 + sovHbase(uint64(m.AddOffset))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	if m.MinDate != 0 {
		n += 1 + sovHbase(uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		n += 1 + sovHbase(uint64(m.MaxDate))
	}
	if m.MinID != 0 {
		n += 1 + sovHbase(uint64(m.MinID))
	}
	if m.MaxID != 0 {
		n += 1 + sovHbase(uint64(m.MaxID))
	}
	return n
}

func (m *SearchMessageResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func (m *GetUserMessageHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.OffsetID != 0 {
		n += 1 + sovHbase(uint64(m.OffsetID))
	}
	if m.OffsetDate != 0 {
		n += 1 + sovHbase(uint64(m.OffsetDate))
	}
	if m.AddOffset != 0 {
		n += 1 + sovHbase(uint64(m.AddOffset))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	if m.MinID != 0 {
		n += 1 + sovHbase(uint64(m.MinID))
	}
	if m.MaxID != 0 {
		n += 1 + sovHbase(uint64(m.MaxID))
	}
	return n
}

func (m *GetUserMessageHistoryResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func (m *FindForwardUserMsgReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if len(m.MsgIDs) > 0 {
		l = 0
		for _, e := range m.MsgIDs {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *FindForwardUserMsgResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func (m *ForwardUserMsg) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovHbase(uint64(m.FromId))
	}
	if m.Encry != 0 {
		n += 1 + sovHbase(uint64(m.Encry))
	}
	if m.GroupId != 0 {
		n += 1 + sovHbase(uint64(m.GroupId))
	}
	if m.MsgID != 0 {
		n += 1 + sovHbase(uint64(m.MsgID))
	}
	if m.Media != 0 {
		n += 1 + sovHbase(uint64(m.Media))
	}
	if m.Date != 0 {
		n += 1 + sovHbase(uint64(m.Date))
	}
	if m.ViaBotID != 0 {
		n += 1 + sovHbase(uint64(m.ViaBotID))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovHbase(uint64(l))
	}
	l = len(m.MediaData)
	if l > 0 {
		n += 1 + l + sovHbase(uint64(l))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 1 + l + sovHbase(uint64(l))
	}
	l = len(m.FwdFrom)
	if l > 0 {
		n += 1 + l + sovHbase(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			l = len(b)
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func (m *UserMessage) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.WithID != 0 {
		n += 1 + sovHbase(uint64(m.WithID))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.MessageType != 0 {
		n += 1 + sovHbase(uint64(m.MessageType))
	}
	if m.Flags != 0 {
		n += 1 + sovHbase(uint64(m.Flags))
	}
	if m.Out {
		n += 2
	}
	if m.Mentioned {
		n += 2
	}
	if m.MediaUnread {
		n += 2
	}
	if m.Silent {
		n += 2
	}
	if m.Post {
		n += 2
	}
	if m.GroupID != 0 {
		n += 1 + sovHbase(uint64(m.GroupID))
	}
	if m.MsgID != 0 {
		n += 1 + sovHbase(uint64(m.MsgID))
	}
	if m.ToID != 0 {
		n += 1 + sovHbase(uint64(m.ToID))
	}
	if m.Pts != 0 {
		n += 1 + sovHbase(uint64(m.Pts))
	}
	l = len(m.FwdFrom)
	if l > 0 {
		n += 1 + l + sovHbase(uint64(l))
	}
	if m.ViaBotID != 0 {
		n += 2 + sovHbase(uint64(m.ViaBotID))
	}
	if m.ReplyToMsgID != 0 {
		n += 2 + sovHbase(uint64(m.ReplyToMsgID))
	}
	if m.Date != 0 {
		n += 2 + sovHbase(uint64(m.Date))
	}
	l = len(m.Message)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	if m.Media != 0 {
		n += 2 + sovHbase(uint64(m.Media))
	}
	l = len(m.MediaData)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			l = len(b)
			n += 2 + l + sovHbase(uint64(l))
		}
	}
	if m.FromID != 0 {
		n += 2 + sovHbase(uint64(m.FromID))
	}
	if m.Views != 0 {
		n += 2 + sovHbase(uint64(m.Views))
	}
	if m.EditDate != 0 {
		n += 2 + sovHbase(uint64(m.EditDate))
	}
	l = len(m.Action)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	if m.RandomID != 0 {
		n += 2 + sovHbase(uint64(m.RandomID))
	}
	if m.UUID != 0 {
		n += 2 + sovHbase(uint64(m.UUID))
	}
	if m.InsertDate != 0 {
		n += 2 + sovHbase(uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		n += 2 + sovHbase(uint64(m.UpdateDate))
	}
	if m.Encry != 0 {
		n += 2 + sovHbase(uint64(m.Encry))
	}
	if m.Combination != nil {
		l = m.Combination.Size()
		n += 2 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *Combination) Size() (n int) {
	var l int
	_ = l
	if len(m.MentionedSlice) > 0 {
		for _, e := range m.MentionedSlice {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	if len(m.KeyID) > 0 {
		l = 0
		for _, e := range m.KeyID {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	return n
}

func (m *MentionStatus) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.Status != 0 {
		n += 1 + sovHbase(uint64(m.Status))
	}
	return n
}

func sovHbase(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHbase(x uint64) (n int) {
	return sovHbase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetMsgIDPtsByDateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMsgIDPtsByDateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMsgIDPtsByDateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMsgIDPtsByDateResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMsgIDPtsByDateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMsgIDPtsByDateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Pts = append(m.Pts, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Pts = append(m.Pts, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMsgID", wireType)
			}
			m.LastMsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMsgByUserIDWithIDWithTypeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMsgByUserIDWithIDWithTypeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMsgByUserIDWithIDWithTypeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMsgByUserIDWithIDWithTypeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMsgByUserIDWithIDWithTypeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMsgByUserIDWithIDWithTypeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchDeleteUserMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchDeleteUserMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchDeleteUserMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchDeleteUserMsgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchDeleteUserMsgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchDeleteUserMsgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMsgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMsgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMsgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMediaMsgHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMediaMsgHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMediaMsgHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgID", wireType)
			}
			m.MaxMsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medias = append(m.Medias, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medias = append(m.Medias, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMediaMsgHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMediaMsgHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMediaMsgHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &UserMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgListByUUIDSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgListByUUIDSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgListByUUIDSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UUIDs = append(m.UUIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UUIDs = append(m.UUIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UUIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgListByUUIDSResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgListByUUIDSResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgListByUUIDSResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &UserMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgIDByUUIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgIDByUUIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgIDByUUIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			m.UUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgIDByUUIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgIDByUUIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgIDByUUIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgByUserIDMsgIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgByUserIDMsgIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &UserMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgByUserIDMsgIDsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgByUserIDMsgIDsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgByUserIDMsgIDsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &UserMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgUUIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgUUIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgUUIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMsgUUIDResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMsgUUIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMsgUUIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			m.UUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &UserMessage{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromID", wireType)
			}
			m.FromID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medias = append(m.Medias, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medias = append(m.Medias, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetID", wireType)
			}
			m.OffsetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOffset", wireType)
			}
			m.AddOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDate", wireType)
			}
			m.MinDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDate", wireType)
			}
			m.MaxDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinID", wireType)
			}
			m.MinID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &UserMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMessageHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMessageHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMessageHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetID", wireType)
			}
			m.OffsetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetDate", wireType)
			}
			m.OffsetDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOffset", wireType)
			}
			m.AddOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinID", wireType)
			}
			m.MinID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserMessageHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserMessageHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserMessageHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &UserMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindForwardUserMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindForwardUserMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindForwardUserMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIDs = append(m.MsgIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIDs = append(m.MsgIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDs", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindForwardUserMsgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindForwardUserMsgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindForwardUserMsgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &ForwardUserMsg{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ForwardUserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ForwardUserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ForwardUserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotID", wireType)
			}
			m.ViaBotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaData = append(m.MediaData[:0], dAtA[iNdEx:postIndex]...)
			if m.MediaData == nil {
				m.MediaData = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdFrom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwdFrom = append(m.FwdFrom[:0], dAtA[iNdEx:postIndex]...)
			if m.FwdFrom == nil {
				m.FwdFrom = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, make([]byte, postIndex-iNdEx))
			copy(m.Entities[len(m.Entities)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithID", wireType)
			}
			m.WithID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Out = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentioned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mentioned = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaUnread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MediaUnread = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Post = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToID", wireType)
			}
			m.ToID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdFrom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwdFrom = append(m.FwdFrom[:0], dAtA[iNdEx:postIndex]...)
			if m.FwdFrom == nil {
				m.FwdFrom = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotID", wireType)
			}
			m.ViaBotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMsgID", wireType)
			}
			m.ReplyToMsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaData = append(m.MediaData[:0], dAtA[iNdEx:postIndex]...)
			if m.MediaData == nil {
				m.MediaData = []byte{}
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, make([]byte, postIndex-iNdEx))
			copy(m.Entities[len(m.Entities)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromID", wireType)
			}
			m.FromID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			m.Views = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Views |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			m.EditDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = append(m.Action[:0], dAtA[iNdEx:postIndex]...)
			if m.Action == nil {
				m.Action = []byte{}
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomID", wireType)
			}
			m.RandomID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			m.UUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UUID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertDate", wireType)
			}
			m.InsertDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDate", wireType)
			}
			m.UpdateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Combination == nil {
				m.Combination = &Combination{}
			}
			if err := m.Combination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Combination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Combination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Combination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedSlice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MentionedSlice = append(m.MentionedSlice, &MentionStatus{})
			if err := m.MentionedSlice[len(m.MentionedSlice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyID = append(m.KeyID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyID = append(m.KeyID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MentionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MentionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MentionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHbase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHbase
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHbase(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHbase = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHbase   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("hbase.proto", fileDescriptorHbase) }

var fileDescriptorHbase = []byte{
	// 1658 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcd, 0x72, 0xdc, 0xc4,
	0x13, 0xb7, 0xf6, 0xc3, 0x5e, 0xf7, 0x6e, 0x9c, 0xf5, 0xf8, 0x23, 0x8a, 0xe2, 0x6c, 0xf6, 0x2f,
	0xff, 0x2b, 0x71, 0x72, 0x70, 0x51, 0x09, 0x29, 0xa8, 0xe2, 0x10, 0x6c, 0xaf, 0xed, 0x2c, 0x64,
	0x63, 0x97, 0xec, 0x0d, 0x95, 0x0b, 0x29, 0xd9, 0x52, 0x6c, 0xc1, 0x7a, 0x25, 0x34, 0x32, 0xc9,
	0x52, 0x1c, 0x79, 0x00, 0x0e, 0xbc, 0x02, 0xdc, 0x38, 0xc1, 0x23, 0x70, 0xe0, 0xc8, 0x1b, 0x40,
	0xe5, 0x09, 0xb8, 0x73, 0xa1, 0xa6, 0x47, 0x1a, 0x8d, 0xb4, 0xd2, 0x7a, 0xed, 0x72, 0xc8, 0x4d,
	0xdd, 0x33, 0xd3, 0xd3, 0x1f, 0xbf, 0xe9, 0x9e, 0x69, 0x41, 0xf5, 0xf8, 0xc0, 0xa4, 0xf6, 0xaa,
	0xe7, 0xbb, 0x81, 0x4b, 0x6a, 0x27, 0x36, 0xa5, 0xe6, 0x91, 0x6d, 0x1d, 0xb8, 0x3d, 0x4b, 0x0f,
	0x60, 0x7e, 0xdb, 0x0e, 0x3a, 0xf4, 0xa8, 0xdd, 0xda, 0x0d, 0xe8, 0xfa, 0xa0, 0x65, 0x06, 0xb6,
	0x61, 0x7f, 0x45, 0x16, 0x61, 0xb2, 0x4b, 0x6d, 0xbf, 0xdd, 0x52, 0x95, 0xa6, 0xb2, 0x52, 0x36,
	0x42, 0x8a, 0x10, 0x28, 0xb1, 0x29, 0x6a, 0x01, 0xb9, 0xf8, 0x4d, 0xde, 0x83, 0x72, 0x6b, 0x7f,
	0xe0, 0xd9, 0x6a, 0xb1, 0xa9, 0xac, 0xcc, 0xdc, 0xd7, 0x56, 0xe5, 0x1d, 0x56, 0x5b, 0x6b, 0xfb,
	0x6b, 0xeb, 0x6b, 0x7b, 0x9b, 0xfb, 0xcf, 0x77, 0x37, 0x0d, 0x3e, 0x51, 0x7f, 0x04, 0x0b, 0x19,
	0xbb, 0x52, 0x8f, 0xcc, 0x43, 0x19, 0xb9, 0xe1, 0xae, 0x9c, 0x20, 0x75, 0x28, 0xee, 0x06, 0x34,
	0xdc, 0x93, 0x7d, 0xea, 0x3f, 0x2a, 0x70, 0x75, 0xa3, 0x67, 0x9b, 0xfe, 0x63, 0x87, 0x06, 0xae,
	0x3f, 0x18, 0xa5, 0xf2, 0x22, 0x4c, 0x7e, 0xe6, 0x04, 0xc7, 0xed, 0x56, 0x28, 0x20, 0xa4, 0x88,
	0x06, 0x15, 0xf6, 0x25, 0x34, 0x2f, 0x1b, 0x82, 0x66, 0x7a, 0x3c, 0x71, 0x4e, 0x9c, 0x40, 0x2d,
	0x71, 0x3d, 0x90, 0x88, 0x0d, 0x2d, 0x8f, 0x6b, 0xa8, 0x07, 0xf5, 0xa4, 0x9a, 0xd4, 0x63, 0xfa,
	0xa0, 0x59, 0x54, 0x55, 0x9a, 0x45, 0xa6, 0x0f, 0xa7, 0x62, 0x2b, 0x8b, 0xa1, 0x95, 0x64, 0x09,
	0xa6, 0x9f, 0x98, 0x94, 0xfb, 0x29, 0x54, 0x31, 0x66, 0x30, 0x1d, 0x37, 0xdc, 0xd3, 0xbe, 0xd0,
	0x11, 0x09, 0xfd, 0x27, 0x05, 0x6e, 0xb7, 0xec, 0x9e, 0x1d, 0xd8, 0xcc, 0xfc, 0x0e, 0x3d, 0x5a,
	0x1f, 0x70, 0x3f, 0x70, 0xab, 0x23, 0x0b, 0x2f, 0xdb, 0x61, 0xc2, 0x35, 0xa5, 0x71, 0x5d, 0x73,
	0x17, 0xee, 0x8c, 0xa5, 0x27, 0xf5, 0xf4, 0x01, 0x2c, 0xac, 0x9b, 0xc1, 0xe1, 0x71, 0x62, 0xfe,
	0x19, 0x16, 0x84, 0x2e, 0x2e, 0x24, 0x5c, 0x7c, 0x7e, 0xa4, 0xaa, 0xb0, 0x98, 0xb5, 0x35, 0xf5,
	0x74, 0x1f, 0xea, 0x63, 0xeb, 0x23, 0x60, 0x5d, 0x90, 0x61, 0x7d, 0x7e, 0x6d, 0xe6, 0x60, 0x76,
	0x58, 0x91, 0x3f, 0x15, 0x7e, 0x9a, 0x6c, 0xcb, 0x31, 0x3b, 0xf4, 0xe8, 0x2d, 0x9d, 0x08, 0x0d,
	0x2a, 0x1d, 0xf3, 0x35, 0xb7, 0x82, 0x03, 0x4e, 0xd0, 0xe8, 0x6e, 0xb6, 0x3b, 0x55, 0xcb, 0xa1,
	0xbb, 0x91, 0x8a, 0x4f, 0xd1, 0x64, 0xe6, 0x29, 0x9a, 0x1a, 0xd7, 0xec, 0x1d, 0x58, 0xcc, 0x32,
	0x90, 0x7a, 0xe4, 0x21, 0x54, 0x3a, 0x7c, 0x35, 0x3f, 0x4d, 0xd5, 0xfb, 0xd7, 0x93, 0xe2, 0xd0,
	0x51, 0x9c, 0x61, 0x88, 0xa9, 0xfa, 0x37, 0xa0, 0x6e, 0xdb, 0x41, 0xe8, 0xc4, 0x27, 0x0e, 0x0d,
	0xd6, 0x07, 0xdd, 0x6e, 0xbb, 0xb5, 0x37, 0xca, 0x69, 0x42, 0xed, 0xc2, 0x98, 0x6a, 0x33, 0xf3,
	0x99, 0x54, 0xaa, 0x16, 0x9b, 0xc5, 0x95, 0xa2, 0xc1, 0x09, 0xdd, 0x80, 0xeb, 0x39, 0x7b, 0x5f,
	0xdc, 0x9e, 0x53, 0x44, 0x40, 0x28, 0xb3, 0xdd, 0xe2, 0x12, 0xcf, 0x48, 0xe3, 0x6c, 0x0a, 0xda,
	0x52, 0x34, 0xf0, 0xfb, 0x02, 0x70, 0xdc, 0xc2, 0xb8, 0x0c, 0x6d, 0xcb, 0x73, 0x5c, 0x88, 0x30,
	0x25, 0x81, 0xb0, 0xcc, 0x83, 0xa0, 0x7f, 0x0b, 0x5a, 0x2c, 0x27, 0xca, 0x03, 0x38, 0xf4, 0x5f,
	0x1c, 0x2a, 0x03, 0x6e, 0xe4, 0xee, 0x4e, 0x3d, 0xf2, 0x00, 0xa6, 0x42, 0x3f, 0xe3, 0xfe, 0x23,
	0x23, 0x12, 0xcd, 0xd4, 0x7f, 0x51, 0x72, 0x85, 0xd2, 0xcb, 0x3e, 0x99, 0x71, 0xb2, 0x2b, 0x65,
	0x27, 0xbb, 0xb1, 0xab, 0x55, 0x17, 0x96, 0xf2, 0x95, 0xbe, 0x38, 0x3a, 0x29, 0xcc, 0xc6, 0x62,
	0xcf, 0x42, 0xe6, 0x65, 0x45, 0xf5, 0x63, 0x20, 0xe9, 0x4d, 0xa9, 0x27, 0x70, 0xaf, 0x48, 0xb8,
	0xcf, 0xf1, 0xb9, 0xfe, 0xbd, 0x02, 0xf5, 0x6d, 0x3b, 0xd8, 0x77, 0xbd, 0xc8, 0xa4, 0x77, 0x5e,
	0x33, 0x1f, 0xa3, 0x27, 0x65, 0x8d, 0x2e, 0x0a, 0xd0, 0xbf, 0x0b, 0x50, 0xdf, 0xb3, 0x4d, 0xff,
	0xf0, 0xf8, 0x2d, 0x19, 0xb7, 0x08, 0x93, 0x5b, 0xbe, 0x7b, 0x22, 0xaa, 0x45, 0x48, 0xe5, 0xd6,
	0x0a, 0x0d, 0x2a, 0x3b, 0x2f, 0x5f, 0x52, 0x3b, 0x68, 0xb7, 0xc2, 0x72, 0x21, 0x68, 0x76, 0x0f,
	0x5a, 0xb3, 0x2c, 0x4e, 0x62, 0xd5, 0x28, 0x1b, 0x31, 0x23, 0x76, 0x63, 0xe5, 0x1c, 0x89, 0x99,
	0xd7, 0xa5, 0x69, 0xb9, 0x2e, 0xa9, 0x30, 0xd5, 0x71, 0xfa, 0x78, 0xbb, 0x05, 0xe4, 0x47, 0x24,
	0x8e, 0x98, 0xaf, 0x71, 0xa4, 0x1a, 0x8e, 0x70, 0x12, 0xd1, 0xea, 0xf4, 0xdb, 0x2d, 0xb5, 0x16,
	0xa2, 0x95, 0x11, 0xc8, 0x35, 0x5f, 0xb7, 0x5b, 0xea, 0x95, 0x90, 0xcb, 0x08, 0xfd, 0x13, 0x98,
	0x4d, 0x79, 0xfc, 0xe2, 0x47, 0xea, 0xd7, 0x42, 0x5c, 0xc1, 0x38, 0xef, 0xed, 0x95, 0x7d, 0x11,
	0x96, 0x52, 0x2a, 0x2c, 0x0d, 0x00, 0xfe, 0x8d, 0x9e, 0x29, 0xe3, 0xa8, 0xc4, 0x49, 0x86, 0x6d,
	0x32, 0x37, 0x6c, 0x53, 0xe7, 0x0e, 0x5b, 0x45, 0x0e, 0x9b, 0x08, 0xc1, 0x74, 0x66, 0x08, 0x40,
	0x0e, 0x81, 0x54, 0x7b, 0x53, 0x5e, 0xbb, 0x78, 0x28, 0x7e, 0x56, 0x60, 0x61, 0xcb, 0xe9, 0x5b,
	0x5b, 0xae, 0xff, 0xca, 0xf4, 0xad, 0xf1, 0x6e, 0xa7, 0xef, 0x30, 0xc9, 0x1b, 0xb0, 0x98, 0xa5,
	0x2e, 0xf5, 0xc8, 0x87, 0x43, 0x0e, 0x58, 0x4a, 0x8a, 0x4b, 0xad, 0x89, 0x7d, 0xf0, 0x5b, 0x01,
	0x66, 0x92, 0x83, 0xe2, 0xfc, 0x5b, 0x91, 0xf1, 0x9c, 0x62, 0x81, 0xd9, 0xec, 0x1f, 0xfa, 0x83,
	0x28, 0xbf, 0x23, 0xc1, 0x4e, 0xd8, 0xb6, 0xef, 0x9e, 0x7a, 0x6d, 0x0b, 0x2d, 0x2f, 0x1a, 0x11,
	0x19, 0xd7, 0x83, 0x92, 0x5c, 0x0f, 0x18, 0x97, 0xe5, 0x8d, 0x10, 0x75, 0x9c, 0x10, 0x8f, 0xd3,
	0x49, 0xe9, 0x71, 0xaa, 0x41, 0xe5, 0x99, 0x63, 0xae, 0xbb, 0x0c, 0xc0, 0x3c, 0x75, 0x08, 0x1a,
	0xcf, 0x75, 0x98, 0x39, 0x19, 0xa4, 0xa6, 0x45, 0x7a, 0x64, 0xd0, 0x45, 0x91, 0x2d, 0x33, 0x30,
	0x11, 0x58, 0x35, 0x23, 0x66, 0x90, 0x26, 0x54, 0x0d, 0xdb, 0xeb, 0x0d, 0x3a, 0xa6, 0xff, 0xe5,
	0xa9, 0x87, 0x10, 0xab, 0x19, 0x32, 0x8b, 0x49, 0xde, 0x7a, 0x65, 0x31, 0x93, 0x31, 0x63, 0xd4,
	0x8c, 0x88, 0x64, 0xfa, 0x6c, 0xf6, 0x03, 0x27, 0x70, 0x6c, 0xaa, 0xd6, 0x9a, 0xc5, 0x95, 0x9a,
	0x21, 0x68, 0xfd, 0xbb, 0x29, 0xa8, 0x4a, 0x20, 0xbb, 0x54, 0x00, 0x35, 0xa1, 0x1a, 0x8a, 0x15,
	0x25, 0xa7, 0x6c, 0xc8, 0x2c, 0xe6, 0xd3, 0xad, 0x9e, 0x79, 0x44, 0x23, 0x9f, 0x22, 0xc1, 0x5e,
	0xa5, 0x3b, 0xa7, 0xfc, 0xf8, 0x56, 0x0c, 0xf6, 0xc9, 0x7d, 0xd3, 0x0f, 0x1c, 0xb7, 0x6f, 0x5b,
	0xe8, 0xd2, 0x8a, 0x11, 0x33, 0xf8, 0x3e, 0x96, 0x63, 0x76, 0xfb, 0xbe, 0x6d, 0x5a, 0xe8, 0xd7,
	0x8a, 0x21, 0xb3, 0x98, 0xf6, 0x7b, 0x4e, 0xcf, 0xee, 0xf3, 0xf4, 0x5b, 0x31, 0x42, 0x8a, 0x45,
	0x6f, 0xd7, 0xa5, 0x01, 0xba, 0xb3, 0x62, 0xe0, 0x77, 0x8c, 0x8b, 0x16, 0xfa, 0x51, 0xe0, 0x42,
	0xba, 0x27, 0xd4, 0x64, 0x5c, 0x10, 0x28, 0xed, 0xbb, 0x22, 0xf1, 0xe2, 0x77, 0xf4, 0xae, 0x9e,
	0x11, 0xdd, 0x03, 0x39, 0x3a, 0x57, 0x87, 0xa2, 0x23, 0xd0, 0x52, 0x4f, 0xa1, 0x45, 0x87, 0x1a,
	0x86, 0x78, 0xdf, 0xe5, 0x1b, 0xcf, 0xe2, 0x78, 0x82, 0x27, 0x10, 0x48, 0x24, 0x04, 0x4a, 0x28,
	0x9b, 0x4b, 0xa2, 0x4c, 0xa0, 0x78, 0x1e, 0x6d, 0x0b, 0x51, 0x9c, 0xc0, 0xde, 0xc2, 0x19, 0xd8,
	0x5b, 0x1c, 0xc6, 0x9e, 0x8c, 0xb0, 0x6b, 0x49, 0x84, 0x49, 0x55, 0x59, 0x4d, 0x54, 0xe5, 0x79,
	0x28, 0x3f, 0x73, 0xec, 0x57, 0x54, 0xbd, 0xce, 0xbd, 0x89, 0x04, 0x4a, 0xb2, 0x1c, 0x9e, 0xde,
	0x35, 0xee, 0x8d, 0x88, 0x66, 0x92, 0xd6, 0x0e, 0x59, 0xcc, 0xd5, 0x1b, 0xa8, 0x42, 0x48, 0xb1,
	0x35, 0x86, 0xd9, 0xb7, 0x70, 0x8f, 0x25, 0x34, 0x4b, 0xd0, 0xe2, 0xf6, 0x75, 0x53, 0xba, 0x7d,
	0x35, 0x00, 0xda, 0x7d, 0x6a, 0xfb, 0x7c, 0x97, 0x06, 0x2f, 0x22, 0x31, 0x87, 0x8d, 0x77, 0x3d,
	0xcb, 0x0c, 0x6c, 0x1c, 0xbf, 0xc5, 0xc7, 0x63, 0x4e, 0x9c, 0x4f, 0x9a, 0x72, 0x3e, 0xf9, 0x08,
	0xaa, 0x1b, 0xee, 0xc9, 0x81, 0xd3, 0x37, 0x51, 0xc5, 0xff, 0x65, 0xdd, 0x8b, 0xa4, 0x09, 0x86,
	0x3c, 0x5b, 0x3f, 0x4e, 0x2c, 0x26, 0x1b, 0x30, 0x23, 0xe0, 0xbd, 0xd7, 0x73, 0x0e, 0xed, 0x30,
	0x39, 0xde, 0x48, 0x8a, 0x0b, 0xe7, 0xec, 0x05, 0x66, 0x70, 0x4a, 0x8d, 0xd4, 0x12, 0xa6, 0xe6,
	0xa7, 0xf6, 0x00, 0x4f, 0x2c, 0xbe, 0x05, 0x91, 0xd0, 0x1f, 0xc1, 0x95, 0xc4, 0xb2, 0x51, 0x27,
	0x9e, 0xcf, 0x88, 0x4e, 0x3c, 0xa7, 0xee, 0x7d, 0x00, 0x35, 0x39, 0xc7, 0x93, 0x32, 0x28, 0x2f,
	0xea, 0x13, 0xa4, 0x06, 0x95, 0xee, 0xd3, 0x17, 0x9b, 0x4f, 0x37, 0x8c, 0xe7, 0x75, 0x85, 0x4c,
	0x43, 0x99, 0x7f, 0x16, 0xc8, 0x14, 0x14, 0x9f, 0xb5, 0x77, 0xeb, 0xa5, 0xfb, 0xff, 0x54, 0x61,
	0xae, 0x13, 0xa9, 0xbf, 0xd3, 0xb3, 0xf6, 0x6c, 0xff, 0x6b, 0xa6, 0xa7, 0x09, 0x64, 0xb8, 0x3a,
	0x90, 0xe5, 0x54, 0x1d, 0xc8, 0x2a, 0x77, 0xda, 0xff, 0xcf, 0x9e, 0x44, 0x3d, 0x7d, 0x82, 0x7c,
	0x11, 0x3f, 0x56, 0x13, 0x45, 0x98, 0xdc, 0x4e, 0x0a, 0xc8, 0xbb, 0xdf, 0x68, 0x77, 0xc6, 0x9a,
	0x87, 0x7b, 0x19, 0x70, 0x25, 0x71, 0xe7, 0x22, 0x8d, 0xe4, 0xda, 0xf4, 0x15, 0x58, 0xbb, 0x35,
	0x72, 0x3c, 0x92, 0x99, 0xb8, 0x84, 0xa7, 0x65, 0xa6, 0xdf, 0x0c, 0x69, 0x99, 0x43, 0x37, 0x78,
	0x7d, 0x82, 0x74, 0x61, 0x26, 0xf9, 0x5a, 0x21, 0xb7, 0xb2, 0x8d, 0x14, 0x0f, 0x28, 0xad, 0x39,
	0x7a, 0x02, 0x8a, 0xf5, 0xe0, 0x5a, 0xce, 0x83, 0x8e, 0xac, 0xe4, 0x2d, 0x4f, 0xbf, 0xbf, 0xb5,
	0xbb, 0x63, 0xce, 0xc4, 0x1d, 0xa9, 0xdc, 0x59, 0x49, 0x3e, 0x21, 0xc9, 0x78, 0x82, 0xd8, 0xfb,
	0x58, 0xbb, 0x37, 0xee, 0x54, 0xdc, 0xd4, 0x94, 0xdf, 0x7a, 0x51, 0x1f, 0x22, 0x0d, 0xda, 0xcc,
	0x06, 0x49, 0x1a, 0xb4, 0xd9, 0xed, 0x8c, 0x24, 0x68, 0x13, 0x5d, 0x9b, 0x3c, 0xd0, 0xa6, 0xdb,
	0x4a, 0x79, 0xa0, 0x1d, 0x6a, 0x01, 0x09, 0x73, 0x52, 0xed, 0xae, 0x0c, 0x73, 0x86, 0x3b, 0x7e,
	0x19, 0xe6, 0x64, 0x74, 0xcd, 0x38, 0x86, 0x13, 0x8d, 0xc4, 0x34, 0x86, 0xd3, 0x9d, 0xcd, 0x34,
	0x86, 0x87, 0xbb, 0x90, 0xa8, 0xf6, 0x70, 0xab, 0x34, 0xad, 0x76, 0x66, 0x1f, 0x37, 0xad, 0x76,
	0x4e, 0xc7, 0x75, 0x82, 0xfc, 0xa0, 0xc0, 0xf2, 0x18, 0x4d, 0x63, 0xf2, 0xfe, 0x08, 0x6d, 0x73,
	0xfb, 0xe1, 0xda, 0xc3, 0x0b, 0xac, 0x42, 0xb5, 0x76, 0xa0, 0x26, 0x77, 0xf9, 0xc9, 0xcd, 0x54,
	0xa1, 0x49, 0xfe, 0xa8, 0xd0, 0x1a, 0xa3, 0x86, 0x51, 0xe0, 0xe7, 0xf8, 0xce, 0x4f, 0xfe, 0x1f,
	0x21, 0xfa, 0x70, 0x6c, 0xd3, 0xbf, 0x6d, 0xb4, 0xe5, 0x33, 0xe7, 0x30, 0xf9, 0xeb, 0xcb, 0xbf,
	0xbf, 0x69, 0x28, 0x7f, 0xbc, 0x69, 0x28, 0x7f, 0xbd, 0x69, 0x28, 0x30, 0xe7, 0x9c, 0xac, 0x7a,
	0x41, 0xb4, 0x92, 0xff, 0x26, 0xda, 0x55, 0x0e, 0x26, 0xf1, 0xe3, 0xc1, 0xbf, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x9e, 0x4a, 0xa9, 0xea, 0x3e, 0x1a, 0x00, 0x00,
}
