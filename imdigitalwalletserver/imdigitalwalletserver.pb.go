// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imdigitalwalletserver/imdigitalwalletserver.proto

/*
Package imdigitalwalletserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/imdigitalwalletserver/imdigitalwalletserver.proto

It has these top-level messages:

	Status
	ReqDigitalWalletUniversalBusiness
	ReplyDigitalWalletUniversalBusiness
	GenerateRechargeAddressReq
	GenerateRechargeAddressResp
	UserRechargeReq
	UserRechargeResp
	UserSwapReq
	UserSwapResp
	QueryRechargeableTokensReq
	AbleToken
	QueryRechargeableTokensResp
	QueryUserAccountInfoReq
	TokenBalance
	AccountInfo
	QueryUserAccountInfoResp
	PaginationParams
	DateParams
	QueryUserRechargeDetailsReq
	RechargeDetail
	QueryUserRechargeDetailsResp
	QueryUserSwapDetailsReq
	SwapDetail
	QueryUserSwapDetailsResp
	BackgroundManageOptReq
	BackgroundManageOptResp
*/
package imdigitalwalletserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Code int32

const (
	Code_Success               Code = 0
	Code_ErrorSystem           Code = 1
	Code_ErrorInvalidRequest   Code = 2
	Code_ErrorInvalidParameter Code = 3
	Code_ErrorQueryNotExist    Code = 4
)

var Code_name = map[int32]string{
	0: "Success",
	1: "ErrorSystem",
	2: "ErrorInvalidRequest",
	3: "ErrorInvalidParameter",
	4: "ErrorQueryNotExist",
}
var Code_value = map[string]int32{
	"Success":               0,
	"ErrorSystem":           1,
	"ErrorInvalidRequest":   2,
	"ErrorInvalidParameter": 3,
	"ErrorQueryNotExist":    4,
}

func (x Code) String() string {
	return proto.EnumName(Code_name, int32(x))
}
func (Code) EnumDescriptor() ([]byte, []int) { return fileDescriptorImdigitalwalletserver, []int{0} }

// 后台管理接口
type BusinessCodeEnum int32

const (
	BusinessCodeEnum_WalletWords               BusinessCodeEnum = 0
	BusinessCodeEnum_WalletCreate              BusinessCodeEnum = 1
	BusinessCodeEnum_WalletActive              BusinessCodeEnum = 2
	BusinessCodeEnum_GetWallets                BusinessCodeEnum = 3
	BusinessCodeEnum_ConfigureCollectionAmount BusinessCodeEnum = 4
	BusinessCodeEnum_WalletRecords             BusinessCodeEnum = 5
	BusinessCodeEnum_GetChains                 BusinessCodeEnum = 6
)

var BusinessCodeEnum_name = map[int32]string{
	0: "WalletWords",
	1: "WalletCreate",
	2: "WalletActive",
	3: "GetWallets",
	4: "ConfigureCollectionAmount",
	5: "WalletRecords",
	6: "GetChains",
}
var BusinessCodeEnum_value = map[string]int32{
	"WalletWords":               0,
	"WalletCreate":              1,
	"WalletActive":              2,
	"GetWallets":                3,
	"ConfigureCollectionAmount": 4,
	"WalletRecords":             5,
	"GetChains":                 6,
}

func (x BusinessCodeEnum) String() string {
	return proto.EnumName(BusinessCodeEnum_name, int32(x))
}
func (BusinessCodeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{1}
}

type Status struct {
	Code   Code   `protobuf:"varint,1,opt,name=Code,proto3,enum=imdigitalwalletserver.Code" json:"Code,omitempty"`
	ErrMsg string `protobuf:"bytes,2,opt,name=ErrMsg,proto3" json:"ErrMsg,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptorImdigitalwalletserver, []int{0} }

func (m *Status) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return Code_Success
}

func (m *Status) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

// ----------------------------------------------------------------------------------------------------------------------------------------------------------------
// 数字钱包业务通用协议请求
type ReqDigitalWalletUniversalBusiness struct {
	Ip         string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	UserId     int64  `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	AppUserId  int64  `protobuf:"varint,3,opt,name=appUserId,proto3" json:"appUserId,omitempty"`
	BusinessId int32  `protobuf:"varint,4,opt,name=businessId,proto3" json:"businessId,omitempty"`
	Uuid       string `protobuf:"bytes,5,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Phone      string `protobuf:"bytes,6,opt,name=phone,proto3" json:"phone,omitempty"`
	Data       []byte `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ReqDigitalWalletUniversalBusiness) Reset()         { *m = ReqDigitalWalletUniversalBusiness{} }
func (m *ReqDigitalWalletUniversalBusiness) String() string { return proto.CompactTextString(m) }
func (*ReqDigitalWalletUniversalBusiness) ProtoMessage()    {}
func (*ReqDigitalWalletUniversalBusiness) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{1}
}

func (m *ReqDigitalWalletUniversalBusiness) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ReqDigitalWalletUniversalBusiness) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqDigitalWalletUniversalBusiness) GetAppUserId() int64 {
	if m != nil {
		return m.AppUserId
	}
	return 0
}

func (m *ReqDigitalWalletUniversalBusiness) GetBusinessId() int32 {
	if m != nil {
		return m.BusinessId
	}
	return 0
}

func (m *ReqDigitalWalletUniversalBusiness) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ReqDigitalWalletUniversalBusiness) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *ReqDigitalWalletUniversalBusiness) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 数字钱包业务通用协议响应
type ReplyDigitalWalletUniversalBusiness struct {
	Data string `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ReplyDigitalWalletUniversalBusiness) Reset()         { *m = ReplyDigitalWalletUniversalBusiness{} }
func (m *ReplyDigitalWalletUniversalBusiness) String() string { return proto.CompactTextString(m) }
func (*ReplyDigitalWalletUniversalBusiness) ProtoMessage()    {}
func (*ReplyDigitalWalletUniversalBusiness) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{2}
}

func (m *ReplyDigitalWalletUniversalBusiness) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// 用户充值地址生成
type GenerateRechargeAddressReq struct {
	UserId   int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Chain    string        `protobuf:"bytes,2,opt,name=Chain,proto3" json:"Chain,omitempty"`
	Contract string        `protobuf:"bytes,3,opt,name=Contract,proto3" json:"Contract,omitempty"`
	Debug    *pbcomm.Debug `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *GenerateRechargeAddressReq) Reset()         { *m = GenerateRechargeAddressReq{} }
func (m *GenerateRechargeAddressReq) String() string { return proto.CompactTextString(m) }
func (*GenerateRechargeAddressReq) ProtoMessage()    {}
func (*GenerateRechargeAddressReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{3}
}

func (m *GenerateRechargeAddressReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GenerateRechargeAddressReq) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *GenerateRechargeAddressReq) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *GenerateRechargeAddressReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type GenerateRechargeAddressResp struct {
	Status  *Status `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
	Address string  `protobuf:"bytes,2,opt,name=Address,proto3" json:"Address,omitempty"`
}

func (m *GenerateRechargeAddressResp) Reset()         { *m = GenerateRechargeAddressResp{} }
func (m *GenerateRechargeAddressResp) String() string { return proto.CompactTextString(m) }
func (*GenerateRechargeAddressResp) ProtoMessage()    {}
func (*GenerateRechargeAddressResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{4}
}

func (m *GenerateRechargeAddressResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *GenerateRechargeAddressResp) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// 用户充值
type UserRechargeReq struct {
	UserId      int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Chain       string        `protobuf:"bytes,2,opt,name=Chain,proto3" json:"Chain,omitempty"`
	Contract    string        `protobuf:"bytes,3,opt,name=Contract,proto3" json:"Contract,omitempty"`
	FromAddress string        `protobuf:"bytes,4,opt,name=FromAddress,proto3" json:"FromAddress,omitempty"`
	ToAddress   string        `protobuf:"bytes,5,opt,name=ToAddress,proto3" json:"ToAddress,omitempty"`
	Value       string        `protobuf:"bytes,6,opt,name=Value,proto3" json:"Value,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *UserRechargeReq) Reset()         { *m = UserRechargeReq{} }
func (m *UserRechargeReq) String() string { return proto.CompactTextString(m) }
func (*UserRechargeReq) ProtoMessage()    {}
func (*UserRechargeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{5}
}

func (m *UserRechargeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserRechargeReq) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *UserRechargeReq) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *UserRechargeReq) GetFromAddress() string {
	if m != nil {
		return m.FromAddress
	}
	return ""
}

func (m *UserRechargeReq) GetToAddress() string {
	if m != nil {
		return m.ToAddress
	}
	return ""
}

func (m *UserRechargeReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *UserRechargeReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UserRechargeResp struct {
	Status *Status `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
}

func (m *UserRechargeResp) Reset()         { *m = UserRechargeResp{} }
func (m *UserRechargeResp) String() string { return proto.CompactTextString(m) }
func (*UserRechargeResp) ProtoMessage()    {}
func (*UserRechargeResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{6}
}

func (m *UserRechargeResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// 用户兑换
type UserSwapReq struct {
	UserId       int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	FromChain    string        `protobuf:"bytes,2,opt,name=FromChain,proto3" json:"FromChain,omitempty"`
	FromContract string        `protobuf:"bytes,3,opt,name=FromContract,proto3" json:"FromContract,omitempty"`
	ToChain      string        `protobuf:"bytes,4,opt,name=ToChain,proto3" json:"ToChain,omitempty"`
	ToContract   string        `protobuf:"bytes,5,opt,name=ToContract,proto3" json:"ToContract,omitempty"`
	Value        string        `protobuf:"bytes,6,opt,name=Value,proto3" json:"Value,omitempty"`
	FromType     int32         `protobuf:"varint,7,opt,name=FromType,proto3" json:"FromType,omitempty"`
	ToType       int32         `protobuf:"varint,8,opt,name=ToType,proto3" json:"ToType,omitempty"`
	Debug        *pbcomm.Debug `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *UserSwapReq) Reset()         { *m = UserSwapReq{} }
func (m *UserSwapReq) String() string { return proto.CompactTextString(m) }
func (*UserSwapReq) ProtoMessage()    {}
func (*UserSwapReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{7}
}

func (m *UserSwapReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserSwapReq) GetFromChain() string {
	if m != nil {
		return m.FromChain
	}
	return ""
}

func (m *UserSwapReq) GetFromContract() string {
	if m != nil {
		return m.FromContract
	}
	return ""
}

func (m *UserSwapReq) GetToChain() string {
	if m != nil {
		return m.ToChain
	}
	return ""
}

func (m *UserSwapReq) GetToContract() string {
	if m != nil {
		return m.ToContract
	}
	return ""
}

func (m *UserSwapReq) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *UserSwapReq) GetFromType() int32 {
	if m != nil {
		return m.FromType
	}
	return 0
}

func (m *UserSwapReq) GetToType() int32 {
	if m != nil {
		return m.ToType
	}
	return 0
}

func (m *UserSwapReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UserSwapResp struct {
	Status *Status `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
}

func (m *UserSwapResp) Reset()         { *m = UserSwapResp{} }
func (m *UserSwapResp) String() string { return proto.CompactTextString(m) }
func (*UserSwapResp) ProtoMessage()    {}
func (*UserSwapResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{8}
}

func (m *UserSwapResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// 查询可充值代币
type QueryRechargeableTokensReq struct {
	Debug *pbcomm.Debug `protobuf:"bytes,1,opt,name=debug" json:"debug,omitempty"`
}

func (m *QueryRechargeableTokensReq) Reset()         { *m = QueryRechargeableTokensReq{} }
func (m *QueryRechargeableTokensReq) String() string { return proto.CompactTextString(m) }
func (*QueryRechargeableTokensReq) ProtoMessage()    {}
func (*QueryRechargeableTokensReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{9}
}

func (m *QueryRechargeableTokensReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 可用代币列表
type AbleToken struct {
	Chain     string `protobuf:"bytes,1,opt,name=Chain,proto3" json:"Chain,omitempty"`
	Contract  string `protobuf:"bytes,2,opt,name=Contract,proto3" json:"Contract,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	PriceUsdt string `protobuf:"bytes,4,opt,name=PriceUsdt,proto3" json:"PriceUsdt,omitempty"`
	PriceDct  string `protobuf:"bytes,5,opt,name=PriceDct,proto3" json:"PriceDct,omitempty"`
	Fee       string `protobuf:"bytes,6,opt,name=Fee,proto3" json:"Fee,omitempty"`
	Type      int32  `protobuf:"varint,7,opt,name=Type,proto3" json:"Type,omitempty"`
}

func (m *AbleToken) Reset()                    { *m = AbleToken{} }
func (m *AbleToken) String() string            { return proto.CompactTextString(m) }
func (*AbleToken) ProtoMessage()               {}
func (*AbleToken) Descriptor() ([]byte, []int) { return fileDescriptorImdigitalwalletserver, []int{10} }

func (m *AbleToken) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *AbleToken) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *AbleToken) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AbleToken) GetPriceUsdt() string {
	if m != nil {
		return m.PriceUsdt
	}
	return ""
}

func (m *AbleToken) GetPriceDct() string {
	if m != nil {
		return m.PriceDct
	}
	return ""
}

func (m *AbleToken) GetFee() string {
	if m != nil {
		return m.Fee
	}
	return ""
}

func (m *AbleToken) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type QueryRechargeableTokensResp struct {
	Status    *Status      `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
	TokenList []*AbleToken `protobuf:"bytes,2,rep,name=TokenList" json:"TokenList,omitempty"`
}

func (m *QueryRechargeableTokensResp) Reset()         { *m = QueryRechargeableTokensResp{} }
func (m *QueryRechargeableTokensResp) String() string { return proto.CompactTextString(m) }
func (*QueryRechargeableTokensResp) ProtoMessage()    {}
func (*QueryRechargeableTokensResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{11}
}

func (m *QueryRechargeableTokensResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QueryRechargeableTokensResp) GetTokenList() []*AbleToken {
	if m != nil {
		return m.TokenList
	}
	return nil
}

// 查询用户账户信息（余额信息）
type QueryUserAccountInfoReq struct {
	UserId int32         `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *QueryUserAccountInfoReq) Reset()         { *m = QueryUserAccountInfoReq{} }
func (m *QueryUserAccountInfoReq) String() string { return proto.CompactTextString(m) }
func (*QueryUserAccountInfoReq) ProtoMessage()    {}
func (*QueryUserAccountInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{12}
}

func (m *QueryUserAccountInfoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *QueryUserAccountInfoReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type TokenBalance struct {
	Chain       string `protobuf:"bytes,1,opt,name=Chain,proto3" json:"Chain,omitempty"`
	Contract    string `protobuf:"bytes,2,opt,name=Contract,proto3" json:"Contract,omitempty"`
	Name        string `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Balance     string `protobuf:"bytes,4,opt,name=Balance,proto3" json:"Balance,omitempty"`
	Frozen      string `protobuf:"bytes,5,opt,name=Frozen,proto3" json:"Frozen,omitempty"`
	BalanceUSDT string `protobuf:"bytes,6,opt,name=BalanceUSDT,proto3" json:"BalanceUSDT,omitempty"`
	BalanceDCT  string `protobuf:"bytes,7,opt,name=BalanceDCT,proto3" json:"BalanceDCT,omitempty"`
}

func (m *TokenBalance) Reset()         { *m = TokenBalance{} }
func (m *TokenBalance) String() string { return proto.CompactTextString(m) }
func (*TokenBalance) ProtoMessage()    {}
func (*TokenBalance) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{13}
}

func (m *TokenBalance) GetChain() string {
	if m != nil {
		return m.Chain
	}
	return ""
}

func (m *TokenBalance) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *TokenBalance) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TokenBalance) GetBalance() string {
	if m != nil {
		return m.Balance
	}
	return ""
}

func (m *TokenBalance) GetFrozen() string {
	if m != nil {
		return m.Frozen
	}
	return ""
}

func (m *TokenBalance) GetBalanceUSDT() string {
	if m != nil {
		return m.BalanceUSDT
	}
	return ""
}

func (m *TokenBalance) GetBalanceDCT() string {
	if m != nil {
		return m.BalanceDCT
	}
	return ""
}

type AccountInfo struct {
	BalanceList      []*TokenBalance `protobuf:"bytes,1,rep,name=BalanceList" json:"BalanceList,omitempty"`
	TotalBalanceUSDT string          `protobuf:"bytes,2,opt,name=TotalBalanceUSDT,proto3" json:"TotalBalanceUSDT,omitempty"`
	TotalBalanceDCT  string          `protobuf:"bytes,3,opt,name=TotalBalanceDCT,proto3" json:"TotalBalanceDCT,omitempty"`
	TotalAssets      string          `protobuf:"bytes,4,opt,name=TotalAssets,proto3" json:"TotalAssets,omitempty"`
	Status           int32           `protobuf:"varint,5,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *AccountInfo) Reset()         { *m = AccountInfo{} }
func (m *AccountInfo) String() string { return proto.CompactTextString(m) }
func (*AccountInfo) ProtoMessage()    {}
func (*AccountInfo) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{14}
}

func (m *AccountInfo) GetBalanceList() []*TokenBalance {
	if m != nil {
		return m.BalanceList
	}
	return nil
}

func (m *AccountInfo) GetTotalBalanceUSDT() string {
	if m != nil {
		return m.TotalBalanceUSDT
	}
	return ""
}

func (m *AccountInfo) GetTotalBalanceDCT() string {
	if m != nil {
		return m.TotalBalanceDCT
	}
	return ""
}

func (m *AccountInfo) GetTotalAssets() string {
	if m != nil {
		return m.TotalAssets
	}
	return ""
}

func (m *AccountInfo) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type QueryUserAccountInfoResp struct {
	Status      *Status      `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
	AccountInfo *AccountInfo `protobuf:"bytes,2,opt,name=AccountInfo" json:"AccountInfo,omitempty"`
}

func (m *QueryUserAccountInfoResp) Reset()         { *m = QueryUserAccountInfoResp{} }
func (m *QueryUserAccountInfoResp) String() string { return proto.CompactTextString(m) }
func (*QueryUserAccountInfoResp) ProtoMessage()    {}
func (*QueryUserAccountInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{15}
}

func (m *QueryUserAccountInfoResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QueryUserAccountInfoResp) GetAccountInfo() *AccountInfo {
	if m != nil {
		return m.AccountInfo
	}
	return nil
}

// 分页参数
type PaginationParams struct {
	PageNumber uint32 `protobuf:"varint,1,opt,name=PageNumber,proto3" json:"PageNumber,omitempty"`
	PageSize   uint32 `protobuf:"varint,2,opt,name=PageSize,proto3" json:"PageSize,omitempty"`
}

func (m *PaginationParams) Reset()         { *m = PaginationParams{} }
func (m *PaginationParams) String() string { return proto.CompactTextString(m) }
func (*PaginationParams) ProtoMessage()    {}
func (*PaginationParams) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{16}
}

func (m *PaginationParams) GetPageNumber() uint32 {
	if m != nil {
		return m.PageNumber
	}
	return 0
}

func (m *PaginationParams) GetPageSize() uint32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// 日期参数
type DateParams struct {
	Year  uint32 `protobuf:"varint,1,opt,name=Year,proto3" json:"Year,omitempty"`
	Month uint32 `protobuf:"varint,2,opt,name=Month,proto3" json:"Month,omitempty"`
	Day   uint32 `protobuf:"varint,3,opt,name=Day,proto3" json:"Day,omitempty"`
}

func (m *DateParams) Reset()         { *m = DateParams{} }
func (m *DateParams) String() string { return proto.CompactTextString(m) }
func (*DateParams) ProtoMessage()    {}
func (*DateParams) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{17}
}

func (m *DateParams) GetYear() uint32 {
	if m != nil {
		return m.Year
	}
	return 0
}

func (m *DateParams) GetMonth() uint32 {
	if m != nil {
		return m.Month
	}
	return 0
}

func (m *DateParams) GetDay() uint32 {
	if m != nil {
		return m.Day
	}
	return 0
}

// 查询用户充值明细
type QueryUserRechargeDetailsReq struct {
	UserId    int32             `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	PageParam *PaginationParams `protobuf:"bytes,2,opt,name=PageParam" json:"PageParam,omitempty"`
	DateParam *DateParams       `protobuf:"bytes,3,opt,name=DateParam" json:"DateParam,omitempty"`
	Status    uint32            `protobuf:"varint,4,opt,name=Status,proto3" json:"Status,omitempty"`
	Debug     *pbcomm.Debug     `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *QueryUserRechargeDetailsReq) Reset()         { *m = QueryUserRechargeDetailsReq{} }
func (m *QueryUserRechargeDetailsReq) String() string { return proto.CompactTextString(m) }
func (*QueryUserRechargeDetailsReq) ProtoMessage()    {}
func (*QueryUserRechargeDetailsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{18}
}

func (m *QueryUserRechargeDetailsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *QueryUserRechargeDetailsReq) GetPageParam() *PaginationParams {
	if m != nil {
		return m.PageParam
	}
	return nil
}

func (m *QueryUserRechargeDetailsReq) GetDateParam() *DateParams {
	if m != nil {
		return m.DateParam
	}
	return nil
}

func (m *QueryUserRechargeDetailsReq) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *QueryUserRechargeDetailsReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type RechargeDetail struct {
	Timestamp uint64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Value     string `protobuf:"bytes,2,opt,name=Value,proto3" json:"Value,omitempty"`
	Address   string `protobuf:"bytes,3,opt,name=Address,proto3" json:"Address,omitempty"`
	BillId    string `protobuf:"bytes,4,opt,name=BillId,proto3" json:"BillId,omitempty"`
	Status    uint32 `protobuf:"varint,5,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *RechargeDetail) Reset()         { *m = RechargeDetail{} }
func (m *RechargeDetail) String() string { return proto.CompactTextString(m) }
func (*RechargeDetail) ProtoMessage()    {}
func (*RechargeDetail) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{19}
}

func (m *RechargeDetail) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RechargeDetail) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *RechargeDetail) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RechargeDetail) GetBillId() string {
	if m != nil {
		return m.BillId
	}
	return ""
}

func (m *RechargeDetail) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type QueryUserRechargeDetailsResp struct {
	Status       *Status           `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
	RecordDetail []*RechargeDetail `protobuf:"bytes,2,rep,name=RecordDetail" json:"RecordDetail,omitempty"`
}

func (m *QueryUserRechargeDetailsResp) Reset()         { *m = QueryUserRechargeDetailsResp{} }
func (m *QueryUserRechargeDetailsResp) String() string { return proto.CompactTextString(m) }
func (*QueryUserRechargeDetailsResp) ProtoMessage()    {}
func (*QueryUserRechargeDetailsResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{20}
}

func (m *QueryUserRechargeDetailsResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QueryUserRechargeDetailsResp) GetRecordDetail() []*RechargeDetail {
	if m != nil {
		return m.RecordDetail
	}
	return nil
}

// 查询用户兑换明细
type QueryUserSwapDetailsReq struct {
	UserId    int32             `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	PageParam *PaginationParams `protobuf:"bytes,2,opt,name=PageParam" json:"PageParam,omitempty"`
	DateParam *DateParams       `protobuf:"bytes,3,opt,name=DateParam" json:"DateParam,omitempty"`
	Debug     *pbcomm.Debug     `protobuf:"bytes,11,opt,name=debug" json:"debug,omitempty"`
}

func (m *QueryUserSwapDetailsReq) Reset()         { *m = QueryUserSwapDetailsReq{} }
func (m *QueryUserSwapDetailsReq) String() string { return proto.CompactTextString(m) }
func (*QueryUserSwapDetailsReq) ProtoMessage()    {}
func (*QueryUserSwapDetailsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{21}
}

func (m *QueryUserSwapDetailsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *QueryUserSwapDetailsReq) GetPageParam() *PaginationParams {
	if m != nil {
		return m.PageParam
	}
	return nil
}

func (m *QueryUserSwapDetailsReq) GetDateParam() *DateParams {
	if m != nil {
		return m.DateParam
	}
	return nil
}

func (m *QueryUserSwapDetailsReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SwapDetail struct {
	Timestamp    uint64 `protobuf:"varint,1,opt,name=Timestamp,proto3" json:"Timestamp,omitempty"`
	Number       string `protobuf:"bytes,2,opt,name=Number,proto3" json:"Number,omitempty"`
	Value        string `protobuf:"bytes,3,opt,name=Value,proto3" json:"Value,omitempty"`
	ExchangeRate string `protobuf:"bytes,4,opt,name=ExchangeRate,proto3" json:"ExchangeRate,omitempty"`
	BillId       string `protobuf:"bytes,5,opt,name=BillId,proto3" json:"BillId,omitempty"`
}

func (m *SwapDetail) Reset()         { *m = SwapDetail{} }
func (m *SwapDetail) String() string { return proto.CompactTextString(m) }
func (*SwapDetail) ProtoMessage()    {}
func (*SwapDetail) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{22}
}

func (m *SwapDetail) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SwapDetail) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *SwapDetail) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *SwapDetail) GetExchangeRate() string {
	if m != nil {
		return m.ExchangeRate
	}
	return ""
}

func (m *SwapDetail) GetBillId() string {
	if m != nil {
		return m.BillId
	}
	return ""
}

type QueryUserSwapDetailsResp struct {
	Status       *Status       `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
	RecordDetail []*SwapDetail `protobuf:"bytes,2,rep,name=RecordDetail" json:"RecordDetail,omitempty"`
}

func (m *QueryUserSwapDetailsResp) Reset()         { *m = QueryUserSwapDetailsResp{} }
func (m *QueryUserSwapDetailsResp) String() string { return proto.CompactTextString(m) }
func (*QueryUserSwapDetailsResp) ProtoMessage()    {}
func (*QueryUserSwapDetailsResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{23}
}

func (m *QueryUserSwapDetailsResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *QueryUserSwapDetailsResp) GetRecordDetail() []*SwapDetail {
	if m != nil {
		return m.RecordDetail
	}
	return nil
}

type BackgroundManageOptReq struct {
	BusinessCode BusinessCodeEnum `protobuf:"varint,1,opt,name=BusinessCode,proto3,enum=imdigitalwalletserver.BusinessCodeEnum" json:"BusinessCode,omitempty"`
	ReqData      string           `protobuf:"bytes,2,opt,name=ReqData,proto3" json:"ReqData,omitempty"`
}

func (m *BackgroundManageOptReq) Reset()         { *m = BackgroundManageOptReq{} }
func (m *BackgroundManageOptReq) String() string { return proto.CompactTextString(m) }
func (*BackgroundManageOptReq) ProtoMessage()    {}
func (*BackgroundManageOptReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{24}
}

func (m *BackgroundManageOptReq) GetBusinessCode() BusinessCodeEnum {
	if m != nil {
		return m.BusinessCode
	}
	return BusinessCodeEnum_WalletWords
}

func (m *BackgroundManageOptReq) GetReqData() string {
	if m != nil {
		return m.ReqData
	}
	return ""
}

type BackgroundManageOptResp struct {
	Status   *Status `protobuf:"bytes,1,opt,name=Status" json:"Status,omitempty"`
	RespData string  `protobuf:"bytes,2,opt,name=RespData,proto3" json:"RespData,omitempty"`
}

func (m *BackgroundManageOptResp) Reset()         { *m = BackgroundManageOptResp{} }
func (m *BackgroundManageOptResp) String() string { return proto.CompactTextString(m) }
func (*BackgroundManageOptResp) ProtoMessage()    {}
func (*BackgroundManageOptResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImdigitalwalletserver, []int{25}
}

func (m *BackgroundManageOptResp) GetStatus() *Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BackgroundManageOptResp) GetRespData() string {
	if m != nil {
		return m.RespData
	}
	return ""
}

func init() {
	proto.RegisterType((*Status)(nil), "imdigitalwalletserver.Status")
	proto.RegisterType((*ReqDigitalWalletUniversalBusiness)(nil), "imdigitalwalletserver.ReqDigitalWalletUniversalBusiness")
	proto.RegisterType((*ReplyDigitalWalletUniversalBusiness)(nil), "imdigitalwalletserver.ReplyDigitalWalletUniversalBusiness")
	proto.RegisterType((*GenerateRechargeAddressReq)(nil), "imdigitalwalletserver.GenerateRechargeAddressReq")
	proto.RegisterType((*GenerateRechargeAddressResp)(nil), "imdigitalwalletserver.GenerateRechargeAddressResp")
	proto.RegisterType((*UserRechargeReq)(nil), "imdigitalwalletserver.UserRechargeReq")
	proto.RegisterType((*UserRechargeResp)(nil), "imdigitalwalletserver.UserRechargeResp")
	proto.RegisterType((*UserSwapReq)(nil), "imdigitalwalletserver.UserSwapReq")
	proto.RegisterType((*UserSwapResp)(nil), "imdigitalwalletserver.UserSwapResp")
	proto.RegisterType((*QueryRechargeableTokensReq)(nil), "imdigitalwalletserver.QueryRechargeableTokensReq")
	proto.RegisterType((*AbleToken)(nil), "imdigitalwalletserver.AbleToken")
	proto.RegisterType((*QueryRechargeableTokensResp)(nil), "imdigitalwalletserver.QueryRechargeableTokensResp")
	proto.RegisterType((*QueryUserAccountInfoReq)(nil), "imdigitalwalletserver.QueryUserAccountInfoReq")
	proto.RegisterType((*TokenBalance)(nil), "imdigitalwalletserver.TokenBalance")
	proto.RegisterType((*AccountInfo)(nil), "imdigitalwalletserver.AccountInfo")
	proto.RegisterType((*QueryUserAccountInfoResp)(nil), "imdigitalwalletserver.QueryUserAccountInfoResp")
	proto.RegisterType((*PaginationParams)(nil), "imdigitalwalletserver.PaginationParams")
	proto.RegisterType((*DateParams)(nil), "imdigitalwalletserver.DateParams")
	proto.RegisterType((*QueryUserRechargeDetailsReq)(nil), "imdigitalwalletserver.QueryUserRechargeDetailsReq")
	proto.RegisterType((*RechargeDetail)(nil), "imdigitalwalletserver.RechargeDetail")
	proto.RegisterType((*QueryUserRechargeDetailsResp)(nil), "imdigitalwalletserver.QueryUserRechargeDetailsResp")
	proto.RegisterType((*QueryUserSwapDetailsReq)(nil), "imdigitalwalletserver.QueryUserSwapDetailsReq")
	proto.RegisterType((*SwapDetail)(nil), "imdigitalwalletserver.SwapDetail")
	proto.RegisterType((*QueryUserSwapDetailsResp)(nil), "imdigitalwalletserver.QueryUserSwapDetailsResp")
	proto.RegisterType((*BackgroundManageOptReq)(nil), "imdigitalwalletserver.BackgroundManageOptReq")
	proto.RegisterType((*BackgroundManageOptResp)(nil), "imdigitalwalletserver.BackgroundManageOptResp")
	proto.RegisterEnum("imdigitalwalletserver.Code", Code_name, Code_value)
	proto.RegisterEnum("imdigitalwalletserver.BusinessCodeEnum", BusinessCodeEnum_name, BusinessCodeEnum_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for DigitalWalletService service

type DigitalWalletServiceClient interface {
	// 数字钱包业务通用协议
	DigitalWalletUniversalBusiness(ctx context.Context, in *ReqDigitalWalletUniversalBusiness, opts ...grpc.CallOption) (*ReplyDigitalWalletUniversalBusiness, error)
	// 用户充值地址生成
	GenerateRechargeAddress(ctx context.Context, in *GenerateRechargeAddressReq, opts ...grpc.CallOption) (*GenerateRechargeAddressResp, error)
	// 用户充值
	UserRecharge(ctx context.Context, in *UserRechargeReq, opts ...grpc.CallOption) (*UserRechargeResp, error)
	// 用户兑换
	UserSwap(ctx context.Context, in *UserSwapReq, opts ...grpc.CallOption) (*UserSwapResp, error)
	// 查询可充值代币
	QueryRechargeableTokens(ctx context.Context, in *QueryRechargeableTokensReq, opts ...grpc.CallOption) (*QueryRechargeableTokensResp, error)
	// 查询用户账户信息（余额信息）
	QueryUserAccountInfo(ctx context.Context, in *QueryUserAccountInfoReq, opts ...grpc.CallOption) (*QueryUserAccountInfoResp, error)
	// 查询用户充值明细
	QueryUserRechargeDetails(ctx context.Context, in *QueryUserRechargeDetailsReq, opts ...grpc.CallOption) (*QueryUserRechargeDetailsResp, error)
	// 查询用户兑换明细
	QueryUserSwapDetails(ctx context.Context, in *QueryUserSwapDetailsReq, opts ...grpc.CallOption) (*QueryUserSwapDetailsResp, error)
	// 后台管理接口添加
	BackgroundManageOpt(ctx context.Context, in *BackgroundManageOptReq, opts ...grpc.CallOption) (*BackgroundManageOptResp, error)
}

type digitalWalletServiceClient struct {
	cc *grpc.ClientConn
}

func NewDigitalWalletServiceClient(cc *grpc.ClientConn) DigitalWalletServiceClient {
	return &digitalWalletServiceClient{cc}
}

func (c *digitalWalletServiceClient) DigitalWalletUniversalBusiness(ctx context.Context, in *ReqDigitalWalletUniversalBusiness, opts ...grpc.CallOption) (*ReplyDigitalWalletUniversalBusiness, error) {
	out := new(ReplyDigitalWalletUniversalBusiness)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/DigitalWalletUniversalBusiness", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) GenerateRechargeAddress(ctx context.Context, in *GenerateRechargeAddressReq, opts ...grpc.CallOption) (*GenerateRechargeAddressResp, error) {
	out := new(GenerateRechargeAddressResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/GenerateRechargeAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) UserRecharge(ctx context.Context, in *UserRechargeReq, opts ...grpc.CallOption) (*UserRechargeResp, error) {
	out := new(UserRechargeResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/UserRecharge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) UserSwap(ctx context.Context, in *UserSwapReq, opts ...grpc.CallOption) (*UserSwapResp, error) {
	out := new(UserSwapResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/UserSwap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) QueryRechargeableTokens(ctx context.Context, in *QueryRechargeableTokensReq, opts ...grpc.CallOption) (*QueryRechargeableTokensResp, error) {
	out := new(QueryRechargeableTokensResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/QueryRechargeableTokens", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) QueryUserAccountInfo(ctx context.Context, in *QueryUserAccountInfoReq, opts ...grpc.CallOption) (*QueryUserAccountInfoResp, error) {
	out := new(QueryUserAccountInfoResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/QueryUserAccountInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) QueryUserRechargeDetails(ctx context.Context, in *QueryUserRechargeDetailsReq, opts ...grpc.CallOption) (*QueryUserRechargeDetailsResp, error) {
	out := new(QueryUserRechargeDetailsResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/QueryUserRechargeDetails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) QueryUserSwapDetails(ctx context.Context, in *QueryUserSwapDetailsReq, opts ...grpc.CallOption) (*QueryUserSwapDetailsResp, error) {
	out := new(QueryUserSwapDetailsResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/QueryUserSwapDetails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *digitalWalletServiceClient) BackgroundManageOpt(ctx context.Context, in *BackgroundManageOptReq, opts ...grpc.CallOption) (*BackgroundManageOptResp, error) {
	out := new(BackgroundManageOptResp)
	err := grpc.Invoke(ctx, "/imdigitalwalletserver.DigitalWalletService/BackgroundManageOpt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for DigitalWalletService service

type DigitalWalletServiceServer interface {
	// 数字钱包业务通用协议
	DigitalWalletUniversalBusiness(context.Context, *ReqDigitalWalletUniversalBusiness) (*ReplyDigitalWalletUniversalBusiness, error)
	// 用户充值地址生成
	GenerateRechargeAddress(context.Context, *GenerateRechargeAddressReq) (*GenerateRechargeAddressResp, error)
	// 用户充值
	UserRecharge(context.Context, *UserRechargeReq) (*UserRechargeResp, error)
	// 用户兑换
	UserSwap(context.Context, *UserSwapReq) (*UserSwapResp, error)
	// 查询可充值代币
	QueryRechargeableTokens(context.Context, *QueryRechargeableTokensReq) (*QueryRechargeableTokensResp, error)
	// 查询用户账户信息（余额信息）
	QueryUserAccountInfo(context.Context, *QueryUserAccountInfoReq) (*QueryUserAccountInfoResp, error)
	// 查询用户充值明细
	QueryUserRechargeDetails(context.Context, *QueryUserRechargeDetailsReq) (*QueryUserRechargeDetailsResp, error)
	// 查询用户兑换明细
	QueryUserSwapDetails(context.Context, *QueryUserSwapDetailsReq) (*QueryUserSwapDetailsResp, error)
	// 后台管理接口添加
	BackgroundManageOpt(context.Context, *BackgroundManageOptReq) (*BackgroundManageOptResp, error)
}

func RegisterDigitalWalletServiceServer(s *grpc.Server, srv DigitalWalletServiceServer) {
	s.RegisterService(&_DigitalWalletService_serviceDesc, srv)
}

func _DigitalWalletService_DigitalWalletUniversalBusiness_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqDigitalWalletUniversalBusiness)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).DigitalWalletUniversalBusiness(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/DigitalWalletUniversalBusiness",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).DigitalWalletUniversalBusiness(ctx, req.(*ReqDigitalWalletUniversalBusiness))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_GenerateRechargeAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateRechargeAddressReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).GenerateRechargeAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/GenerateRechargeAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).GenerateRechargeAddress(ctx, req.(*GenerateRechargeAddressReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_UserRecharge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRechargeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).UserRecharge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/UserRecharge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).UserRecharge(ctx, req.(*UserRechargeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_UserSwap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserSwapReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).UserSwap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/UserSwap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).UserSwap(ctx, req.(*UserSwapReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_QueryRechargeableTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRechargeableTokensReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).QueryRechargeableTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/QueryRechargeableTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).QueryRechargeableTokens(ctx, req.(*QueryRechargeableTokensReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_QueryUserAccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserAccountInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).QueryUserAccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/QueryUserAccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).QueryUserAccountInfo(ctx, req.(*QueryUserAccountInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_QueryUserRechargeDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserRechargeDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).QueryUserRechargeDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/QueryUserRechargeDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).QueryUserRechargeDetails(ctx, req.(*QueryUserRechargeDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_QueryUserSwapDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserSwapDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).QueryUserSwapDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/QueryUserSwapDetails",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).QueryUserSwapDetails(ctx, req.(*QueryUserSwapDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _DigitalWalletService_BackgroundManageOpt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BackgroundManageOptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DigitalWalletServiceServer).BackgroundManageOpt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imdigitalwalletserver.DigitalWalletService/BackgroundManageOpt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DigitalWalletServiceServer).BackgroundManageOpt(ctx, req.(*BackgroundManageOptReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _DigitalWalletService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imdigitalwalletserver.DigitalWalletService",
	HandlerType: (*DigitalWalletServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DigitalWalletUniversalBusiness",
			Handler:    _DigitalWalletService_DigitalWalletUniversalBusiness_Handler,
		},
		{
			MethodName: "GenerateRechargeAddress",
			Handler:    _DigitalWalletService_GenerateRechargeAddress_Handler,
		},
		{
			MethodName: "UserRecharge",
			Handler:    _DigitalWalletService_UserRecharge_Handler,
		},
		{
			MethodName: "UserSwap",
			Handler:    _DigitalWalletService_UserSwap_Handler,
		},
		{
			MethodName: "QueryRechargeableTokens",
			Handler:    _DigitalWalletService_QueryRechargeableTokens_Handler,
		},
		{
			MethodName: "QueryUserAccountInfo",
			Handler:    _DigitalWalletService_QueryUserAccountInfo_Handler,
		},
		{
			MethodName: "QueryUserRechargeDetails",
			Handler:    _DigitalWalletService_QueryUserRechargeDetails_Handler,
		},
		{
			MethodName: "QueryUserSwapDetails",
			Handler:    _DigitalWalletService_QueryUserSwapDetails_Handler,
		},
		{
			MethodName: "BackgroundManageOpt",
			Handler:    _DigitalWalletService_BackgroundManageOpt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imdigitalwalletserver/imdigitalwalletserver.proto",
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Code))
	}
	if len(m.ErrMsg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.ErrMsg)))
		i += copy(dAtA[i:], m.ErrMsg)
	}
	return i, nil
}

func (m *ReqDigitalWalletUniversalBusiness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDigitalWalletUniversalBusiness) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.UserId))
	}
	if m.AppUserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.AppUserId))
	}
	if m.BusinessId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.BusinessId))
	}
	if len(m.Uuid) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ReplyDigitalWalletUniversalBusiness) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyDigitalWalletUniversalBusiness) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *GenerateRechargeAddressReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateRechargeAddressReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Chain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Chain)))
		i += copy(dAtA[i:], m.Chain)
	}
	if len(m.Contract) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Contract)))
		i += copy(dAtA[i:], m.Contract)
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Debug.Size()))
		n1, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GenerateRechargeAddressResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerateRechargeAddressResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *UserRechargeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRechargeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Chain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Chain)))
		i += copy(dAtA[i:], m.Chain)
	}
	if len(m.Contract) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Contract)))
		i += copy(dAtA[i:], m.Contract)
	}
	if len(m.FromAddress) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.FromAddress)))
		i += copy(dAtA[i:], m.FromAddress)
	}
	if len(m.ToAddress) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.ToAddress)))
		i += copy(dAtA[i:], m.ToAddress)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Debug.Size()))
		n3, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *UserRechargeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRechargeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n4, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *UserSwapReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSwapReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.FromChain) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.FromChain)))
		i += copy(dAtA[i:], m.FromChain)
	}
	if len(m.FromContract) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.FromContract)))
		i += copy(dAtA[i:], m.FromContract)
	}
	if len(m.ToChain) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.ToChain)))
		i += copy(dAtA[i:], m.ToChain)
	}
	if len(m.ToContract) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.ToContract)))
		i += copy(dAtA[i:], m.ToContract)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.FromType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.FromType))
	}
	if m.ToType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.ToType))
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Debug.Size()))
		n5, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *UserSwapResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserSwapResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n6, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *QueryRechargeableTokensReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRechargeableTokensReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Debug != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Debug.Size()))
		n7, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *AbleToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbleToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chain) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Chain)))
		i += copy(dAtA[i:], m.Chain)
	}
	if len(m.Contract) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Contract)))
		i += copy(dAtA[i:], m.Contract)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.PriceUsdt) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.PriceUsdt)))
		i += copy(dAtA[i:], m.PriceUsdt)
	}
	if len(m.PriceDct) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.PriceDct)))
		i += copy(dAtA[i:], m.PriceDct)
	}
	if len(m.Fee) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Fee)))
		i += copy(dAtA[i:], m.Fee)
	}
	if m.Type != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *QueryRechargeableTokensResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRechargeableTokensResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n8, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.TokenList) > 0 {
		for _, msg := range m.TokenList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryUserAccountInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserAccountInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.UserId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Debug.Size()))
		n9, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *TokenBalance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenBalance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Chain) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Chain)))
		i += copy(dAtA[i:], m.Chain)
	}
	if len(m.Contract) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Contract)))
		i += copy(dAtA[i:], m.Contract)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Balance) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Balance)))
		i += copy(dAtA[i:], m.Balance)
	}
	if len(m.Frozen) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Frozen)))
		i += copy(dAtA[i:], m.Frozen)
	}
	if len(m.BalanceUSDT) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.BalanceUSDT)))
		i += copy(dAtA[i:], m.BalanceUSDT)
	}
	if len(m.BalanceDCT) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.BalanceDCT)))
		i += copy(dAtA[i:], m.BalanceDCT)
	}
	return i, nil
}

func (m *AccountInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BalanceList) > 0 {
		for _, msg := range m.BalanceList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TotalBalanceUSDT) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.TotalBalanceUSDT)))
		i += copy(dAtA[i:], m.TotalBalanceUSDT)
	}
	if len(m.TotalBalanceDCT) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.TotalBalanceDCT)))
		i += copy(dAtA[i:], m.TotalBalanceDCT)
	}
	if len(m.TotalAssets) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.TotalAssets)))
		i += copy(dAtA[i:], m.TotalAssets)
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *QueryUserAccountInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserAccountInfoResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n10, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.AccountInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.AccountInfo.Size()))
		n11, err := m.AccountInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *PaginationParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaginationParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PageNumber != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.PageNumber))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.PageSize))
	}
	return i, nil
}

func (m *DateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DateParams) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Year != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Year))
	}
	if m.Month != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Month))
	}
	if m.Day != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Day))
	}
	return i, nil
}

func (m *QueryUserRechargeDetailsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserRechargeDetailsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.UserId))
	}
	if m.PageParam != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.PageParam.Size()))
		n12, err := m.PageParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.DateParam != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.DateParam.Size()))
		n13, err := m.DateParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Status != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status))
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Debug.Size()))
		n14, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *RechargeDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.BillId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.BillId)))
		i += copy(dAtA[i:], m.BillId)
	}
	if m.Status != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *QueryUserRechargeDetailsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserRechargeDetailsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n15, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.RecordDetail) > 0 {
		for _, msg := range m.RecordDetail {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *QueryUserSwapDetailsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserSwapDetailsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.UserId))
	}
	if m.PageParam != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.PageParam.Size()))
		n16, err := m.PageParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.DateParam != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.DateParam.Size()))
		n17, err := m.DateParam.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Debug != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Debug.Size()))
		n18, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SwapDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwapDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Timestamp))
	}
	if len(m.Number) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Number)))
		i += copy(dAtA[i:], m.Number)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if len(m.ExchangeRate) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.ExchangeRate)))
		i += copy(dAtA[i:], m.ExchangeRate)
	}
	if len(m.BillId) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.BillId)))
		i += copy(dAtA[i:], m.BillId)
	}
	return i, nil
}

func (m *QueryUserSwapDetailsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUserSwapDetailsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n19, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.RecordDetail) > 0 {
		for _, msg := range m.RecordDetail {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BackgroundManageOptReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackgroundManageOptReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BusinessCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.BusinessCode))
	}
	if len(m.ReqData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.ReqData)))
		i += copy(dAtA[i:], m.ReqData)
	}
	return i, nil
}

func (m *BackgroundManageOptResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackgroundManageOptResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(m.Status.Size()))
		n20, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.RespData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImdigitalwalletserver(dAtA, i, uint64(len(m.RespData)))
		i += copy(dAtA[i:], m.RespData)
	}
	return i, nil
}

func encodeVarintImdigitalwalletserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Status) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Code))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *ReqDigitalWalletUniversalBusiness) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.UserId))
	}
	if m.AppUserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.AppUserId))
	}
	if m.BusinessId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.BusinessId))
	}
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *ReplyDigitalWalletUniversalBusiness) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *GenerateRechargeAddressReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.UserId))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *GenerateRechargeAddressResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *UserRechargeReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.UserId))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.FromAddress)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.ToAddress)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *UserRechargeResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *UserSwapReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.UserId))
	}
	l = len(m.FromChain)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.FromContract)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.ToChain)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.ToContract)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.FromType != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.FromType))
	}
	if m.ToType != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.ToType))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *UserSwapResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *QueryRechargeableTokensReq) Size() (n int) {
	var l int
	_ = l
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *AbleToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.PriceUsdt)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.PriceDct)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Fee)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Type))
	}
	return n
}

func (m *QueryRechargeableTokensResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if len(m.TokenList) > 0 {
		for _, e := range m.TokenList {
			l = e.Size()
			n += 1 + l + sovImdigitalwalletserver(uint64(l))
		}
	}
	return n
}

func (m *QueryUserAccountInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.UserId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *TokenBalance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Balance)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Frozen)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.BalanceUSDT)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.BalanceDCT)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *AccountInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.BalanceList) > 0 {
		for _, e := range m.BalanceList {
			l = e.Size()
			n += 1 + l + sovImdigitalwalletserver(uint64(l))
		}
	}
	l = len(m.TotalBalanceUSDT)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.TotalBalanceDCT)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.TotalAssets)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Status))
	}
	return n
}

func (m *QueryUserAccountInfoResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.AccountInfo != nil {
		l = m.AccountInfo.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *PaginationParams) Size() (n int) {
	var l int
	_ = l
	if m.PageNumber != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.PageNumber))
	}
	if m.PageSize != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.PageSize))
	}
	return n
}

func (m *DateParams) Size() (n int) {
	var l int
	_ = l
	if m.Year != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Year))
	}
	if m.Month != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Month))
	}
	if m.Day != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Day))
	}
	return n
}

func (m *QueryUserRechargeDetailsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.UserId))
	}
	if m.PageParam != nil {
		l = m.PageParam.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.DateParam != nil {
		l = m.DateParam.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Status))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *RechargeDetail) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Timestamp))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.BillId)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Status))
	}
	return n
}

func (m *QueryUserRechargeDetailsResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if len(m.RecordDetail) > 0 {
		for _, e := range m.RecordDetail {
			l = e.Size()
			n += 1 + l + sovImdigitalwalletserver(uint64(l))
		}
	}
	return n
}

func (m *QueryUserSwapDetailsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.UserId))
	}
	if m.PageParam != nil {
		l = m.PageParam.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.DateParam != nil {
		l = m.DateParam.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *SwapDetail) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.Timestamp))
	}
	l = len(m.Number)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.ExchangeRate)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.BillId)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *QueryUserSwapDetailsResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	if len(m.RecordDetail) > 0 {
		for _, e := range m.RecordDetail {
			l = e.Size()
			n += 1 + l + sovImdigitalwalletserver(uint64(l))
		}
	}
	return n
}

func (m *BackgroundManageOptReq) Size() (n int) {
	var l int
	_ = l
	if m.BusinessCode != 0 {
		n += 1 + sovImdigitalwalletserver(uint64(m.BusinessCode))
	}
	l = len(m.ReqData)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func (m *BackgroundManageOptResp) Size() (n int) {
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	l = len(m.RespData)
	if l > 0 {
		n += 1 + l + sovImdigitalwalletserver(uint64(l))
	}
	return n
}

func sovImdigitalwalletserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImdigitalwalletserver(x uint64) (n int) {
	return sovImdigitalwalletserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDigitalWalletUniversalBusiness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDigitalWalletUniversalBusiness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDigitalWalletUniversalBusiness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppUserId", wireType)
			}
			m.AppUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppUserId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessId", wireType)
			}
			m.BusinessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyDigitalWalletUniversalBusiness) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyDigitalWalletUniversalBusiness: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyDigitalWalletUniversalBusiness: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateRechargeAddressReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateRechargeAddressReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateRechargeAddressReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateRechargeAddressResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateRechargeAddressResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateRechargeAddressResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRechargeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRechargeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRechargeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRechargeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRechargeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRechargeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSwapReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSwapReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSwapReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToChain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToChain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromType", wireType)
			}
			m.FromType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToType", wireType)
			}
			m.ToType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserSwapResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserSwapResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserSwapResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRechargeableTokensReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRechargeableTokensReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRechargeableTokensReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbleToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbleToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbleToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceUsdt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceUsdt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceDct", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceDct = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRechargeableTokensResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRechargeableTokensResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRechargeableTokensResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenList = append(m.TokenList, &AbleToken{})
			if err := m.TokenList[len(m.TokenList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserAccountInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserAccountInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserAccountInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenBalance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenBalance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenBalance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balance = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frozen", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Frozen = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceUSDT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceUSDT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceDCT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceDCT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BalanceList = append(m.BalanceList, &TokenBalance{})
			if err := m.BalanceList[len(m.BalanceList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBalanceUSDT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalBalanceUSDT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBalanceDCT", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalBalanceDCT = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAssets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAssets = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserAccountInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserAccountInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserAccountInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AccountInfo == nil {
				m.AccountInfo = &AccountInfo{}
			}
			if err := m.AccountInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaginationParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaginationParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaginationParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageNumber", wireType)
			}
			m.PageNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageNumber |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Year", wireType)
			}
			m.Year = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Year |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Month", wireType)
			}
			m.Month = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Month |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Day", wireType)
			}
			m.Day = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Day |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserRechargeDetailsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserRechargeDetailsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserRechargeDetailsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageParam == nil {
				m.PageParam = &PaginationParams{}
			}
			if err := m.PageParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateParam == nil {
				m.DateParam = &DateParams{}
			}
			if err := m.DateParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserRechargeDetailsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserRechargeDetailsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserRechargeDetailsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordDetail = append(m.RecordDetail, &RechargeDetail{})
			if err := m.RecordDetail[len(m.RecordDetail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserSwapDetailsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserSwapDetailsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserSwapDetailsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PageParam == nil {
				m.PageParam = &PaginationParams{}
			}
			if err := m.PageParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateParam == nil {
				m.DateParam = &DateParams{}
			}
			if err := m.DateParam.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwapDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwapDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwapDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExchangeRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BillId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BillId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUserSwapDetailsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUserSwapDetailsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUserSwapDetailsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordDetail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordDetail = append(m.RecordDetail, &SwapDetail{})
			if err := m.RecordDetail[len(m.RecordDetail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackgroundManageOptReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackgroundManageOptReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackgroundManageOptReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessCode", wireType)
			}
			m.BusinessCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessCode |= (BusinessCodeEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackgroundManageOptResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackgroundManageOptResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackgroundManageOptResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RespData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImdigitalwalletserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImdigitalwalletserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImdigitalwalletserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImdigitalwalletserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImdigitalwalletserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImdigitalwalletserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImdigitalwalletserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImdigitalwalletserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImdigitalwalletserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImdigitalwalletserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imdigitalwalletserver/imdigitalwalletserver.proto", fileDescriptorImdigitalwalletserver)
}

var fileDescriptorImdigitalwalletserver = []byte{
	// 1576 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0xcd, 0x6e, 0xdb, 0xc6,
	0x13, 0xf7, 0xea, 0xc3, 0xb6, 0x46, 0xb2, 0xc3, 0xff, 0x26, 0xb1, 0x15, 0x25, 0x31, 0x1c, 0x1a,
	0xff, 0xc6, 0x08, 0x50, 0x1b, 0x55, 0x50, 0x20, 0xed, 0xa1, 0x85, 0x6d, 0x29, 0xa9, 0xd1, 0xc6,
	0x75, 0x68, 0x39, 0x41, 0x8f, 0x2b, 0x6a, 0x2d, 0x13, 0xa1, 0x48, 0x66, 0xb9, 0x74, 0xe2, 0x5c,
	0x0a, 0x04, 0xe8, 0xa9, 0x40, 0xd1, 0x43, 0x80, 0xe6, 0xd8, 0x57, 0xe8, 0x53, 0x34, 0xc7, 0x9e,
	0x7a, 0x2c, 0x8a, 0xa0, 0xb7, 0xbe, 0x41, 0x4f, 0xc5, 0x2e, 0x97, 0xe4, 0x4a, 0x16, 0x2d, 0xdb,
	0xc8, 0xa5, 0x27, 0x71, 0x66, 0x77, 0xbe, 0x7e, 0x33, 0xb3, 0xbb, 0x23, 0x78, 0xdc, 0x77, 0xb8,
	0x4b, 0xba, 0x6b, 0xf6, 0x21, 0xe1, 0x21, 0x65, 0x47, 0x94, 0xad, 0x39, 0x83, 0x75, 0xc7, 0xe3,
	0x94, 0x1d, 0x10, 0x9b, 0x06, 0xcc, 0xef, 0x46, 0x07, 0xeb, 0xce, 0xa0, 0xe7, 0xf4, 0x1d, 0x4e,
	0xdc, 0xe7, 0xc4, 0x75, 0xa9, 0xda, 0x38, 0x9e, 0xbb, 0x16, 0x30, 0x9f, 0xfb, 0xf8, 0xea, 0xd8,
	0xc5, 0xc6, 0xbd, 0x33, 0x99, 0x0b, 0xba, 0xb6, 0x3f, 0x18, 0xa8, 0x9f, 0x58, 0xa1, 0xf9, 0x08,
	0xa6, 0xf7, 0x38, 0xe1, 0x51, 0x88, 0xd7, 0xa1, 0xb4, 0xe5, 0xf7, 0x68, 0x1d, 0x2d, 0xa3, 0xd5,
	0xf9, 0xe6, 0xf5, 0xb5, 0xf1, 0x6e, 0x88, 0x2d, 0x96, 0xdc, 0x88, 0x17, 0x60, 0xba, 0xcd, 0xd8,
	0xc3, 0xb0, 0x5f, 0x2f, 0x2c, 0xa3, 0xd5, 0x8a, 0xa5, 0x28, 0xf3, 0x57, 0x04, 0xb7, 0x2c, 0xfa,
	0xac, 0x15, 0x4b, 0x3f, 0x91, 0xd2, 0xfb, 0x9e, 0x73, 0x44, 0x59, 0x48, 0xdc, 0xcd, 0x28, 0x74,
	0x3c, 0x1a, 0x86, 0x78, 0x1e, 0x0a, 0x4e, 0x20, 0x8d, 0x55, 0xac, 0x82, 0x13, 0x08, 0x6d, 0x51,
	0x48, 0xd9, 0x76, 0x4f, 0x6a, 0x2b, 0x5a, 0x8a, 0xc2, 0x37, 0xa0, 0x42, 0x82, 0x60, 0x3f, 0x5e,
	0x2a, 0xca, 0xa5, 0x8c, 0x81, 0x97, 0x00, 0xba, 0x4a, 0xe3, 0x76, 0xaf, 0x5e, 0x5a, 0x46, 0xab,
	0x65, 0x4b, 0xe3, 0x60, 0x0c, 0xa5, 0x28, 0x72, 0x7a, 0xf5, 0xb2, 0xb4, 0x23, 0xbf, 0xf1, 0x15,
	0x28, 0x07, 0x87, 0xbe, 0x47, 0xeb, 0xd3, 0x92, 0x19, 0x13, 0x62, 0x67, 0x8f, 0x70, 0x52, 0x9f,
	0x59, 0x46, 0xab, 0x35, 0x4b, 0x7e, 0x9b, 0x9f, 0xc0, 0x8a, 0x45, 0x03, 0xf7, 0x78, 0x42, 0x28,
	0x89, 0x68, 0x1c, 0x4c, 0x2c, 0xfa, 0x3d, 0x82, 0xc6, 0x03, 0xea, 0x51, 0x46, 0x38, 0xb5, 0xa8,
	0x7d, 0x48, 0x58, 0x9f, 0x6e, 0xf4, 0x7a, 0x8c, 0x86, 0xa1, 0x45, 0x9f, 0x89, 0x68, 0x55, 0x48,
	0x48, 0xfa, 0xac, 0x28, 0xe1, 0xdb, 0xd6, 0x21, 0x71, 0x3c, 0x05, 0x69, 0x4c, 0xe0, 0x06, 0xcc,
	0x6e, 0xf9, 0x1e, 0x67, 0xc4, 0xe6, 0x12, 0x82, 0x8a, 0x95, 0xd2, 0x78, 0x05, 0xca, 0x3d, 0xda,
	0x8d, 0xfa, 0xf5, 0xea, 0x32, 0x5a, 0xad, 0x36, 0xe7, 0xd6, 0x54, 0x7a, 0x5b, 0x82, 0x69, 0xc5,
	0x6b, 0xa6, 0x07, 0xd7, 0x73, 0x9d, 0x09, 0x03, 0xfc, 0x71, 0x52, 0x04, 0xd2, 0x9b, 0x6a, 0xf3,
	0x66, 0x4e, 0xf2, 0xe3, 0x4d, 0x56, 0x52, 0x31, 0x75, 0x98, 0x51, 0x5a, 0x94, 0xbb, 0x09, 0x69,
	0xfe, 0x8e, 0xe0, 0x92, 0x88, 0x28, 0x31, 0xf6, 0x7e, 0x43, 0x5e, 0x86, 0xea, 0x7d, 0xe6, 0x0f,
	0x12, 0xdb, 0x25, 0xb9, 0xac, 0xb3, 0x44, 0xd1, 0x74, 0xfc, 0x64, 0x3d, 0xce, 0x7d, 0xc6, 0x10,
	0x16, 0x1f, 0x13, 0x37, 0x4a, 0x0b, 0x40, 0x12, 0x67, 0x03, 0x72, 0x1b, 0x8c, 0xe1, 0xb8, 0x2e,
	0x8c, 0x9e, 0xf9, 0x63, 0x01, 0xaa, 0x42, 0xd7, 0xde, 0x73, 0x12, 0x9c, 0x86, 0xcf, 0x0d, 0xa8,
	0x88, 0xd0, 0x74, 0x8c, 0x32, 0x06, 0x36, 0xa1, 0x26, 0x89, 0x61, 0xac, 0x86, 0x78, 0x22, 0x4f,
	0x1d, 0x3f, 0x96, 0x8f, 0xb1, 0x4a, 0x48, 0xd1, 0x3e, 0x1d, 0x3f, 0x95, 0x8d, 0x81, 0xd2, 0x38,
	0x39, 0x48, 0x35, 0x60, 0x56, 0xe8, 0xef, 0x1c, 0x07, 0x54, 0xb6, 0x4b, 0xd9, 0x4a, 0x69, 0x11,
	0x45, 0xc7, 0x97, 0x2b, 0xb3, 0x71, 0x14, 0x31, 0x75, 0x36, 0x74, 0xdb, 0x50, 0xcb, 0x10, 0xb9,
	0x38, 0xb2, 0x1b, 0xd0, 0x78, 0x14, 0x51, 0x76, 0x9c, 0x64, 0x89, 0x74, 0x5d, 0xda, 0xf1, 0x9f,
	0x52, 0x4f, 0xb6, 0x5e, 0xea, 0x09, 0x3a, 0xc5, 0x93, 0x5f, 0x10, 0x54, 0x36, 0x12, 0xb1, 0xac,
	0x44, 0x51, 0x5e, 0x89, 0x16, 0x46, 0x4a, 0x14, 0x43, 0x69, 0x87, 0x0c, 0xa8, 0x4a, 0x87, 0xfc,
	0x16, 0x89, 0xdc, 0x65, 0x8e, 0x4d, 0xf7, 0xc3, 0x1e, 0x57, 0x89, 0xc8, 0x18, 0x42, 0x9b, 0x24,
	0x5a, 0x69, 0x22, 0x52, 0x1a, 0x1b, 0x50, 0xbc, 0x4f, 0x93, 0x24, 0x88, 0x4f, 0xa1, 0x5f, 0x83,
	0x5f, 0x7e, 0x9b, 0xaf, 0x11, 0x5c, 0xcf, 0x8d, 0xfb, 0xe2, 0x5d, 0xfe, 0x99, 0xe8, 0xa5, 0xa7,
	0xd4, 0xfb, 0xca, 0x09, 0x45, 0x9c, 0xc5, 0xd5, 0x6a, 0x73, 0x39, 0x47, 0x32, 0x45, 0xcc, 0xca,
	0x44, 0xcc, 0xc7, 0xb0, 0x28, 0xbd, 0x12, 0x99, 0xdd, 0xb0, 0x6d, 0x3f, 0xf2, 0xf8, 0xb6, 0x77,
	0xe0, 0x9f, 0x56, 0xf2, 0x67, 0x2a, 0x96, 0xb7, 0x08, 0x6a, 0xd2, 0xca, 0x26, 0x71, 0x89, 0x67,
	0xd3, 0xf7, 0x94, 0xa5, 0x3a, 0xcc, 0x28, 0x85, 0x49, 0xb3, 0x24, 0xfa, 0x17, 0x60, 0xfa, 0x3e,
	0xf3, 0x5f, 0x52, 0x4f, 0xe5, 0x47, 0x51, 0xe2, 0x38, 0x52, 0x5b, 0xf6, 0xf7, 0x5a, 0x1d, 0x95,
	0x25, 0x9d, 0x25, 0xda, 0x4c, 0x91, 0xad, 0xad, 0x8e, 0xcc, 0x59, 0xc5, 0xd2, 0x38, 0xe6, 0x5f,
	0x08, 0xaa, 0x1a, 0x34, 0xb8, 0x9d, 0x6a, 0x94, 0xa0, 0x23, 0x09, 0xfa, 0x4a, 0x0e, 0xe8, 0x3a,
	0x06, 0x96, 0x2e, 0x87, 0xef, 0x80, 0xd1, 0xf1, 0x39, 0x71, 0x75, 0xef, 0x62, 0x08, 0x4e, 0xf0,
	0xf1, 0x2a, 0x5c, 0xd2, 0x79, 0xc2, 0xcf, 0x18, 0x95, 0x51, 0xb6, 0x08, 0x57, 0xb2, 0x36, 0xc2,
	0x90, 0xf2, 0xf4, 0xf4, 0xd5, 0x58, 0x02, 0x28, 0x55, 0x68, 0xe5, 0x38, 0xad, 0xaa, 0x2f, 0x7f,
	0x42, 0x50, 0x1f, 0x5f, 0x0a, 0x17, 0xaf, 0xce, 0xd6, 0x10, 0x72, 0x32, 0xbc, 0x6a, 0xd3, 0xcc,
	0xab, 0x4f, 0xcd, 0xa6, 0x2e, 0x66, 0xee, 0x80, 0xb1, 0x4b, 0xfa, 0x8e, 0x47, 0xb8, 0xe3, 0x7b,
	0xbb, 0x84, 0x91, 0x41, 0x28, 0x92, 0xb6, 0x4b, 0xfa, 0x74, 0x27, 0x1a, 0x74, 0x29, 0x93, 0x4e,
	0xcd, 0x59, 0x1a, 0x47, 0x36, 0x2c, 0xe9, 0xd3, 0x3d, 0xe7, 0x25, 0x95, 0x66, 0xe7, 0xac, 0x94,
	0x36, 0xbf, 0x00, 0x68, 0x11, 0x4e, 0x95, 0x26, 0x0c, 0xa5, 0x6f, 0x28, 0x49, 0x74, 0xc8, 0x6f,
	0x51, 0xac, 0x0f, 0x7d, 0x8f, 0x1f, 0x2a, 0xd1, 0x98, 0x10, 0x8d, 0xde, 0x22, 0xc7, 0x12, 0xf9,
	0x39, 0x4b, 0x7c, 0x9a, 0xff, 0x24, 0x4d, 0xad, 0x5f, 0x3b, 0x2d, 0xca, 0x89, 0xe3, 0x9e, 0xfa,
	0x90, 0x68, 0x43, 0x45, 0x78, 0x23, 0x3d, 0x50, 0xa8, 0xdc, 0xce, 0x41, 0x65, 0x34, 0x72, 0x2b,
	0x93, 0xc4, 0x9f, 0x43, 0x25, 0x0d, 0x44, 0xba, 0x55, 0x6d, 0xde, 0xca, 0x51, 0x93, 0x05, 0x6c,
	0x65, 0x32, 0x5a, 0x2d, 0x94, 0x64, 0x50, 0x49, 0xde, 0xce, 0xd4, 0xe2, 0x3f, 0x20, 0x98, 0x1f,
	0x8e, 0x59, 0xde, 0xec, 0xce, 0x80, 0x86, 0x9c, 0x0c, 0xe2, 0xd7, 0x63, 0xc9, 0xca, 0x18, 0xd9,
	0x7d, 0x55, 0xd0, 0xef, 0x2b, 0xed, 0x9d, 0x52, 0x1c, 0x7a, 0xa7, 0x08, 0xef, 0x36, 0x1d, 0xd7,
	0x55, 0x4f, 0xc7, 0x8a, 0xa5, 0xa8, 0x91, 0x0a, 0x4e, 0xbd, 0x36, 0x7f, 0x46, 0x70, 0x23, 0x3f,
	0x1b, 0x17, 0xaf, 0xe2, 0x6d, 0xa8, 0x59, 0xd4, 0xf6, 0x59, 0x2f, 0xd6, 0xa5, 0x8e, 0xd9, 0xff,
	0xe7, 0x08, 0x0f, 0x1b, 0xb6, 0x86, 0x44, 0xcd, 0x3f, 0x90, 0x76, 0xde, 0x8a, 0x9b, 0xf4, 0x3f,
	0x54, 0x2c, 0x67, 0x2a, 0x8a, 0xd7, 0x08, 0x20, 0x8b, 0x6b, 0x42, 0x41, 0x2c, 0xc0, 0xb4, 0x6a,
	0x60, 0x35, 0xa3, 0xa8, 0xe6, 0x4d, 0x0b, 0xa5, 0xa8, 0x17, 0x8a, 0x09, 0xb5, 0xf6, 0x0b, 0xfb,
	0x90, 0x78, 0x7d, 0x6a, 0x11, 0x9e, 0x5c, 0x00, 0x43, 0x3c, 0xad, 0x64, 0xca, 0x7a, 0xc9, 0x98,
	0x6f, 0xf4, 0xc3, 0x6d, 0x08, 0xf7, 0x8b, 0x97, 0x45, 0x7b, 0x6c, 0x59, 0xe4, 0x61, 0x9a, 0x19,
	0x1d, 0x29, 0x89, 0x6f, 0x61, 0x61, 0x93, 0xd8, 0x4f, 0xfb, 0xcc, 0x8f, 0xbc, 0xde, 0x43, 0xe2,
	0x91, 0x3e, 0xfd, 0x3a, 0xe0, 0xa2, 0x20, 0xbe, 0x84, 0x5a, 0x32, 0xc5, 0x68, 0xb3, 0x5f, 0x5e,
	0xee, 0xf5, 0xad, 0x6d, 0x2f, 0x1a, 0x58, 0x43, 0xc2, 0xa2, 0xcd, 0xc4, 0xd8, 0x27, 0x26, 0x21,
	0x35, 0x0e, 0x28, 0xd2, 0x74, 0x61, 0x71, 0xac, 0x03, 0x17, 0x47, 0xa6, 0x01, 0xb3, 0x42, 0x5c,
	0x33, 0x96, 0xd2, 0x77, 0x82, 0x78, 0x90, 0xc5, 0x55, 0x98, 0xd9, 0x8b, 0x6c, 0x9b, 0x86, 0xa1,
	0x31, 0x85, 0x2f, 0x41, 0xb5, 0xcd, 0x98, 0xcf, 0xf6, 0x8e, 0x43, 0x4e, 0x07, 0x06, 0xc2, 0x8b,
	0x70, 0x59, 0x32, 0xb6, 0xbd, 0x23, 0xe2, 0x3a, 0x3d, 0x8b, 0x3e, 0x8b, 0x68, 0xc8, 0x8d, 0x02,
	0xbe, 0x06, 0x57, 0xf5, 0x05, 0x59, 0x99, 0x94, 0x53, 0x66, 0x14, 0xf1, 0x02, 0x60, 0xb9, 0x24,
	0xf3, 0xbc, 0xe3, 0xf3, 0xf6, 0x0b, 0x27, 0xe4, 0x46, 0xe9, 0xce, 0x1b, 0x04, 0xc6, 0x28, 0x38,
	0xc2, 0x62, 0x3c, 0x30, 0x3e, 0xf1, 0x59, 0x4f, 0xb8, 0x60, 0x40, 0x2d, 0x66, 0x6c, 0x31, 0x4a,
	0x38, 0x35, 0x50, 0xc6, 0xd9, 0xb0, 0xb9, 0x73, 0x44, 0x8d, 0x02, 0x9e, 0x07, 0x78, 0x40, 0x79,
	0xcc, 0x0c, 0x8d, 0x22, 0xbe, 0x09, 0xd7, 0xb6, 0x7c, 0xef, 0xc0, 0xe9, 0x47, 0x8c, 0x6e, 0xf9,
	0xae, 0x4b, 0x6d, 0xd1, 0x7a, 0x1b, 0x03, 0x71, 0x73, 0x19, 0x25, 0xfc, 0x3f, 0x98, 0x8b, 0xf7,
	0xc6, 0xf9, 0x0e, 0x8d, 0x32, 0x9e, 0x83, 0xca, 0x03, 0xca, 0xe5, 0xdb, 0x27, 0x34, 0xa6, 0x9b,
	0x7f, 0xcf, 0xc2, 0x95, 0xa1, 0xf1, 0x75, 0x8f, 0xb2, 0x23, 0xc7, 0xa6, 0xf8, 0x0d, 0x82, 0xa5,
	0x09, 0x73, 0xed, 0xbd, 0xdc, 0xf3, 0x67, 0xc2, 0x70, 0xdf, 0xf8, 0x34, 0x57, 0x72, 0xe2, 0x34,
	0x6d, 0x4e, 0xe1, 0x57, 0x08, 0x16, 0x73, 0xc6, 0x55, 0xfc, 0x51, 0x8e, 0xe6, 0xfc, 0x59, 0xbb,
	0xd1, 0x3c, 0xaf, 0x48, 0x18, 0x98, 0x53, 0x98, 0xc4, 0xb3, 0x48, 0xb2, 0x88, 0x3f, 0xc8, 0xd1,
	0x32, 0x32, 0xe6, 0x36, 0x6e, 0x9f, 0x69, 0x9f, 0x34, 0xb1, 0x0f, 0xb3, 0xc9, 0x61, 0x81, 0xcd,
	0x53, 0xc4, 0xd4, 0x84, 0xd8, 0x58, 0x99, 0xb8, 0x47, 0xaa, 0x7d, 0x95, 0xdc, 0x00, 0x27, 0xe7,
	0x80, 0x5c, 0xf8, 0xf2, 0xe7, 0xa5, 0x5c, 0xf8, 0x4e, 0x19, 0x35, 0xcc, 0x29, 0x7c, 0x0c, 0x57,
	0xc6, 0x3d, 0xf5, 0xf0, 0xda, 0x69, 0xda, 0x4e, 0x8e, 0x08, 0x8d, 0xf5, 0x73, 0xed, 0x97, 0xa6,
	0xbf, 0xd3, 0x4f, 0xe2, 0x91, 0x4b, 0x1a, 0x37, 0x27, 0xe9, 0x3b, 0xf9, 0xc6, 0x6a, 0xdc, 0x3d,
	0xb7, 0xcc, 0x09, 0x08, 0xb4, 0x0b, 0x61, 0x32, 0x04, 0xc3, 0xb7, 0xf6, 0x64, 0x08, 0x46, 0x6e,
	0x1b, 0x73, 0x0a, 0x1f, 0xc1, 0xe5, 0x31, 0x07, 0x2e, 0xfe, 0x30, 0xef, 0x60, 0x1f, 0x7b, 0x3b,
	0x34, 0xd6, 0xce, 0xb3, 0x5d, 0xd8, 0xdd, 0xac, 0xbd, 0x7d, 0xb7, 0x84, 0x7e, 0x7b, 0xb7, 0x84,
	0xfe, 0x7c, 0xb7, 0x84, 0xba, 0xd3, 0xf2, 0x2f, 0xc6, 0xbb, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff,
	0x19, 0xdd, 0xe2, 0x54, 0x0d, 0x15, 0x00, 0x00,
}
