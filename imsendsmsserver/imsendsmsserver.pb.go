// Code generated by protoc-gen-gogo.
// source: imsendsmsserver.proto
// DO NOT EDIT!

/*
Package imsendsmsserver is a generated protocol buffer package.

It is generated from these files:

	imsendsmsserver.proto

It has these top-level messages:

	SendPhoneCodeReq
	SendPhoneCodeReply
	CheckPhoneCodeReq
	CheckPhoneCodeReply
	SendEmailCodeReq
	SendEmailCodeReply
	CheckEmailCodeReq
	CheckEmailCodeReply
	BatchSendSMSReq
	SendSmsDetail
	BatchSendSMSReply
*/
package imsendsmsserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ReErrCode int32

const (
	// 成功
	ReErrCode_Success ReErrCode = 0
	// 手机号错误
	ReErrCode_Phone_Error ReErrCode = 1
	// 邮箱错误
	ReErrCode_Email_Error ReErrCode = 2
)

var ReErrCode_name = map[int32]string{
	0: "Success",
	1: "Phone_Error",
	2: "Email_Error",
}
var ReErrCode_value = map[string]int32{
	"Success":     0,
	"Phone_Error": 1,
	"Email_Error": 2,
}

func (x ReErrCode) String() string {
	return proto.EnumName(ReErrCode_name, int32(x))
}
func (ReErrCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorImsendsmsserver, []int{0} }

// 发送手机验证码请求
type SendPhoneCodeReq struct {
	// 客户端传过来的电话号码 未处理过的
	PhoneNumber string `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	// 语言代码
	LangCode string `protobuf:"bytes,2,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	// 用户的ID
	UserId int32 `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// 用户的keyId(端的标识)
	KeyId int64 `protobuf:"varint,4,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// 国家码
	CountryCode string `protobuf:"bytes,5,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty"`
	// 不带国家码的电话号码
	LocalPhone string `protobuf:"bytes,6,opt,name=local_phone,json=localPhone,proto3" json:"local_phone,omitempty"`
}

func (m *SendPhoneCodeReq) Reset()                    { *m = SendPhoneCodeReq{} }
func (m *SendPhoneCodeReq) String() string            { return proto.CompactTextString(m) }
func (*SendPhoneCodeReq) ProtoMessage()               {}
func (*SendPhoneCodeReq) Descriptor() ([]byte, []int) { return fileDescriptorImsendsmsserver, []int{0} }

func (m *SendPhoneCodeReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SendPhoneCodeReq) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *SendPhoneCodeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SendPhoneCodeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SendPhoneCodeReq) GetCountryCode() string {
	if m != nil {
		return m.CountryCode
	}
	return ""
}

func (m *SendPhoneCodeReq) GetLocalPhone() string {
	if m != nil {
		return m.LocalPhone
	}
	return ""
}

// 发送验证码响应
type SendPhoneCodeReply struct {
	// 发送是否成功
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// 验证码的哈希值
	PhoneHashCode string `protobuf:"bytes,2,opt,name=phone_hash_code,json=phoneHashCode,proto3" json:"phone_hash_code,omitempty"`
	// 短信的失效时间
	Timeout int32 `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// 错误信息
	ErrorCode ReErrCode `protobuf:"varint,4,opt,name=error_code,json=errorCode,proto3,enum=imsendsmsserver.ReErrCode" json:"error_code,omitempty"`
}

func (m *SendPhoneCodeReply) Reset()         { *m = SendPhoneCodeReply{} }
func (m *SendPhoneCodeReply) String() string { return proto.CompactTextString(m) }
func (*SendPhoneCodeReply) ProtoMessage()    {}
func (*SendPhoneCodeReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImsendsmsserver, []int{1}
}

func (m *SendPhoneCodeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *SendPhoneCodeReply) GetPhoneHashCode() string {
	if m != nil {
		return m.PhoneHashCode
	}
	return ""
}

func (m *SendPhoneCodeReply) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SendPhoneCodeReply) GetErrorCode() ReErrCode {
	if m != nil {
		return m.ErrorCode
	}
	return ReErrCode_Success
}

// 校验验证码请求
type CheckPhoneCodeReq struct {
	// 客户端传过来的电话号码 未处理过的
	PhoneNumber string `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	// 用户的ID
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// 用户的keyId(端的标识)
	KeyId int64 `protobuf:"varint,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// 验证码
	Code string `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *CheckPhoneCodeReq) Reset()         { *m = CheckPhoneCodeReq{} }
func (m *CheckPhoneCodeReq) String() string { return proto.CompactTextString(m) }
func (*CheckPhoneCodeReq) ProtoMessage()    {}
func (*CheckPhoneCodeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsendsmsserver, []int{2}
}

func (m *CheckPhoneCodeReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *CheckPhoneCodeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CheckPhoneCodeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *CheckPhoneCodeReq) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// 校验验证码响应
type CheckPhoneCodeReply struct {
	// 验证码校验是否成功
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *CheckPhoneCodeReply) Reset()         { *m = CheckPhoneCodeReply{} }
func (m *CheckPhoneCodeReply) String() string { return proto.CompactTextString(m) }
func (*CheckPhoneCodeReply) ProtoMessage()    {}
func (*CheckPhoneCodeReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImsendsmsserver, []int{3}
}

func (m *CheckPhoneCodeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// 发送邮件验证码请求
type SendEmailCodeReq struct {
	// 邮箱地址
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// 语言代码
	LangCode string `protobuf:"bytes,2,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	// 用户的ID
	UserId int32 `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// 用户的keyId(端的标识)
	KeyId int64 `protobuf:"varint,4,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SendEmailCodeReq) Reset()                    { *m = SendEmailCodeReq{} }
func (m *SendEmailCodeReq) String() string            { return proto.CompactTextString(m) }
func (*SendEmailCodeReq) ProtoMessage()               {}
func (*SendEmailCodeReq) Descriptor() ([]byte, []int) { return fileDescriptorImsendsmsserver, []int{4} }

func (m *SendEmailCodeReq) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *SendEmailCodeReq) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *SendEmailCodeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SendEmailCodeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

// 发送验证码响应
type SendEmailCodeReply struct {
	// 发送是否成功
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// 验证码的哈希值
	EmailCodeHash string `protobuf:"bytes,2,opt,name=email_code_hash,json=emailCodeHash,proto3" json:"email_code_hash,omitempty"`
	// 短信的失效时间
	Timeout int32 `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// 错误信息
	ErrorCode ReErrCode `protobuf:"varint,4,opt,name=error_code,json=errorCode,proto3,enum=imsendsmsserver.ReErrCode" json:"error_code,omitempty"`
}

func (m *SendEmailCodeReply) Reset()         { *m = SendEmailCodeReply{} }
func (m *SendEmailCodeReply) String() string { return proto.CompactTextString(m) }
func (*SendEmailCodeReply) ProtoMessage()    {}
func (*SendEmailCodeReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImsendsmsserver, []int{5}
}

func (m *SendEmailCodeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *SendEmailCodeReply) GetEmailCodeHash() string {
	if m != nil {
		return m.EmailCodeHash
	}
	return ""
}

func (m *SendEmailCodeReply) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *SendEmailCodeReply) GetErrorCode() ReErrCode {
	if m != nil {
		return m.ErrorCode
	}
	return ReErrCode_Success
}

// 校验邮箱验证码请求
type CheckEmailCodeReq struct {
	// 邮箱
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// 用户的ID
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// 用户的keyId(端的标识)
	KeyId int64 `protobuf:"varint,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// 验证码
	Code string `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *CheckEmailCodeReq) Reset()         { *m = CheckEmailCodeReq{} }
func (m *CheckEmailCodeReq) String() string { return proto.CompactTextString(m) }
func (*CheckEmailCodeReq) ProtoMessage()    {}
func (*CheckEmailCodeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsendsmsserver, []int{6}
}

func (m *CheckEmailCodeReq) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *CheckEmailCodeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CheckEmailCodeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *CheckEmailCodeReq) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// 校验验证码响应
type CheckEmailCodeReply struct {
	// 验证码校验是否成功
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *CheckEmailCodeReply) Reset()         { *m = CheckEmailCodeReply{} }
func (m *CheckEmailCodeReply) String() string { return proto.CompactTextString(m) }
func (*CheckEmailCodeReply) ProtoMessage()    {}
func (*CheckEmailCodeReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImsendsmsserver, []int{7}
}

func (m *CheckEmailCodeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// 批量发送信息请求
type BatchSendSMSReq struct {
	// 手机号,数据库取出的手机号
	PhoneNumbers []string `protobuf:"bytes,1,rep,name=phone_numbers,json=phoneNumbers" json:"phone_numbers,omitempty"`
	// 文本内容
	Text string `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
}

func (m *BatchSendSMSReq) Reset()                    { *m = BatchSendSMSReq{} }
func (m *BatchSendSMSReq) String() string            { return proto.CompactTextString(m) }
func (*BatchSendSMSReq) ProtoMessage()               {}
func (*BatchSendSMSReq) Descriptor() ([]byte, []int) { return fileDescriptorImsendsmsserver, []int{8} }

func (m *BatchSendSMSReq) GetPhoneNumbers() []string {
	if m != nil {
		return m.PhoneNumbers
	}
	return nil
}

func (m *BatchSendSMSReq) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

// 发送短信详细
type SendSmsDetail struct {
	// 手机号码
	Mobile string `protobuf:"bytes,1,opt,name=mobile,proto3" json:"mobile,omitempty"`
	// 错误信息
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	// 消息id
	Sid int64 `protobuf:"varint,3,opt,name=sid,proto3" json:"sid,omitempty"`
	// code 0 成功
	Code int32 `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
	// 数量
	Count int32 `protobuf:"varint,5,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *SendSmsDetail) Reset()                    { *m = SendSmsDetail{} }
func (m *SendSmsDetail) String() string            { return proto.CompactTextString(m) }
func (*SendSmsDetail) ProtoMessage()               {}
func (*SendSmsDetail) Descriptor() ([]byte, []int) { return fileDescriptorImsendsmsserver, []int{9} }

func (m *SendSmsDetail) GetMobile() string {
	if m != nil {
		return m.Mobile
	}
	return ""
}

func (m *SendSmsDetail) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SendSmsDetail) GetSid() int64 {
	if m != nil {
		return m.Sid
	}
	return 0
}

func (m *SendSmsDetail) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SendSmsDetail) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// 批量发送信息响应
type BatchSendSMSReply struct {
	// 发送成功数
	TotalCount int32 `protobuf:"varint,1,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// 批量发送详细
	Data []*SendSmsDetail `protobuf:"bytes,2,rep,name=data" json:"data,omitempty"`
}

func (m *BatchSendSMSReply) Reset()         { *m = BatchSendSMSReply{} }
func (m *BatchSendSMSReply) String() string { return proto.CompactTextString(m) }
func (*BatchSendSMSReply) ProtoMessage()    {}
func (*BatchSendSMSReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImsendsmsserver, []int{10}
}

func (m *BatchSendSMSReply) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *BatchSendSMSReply) GetData() []*SendSmsDetail {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*SendPhoneCodeReq)(nil), "imsendsmsserver.SendPhoneCodeReq")
	proto.RegisterType((*SendPhoneCodeReply)(nil), "imsendsmsserver.SendPhoneCodeReply")
	proto.RegisterType((*CheckPhoneCodeReq)(nil), "imsendsmsserver.CheckPhoneCodeReq")
	proto.RegisterType((*CheckPhoneCodeReply)(nil), "imsendsmsserver.CheckPhoneCodeReply")
	proto.RegisterType((*SendEmailCodeReq)(nil), "imsendsmsserver.SendEmailCodeReq")
	proto.RegisterType((*SendEmailCodeReply)(nil), "imsendsmsserver.SendEmailCodeReply")
	proto.RegisterType((*CheckEmailCodeReq)(nil), "imsendsmsserver.CheckEmailCodeReq")
	proto.RegisterType((*CheckEmailCodeReply)(nil), "imsendsmsserver.CheckEmailCodeReply")
	proto.RegisterType((*BatchSendSMSReq)(nil), "imsendsmsserver.BatchSendSMSReq")
	proto.RegisterType((*SendSmsDetail)(nil), "imsendsmsserver.SendSmsDetail")
	proto.RegisterType((*BatchSendSMSReply)(nil), "imsendsmsserver.BatchSendSMSReply")
	proto.RegisterEnum("imsendsmsserver.ReErrCode", ReErrCode_name, ReErrCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SendSmsServer service

type SendSmsServerClient interface {
	// 发送手机验证码
	SendPhoneCode(ctx context.Context, in *SendPhoneCodeReq, opts ...grpc.CallOption) (*SendPhoneCodeReply, error)
	// 重发手机验证
	ReSendPhoneCode(ctx context.Context, in *SendPhoneCodeReq, opts ...grpc.CallOption) (*SendPhoneCodeReply, error)
	// 校验手机验证码
	CheckPhoneCode(ctx context.Context, in *CheckPhoneCodeReq, opts ...grpc.CallOption) (*CheckPhoneCodeReply, error)
	// 批量发送手机短信
	BatchSendSMS(ctx context.Context, in *BatchSendSMSReq, opts ...grpc.CallOption) (*BatchSendSMSReply, error)
	// 发送邮件验证码
	SendEmailCode(ctx context.Context, in *SendEmailCodeReq, opts ...grpc.CallOption) (*SendEmailCodeReply, error)
	// 重发邮件验证码
	ReSendEmailCode(ctx context.Context, in *SendEmailCodeReq, opts ...grpc.CallOption) (*SendEmailCodeReply, error)
	// 校验邮箱验证码
	CheckEmailCode(ctx context.Context, in *CheckEmailCodeReq, opts ...grpc.CallOption) (*CheckEmailCodeReply, error)
}

type sendSmsServerClient struct {
	cc *grpc.ClientConn
}

func NewSendSmsServerClient(cc *grpc.ClientConn) SendSmsServerClient {
	return &sendSmsServerClient{cc}
}

func (c *sendSmsServerClient) SendPhoneCode(ctx context.Context, in *SendPhoneCodeReq, opts ...grpc.CallOption) (*SendPhoneCodeReply, error) {
	out := new(SendPhoneCodeReply)
	err := grpc.Invoke(ctx, "/imsendsmsserver.SendSmsServer/SendPhoneCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendSmsServerClient) ReSendPhoneCode(ctx context.Context, in *SendPhoneCodeReq, opts ...grpc.CallOption) (*SendPhoneCodeReply, error) {
	out := new(SendPhoneCodeReply)
	err := grpc.Invoke(ctx, "/imsendsmsserver.SendSmsServer/ReSendPhoneCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendSmsServerClient) CheckPhoneCode(ctx context.Context, in *CheckPhoneCodeReq, opts ...grpc.CallOption) (*CheckPhoneCodeReply, error) {
	out := new(CheckPhoneCodeReply)
	err := grpc.Invoke(ctx, "/imsendsmsserver.SendSmsServer/CheckPhoneCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendSmsServerClient) BatchSendSMS(ctx context.Context, in *BatchSendSMSReq, opts ...grpc.CallOption) (*BatchSendSMSReply, error) {
	out := new(BatchSendSMSReply)
	err := grpc.Invoke(ctx, "/imsendsmsserver.SendSmsServer/BatchSendSMS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendSmsServerClient) SendEmailCode(ctx context.Context, in *SendEmailCodeReq, opts ...grpc.CallOption) (*SendEmailCodeReply, error) {
	out := new(SendEmailCodeReply)
	err := grpc.Invoke(ctx, "/imsendsmsserver.SendSmsServer/SendEmailCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendSmsServerClient) ReSendEmailCode(ctx context.Context, in *SendEmailCodeReq, opts ...grpc.CallOption) (*SendEmailCodeReply, error) {
	out := new(SendEmailCodeReply)
	err := grpc.Invoke(ctx, "/imsendsmsserver.SendSmsServer/ReSendEmailCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sendSmsServerClient) CheckEmailCode(ctx context.Context, in *CheckEmailCodeReq, opts ...grpc.CallOption) (*CheckEmailCodeReply, error) {
	out := new(CheckEmailCodeReply)
	err := grpc.Invoke(ctx, "/imsendsmsserver.SendSmsServer/CheckEmailCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SendSmsServer service

type SendSmsServerServer interface {
	// 发送手机验证码
	SendPhoneCode(context.Context, *SendPhoneCodeReq) (*SendPhoneCodeReply, error)
	// 重发手机验证
	ReSendPhoneCode(context.Context, *SendPhoneCodeReq) (*SendPhoneCodeReply, error)
	// 校验手机验证码
	CheckPhoneCode(context.Context, *CheckPhoneCodeReq) (*CheckPhoneCodeReply, error)
	// 批量发送手机短信
	BatchSendSMS(context.Context, *BatchSendSMSReq) (*BatchSendSMSReply, error)
	// 发送邮件验证码
	SendEmailCode(context.Context, *SendEmailCodeReq) (*SendEmailCodeReply, error)
	// 重发邮件验证码
	ReSendEmailCode(context.Context, *SendEmailCodeReq) (*SendEmailCodeReply, error)
	// 校验邮箱验证码
	CheckEmailCode(context.Context, *CheckEmailCodeReq) (*CheckEmailCodeReply, error)
}

func RegisterSendSmsServerServer(s *grpc.Server, srv SendSmsServerServer) {
	s.RegisterService(&_SendSmsServer_serviceDesc, srv)
}

func _SendSmsServer_SendPhoneCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPhoneCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendSmsServerServer).SendPhoneCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsendsmsserver.SendSmsServer/SendPhoneCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendSmsServerServer).SendPhoneCode(ctx, req.(*SendPhoneCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendSmsServer_ReSendPhoneCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPhoneCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendSmsServerServer).ReSendPhoneCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsendsmsserver.SendSmsServer/ReSendPhoneCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendSmsServerServer).ReSendPhoneCode(ctx, req.(*SendPhoneCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendSmsServer_CheckPhoneCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckPhoneCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendSmsServerServer).CheckPhoneCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsendsmsserver.SendSmsServer/CheckPhoneCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendSmsServerServer).CheckPhoneCode(ctx, req.(*CheckPhoneCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendSmsServer_BatchSendSMS_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSendSMSReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendSmsServerServer).BatchSendSMS(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsendsmsserver.SendSmsServer/BatchSendSMS",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendSmsServerServer).BatchSendSMS(ctx, req.(*BatchSendSMSReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendSmsServer_SendEmailCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendEmailCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendSmsServerServer).SendEmailCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsendsmsserver.SendSmsServer/SendEmailCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendSmsServerServer).SendEmailCode(ctx, req.(*SendEmailCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendSmsServer_ReSendEmailCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendEmailCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendSmsServerServer).ReSendEmailCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsendsmsserver.SendSmsServer/ReSendEmailCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendSmsServerServer).ReSendEmailCode(ctx, req.(*SendEmailCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SendSmsServer_CheckEmailCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckEmailCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendSmsServerServer).CheckEmailCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsendsmsserver.SendSmsServer/CheckEmailCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendSmsServerServer).CheckEmailCode(ctx, req.(*CheckEmailCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _SendSmsServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imsendsmsserver.SendSmsServer",
	HandlerType: (*SendSmsServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendPhoneCode",
			Handler:    _SendSmsServer_SendPhoneCode_Handler,
		},
		{
			MethodName: "ReSendPhoneCode",
			Handler:    _SendSmsServer_ReSendPhoneCode_Handler,
		},
		{
			MethodName: "CheckPhoneCode",
			Handler:    _SendSmsServer_CheckPhoneCode_Handler,
		},
		{
			MethodName: "BatchSendSMS",
			Handler:    _SendSmsServer_BatchSendSMS_Handler,
		},
		{
			MethodName: "SendEmailCode",
			Handler:    _SendSmsServer_SendEmailCode_Handler,
		},
		{
			MethodName: "ReSendEmailCode",
			Handler:    _SendSmsServer_ReSendEmailCode_Handler,
		},
		{
			MethodName: "CheckEmailCode",
			Handler:    _SendSmsServer_CheckEmailCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "imsendsmsserver.proto",
}

func (m *SendPhoneCodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPhoneCodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.KeyId))
	}
	if len(m.CountryCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.CountryCode)))
		i += copy(dAtA[i:], m.CountryCode)
	}
	if len(m.LocalPhone) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.LocalPhone)))
		i += copy(dAtA[i:], m.LocalPhone)
	}
	return i, nil
}

func (m *SendPhoneCodeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendPhoneCodeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PhoneHashCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.PhoneHashCode)))
		i += copy(dAtA[i:], m.PhoneHashCode)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.Timeout))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *CheckPhoneCodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPhoneCodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.KeyId))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *CheckPhoneCodeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckPhoneCodeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SendEmailCodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEmailCodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SendEmailCodeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEmailCodeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.EmailCodeHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.EmailCodeHash)))
		i += copy(dAtA[i:], m.EmailCodeHash)
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.Timeout))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *CheckEmailCodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckEmailCodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Email) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.KeyId))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *CheckEmailCodeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckEmailCodeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BatchSendSMSReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSendSMSReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumbers) > 0 {
		for _, s := range m.PhoneNumbers {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *SendSmsDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendSmsDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mobile) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.Mobile)))
		i += copy(dAtA[i:], m.Mobile)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Sid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.Sid))
	}
	if m.Code != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.Code))
	}
	if m.Count != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *BatchSendSMSReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSendSMSReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsendsmsserver(dAtA, i, uint64(m.TotalCount))
	}
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImsendsmsserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeFixed64Imsendsmsserver(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Imsendsmsserver(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintImsendsmsserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SendPhoneCodeReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.KeyId))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	l = len(m.LocalPhone)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	return n
}

func (m *SendPhoneCodeReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.PhoneHashCode)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.Timeout))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *CheckPhoneCodeReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.KeyId))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	return n
}

func (m *CheckPhoneCodeReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *SendEmailCodeReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.KeyId))
	}
	return n
}

func (m *SendEmailCodeReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.EmailCodeHash)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.Timeout))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *CheckEmailCodeReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.KeyId))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	return n
}

func (m *CheckEmailCodeReply) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *BatchSendSMSReq) Size() (n int) {
	var l int
	_ = l
	if len(m.PhoneNumbers) > 0 {
		for _, s := range m.PhoneNumbers {
			l = len(s)
			n += 1 + l + sovImsendsmsserver(uint64(l))
		}
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	return n
}

func (m *SendSmsDetail) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mobile)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovImsendsmsserver(uint64(l))
	}
	if m.Sid != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.Sid))
	}
	if m.Code != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.Code))
	}
	if m.Count != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.Count))
	}
	return n
}

func (m *BatchSendSMSReply) Size() (n int) {
	var l int
	_ = l
	if m.TotalCount != 0 {
		n += 1 + sovImsendsmsserver(uint64(m.TotalCount))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovImsendsmsserver(uint64(l))
		}
	}
	return n
}

func sovImsendsmsserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImsendsmsserver(x uint64) (n int) {
	return sovImsendsmsserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SendPhoneCodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPhoneCodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPhoneCodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendPhoneCodeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendPhoneCodeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendPhoneCodeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneHashCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneHashCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckPhoneCodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPhoneCodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPhoneCodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckPhoneCodeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckPhoneCodeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckPhoneCodeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEmailCodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEmailCodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEmailCodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEmailCodeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEmailCodeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEmailCodeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailCodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmailCodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ReErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckEmailCodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckEmailCodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckEmailCodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckEmailCodeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckEmailCodeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckEmailCodeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSendSMSReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSendSMSReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSendSMSReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumbers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumbers = append(m.PhoneNumbers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendSmsDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendSmsDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendSmsDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mobile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mobile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sid", wireType)
			}
			m.Sid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSendSMSReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSendSMSReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSendSMSReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &SendSmsDetail{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsendsmsserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsendsmsserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImsendsmsserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImsendsmsserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImsendsmsserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImsendsmsserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImsendsmsserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImsendsmsserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImsendsmsserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImsendsmsserver   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("imsendsmsserver.proto", fileDescriptorImsendsmsserver) }

var fileDescriptorImsendsmsserver = []byte{
	// 670 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xed, 0x6a, 0xd3, 0x50,
	0x18, 0x5e, 0xda, 0xa5, 0x5d, 0xde, 0x74, 0x6b, 0x77, 0x74, 0x1a, 0x2a, 0x74, 0x5d, 0x36, 0xa4,
	0xf8, 0x63, 0x42, 0xfd, 0xa5, 0x3f, 0x37, 0x07, 0x4e, 0x50, 0x24, 0x05, 0x41, 0x14, 0x4a, 0x96,
	0x1c, 0x96, 0xb2, 0x7c, 0xd4, 0x9c, 0x44, 0xac, 0xb7, 0xe1, 0x65, 0x78, 0x1f, 0xe2, 0x4f, 0x2f,
	0x41, 0x76, 0x25, 0xf2, 0xbe, 0x27, 0x89, 0x49, 0x6b, 0xed, 0x84, 0xf5, 0xdf, 0x79, 0x9f, 0xbe,
	0x5f, 0xcf, 0xf3, 0x9c, 0x13, 0x0a, 0x7b, 0x93, 0x40, 0xf0, 0xd0, 0x15, 0x81, 0x10, 0x3c, 0xfe,
	0xc4, 0xe3, 0xe3, 0x69, 0x1c, 0x25, 0x11, 0x6b, 0xcf, 0xc1, 0xe6, 0x77, 0x05, 0x3a, 0x23, 0x1e,
	0xba, 0x6f, 0xbc, 0x28, 0xe4, 0xa7, 0x91, 0xcb, 0x2d, 0xfe, 0x91, 0x1d, 0x40, 0x6b, 0x8a, 0xf1,
	0x38, 0x4c, 0x83, 0x0b, 0x1e, 0x1b, 0x4a, 0x5f, 0x19, 0x68, 0x96, 0x4e, 0xd8, 0x6b, 0x82, 0xd8,
	0x03, 0xd0, 0x7c, 0x3b, 0xbc, 0x1c, 0x3b, 0x91, 0xcb, 0x8d, 0x1a, 0xfd, 0xbe, 0x85, 0x00, 0xb6,
	0x60, 0xf7, 0xa1, 0x99, 0x0a, 0x1e, 0x8f, 0x27, 0xae, 0x51, 0xef, 0x2b, 0x03, 0xd5, 0x6a, 0x60,
	0x78, 0xee, 0xb2, 0x3d, 0x68, 0x5c, 0xf1, 0x19, 0xe2, 0x9b, 0x7d, 0x65, 0x50, 0xb7, 0xd4, 0x2b,
	0x3e, 0x3b, 0x77, 0x71, 0x9e, 0x13, 0xa5, 0x61, 0x12, 0xcf, 0x64, 0x3f, 0x55, 0xce, 0xcb, 0x30,
	0x6a, 0xb9, 0x0f, 0xba, 0x1f, 0x39, 0xb6, 0x3f, 0xa6, 0x25, 0x8c, 0x06, 0x65, 0x00, 0x41, 0xb4,
	0xba, 0xf9, 0x4d, 0x01, 0x36, 0x47, 0x64, 0xea, 0xcf, 0x98, 0x01, 0x4d, 0x91, 0x3a, 0x0e, 0x17,
	0x82, 0x58, 0x6c, 0x59, 0x79, 0xc8, 0x1e, 0x42, 0x5b, 0x92, 0xf4, 0x6c, 0xe1, 0x95, 0x79, 0x6c,
	0x13, 0xfc, 0xc2, 0x16, 0x1e, 0x4d, 0x36, 0xa0, 0x99, 0x4c, 0x02, 0x1e, 0xa5, 0x49, 0x46, 0x26,
	0x0f, 0xd9, 0x53, 0x00, 0x1e, 0xc7, 0x51, 0x2c, 0x8b, 0x91, 0xd1, 0xce, 0xb0, 0x7b, 0x3c, 0x2f,
	0xbc, 0xc5, 0xcf, 0xe2, 0x98, 0x16, 0xd2, 0x28, 0x1b, 0x8f, 0xe6, 0x17, 0xd8, 0x3d, 0xf5, 0xb8,
	0x73, 0xf5, 0xbf, 0xb2, 0x97, 0x94, 0xad, 0x2d, 0x51, 0xb6, 0x5e, 0x56, 0x96, 0xc1, 0x66, 0xb1,
	0x9c, 0x66, 0xd1, 0xd9, 0x7c, 0x0c, 0x77, 0xe6, 0x67, 0xff, 0x53, 0x29, 0x33, 0x95, 0x57, 0xe4,
	0x2c, 0xb0, 0x27, 0x7e, 0xbe, 0xeb, 0x5d, 0x50, 0x39, 0xc6, 0xd9, 0x92, 0x32, 0xb8, 0xd5, 0x5b,
	0x51, 0x38, 0x5a, 0x9a, 0xbb, 0xd2, 0x51, 0x5a, 0x83, 0xc6, 0x93, 0xad, 0xb9, 0xa3, 0x3c, 0x6f,
	0x81, 0xae, 0xae, 0xc7, 0xd1, 0x20, 0x73, 0xf4, 0x06, 0x2a, 0xdd, 0xa6, 0x89, 0x37, 0x15, 0xc7,
	0x7c, 0x09, 0xed, 0x13, 0x3b, 0x71, 0x3c, 0x54, 0x74, 0xf4, 0x6a, 0x84, 0xdb, 0x1d, 0xc2, 0x76,
	0xf9, 0xbe, 0x61, 0x49, 0x7d, 0xa0, 0x59, 0xad, 0xd2, 0x85, 0x13, 0x38, 0x3c, 0xe1, 0x9f, 0x93,
	0x4c, 0x49, 0x3a, 0x9b, 0x29, 0x6c, 0x53, 0x9b, 0x40, 0x3c, 0xe7, 0x09, 0x32, 0xba, 0x07, 0x8d,
	0x20, 0xba, 0x98, 0xf8, 0x3c, 0x23, 0x9a, 0x45, 0xac, 0x03, 0xf5, 0x40, 0x5c, 0x66, 0xb5, 0x78,
	0x44, 0x44, 0x14, 0xfc, 0xf0, 0x58, 0x61, 0xa7, 0x4a, 0x76, 0xa8, 0x1b, 0x3d, 0x7e, 0xfa, 0x12,
	0xa8, 0x96, 0x0c, 0x4c, 0x0f, 0x76, 0xab, 0x14, 0x90, 0xf1, 0x3e, 0xe8, 0x49, 0x94, 0xd8, 0x68,
	0x3a, 0x16, 0x28, 0x54, 0x00, 0x04, 0x9d, 0x22, 0xc2, 0x86, 0xb0, 0xe9, 0xda, 0x89, 0x6d, 0xd4,
	0xfa, 0xf5, 0x81, 0x3e, 0xec, 0x2d, 0xb8, 0x59, 0x61, 0x62, 0x51, 0xee, 0xa3, 0x67, 0xa0, 0x15,
	0x26, 0x33, 0x1d, 0x9a, 0x23, 0x29, 0x62, 0x67, 0x83, 0xb5, 0x41, 0xa7, 0x77, 0x33, 0x3e, 0x43,
	0xe7, 0x3b, 0x0a, 0x02, 0xe4, 0x41, 0x06, 0xd4, 0x86, 0x5f, 0xd5, 0x42, 0x9d, 0x11, 0x4d, 0x60,
	0xef, 0x24, 0x50, 0xbc, 0x37, 0x76, 0xf0, 0xd7, 0x25, 0xca, 0xdf, 0x82, 0xee, 0xe1, 0xaa, 0x94,
	0xa9, 0x3f, 0x33, 0x37, 0xd8, 0x7b, 0x68, 0x5b, 0x7c, 0x5d, 0xcd, 0x3f, 0xc0, 0x4e, 0xf5, 0x43,
	0xc1, 0xcc, 0x85, 0xc2, 0x85, 0xaf, 0x58, 0xf7, 0x68, 0x65, 0x8e, 0xec, 0xfe, 0x16, 0x5a, 0x65,
	0x37, 0x59, 0x7f, 0xa1, 0x6e, 0xee, 0xbe, 0x76, 0xcd, 0x15, 0x19, 0xb2, 0x6f, 0xa6, 0x76, 0xf1,
	0x30, 0x96, 0x08, 0x52, 0x7e, 0xa7, 0x4b, 0x04, 0xa9, 0xbe, 0xad, 0xb2, 0xda, 0xeb, 0x68, 0x9e,
	0xab, 0xfd, 0xa7, 0xf7, 0x12, 0xb5, 0x2b, 0xcd, 0x8f, 0x56, 0xe6, 0x50, 0xf7, 0x93, 0xd6, 0x8f,
	0xeb, 0x9e, 0xf2, 0xf3, 0xba, 0xa7, 0xfc, 0xba, 0xee, 0x29, 0x17, 0x0d, 0xfa, 0x37, 0xf0, 0xe4,
	0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf4, 0x07, 0x3a, 0xbf, 0x26, 0x08, 0x00, 0x00,
}
