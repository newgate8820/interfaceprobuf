// Code generated by protoc-gen-gogo.
// source: sequencer.proto
// DO NOT EDIT!

/*
Package sequencer is a generated protocol buffer package.

It is generated from these files:

	sequencer.proto

It has these top-level messages:

	GetRouterMessageReq
	GetRouterMessageReply
	GetCurMsgIDReq
	GetCurMsgIDReply
	IncreaseMsgIDReq
	IncreaseMsgIDReply
	LBVersion
	MetaData
*/
package sequencer

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GetRouterMessageReq struct {
	UserID  int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Version int32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *GetRouterMessageReq) Reset()                    { *m = GetRouterMessageReq{} }
func (m *GetRouterMessageReq) String() string            { return proto.CompactTextString(m) }
func (*GetRouterMessageReq) ProtoMessage()               {}
func (*GetRouterMessageReq) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{0} }

func (m *GetRouterMessageReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetRouterMessageReq) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type GetRouterMessageReply struct {
	ServerID  int32      `protobuf:"varint,1,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	HostName  string     `protobuf:"bytes,2,opt,name=HostName,proto3" json:"HostName,omitempty"`
	ServerIP  string     `protobuf:"bytes,3,opt,name=ServerIP,proto3" json:"ServerIP,omitempty"`
	LBVersion *LBVersion `protobuf:"bytes,4,opt,name=LBVersion" json:"LBVersion,omitempty"`
}

func (m *GetRouterMessageReply) Reset()                    { *m = GetRouterMessageReply{} }
func (m *GetRouterMessageReply) String() string            { return proto.CompactTextString(m) }
func (*GetRouterMessageReply) ProtoMessage()               {}
func (*GetRouterMessageReply) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{1} }

func (m *GetRouterMessageReply) GetServerID() int32 {
	if m != nil {
		return m.ServerID
	}
	return 0
}

func (m *GetRouterMessageReply) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *GetRouterMessageReply) GetServerIP() string {
	if m != nil {
		return m.ServerIP
	}
	return ""
}

func (m *GetRouterMessageReply) GetLBVersion() *LBVersion {
	if m != nil {
		return m.LBVersion
	}
	return nil
}

type GetCurMsgIDReq struct {
	UserID  int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	Version int32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *GetCurMsgIDReq) Reset()                    { *m = GetCurMsgIDReq{} }
func (m *GetCurMsgIDReq) String() string            { return proto.CompactTextString(m) }
func (*GetCurMsgIDReq) ProtoMessage()               {}
func (*GetCurMsgIDReq) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{2} }

func (m *GetCurMsgIDReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *GetCurMsgIDReq) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type GetCurMsgIDReply struct {
	MsgID     int32      `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Pts       int32      `protobuf:"varint,2,opt,name=Pts,proto3" json:"Pts,omitempty"`
	LBVersion *LBVersion `protobuf:"bytes,3,opt,name=LBVersion" json:"LBVersion,omitempty"`
}

func (m *GetCurMsgIDReply) Reset()                    { *m = GetCurMsgIDReply{} }
func (m *GetCurMsgIDReply) String() string            { return proto.CompactTextString(m) }
func (*GetCurMsgIDReply) ProtoMessage()               {}
func (*GetCurMsgIDReply) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{3} }

func (m *GetCurMsgIDReply) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *GetCurMsgIDReply) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *GetCurMsgIDReply) GetLBVersion() *LBVersion {
	if m != nil {
		return m.LBVersion
	}
	return nil
}

type IncreaseMsgIDReq struct {
	UserID    int32  `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	MsgIDIncr uint32 `protobuf:"varint,2,opt,name=MsgIDIncr,proto3" json:"MsgIDIncr,omitempty"`
	PtsIncr   uint32 `protobuf:"varint,3,opt,name=PtsIncr,proto3" json:"PtsIncr,omitempty"`
	Version   int32  `protobuf:"varint,4,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *IncreaseMsgIDReq) Reset()                    { *m = IncreaseMsgIDReq{} }
func (m *IncreaseMsgIDReq) String() string            { return proto.CompactTextString(m) }
func (*IncreaseMsgIDReq) ProtoMessage()               {}
func (*IncreaseMsgIDReq) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{4} }

func (m *IncreaseMsgIDReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *IncreaseMsgIDReq) GetMsgIDIncr() uint32 {
	if m != nil {
		return m.MsgIDIncr
	}
	return 0
}

func (m *IncreaseMsgIDReq) GetPtsIncr() uint32 {
	if m != nil {
		return m.PtsIncr
	}
	return 0
}

func (m *IncreaseMsgIDReq) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type IncreaseMsgIDReply struct {
	MsgID     int32      `protobuf:"varint,1,opt,name=MsgID,proto3" json:"MsgID,omitempty"`
	Pts       int32      `protobuf:"varint,2,opt,name=Pts,proto3" json:"Pts,omitempty"`
	LBVersion *LBVersion `protobuf:"bytes,3,opt,name=LBVersion" json:"LBVersion,omitempty"`
}

func (m *IncreaseMsgIDReply) Reset()                    { *m = IncreaseMsgIDReply{} }
func (m *IncreaseMsgIDReply) String() string            { return proto.CompactTextString(m) }
func (*IncreaseMsgIDReply) ProtoMessage()               {}
func (*IncreaseMsgIDReply) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{5} }

func (m *IncreaseMsgIDReply) GetMsgID() int32 {
	if m != nil {
		return m.MsgID
	}
	return 0
}

func (m *IncreaseMsgIDReply) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *IncreaseMsgIDReply) GetLBVersion() *LBVersion {
	if m != nil {
		return m.LBVersion
	}
	return nil
}

type LBVersion struct {
	ServerID int32 `protobuf:"varint,1,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	Version  int32 `protobuf:"varint,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *LBVersion) Reset()                    { *m = LBVersion{} }
func (m *LBVersion) String() string            { return proto.CompactTextString(m) }
func (*LBVersion) ProtoMessage()               {}
func (*LBVersion) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{6} }

func (m *LBVersion) GetServerID() int32 {
	if m != nil {
		return m.ServerID
	}
	return 0
}

func (m *LBVersion) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type MetaData struct {
	ServerStatus string `protobuf:"bytes,1,opt,name=ServerStatus,proto3" json:"ServerStatus,omitempty"`
	ServerID     int32  `protobuf:"varint,2,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
}

func (m *MetaData) Reset()                    { *m = MetaData{} }
func (m *MetaData) String() string            { return proto.CompactTextString(m) }
func (*MetaData) ProtoMessage()               {}
func (*MetaData) Descriptor() ([]byte, []int) { return fileDescriptorSequencer, []int{7} }

func (m *MetaData) GetServerStatus() string {
	if m != nil {
		return m.ServerStatus
	}
	return ""
}

func (m *MetaData) GetServerID() int32 {
	if m != nil {
		return m.ServerID
	}
	return 0
}

func init() {
	proto.RegisterType((*GetRouterMessageReq)(nil), "sequencer.GetRouterMessageReq")
	proto.RegisterType((*GetRouterMessageReply)(nil), "sequencer.GetRouterMessageReply")
	proto.RegisterType((*GetCurMsgIDReq)(nil), "sequencer.GetCurMsgIDReq")
	proto.RegisterType((*GetCurMsgIDReply)(nil), "sequencer.GetCurMsgIDReply")
	proto.RegisterType((*IncreaseMsgIDReq)(nil), "sequencer.IncreaseMsgIDReq")
	proto.RegisterType((*IncreaseMsgIDReply)(nil), "sequencer.IncreaseMsgIDReply")
	proto.RegisterType((*LBVersion)(nil), "sequencer.LBVersion")
	proto.RegisterType((*MetaData)(nil), "sequencer.MetaData")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SequenceService service

type SequenceServiceClient interface {
	// IncreaseMsgID 自增
	IncreaseMsgID(ctx context.Context, in *IncreaseMsgIDReq, opts ...grpc.CallOption) (*IncreaseMsgIDReply, error)
	// GetCurMsgID 获取当前自增序列值
	GetCurMsgID(ctx context.Context, in *GetCurMsgIDReq, opts ...grpc.CallOption) (*GetCurMsgIDReply, error)
	// 获取用户路由表，返回用户对应的机器im、hostname etc
	GetRouterMessage(ctx context.Context, in *GetRouterMessageReq, opts ...grpc.CallOption) (*GetRouterMessageReply, error)
}

type sequenceServiceClient struct {
	cc *grpc.ClientConn
}

func NewSequenceServiceClient(cc *grpc.ClientConn) SequenceServiceClient {
	return &sequenceServiceClient{cc}
}

func (c *sequenceServiceClient) IncreaseMsgID(ctx context.Context, in *IncreaseMsgIDReq, opts ...grpc.CallOption) (*IncreaseMsgIDReply, error) {
	out := new(IncreaseMsgIDReply)
	err := grpc.Invoke(ctx, "/sequencer.SequenceService/IncreaseMsgID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sequenceServiceClient) GetCurMsgID(ctx context.Context, in *GetCurMsgIDReq, opts ...grpc.CallOption) (*GetCurMsgIDReply, error) {
	out := new(GetCurMsgIDReply)
	err := grpc.Invoke(ctx, "/sequencer.SequenceService/GetCurMsgID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sequenceServiceClient) GetRouterMessage(ctx context.Context, in *GetRouterMessageReq, opts ...grpc.CallOption) (*GetRouterMessageReply, error) {
	out := new(GetRouterMessageReply)
	err := grpc.Invoke(ctx, "/sequencer.SequenceService/GetRouterMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SequenceService service

type SequenceServiceServer interface {
	// IncreaseMsgID 自增
	IncreaseMsgID(context.Context, *IncreaseMsgIDReq) (*IncreaseMsgIDReply, error)
	// GetCurMsgID 获取当前自增序列值
	GetCurMsgID(context.Context, *GetCurMsgIDReq) (*GetCurMsgIDReply, error)
	// 获取用户路由表，返回用户对应的机器im、hostname etc
	GetRouterMessage(context.Context, *GetRouterMessageReq) (*GetRouterMessageReply, error)
}

func RegisterSequenceServiceServer(s *grpc.Server, srv SequenceServiceServer) {
	s.RegisterService(&_SequenceService_serviceDesc, srv)
}

func _SequenceService_IncreaseMsgID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncreaseMsgIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SequenceServiceServer).IncreaseMsgID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sequencer.SequenceService/IncreaseMsgID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SequenceServiceServer).IncreaseMsgID(ctx, req.(*IncreaseMsgIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SequenceService_GetCurMsgID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCurMsgIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SequenceServiceServer).GetCurMsgID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sequencer.SequenceService/GetCurMsgID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SequenceServiceServer).GetCurMsgID(ctx, req.(*GetCurMsgIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SequenceService_GetRouterMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRouterMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SequenceServiceServer).GetRouterMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sequencer.SequenceService/GetRouterMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SequenceServiceServer).GetRouterMessage(ctx, req.(*GetRouterMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _SequenceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sequencer.SequenceService",
	HandlerType: (*SequenceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IncreaseMsgID",
			Handler:    _SequenceService_IncreaseMsgID_Handler,
		},
		{
			MethodName: "GetCurMsgID",
			Handler:    _SequenceService_GetCurMsgID_Handler,
		},
		{
			MethodName: "GetRouterMessage",
			Handler:    _SequenceService_GetRouterMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sequencer.proto",
}

func (m *GetRouterMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRouterMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.UserID))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *GetRouterMessageReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRouterMessageReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.ServerID))
	}
	if len(m.HostName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	if len(m.ServerIP) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(len(m.ServerIP)))
		i += copy(dAtA[i:], m.ServerIP)
	}
	if m.LBVersion != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.LBVersion.Size()))
		n1, err := m.LBVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *GetCurMsgIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCurMsgIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.UserID))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *GetCurMsgIDReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCurMsgIDReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.MsgID))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.Pts))
	}
	if m.LBVersion != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.LBVersion.Size()))
		n2, err := m.LBVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *IncreaseMsgIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncreaseMsgIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.UserID))
	}
	if m.MsgIDIncr != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.MsgIDIncr))
	}
	if m.PtsIncr != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.PtsIncr))
	}
	if m.Version != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *IncreaseMsgIDReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IncreaseMsgIDReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.MsgID))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.Pts))
	}
	if m.LBVersion != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.LBVersion.Size()))
		n3, err := m.LBVersion.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *LBVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LBVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.ServerID))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *MetaData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetaData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerStatus) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(len(m.ServerStatus)))
		i += copy(dAtA[i:], m.ServerStatus)
	}
	if m.ServerID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSequencer(dAtA, i, uint64(m.ServerID))
	}
	return i, nil
}

func encodeFixed64Sequencer(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Sequencer(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSequencer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetRouterMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovSequencer(uint64(m.UserID))
	}
	if m.Version != 0 {
		n += 1 + sovSequencer(uint64(m.Version))
	}
	return n
}

func (m *GetRouterMessageReply) Size() (n int) {
	var l int
	_ = l
	if m.ServerID != 0 {
		n += 1 + sovSequencer(uint64(m.ServerID))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovSequencer(uint64(l))
	}
	l = len(m.ServerIP)
	if l > 0 {
		n += 1 + l + sovSequencer(uint64(l))
	}
	if m.LBVersion != nil {
		l = m.LBVersion.Size()
		n += 1 + l + sovSequencer(uint64(l))
	}
	return n
}

func (m *GetCurMsgIDReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovSequencer(uint64(m.UserID))
	}
	if m.Version != 0 {
		n += 1 + sovSequencer(uint64(m.Version))
	}
	return n
}

func (m *GetCurMsgIDReply) Size() (n int) {
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovSequencer(uint64(m.MsgID))
	}
	if m.Pts != 0 {
		n += 1 + sovSequencer(uint64(m.Pts))
	}
	if m.LBVersion != nil {
		l = m.LBVersion.Size()
		n += 1 + l + sovSequencer(uint64(l))
	}
	return n
}

func (m *IncreaseMsgIDReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovSequencer(uint64(m.UserID))
	}
	if m.MsgIDIncr != 0 {
		n += 1 + sovSequencer(uint64(m.MsgIDIncr))
	}
	if m.PtsIncr != 0 {
		n += 1 + sovSequencer(uint64(m.PtsIncr))
	}
	if m.Version != 0 {
		n += 1 + sovSequencer(uint64(m.Version))
	}
	return n
}

func (m *IncreaseMsgIDReply) Size() (n int) {
	var l int
	_ = l
	if m.MsgID != 0 {
		n += 1 + sovSequencer(uint64(m.MsgID))
	}
	if m.Pts != 0 {
		n += 1 + sovSequencer(uint64(m.Pts))
	}
	if m.LBVersion != nil {
		l = m.LBVersion.Size()
		n += 1 + l + sovSequencer(uint64(l))
	}
	return n
}

func (m *LBVersion) Size() (n int) {
	var l int
	_ = l
	if m.ServerID != 0 {
		n += 1 + sovSequencer(uint64(m.ServerID))
	}
	if m.Version != 0 {
		n += 1 + sovSequencer(uint64(m.Version))
	}
	return n
}

func (m *MetaData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerStatus)
	if l > 0 {
		n += 1 + l + sovSequencer(uint64(l))
	}
	if m.ServerID != 0 {
		n += 1 + sovSequencer(uint64(m.ServerID))
	}
	return n
}

func sovSequencer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSequencer(x uint64) (n int) {
	return sovSequencer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetRouterMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRouterMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRouterMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRouterMessageReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRouterMessageReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRouterMessageReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSequencer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSequencer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LBVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSequencer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LBVersion == nil {
				m.LBVersion = &LBVersion{}
			}
			if err := m.LBVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCurMsgIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCurMsgIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCurMsgIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCurMsgIDReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCurMsgIDReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCurMsgIDReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LBVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSequencer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LBVersion == nil {
				m.LBVersion = &LBVersion{}
			}
			if err := m.LBVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncreaseMsgIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncreaseMsgIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncreaseMsgIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIDIncr", wireType)
			}
			m.MsgIDIncr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgIDIncr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PtsIncr", wireType)
			}
			m.PtsIncr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PtsIncr |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IncreaseMsgIDReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IncreaseMsgIDReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IncreaseMsgIDReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgID", wireType)
			}
			m.MsgID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LBVersion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSequencer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LBVersion == nil {
				m.LBVersion = &LBVersion{}
			}
			if err := m.LBVersion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LBVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LBVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LBVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetaData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetaData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetaData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSequencer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			m.ServerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSequencer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSequencer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSequencer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSequencer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSequencer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSequencer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSequencer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSequencer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSequencer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSequencer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sequencer.proto", fileDescriptorSequencer) }

var fileDescriptorSequencer = []byte{
	// 403 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xc1, 0x6e, 0xda, 0x40,
	0x10, 0xd5, 0x62, 0xa0, 0x78, 0x80, 0x82, 0xb6, 0xb4, 0x72, 0x4d, 0x6b, 0x21, 0x9f, 0x38, 0x71,
	0xa0, 0x5f, 0x50, 0x4a, 0x45, 0x69, 0x4b, 0x85, 0x4c, 0x93, 0xbb, 0x83, 0x46, 0x08, 0x89, 0xd8,
	0x66, 0x77, 0x1d, 0x09, 0x29, 0xff, 0x92, 0xdf, 0xc9, 0x31, 0x9f, 0x10, 0xf1, 0x1b, 0xb9, 0x44,
	0xbb, 0xd8, 0xc6, 0x4b, 0x04, 0x89, 0x22, 0xe5, 0xe6, 0x37, 0x6f, 0xe6, 0xcd, 0xbc, 0xdd, 0x59,
	0x43, 0x83, 0xe3, 0x3a, 0xc6, 0x60, 0x8e, 0xac, 0x17, 0xb1, 0x50, 0x84, 0xd4, 0xcc, 0x02, 0xee,
	0x08, 0x3e, 0x8c, 0x50, 0x78, 0x61, 0x2c, 0x90, 0x4d, 0x90, 0x73, 0x7f, 0x81, 0x1e, 0xae, 0xe9,
	0x27, 0x28, 0x9f, 0x71, 0x64, 0xe3, 0xa1, 0x45, 0x3a, 0xa4, 0x5b, 0xf2, 0x12, 0x44, 0x2d, 0x78,
	0x77, 0x8e, 0x8c, 0x2f, 0xc3, 0xc0, 0x2a, 0x28, 0x22, 0x85, 0xee, 0x0d, 0x81, 0x8f, 0x4f, 0x95,
	0xa2, 0xd5, 0x86, 0xda, 0x50, 0x99, 0x21, 0xbb, 0xca, 0xa9, 0x65, 0x58, 0x72, 0xbf, 0x42, 0x2e,
	0xfe, 0xf9, 0x97, 0xa8, 0x04, 0x4d, 0x2f, 0xc3, 0xb9, 0xba, 0xa9, 0x65, 0xec, 0xb8, 0x14, 0xd3,
	0x3e, 0x98, 0x7f, 0x07, 0xe9, 0x24, 0xc5, 0x0e, 0xe9, 0x56, 0xfb, 0xad, 0xde, 0xde, 0x66, 0xc6,
	0x79, 0xfb, 0x34, 0x77, 0x00, 0xef, 0x47, 0x28, 0x7e, 0xc4, 0x6c, 0xc2, 0x17, 0xe3, 0xe1, 0xeb,
	0x5c, 0x06, 0xd0, 0xd4, 0x34, 0xa4, 0xbf, 0x16, 0x94, 0x14, 0x4a, 0x44, 0x76, 0x80, 0x36, 0xc1,
	0x98, 0x0a, 0x9e, 0xd4, 0xcb, 0x4f, 0x7d, 0x66, 0xe3, 0x65, 0x33, 0x5f, 0x43, 0x73, 0x1c, 0xcc,
	0x19, 0xfa, 0x1c, 0x9f, 0x9d, 0xfa, 0x0b, 0x98, 0x2a, 0x47, 0x16, 0xa8, 0xbe, 0x75, 0x6f, 0x1f,
	0x90, 0x9e, 0xa6, 0x82, 0x2b, 0xce, 0x50, 0x5c, 0x0a, 0xf3, 0x6e, 0x8b, 0xba, 0xdb, 0x08, 0xe8,
	0x41, 0xf7, 0xb7, 0xf6, 0xfb, 0x3d, 0x57, 0x73, 0x72, 0x71, 0x8e, 0x5f, 0xd1, 0x6f, 0xa8, 0x4c,
	0x50, 0xf8, 0x43, 0x5f, 0xf8, 0xd4, 0x85, 0xda, 0xae, 0x62, 0x26, 0x7c, 0x11, 0x73, 0xa5, 0x62,
	0x7a, 0x5a, 0x4c, 0xeb, 0x52, 0xd0, 0xbb, 0xf4, 0x1f, 0x08, 0x34, 0x66, 0xc9, 0xc4, 0x32, 0xb8,
	0x9c, 0x23, 0xfd, 0x03, 0x75, 0xed, 0x50, 0x68, 0x3b, 0x67, 0xea, 0xf0, 0xb2, 0xec, 0xaf, 0xc7,
	0x49, 0x79, 0x96, 0x3f, 0xa1, 0x9a, 0xdb, 0x27, 0xfa, 0x39, 0x97, 0xad, 0xef, 0xaa, 0xdd, 0x3e,
	0x46, 0x49, 0x99, 0xff, 0x6a, 0x2d, 0xb5, 0xb7, 0x47, 0x1d, 0xbd, 0xe0, 0xf0, 0x89, 0xdb, 0x9d,
	0x93, 0x7c, 0xb4, 0xda, 0x0c, 0x6a, 0xb7, 0x5b, 0x87, 0xdc, 0x6d, 0x1d, 0x72, 0xbf, 0x75, 0xc8,
	0x45, 0x59, 0xfd, 0x3b, 0xbe, 0x3d, 0x06, 0x00, 0x00, 0xff, 0xff, 0x57, 0xe8, 0x0a, 0x74, 0x4e,
	0x04, 0x00, 0x00,
}
