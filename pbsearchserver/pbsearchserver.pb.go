// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/pbsearchserver/pbsearchserver.proto

/*
Package pbsearchserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/pbsearchserver/pbsearchserver.proto

It has these top-level messages:

	Message
	MessageInfo
	HandleSearchLogicReq
	HandleSearchLogicResp
	MessageSearchReq
	NoUseResp
	DeleteUserMessageReq
	DeleteChannelMessageReq
	SearchCursor
	UserChannelMsgId
	SearchMessageReq
	SearchResp
	SearchUserMessageByMaxMsgIdReq
	SearchChannelMessageByMaxMsgIdReq
	UpdateUserMessageMediaUnreadByMsgIdsReq
	DeleteUserMessageByMsgIdsReq
	DeleteUserMessageByUuidsReq
	DeleteUserMessageByUWTReq
	DeleteChannelMessageByMsgIdsReq
	DeleteChannelMessageByWithIdReq
	DeleteChannelMessageByUWMReq
	SearchUserMessageMediaReq
	SearchChannelMessageMediaReq
	SearchMediaResp
	HandlerReply
	UserNameInfo
	InsertGroupUsersReq
	DeleteGroupUsersReq
	UpdateGroupUserReq
	RenameGroupUserReq
	SearchGroupUsersReq
	SearchGroupUsersRsp
	InsertChanNameReq
	UpdateChanNameReq
	DeleteChanNameReq
	SearchChannelsReq
	SearchChannelsRsp
*/
package pbsearchserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"
import messagedb "gitlab.chatserver.im/interfaceprobuf/pbmessagedb"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type PeerType int32

const (
	PeerType_Empty     PeerType = 0
	PeerType_Self_User PeerType = 1
	PeerType_Chat      PeerType = 2
	PeerType_Channel   PeerType = 3
)

var PeerType_name = map[int32]string{
	0: "Empty",
	1: "Self_User",
	2: "Chat",
	3: "Channel",
}
var PeerType_value = map[string]int32{
	"Empty":     0,
	"Self_User": 1,
	"Chat":      2,
	"Channel":   3,
}

func (x PeerType) String() string {
	return proto.EnumName(PeerType_name, int32(x))
}
func (PeerType) EnumDescriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{0} }

type EMsgFlag int32

const (
	EMsgFlag_USERMESSAGE    EMsgFlag = 0
	EMsgFlag_CHANNELMESSAGE EMsgFlag = 1
)

var EMsgFlag_name = map[int32]string{
	0: "USERMESSAGE",
	1: "CHANNELMESSAGE",
}
var EMsgFlag_value = map[string]int32{
	"USERMESSAGE":    0,
	"CHANNELMESSAGE": 1,
}

func (x EMsgFlag) String() string {
	return proto.EnumName(EMsgFlag_name, int32(x))
}
func (EMsgFlag) EnumDescriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{1} }

type ErrorCode int32

const (
	ErrorCode_RPC_OK          ErrorCode = 0
	ErrorCode_RPC_ERROR       ErrorCode = 1
	ErrorCode_CHAN_NOT_EXIST  ErrorCode = 2
	ErrorCode_USER_NOT_EXIST  ErrorCode = 3
	ErrorCode_USER_NOT_FOUND  ErrorCode = 4
	ErrorCode_Keyword_Illegal ErrorCode = 5
	ErrorCode_Channel_Illegal ErrorCode = 6
)

var ErrorCode_name = map[int32]string{
	0: "RPC_OK",
	1: "RPC_ERROR",
	2: "CHAN_NOT_EXIST",
	3: "USER_NOT_EXIST",
	4: "USER_NOT_FOUND",
	5: "Keyword_Illegal",
	6: "Channel_Illegal",
}
var ErrorCode_value = map[string]int32{
	"RPC_OK":          0,
	"RPC_ERROR":       1,
	"CHAN_NOT_EXIST":  2,
	"USER_NOT_EXIST":  3,
	"USER_NOT_FOUND":  4,
	"Keyword_Illegal": 5,
	"Channel_Illegal": 6,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{2} }

type Message struct {
	UserId       int32    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId       int32    `protobuf:"varint,2,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	WithIdType   int32    `protobuf:"varint,3,opt,name=with_id_type,json=withIdType,proto3" json:"with_id_type,omitempty"`
	MsgId        int32    `protobuf:"varint,4,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	MessageType  int32    `protobuf:"varint,5,opt,name=message_type,json=messageType,proto3" json:"message_type,omitempty"`
	Message      string   `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
	FromId       int32    `protobuf:"varint,7,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	ToId         int32    `protobuf:"varint,8,opt,name=to_id,json=toId,proto3" json:"to_id,omitempty"`
	Media        int32    `protobuf:"varint,9,opt,name=media,proto3" json:"media,omitempty"`
	Date         int32    `protobuf:"varint,10,opt,name=date,proto3" json:"date,omitempty"`
	Uuid         int64    `protobuf:"varint,11,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Flags        int32    `protobuf:"varint,12,opt,name=flags,proto3" json:"flags,omitempty"`
	Out          bool     `protobuf:"varint,13,opt,name=out,proto3" json:"out,omitempty"`
	Mentioned    bool     `protobuf:"varint,14,opt,name=mentioned,proto3" json:"mentioned,omitempty"`
	MediaUnread  bool     `protobuf:"varint,15,opt,name=mediaUnread,proto3" json:"mediaUnread,omitempty"`
	Silent       bool     `protobuf:"varint,16,opt,name=silent,proto3" json:"silent,omitempty"`
	Post         bool     `protobuf:"varint,17,opt,name=post,proto3" json:"post,omitempty"`
	Pts          int32    `protobuf:"varint,18,opt,name=pts,proto3" json:"pts,omitempty"`
	FwdFrom      string   `protobuf:"bytes,19,opt,name=fwd_from,json=fwdFrom,proto3" json:"fwd_from,omitempty"`
	ViaBotId     int32    `protobuf:"varint,20,opt,name=via_bot_id,json=viaBotId,proto3" json:"via_bot_id,omitempty"`
	ReplyToMsgId int32    `protobuf:"varint,21,opt,name=reply_to_msg_id,json=replyToMsgId,proto3" json:"reply_to_msg_id,omitempty"`
	MediaData    string   `protobuf:"bytes,22,opt,name=media_data,json=mediaData,proto3" json:"media_data,omitempty"`
	ReplyMarkup  string   `protobuf:"bytes,23,opt,name=reply_markup,json=replyMarkup,proto3" json:"reply_markup,omitempty"`
	Entities     string   `protobuf:"bytes,24,opt,name=entities,proto3" json:"entities,omitempty"`
	Views        int32    `protobuf:"varint,25,opt,name=views,proto3" json:"views,omitempty"`
	EditDate     int32    `protobuf:"varint,26,opt,name=edit_date,json=editDate,proto3" json:"edit_date,omitempty"`
	Action       string   `protobuf:"bytes,27,opt,name=action,proto3" json:"action,omitempty"`
	RandomId     int64    `protobuf:"varint,28,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	InsertDate   int32    `protobuf:"varint,29,opt,name=insert_date,json=insertDate,proto3" json:"insert_date,omitempty"`
	UpdateDate   int32    `protobuf:"varint,30,opt,name=update_date,json=updateDate,proto3" json:"update_date,omitempty"`
	GroupId      int64    `protobuf:"varint,31,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Combination  string   `protobuf:"bytes,32,opt,name=combination,proto3" json:"combination,omitempty"`
	Encry        int32    `protobuf:"varint,33,opt,name=encry,proto3" json:"encry,omitempty"`
	Flag         EMsgFlag `protobuf:"varint,34,opt,name=flag,proto3,enum=pbsearchserver.EMsgFlag" json:"flag,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{0} }

func (m *Message) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Message) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *Message) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *Message) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *Message) GetMessageType() int32 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *Message) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Message) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *Message) GetToId() int32 {
	if m != nil {
		return m.ToId
	}
	return 0
}

func (m *Message) GetMedia() int32 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *Message) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *Message) GetUuid() int64 {
	if m != nil {
		return m.Uuid
	}
	return 0
}

func (m *Message) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *Message) GetOut() bool {
	if m != nil {
		return m.Out
	}
	return false
}

func (m *Message) GetMentioned() bool {
	if m != nil {
		return m.Mentioned
	}
	return false
}

func (m *Message) GetMediaUnread() bool {
	if m != nil {
		return m.MediaUnread
	}
	return false
}

func (m *Message) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *Message) GetPost() bool {
	if m != nil {
		return m.Post
	}
	return false
}

func (m *Message) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *Message) GetFwdFrom() string {
	if m != nil {
		return m.FwdFrom
	}
	return ""
}

func (m *Message) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

func (m *Message) GetReplyToMsgId() int32 {
	if m != nil {
		return m.ReplyToMsgId
	}
	return 0
}

func (m *Message) GetMediaData() string {
	if m != nil {
		return m.MediaData
	}
	return ""
}

func (m *Message) GetReplyMarkup() string {
	if m != nil {
		return m.ReplyMarkup
	}
	return ""
}

func (m *Message) GetEntities() string {
	if m != nil {
		return m.Entities
	}
	return ""
}

func (m *Message) GetViews() int32 {
	if m != nil {
		return m.Views
	}
	return 0
}

func (m *Message) GetEditDate() int32 {
	if m != nil {
		return m.EditDate
	}
	return 0
}

func (m *Message) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *Message) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *Message) GetInsertDate() int32 {
	if m != nil {
		return m.InsertDate
	}
	return 0
}

func (m *Message) GetUpdateDate() int32 {
	if m != nil {
		return m.UpdateDate
	}
	return 0
}

func (m *Message) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *Message) GetCombination() string {
	if m != nil {
		return m.Combination
	}
	return ""
}

func (m *Message) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *Message) GetFlag() EMsgFlag {
	if m != nil {
		return m.Flag
	}
	return EMsgFlag_USERMESSAGE
}

type MessageInfo struct {
	UserId     int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId     int32  `protobuf:"varint,2,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	WithIdType int32  `protobuf:"varint,3,opt,name=with_id_type,json=withIdType,proto3" json:"with_id_type,omitempty"`
	MsgId      int32  `protobuf:"varint,4,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	Message    string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	FromId     int32  `protobuf:"varint,6,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	Media      int32  `protobuf:"varint,7,opt,name=media,proto3" json:"media,omitempty"`
	Date       int32  `protobuf:"varint,8,opt,name=date,proto3" json:"date,omitempty"`
	Encry      int32  `protobuf:"varint,9,opt,name=encry,proto3" json:"encry,omitempty"`
	Uuid       int64  `protobuf:"varint,10,opt,name=uuid,proto3" json:"uuid,omitempty"`
}

func (m *MessageInfo) Reset()                    { *m = MessageInfo{} }
func (m *MessageInfo) String() string            { return proto.CompactTextString(m) }
func (*MessageInfo) ProtoMessage()               {}
func (*MessageInfo) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{1} }

func (m *MessageInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MessageInfo) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *MessageInfo) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *MessageInfo) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *MessageInfo) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *MessageInfo) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *MessageInfo) GetMedia() int32 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *MessageInfo) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *MessageInfo) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *MessageInfo) GetUuid() int64 {
	if m != nil {
		return m.Uuid
	}
	return 0
}

// 搜索协议请求
type HandleSearchLogicReq struct {
	MessageId  int64  `protobuf:"varint,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	KeyId      int64  `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	UserId     int32  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CrcId      int64  `protobuf:"varint,4,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	ObjBin     []byte `protobuf:"bytes,5,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	PhoneId    string `protobuf:"bytes,6,opt,name=phone_id,json=phoneId,proto3" json:"phone_id,omitempty"`
	Layer      int32  `protobuf:"varint,7,opt,name=layer,proto3" json:"layer,omitempty"`
	AppVersion string `protobuf:"bytes,8,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
}

func (m *HandleSearchLogicReq) Reset()         { *m = HandleSearchLogicReq{} }
func (m *HandleSearchLogicReq) String() string { return proto.CompactTextString(m) }
func (*HandleSearchLogicReq) ProtoMessage()    {}
func (*HandleSearchLogicReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{2}
}

func (m *HandleSearchLogicReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *HandleSearchLogicReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *HandleSearchLogicReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HandleSearchLogicReq) GetCrcId() int64 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *HandleSearchLogicReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *HandleSearchLogicReq) GetPhoneId() string {
	if m != nil {
		return m.PhoneId
	}
	return ""
}

func (m *HandleSearchLogicReq) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *HandleSearchLogicReq) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

// 搜索协议响应
type HandleSearchLogicResp struct {
	Result  []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	ErrCode int32  `protobuf:"varint,2,opt,name=err_code,json=errCode,proto3" json:"err_code,omitempty"`
	ErrMsg  string `protobuf:"bytes,3,opt,name=err_msg,json=errMsg,proto3" json:"err_msg,omitempty"`
}

func (m *HandleSearchLogicResp) Reset()         { *m = HandleSearchLogicResp{} }
func (m *HandleSearchLogicResp) String() string { return proto.CompactTextString(m) }
func (*HandleSearchLogicResp) ProtoMessage()    {}
func (*HandleSearchLogicResp) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{3}
}

func (m *HandleSearchLogicResp) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *HandleSearchLogicResp) GetErrCode() int32 {
	if m != nil {
		return m.ErrCode
	}
	return 0
}

func (m *HandleSearchLogicResp) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

// es 消息搜索结构体
type MessageSearchReq struct {
	KeyId      int64    `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	UserId     int32    `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FromId     int32    `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerType   PeerType `protobuf:"varint,4,opt,name=peer_type,json=peerType,proto3,enum=pbsearchserver.PeerType" json:"peer_type,omitempty"`
	WithId     int32    `protobuf:"varint,5,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	WithIdType int32    `protobuf:"varint,6,opt,name=with_id_type,json=withIdType,proto3" json:"with_id_type,omitempty"`
	Keyword    string   `protobuf:"bytes,7,opt,name=keyword,proto3" json:"keyword,omitempty"`
	MinDate    int32    `protobuf:"varint,8,opt,name=min_date,json=minDate,proto3" json:"min_date,omitempty"`
	MaxDate    int32    `protobuf:"varint,9,opt,name=max_date,json=maxDate,proto3" json:"max_date,omitempty"`
	Offset     int32    `protobuf:"varint,10,opt,name=offset,proto3" json:"offset,omitempty"`
	MaxId      int32    `protobuf:"varint,11,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
	Limit      int32    `protobuf:"varint,12,opt,name=limit,proto3" json:"limit,omitempty"`
	Encry      int32    `protobuf:"varint,13,opt,name=encry,proto3" json:"encry,omitempty"`
	MediaTypes []int32  `protobuf:"varint,14,rep,packed,name=media_types,json=mediaTypes" json:"media_types,omitempty"`
}

func (m *MessageSearchReq) Reset()                    { *m = MessageSearchReq{} }
func (m *MessageSearchReq) String() string            { return proto.CompactTextString(m) }
func (*MessageSearchReq) ProtoMessage()               {}
func (*MessageSearchReq) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{4} }

func (m *MessageSearchReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *MessageSearchReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MessageSearchReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *MessageSearchReq) GetPeerType() PeerType {
	if m != nil {
		return m.PeerType
	}
	return PeerType_Empty
}

func (m *MessageSearchReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *MessageSearchReq) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *MessageSearchReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *MessageSearchReq) GetMinDate() int32 {
	if m != nil {
		return m.MinDate
	}
	return 0
}

func (m *MessageSearchReq) GetMaxDate() int32 {
	if m != nil {
		return m.MaxDate
	}
	return 0
}

func (m *MessageSearchReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MessageSearchReq) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *MessageSearchReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *MessageSearchReq) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *MessageSearchReq) GetMediaTypes() []int32 {
	if m != nil {
		return m.MediaTypes
	}
	return nil
}

type NoUseResp struct {
	Reserved uint32 `protobuf:"varint,1,opt,name=reserved,proto3" json:"reserved,omitempty"`
}

func (m *NoUseResp) Reset()                    { *m = NoUseResp{} }
func (m *NoUseResp) String() string            { return proto.CompactTextString(m) }
func (*NoUseResp) ProtoMessage()               {}
func (*NoUseResp) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{5} }

func (m *NoUseResp) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

// 删除普通消息请求
type DeleteUserMessageReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	MsgId  int32 `protobuf:"varint,2,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
}

func (m *DeleteUserMessageReq) Reset()         { *m = DeleteUserMessageReq{} }
func (m *DeleteUserMessageReq) String() string { return proto.CompactTextString(m) }
func (*DeleteUserMessageReq) ProtoMessage()    {}
func (*DeleteUserMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{6}
}

func (m *DeleteUserMessageReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteUserMessageReq) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

type DeleteChannelMessageReq struct {
	WithId int32 `protobuf:"varint,1,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	MsgId  int32 `protobuf:"varint,2,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
}

func (m *DeleteChannelMessageReq) Reset()         { *m = DeleteChannelMessageReq{} }
func (m *DeleteChannelMessageReq) String() string { return proto.CompactTextString(m) }
func (*DeleteChannelMessageReq) ProtoMessage()    {}
func (*DeleteChannelMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{7}
}

func (m *DeleteChannelMessageReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *DeleteChannelMessageReq) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

type SearchCursor struct {
	Date  int32 `protobuf:"varint,1,opt,name=date,proto3" json:"date,omitempty"`
	UWId  int32 `protobuf:"varint,2,opt,name=u_w_id,json=uWId,proto3" json:"u_w_id,omitempty"`
	MsgId int32 `protobuf:"varint,3,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
}

func (m *SearchCursor) Reset()                    { *m = SearchCursor{} }
func (m *SearchCursor) String() string            { return proto.CompactTextString(m) }
func (*SearchCursor) ProtoMessage()               {}
func (*SearchCursor) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{8} }

func (m *SearchCursor) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *SearchCursor) GetUWId() int32 {
	if m != nil {
		return m.UWId
	}
	return 0
}

func (m *SearchCursor) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

type UserChannelMsgId struct {
	ChannelId  int32 `protobuf:"varint,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	MsgIdStart int32 `protobuf:"varint,2,opt,name=msg_id_start,json=msgIdStart,proto3" json:"msg_id_start,omitempty"`
}

func (m *UserChannelMsgId) Reset()                    { *m = UserChannelMsgId{} }
func (m *UserChannelMsgId) String() string            { return proto.CompactTextString(m) }
func (*UserChannelMsgId) ProtoMessage()               {}
func (*UserChannelMsgId) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{9} }

func (m *UserChannelMsgId) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *UserChannelMsgId) GetMsgIdStart() int32 {
	if m != nil {
		return m.MsgIdStart
	}
	return 0
}

// 全局搜索请求
type SearchMessageReq struct {
	KeyId             uint64              `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Keyword           string              `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Cursor            *SearchCursor       `protobuf:"bytes,3,opt,name=cursor" json:"cursor,omitempty"`
	Size_             int32               `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
	UserId            int32               `protobuf:"varint,5,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FromId            int32               `protobuf:"varint,6,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	Searchtype        EMsgFlag            `protobuf:"varint,7,opt,name=searchtype,proto3,enum=pbsearchserver.EMsgFlag" json:"searchtype,omitempty"`
	UserChannelMsgIds []*UserChannelMsgId `protobuf:"bytes,8,rep,name=user_channel_msg_ids,json=userChannelMsgIds" json:"user_channel_msg_ids,omitempty"`
}

func (m *SearchMessageReq) Reset()                    { *m = SearchMessageReq{} }
func (m *SearchMessageReq) String() string            { return proto.CompactTextString(m) }
func (*SearchMessageReq) ProtoMessage()               {}
func (*SearchMessageReq) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{10} }

func (m *SearchMessageReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SearchMessageReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *SearchMessageReq) GetCursor() *SearchCursor {
	if m != nil {
		return m.Cursor
	}
	return nil
}

func (m *SearchMessageReq) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchMessageReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SearchMessageReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *SearchMessageReq) GetSearchtype() EMsgFlag {
	if m != nil {
		return m.Searchtype
	}
	return EMsgFlag_USERMESSAGE
}

func (m *SearchMessageReq) GetUserChannelMsgIds() []*UserChannelMsgId {
	if m != nil {
		return m.UserChannelMsgIds
	}
	return nil
}

type SearchResp struct {
	Messages []*Message    `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
	Count    int32         `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	Cursor   *SearchCursor `protobuf:"bytes,3,opt,name=cursor" json:"cursor,omitempty"`
}

func (m *SearchResp) Reset()                    { *m = SearchResp{} }
func (m *SearchResp) String() string            { return proto.CompactTextString(m) }
func (*SearchResp) ProtoMessage()               {}
func (*SearchResp) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{11} }

func (m *SearchResp) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *SearchResp) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *SearchResp) GetCursor() *SearchCursor {
	if m != nil {
		return m.Cursor
	}
	return nil
}

type SearchUserMessageByMaxMsgIdReq struct {
	KeyId    uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Keyword  string `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Size_    int32  `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	UserId   int32  `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId   int32  `protobuf:"varint,5,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	FromId   int32  `protobuf:"varint,6,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	MaxMsgId int32  `protobuf:"varint,7,opt,name=max_msg_id,json=maxMsgId,proto3" json:"max_msg_id,omitempty"`
}

func (m *SearchUserMessageByMaxMsgIdReq) Reset()         { *m = SearchUserMessageByMaxMsgIdReq{} }
func (m *SearchUserMessageByMaxMsgIdReq) String() string { return proto.CompactTextString(m) }
func (*SearchUserMessageByMaxMsgIdReq) ProtoMessage()    {}
func (*SearchUserMessageByMaxMsgIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{12}
}

func (m *SearchUserMessageByMaxMsgIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SearchUserMessageByMaxMsgIdReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *SearchUserMessageByMaxMsgIdReq) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchUserMessageByMaxMsgIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SearchUserMessageByMaxMsgIdReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *SearchUserMessageByMaxMsgIdReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *SearchUserMessageByMaxMsgIdReq) GetMaxMsgId() int32 {
	if m != nil {
		return m.MaxMsgId
	}
	return 0
}

type SearchChannelMessageByMaxMsgIdReq struct {
	KeyId      uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Keyword    string `protobuf:"bytes,2,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Size_      int32  `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	UserId     int32  `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId     int32  `protobuf:"varint,5,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	FromId     int32  `protobuf:"varint,6,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	MsgIdStart int32  `protobuf:"varint,7,opt,name=msg_id_start,json=msgIdStart,proto3" json:"msg_id_start,omitempty"`
	MaxMsgId   int32  `protobuf:"varint,8,opt,name=max_msg_id,json=maxMsgId,proto3" json:"max_msg_id,omitempty"`
}

func (m *SearchChannelMessageByMaxMsgIdReq) Reset()         { *m = SearchChannelMessageByMaxMsgIdReq{} }
func (m *SearchChannelMessageByMaxMsgIdReq) String() string { return proto.CompactTextString(m) }
func (*SearchChannelMessageByMaxMsgIdReq) ProtoMessage()    {}
func (*SearchChannelMessageByMaxMsgIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{13}
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetMsgIdStart() int32 {
	if m != nil {
		return m.MsgIdStart
	}
	return 0
}

func (m *SearchChannelMessageByMaxMsgIdReq) GetMaxMsgId() int32 {
	if m != nil {
		return m.MaxMsgId
	}
	return 0
}

type UpdateUserMessageMediaUnreadByMsgIdsReq struct {
	MediaUnread bool    `protobuf:"varint,1,opt,name=media_unread,json=mediaUnread,proto3" json:"media_unread,omitempty"`
	UserId      int32   `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	MsgIds      []int32 `protobuf:"varint,3,rep,packed,name=msg_ids,json=msgIds" json:"msg_ids,omitempty"`
}

func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) Reset() {
	*m = UpdateUserMessageMediaUnreadByMsgIdsReq{}
}
func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) String() string { return proto.CompactTextString(m) }
func (*UpdateUserMessageMediaUnreadByMsgIdsReq) ProtoMessage()    {}
func (*UpdateUserMessageMediaUnreadByMsgIdsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{14}
}

func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) GetMediaUnread() bool {
	if m != nil {
		return m.MediaUnread
	}
	return false
}

func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) GetMsgIds() []int32 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

type DeleteUserMessageByMsgIdsReq struct {
	UserId int32   `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	MsgIds []int32 `protobuf:"varint,2,rep,packed,name=msg_ids,json=msgIds" json:"msg_ids,omitempty"`
}

func (m *DeleteUserMessageByMsgIdsReq) Reset()         { *m = DeleteUserMessageByMsgIdsReq{} }
func (m *DeleteUserMessageByMsgIdsReq) String() string { return proto.CompactTextString(m) }
func (*DeleteUserMessageByMsgIdsReq) ProtoMessage()    {}
func (*DeleteUserMessageByMsgIdsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{15}
}

func (m *DeleteUserMessageByMsgIdsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteUserMessageByMsgIdsReq) GetMsgIds() []int32 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

type DeleteUserMessageByUuidsReq struct {
	UserId int32   `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Uuids  []int32 `protobuf:"varint,2,rep,packed,name=uuids" json:"uuids,omitempty"`
}

func (m *DeleteUserMessageByUuidsReq) Reset()         { *m = DeleteUserMessageByUuidsReq{} }
func (m *DeleteUserMessageByUuidsReq) String() string { return proto.CompactTextString(m) }
func (*DeleteUserMessageByUuidsReq) ProtoMessage()    {}
func (*DeleteUserMessageByUuidsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{16}
}

func (m *DeleteUserMessageByUuidsReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteUserMessageByUuidsReq) GetUuids() []int32 {
	if m != nil {
		return m.Uuids
	}
	return nil
}

type DeleteUserMessageByUWTReq struct {
	UserId     int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId     int32 `protobuf:"varint,2,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	WithIdType int32 `protobuf:"varint,3,opt,name=with_id_type,json=withIdType,proto3" json:"with_id_type,omitempty"`
}

func (m *DeleteUserMessageByUWTReq) Reset()         { *m = DeleteUserMessageByUWTReq{} }
func (m *DeleteUserMessageByUWTReq) String() string { return proto.CompactTextString(m) }
func (*DeleteUserMessageByUWTReq) ProtoMessage()    {}
func (*DeleteUserMessageByUWTReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{17}
}

func (m *DeleteUserMessageByUWTReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteUserMessageByUWTReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *DeleteUserMessageByUWTReq) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

// 批量删除超级群消息
type DeleteChannelMessageByMsgIdsReq struct {
	WithId int32   `protobuf:"varint,1,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	MsgIds []int32 `protobuf:"varint,2,rep,packed,name=msg_ids,json=msgIds" json:"msg_ids,omitempty"`
}

func (m *DeleteChannelMessageByMsgIdsReq) Reset()         { *m = DeleteChannelMessageByMsgIdsReq{} }
func (m *DeleteChannelMessageByMsgIdsReq) String() string { return proto.CompactTextString(m) }
func (*DeleteChannelMessageByMsgIdsReq) ProtoMessage()    {}
func (*DeleteChannelMessageByMsgIdsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{18}
}

func (m *DeleteChannelMessageByMsgIdsReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *DeleteChannelMessageByMsgIdsReq) GetMsgIds() []int32 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

// 删除具体超级群消息
type DeleteChannelMessageByWithIdReq struct {
	WithId int32 `protobuf:"varint,1,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
}

func (m *DeleteChannelMessageByWithIdReq) Reset()         { *m = DeleteChannelMessageByWithIdReq{} }
func (m *DeleteChannelMessageByWithIdReq) String() string { return proto.CompactTextString(m) }
func (*DeleteChannelMessageByWithIdReq) ProtoMessage()    {}
func (*DeleteChannelMessageByWithIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{19}
}

func (m *DeleteChannelMessageByWithIdReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

// 根据个人清除超级群消息
type DeleteChannelMessageByUWMReq struct {
	UserId   int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId   int32 `protobuf:"varint,2,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	MaxMsgId int32 `protobuf:"varint,3,opt,name=max_msg_id,json=maxMsgId,proto3" json:"max_msg_id,omitempty"`
}

func (m *DeleteChannelMessageByUWMReq) Reset()         { *m = DeleteChannelMessageByUWMReq{} }
func (m *DeleteChannelMessageByUWMReq) String() string { return proto.CompactTextString(m) }
func (*DeleteChannelMessageByUWMReq) ProtoMessage()    {}
func (*DeleteChannelMessageByUWMReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{20}
}

func (m *DeleteChannelMessageByUWMReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteChannelMessageByUWMReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *DeleteChannelMessageByUWMReq) GetMaxMsgId() int32 {
	if m != nil {
		return m.MaxMsgId
	}
	return 0
}

// 搜索普通群媒体消息
type SearchUserMessageMediaReq struct {
	Keyword    string        `protobuf:"bytes,1,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Size_      int32         `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	UserId     int32         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId     int32         `protobuf:"varint,4,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	WithType   int32         `protobuf:"varint,5,opt,name=with_type,json=withType,proto3" json:"with_type,omitempty"`
	Encry      int32         `protobuf:"varint,6,opt,name=encry,proto3" json:"encry,omitempty"`
	MaxMsgId   int32         `protobuf:"varint,7,opt,name=max_msg_id,json=maxMsgId,proto3" json:"max_msg_id,omitempty"`
	Offset     int32         `protobuf:"varint,8,opt,name=offset,proto3" json:"offset,omitempty"`
	MediaTypes []int32       `protobuf:"varint,9,rep,packed,name=media_types,json=mediaTypes" json:"media_types,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,10,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *SearchUserMessageMediaReq) Reset()         { *m = SearchUserMessageMediaReq{} }
func (m *SearchUserMessageMediaReq) String() string { return proto.CompactTextString(m) }
func (*SearchUserMessageMediaReq) ProtoMessage()    {}
func (*SearchUserMessageMediaReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{21}
}

func (m *SearchUserMessageMediaReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *SearchUserMessageMediaReq) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchUserMessageMediaReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SearchUserMessageMediaReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *SearchUserMessageMediaReq) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *SearchUserMessageMediaReq) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *SearchUserMessageMediaReq) GetMaxMsgId() int32 {
	if m != nil {
		return m.MaxMsgId
	}
	return 0
}

func (m *SearchUserMessageMediaReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SearchUserMessageMediaReq) GetMediaTypes() []int32 {
	if m != nil {
		return m.MediaTypes
	}
	return nil
}

func (m *SearchUserMessageMediaReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 搜索超级群媒体消息
type SearchChannelMessageMediaReq struct {
	Keyword    string        `protobuf:"bytes,1,opt,name=keyword,proto3" json:"keyword,omitempty"`
	Size_      int32         `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	UserId     int32         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	WithId     int32         `protobuf:"varint,4,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	MaxMsgId   int32         `protobuf:"varint,5,opt,name=max_msg_id,json=maxMsgId,proto3" json:"max_msg_id,omitempty"`
	Encry      int32         `protobuf:"varint,6,opt,name=encry,proto3" json:"encry,omitempty"`
	Offset     int32         `protobuf:"varint,7,opt,name=offset,proto3" json:"offset,omitempty"`
	MediaTypes []int32       `protobuf:"varint,8,rep,packed,name=media_types,json=mediaTypes" json:"media_types,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,9,opt,name=Debug" json:"Debug,omitempty"`
}

func (m *SearchChannelMessageMediaReq) Reset()         { *m = SearchChannelMessageMediaReq{} }
func (m *SearchChannelMessageMediaReq) String() string { return proto.CompactTextString(m) }
func (*SearchChannelMessageMediaReq) ProtoMessage()    {}
func (*SearchChannelMessageMediaReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{22}
}

func (m *SearchChannelMessageMediaReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

func (m *SearchChannelMessageMediaReq) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchChannelMessageMediaReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SearchChannelMessageMediaReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *SearchChannelMessageMediaReq) GetMaxMsgId() int32 {
	if m != nil {
		return m.MaxMsgId
	}
	return 0
}

func (m *SearchChannelMessageMediaReq) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *SearchChannelMessageMediaReq) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *SearchChannelMessageMediaReq) GetMediaTypes() []int32 {
	if m != nil {
		return m.MediaTypes
	}
	return nil
}

func (m *SearchChannelMessageMediaReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SearchMediaResp struct {
	Messages []*messagedb.UserMsg `protobuf:"bytes,1,rep,name=messages" json:"messages,omitempty"`
	Count    int32                `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *SearchMediaResp) Reset()                    { *m = SearchMediaResp{} }
func (m *SearchMediaResp) String() string            { return proto.CompactTextString(m) }
func (*SearchMediaResp) ProtoMessage()               {}
func (*SearchMediaResp) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{23} }

func (m *SearchMediaResp) GetMessages() []*messagedb.UserMsg {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *SearchMediaResp) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type HandlerReply struct {
	ReplyCode ErrorCode `protobuf:"varint,1,opt,name=Reply_code,json=ReplyCode,proto3,enum=pbsearchserver.ErrorCode" json:"Reply_code,omitempty"`
	ReplyInfo string    `protobuf:"bytes,2,opt,name=Reply_info,json=ReplyInfo,proto3" json:"Reply_info,omitempty"`
}

func (m *HandlerReply) Reset()                    { *m = HandlerReply{} }
func (m *HandlerReply) String() string            { return proto.CompactTextString(m) }
func (*HandlerReply) ProtoMessage()               {}
func (*HandlerReply) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{24} }

func (m *HandlerReply) GetReplyCode() ErrorCode {
	if m != nil {
		return m.ReplyCode
	}
	return ErrorCode_RPC_OK
}

func (m *HandlerReply) GetReplyInfo() string {
	if m != nil {
		return m.ReplyInfo
	}
	return ""
}

// 用户昵称信息
type UserNameInfo struct {
	UserId    int32  `protobuf:"varint,1,opt,name=User_id,json=UserId,proto3" json:"User_id,omitempty"`
	FirstName string `protobuf:"bytes,2,opt,name=First_name,json=FirstName,proto3" json:"First_name,omitempty"`
	LastName  string `protobuf:"bytes,3,opt,name=Last_name,json=LastName,proto3" json:"Last_name,omitempty"`
	IsKick    bool   `protobuf:"varint,4,opt,name=Is_kick,json=IsKick,proto3" json:"Is_kick,omitempty"`
}

func (m *UserNameInfo) Reset()                    { *m = UserNameInfo{} }
func (m *UserNameInfo) String() string            { return proto.CompactTextString(m) }
func (*UserNameInfo) ProtoMessage()               {}
func (*UserNameInfo) Descriptor() ([]byte, []int) { return fileDescriptorPbsearchserver, []int{25} }

func (m *UserNameInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserNameInfo) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UserNameInfo) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UserNameInfo) GetIsKick() bool {
	if m != nil {
		return m.IsKick
	}
	return false
}

type InsertGroupUsersReq struct {
	GroupId int32           `protobuf:"varint,1,opt,name=Group_id,json=GroupId,proto3" json:"Group_id,omitempty"`
	UserArr []*UserNameInfo `protobuf:"bytes,2,rep,name=User_arr,json=UserArr" json:"User_arr,omitempty"`
}

func (m *InsertGroupUsersReq) Reset()         { *m = InsertGroupUsersReq{} }
func (m *InsertGroupUsersReq) String() string { return proto.CompactTextString(m) }
func (*InsertGroupUsersReq) ProtoMessage()    {}
func (*InsertGroupUsersReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{26}
}

func (m *InsertGroupUsersReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *InsertGroupUsersReq) GetUserArr() []*UserNameInfo {
	if m != nil {
		return m.UserArr
	}
	return nil
}

// 删除群组用户
type DeleteGroupUsersReq struct {
	GroupId int32   `protobuf:"varint,1,opt,name=Group_id,json=GroupId,proto3" json:"Group_id,omitempty"`
	UserIds []int32 `protobuf:"varint,2,rep,packed,name=User_ids,json=UserIds" json:"User_ids,omitempty"`
}

func (m *DeleteGroupUsersReq) Reset()         { *m = DeleteGroupUsersReq{} }
func (m *DeleteGroupUsersReq) String() string { return proto.CompactTextString(m) }
func (*DeleteGroupUsersReq) ProtoMessage()    {}
func (*DeleteGroupUsersReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{27}
}

func (m *DeleteGroupUsersReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *DeleteGroupUsersReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type UpdateGroupUserReq struct {
	GroupId int32         `protobuf:"varint,1,opt,name=Group_id,json=GroupId,proto3" json:"Group_id,omitempty"`
	User    *UserNameInfo `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
}

func (m *UpdateGroupUserReq) Reset()         { *m = UpdateGroupUserReq{} }
func (m *UpdateGroupUserReq) String() string { return proto.CompactTextString(m) }
func (*UpdateGroupUserReq) ProtoMessage()    {}
func (*UpdateGroupUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{28}
}

func (m *UpdateGroupUserReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupUserReq) GetUser() *UserNameInfo {
	if m != nil {
		return m.User
	}
	return nil
}

type RenameGroupUserReq struct {
	GroupId int32         `protobuf:"varint,1,opt,name=Group_id,json=GroupId,proto3" json:"Group_id,omitempty"`
	User    *UserNameInfo `protobuf:"bytes,2,opt,name=User" json:"User,omitempty"`
}

func (m *RenameGroupUserReq) Reset()         { *m = RenameGroupUserReq{} }
func (m *RenameGroupUserReq) String() string { return proto.CompactTextString(m) }
func (*RenameGroupUserReq) ProtoMessage()    {}
func (*RenameGroupUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{29}
}

func (m *RenameGroupUserReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *RenameGroupUserReq) GetUser() *UserNameInfo {
	if m != nil {
		return m.User
	}
	return nil
}

// 群组用户昵称模糊匹配请求
type SearchGroupUsersReq struct {
	GroupId int32  `protobuf:"varint,1,opt,name=Group_id,json=GroupId,proto3" json:"Group_id,omitempty"`
	KickFlg bool   `protobuf:"varint,2,opt,name=Kick_flg,json=KickFlg,proto3" json:"Kick_flg,omitempty"`
	KeyWord string `protobuf:"bytes,3,opt,name=Key_word,json=KeyWord,proto3" json:"Key_word,omitempty"`
	RetRows int32  `protobuf:"varint,4,opt,name=Ret_rows,json=RetRows,proto3" json:"Ret_rows,omitempty"`
}

func (m *SearchGroupUsersReq) Reset()         { *m = SearchGroupUsersReq{} }
func (m *SearchGroupUsersReq) String() string { return proto.CompactTextString(m) }
func (*SearchGroupUsersReq) ProtoMessage()    {}
func (*SearchGroupUsersReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{30}
}

func (m *SearchGroupUsersReq) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *SearchGroupUsersReq) GetKickFlg() bool {
	if m != nil {
		return m.KickFlg
	}
	return false
}

func (m *SearchGroupUsersReq) GetKeyWord() string {
	if m != nil {
		return m.KeyWord
	}
	return ""
}

func (m *SearchGroupUsersReq) GetRetRows() int32 {
	if m != nil {
		return m.RetRows
	}
	return 0
}

// 群组用户昵称模糊匹配返回
type SearchGroupUsersRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=Err_code,json=ErrCode,proto3,enum=pbsearchserver.ErrorCode" json:"Err_code,omitempty"`
	ErrInfo string    `protobuf:"bytes,2,opt,name=Err_info,json=ErrInfo,proto3" json:"Err_info,omitempty"`
	UserIds []int32   `protobuf:"varint,3,rep,packed,name=User_ids,json=UserIds" json:"User_ids,omitempty"`
}

func (m *SearchGroupUsersRsp) Reset()         { *m = SearchGroupUsersRsp{} }
func (m *SearchGroupUsersRsp) String() string { return proto.CompactTextString(m) }
func (*SearchGroupUsersRsp) ProtoMessage()    {}
func (*SearchGroupUsersRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{31}
}

func (m *SearchGroupUsersRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_RPC_OK
}

func (m *SearchGroupUsersRsp) GetErrInfo() string {
	if m != nil {
		return m.ErrInfo
	}
	return ""
}

func (m *SearchGroupUsersRsp) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

// @ add by qingsong at 2020-04-24 for fuzzy search channel by title or username /////////////////
// 新增群组名称信息 for create channel
type InsertChanNameReq struct {
	ChannelId int32  `protobuf:"varint,1,opt,name=Channel_id,json=ChannelId,proto3" json:"Channel_id,omitempty"`
	Title     string `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	Uname     string `protobuf:"bytes,3,opt,name=Uname,proto3" json:"Uname,omitempty"`
}

func (m *InsertChanNameReq) Reset()         { *m = InsertChanNameReq{} }
func (m *InsertChanNameReq) String() string { return proto.CompactTextString(m) }
func (*InsertChanNameReq) ProtoMessage()    {}
func (*InsertChanNameReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{32}
}

func (m *InsertChanNameReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *InsertChanNameReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *InsertChanNameReq) GetUname() string {
	if m != nil {
		return m.Uname
	}
	return ""
}

// 更新群组名称信息 for edit channel title or username column
type UpdateChanNameReq struct {
	ChannelId int32  `protobuf:"varint,1,opt,name=Channel_id,json=ChannelId,proto3" json:"Channel_id,omitempty"`
	Title     string `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	Uname     string `protobuf:"bytes,3,opt,name=Uname,proto3" json:"Uname,omitempty"`
}

func (m *UpdateChanNameReq) Reset()         { *m = UpdateChanNameReq{} }
func (m *UpdateChanNameReq) String() string { return proto.CompactTextString(m) }
func (*UpdateChanNameReq) ProtoMessage()    {}
func (*UpdateChanNameReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{33}
}

func (m *UpdateChanNameReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *UpdateChanNameReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *UpdateChanNameReq) GetUname() string {
	if m != nil {
		return m.Uname
	}
	return ""
}

// 删除群组名称信息 for dismiss channel
type DeleteChanNameReq struct {
	ChannelId int32 `protobuf:"varint,1,opt,name=Channel_id,json=ChannelId,proto3" json:"Channel_id,omitempty"`
}

func (m *DeleteChanNameReq) Reset()         { *m = DeleteChanNameReq{} }
func (m *DeleteChanNameReq) String() string { return proto.CompactTextString(m) }
func (*DeleteChanNameReq) ProtoMessage()    {}
func (*DeleteChanNameReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{34}
}

func (m *DeleteChanNameReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

// 根据名称搜索群组
type SearchChannelsReq struct {
	KeyWord string `protobuf:"bytes,1,opt,name=Key_word,json=KeyWord,proto3" json:"Key_word,omitempty"`
	RetRows int32  `protobuf:"varint,2,opt,name=Ret_rows,json=RetRows,proto3" json:"Ret_rows,omitempty"`
}

func (m *SearchChannelsReq) Reset()         { *m = SearchChannelsReq{} }
func (m *SearchChannelsReq) String() string { return proto.CompactTextString(m) }
func (*SearchChannelsReq) ProtoMessage()    {}
func (*SearchChannelsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{35}
}

func (m *SearchChannelsReq) GetKeyWord() string {
	if m != nil {
		return m.KeyWord
	}
	return ""
}

func (m *SearchChannelsReq) GetRetRows() int32 {
	if m != nil {
		return m.RetRows
	}
	return 0
}

type SearchChannelsRsp struct {
	ErrCode ErrorCode `protobuf:"varint,1,opt,name=Err_code,json=ErrCode,proto3,enum=pbsearchserver.ErrorCode" json:"Err_code,omitempty"`
	ErrInfo string    `protobuf:"bytes,2,opt,name=Err_info,json=ErrInfo,proto3" json:"Err_info,omitempty"`
	ChanIds []int32   `protobuf:"varint,3,rep,packed,name=Chan_ids,json=ChanIds" json:"Chan_ids,omitempty"`
}

func (m *SearchChannelsRsp) Reset()         { *m = SearchChannelsRsp{} }
func (m *SearchChannelsRsp) String() string { return proto.CompactTextString(m) }
func (*SearchChannelsRsp) ProtoMessage()    {}
func (*SearchChannelsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorPbsearchserver, []int{36}
}

func (m *SearchChannelsRsp) GetErrCode() ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrorCode_RPC_OK
}

func (m *SearchChannelsRsp) GetErrInfo() string {
	if m != nil {
		return m.ErrInfo
	}
	return ""
}

func (m *SearchChannelsRsp) GetChanIds() []int32 {
	if m != nil {
		return m.ChanIds
	}
	return nil
}

func init() {
	proto.RegisterType((*Message)(nil), "pbsearchserver.Message")
	proto.RegisterType((*MessageInfo)(nil), "pbsearchserver.MessageInfo")
	proto.RegisterType((*HandleSearchLogicReq)(nil), "pbsearchserver.HandleSearchLogicReq")
	proto.RegisterType((*HandleSearchLogicResp)(nil), "pbsearchserver.HandleSearchLogicResp")
	proto.RegisterType((*MessageSearchReq)(nil), "pbsearchserver.MessageSearchReq")
	proto.RegisterType((*NoUseResp)(nil), "pbsearchserver.NoUseResp")
	proto.RegisterType((*DeleteUserMessageReq)(nil), "pbsearchserver.DeleteUserMessageReq")
	proto.RegisterType((*DeleteChannelMessageReq)(nil), "pbsearchserver.DeleteChannelMessageReq")
	proto.RegisterType((*SearchCursor)(nil), "pbsearchserver.SearchCursor")
	proto.RegisterType((*UserChannelMsgId)(nil), "pbsearchserver.UserChannelMsgId")
	proto.RegisterType((*SearchMessageReq)(nil), "pbsearchserver.SearchMessageReq")
	proto.RegisterType((*SearchResp)(nil), "pbsearchserver.SearchResp")
	proto.RegisterType((*SearchUserMessageByMaxMsgIdReq)(nil), "pbsearchserver.SearchUserMessageByMaxMsgIdReq")
	proto.RegisterType((*SearchChannelMessageByMaxMsgIdReq)(nil), "pbsearchserver.SearchChannelMessageByMaxMsgIdReq")
	proto.RegisterType((*UpdateUserMessageMediaUnreadByMsgIdsReq)(nil), "pbsearchserver.UpdateUserMessageMediaUnreadByMsgIdsReq")
	proto.RegisterType((*DeleteUserMessageByMsgIdsReq)(nil), "pbsearchserver.DeleteUserMessageByMsgIdsReq")
	proto.RegisterType((*DeleteUserMessageByUuidsReq)(nil), "pbsearchserver.DeleteUserMessageByUuidsReq")
	proto.RegisterType((*DeleteUserMessageByUWTReq)(nil), "pbsearchserver.DeleteUserMessageByUWTReq")
	proto.RegisterType((*DeleteChannelMessageByMsgIdsReq)(nil), "pbsearchserver.DeleteChannelMessageByMsgIdsReq")
	proto.RegisterType((*DeleteChannelMessageByWithIdReq)(nil), "pbsearchserver.DeleteChannelMessageByWithIdReq")
	proto.RegisterType((*DeleteChannelMessageByUWMReq)(nil), "pbsearchserver.DeleteChannelMessageByUWMReq")
	proto.RegisterType((*SearchUserMessageMediaReq)(nil), "pbsearchserver.SearchUserMessageMediaReq")
	proto.RegisterType((*SearchChannelMessageMediaReq)(nil), "pbsearchserver.SearchChannelMessageMediaReq")
	proto.RegisterType((*SearchMediaResp)(nil), "pbsearchserver.SearchMediaResp")
	proto.RegisterType((*HandlerReply)(nil), "pbsearchserver.HandlerReply")
	proto.RegisterType((*UserNameInfo)(nil), "pbsearchserver.UserNameInfo")
	proto.RegisterType((*InsertGroupUsersReq)(nil), "pbsearchserver.InsertGroupUsersReq")
	proto.RegisterType((*DeleteGroupUsersReq)(nil), "pbsearchserver.DeleteGroupUsersReq")
	proto.RegisterType((*UpdateGroupUserReq)(nil), "pbsearchserver.UpdateGroupUserReq")
	proto.RegisterType((*RenameGroupUserReq)(nil), "pbsearchserver.RenameGroupUserReq")
	proto.RegisterType((*SearchGroupUsersReq)(nil), "pbsearchserver.SearchGroupUsersReq")
	proto.RegisterType((*SearchGroupUsersRsp)(nil), "pbsearchserver.SearchGroupUsersRsp")
	proto.RegisterType((*InsertChanNameReq)(nil), "pbsearchserver.InsertChanNameReq")
	proto.RegisterType((*UpdateChanNameReq)(nil), "pbsearchserver.UpdateChanNameReq")
	proto.RegisterType((*DeleteChanNameReq)(nil), "pbsearchserver.DeleteChanNameReq")
	proto.RegisterType((*SearchChannelsReq)(nil), "pbsearchserver.SearchChannelsReq")
	proto.RegisterType((*SearchChannelsRsp)(nil), "pbsearchserver.SearchChannelsRsp")
	proto.RegisterEnum("pbsearchserver.PeerType", PeerType_name, PeerType_value)
	proto.RegisterEnum("pbsearchserver.EMsgFlag", EMsgFlag_name, EMsgFlag_value)
	proto.RegisterEnum("pbsearchserver.ErrorCode", ErrorCode_name, ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SearchService service

type SearchServiceClient interface {
	SearchMessage(ctx context.Context, in *SearchMessageReq, opts ...grpc.CallOption) (*SearchResp, error)
	SearchUserMessageByMaxMsgId(ctx context.Context, in *SearchUserMessageByMaxMsgIdReq, opts ...grpc.CallOption) (*SearchResp, error)
	SearchChannelMessageByMaxMsgId(ctx context.Context, in *SearchChannelMessageByMaxMsgIdReq, opts ...grpc.CallOption) (*SearchResp, error)
	UpdateUserMessageMediaUnreadByMsgIds(ctx context.Context, in *UpdateUserMessageMediaUnreadByMsgIdsReq, opts ...grpc.CallOption) (*NoUseResp, error)
	SearchUserMessageMedia(ctx context.Context, in *SearchUserMessageMediaReq, opts ...grpc.CallOption) (*SearchMediaResp, error)
	SearchChannelMessageMedia(ctx context.Context, in *SearchChannelMessageMediaReq, opts ...grpc.CallOption) (*SearchMediaResp, error)
	// 搜索logic协议处理
	HandleSearchLogic(ctx context.Context, in *HandleSearchLogicReq, opts ...grpc.CallOption) (*HandleSearchLogicResp, error)
	// 新增消息
	AddMessage(ctx context.Context, in *MessageInfo, opts ...grpc.CallOption) (*NoUseResp, error)
	// 单条删除普通消息
	DeleteUserMessage(ctx context.Context, in *DeleteUserMessageReq, opts ...grpc.CallOption) (*NoUseResp, error)
	// 单条删除超级群消息
	DeleteChannelMessage(ctx context.Context, in *DeleteChannelMessageReq, opts ...grpc.CallOption) (*NoUseResp, error)
	// 批量删除普通消息
	DeleteUserMessageByMsgIds(ctx context.Context, in *DeleteUserMessageByMsgIdsReq, opts ...grpc.CallOption) (*NoUseResp, error)
	// 根据Userid、WithId、WithType删除普通消息-(清除历史消息)
	DeleteUserMessageByUWT(ctx context.Context, in *DeleteUserMessageByUWTReq, opts ...grpc.CallOption) (*NoUseResp, error)
	DeleteUserMessageByUuids(ctx context.Context, in *DeleteUserMessageByUuidsReq, opts ...grpc.CallOption) (*NoUseResp, error)
	// 批量删除超级群消息
	DeleteChannelMessageByMsgIds(ctx context.Context, in *DeleteChannelMessageByMsgIdsReq, opts ...grpc.CallOption) (*NoUseResp, error)
	// 根据WithId删除超级群消息
	DeleteChannelMessageByWithId(ctx context.Context, in *DeleteChannelMessageByWithIdReq, opts ...grpc.CallOption) (*NoUseResp, error)
	// 超级群清除历史
	DeleteChannelMessageByUWM(ctx context.Context, in *DeleteChannelMessageByUWMReq, opts ...grpc.CallOption) (*NoUseResp, error)
	// 添加群组成员
	InsertGroupUsers(ctx context.Context, in *InsertGroupUsersReq, opts ...grpc.CallOption) (*HandlerReply, error)
	// 移除群组成员
	DeleteGroupUsers(ctx context.Context, in *DeleteGroupUsersReq, opts ...grpc.CallOption) (*HandlerReply, error)
	// 更新群组用户
	UpdateGroupUser(ctx context.Context, in *UpdateGroupUserReq, opts ...grpc.CallOption) (*HandlerReply, error)
	// 更新用户昵称
	RenameGroupUser(ctx context.Context, in *RenameGroupUserReq, opts ...grpc.CallOption) (*HandlerReply, error)
	// 群组成员搜索(昵称模糊匹配)
	SearchGroupUsers(ctx context.Context, in *SearchGroupUsersReq, opts ...grpc.CallOption) (*SearchGroupUsersRsp, error)
	// @ add by qingsong at 2020-04-24 for fuzzy search channel by title or username /////////////////
	// 新增群组名称信息 for create channel
	InsertChanName(ctx context.Context, in *InsertChanNameReq, opts ...grpc.CallOption) (*HandlerReply, error)
	// 更新群组名称信息 for edit channel title or username column
	UpdateChanName(ctx context.Context, in *UpdateChanNameReq, opts ...grpc.CallOption) (*HandlerReply, error)
	// 删除群组名称信息 for dismiss channel
	DeleteChanName(ctx context.Context, in *DeleteChanNameReq, opts ...grpc.CallOption) (*HandlerReply, error)
	// 根据名称搜索群组
	SearchChannels(ctx context.Context, in *SearchChannelsReq, opts ...grpc.CallOption) (*SearchChannelsRsp, error)
}

type searchServiceClient struct {
	cc *grpc.ClientConn
}

func NewSearchServiceClient(cc *grpc.ClientConn) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) SearchMessage(ctx context.Context, in *SearchMessageReq, opts ...grpc.CallOption) (*SearchResp, error) {
	out := new(SearchResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/SearchMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchUserMessageByMaxMsgId(ctx context.Context, in *SearchUserMessageByMaxMsgIdReq, opts ...grpc.CallOption) (*SearchResp, error) {
	out := new(SearchResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/SearchUserMessageByMaxMsgId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchChannelMessageByMaxMsgId(ctx context.Context, in *SearchChannelMessageByMaxMsgIdReq, opts ...grpc.CallOption) (*SearchResp, error) {
	out := new(SearchResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/SearchChannelMessageByMaxMsgId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) UpdateUserMessageMediaUnreadByMsgIds(ctx context.Context, in *UpdateUserMessageMediaUnreadByMsgIdsReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/UpdateUserMessageMediaUnreadByMsgIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchUserMessageMedia(ctx context.Context, in *SearchUserMessageMediaReq, opts ...grpc.CallOption) (*SearchMediaResp, error) {
	out := new(SearchMediaResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/SearchUserMessageMedia", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchChannelMessageMedia(ctx context.Context, in *SearchChannelMessageMediaReq, opts ...grpc.CallOption) (*SearchMediaResp, error) {
	out := new(SearchMediaResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/SearchChannelMessageMedia", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) HandleSearchLogic(ctx context.Context, in *HandleSearchLogicReq, opts ...grpc.CallOption) (*HandleSearchLogicResp, error) {
	out := new(HandleSearchLogicResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/HandleSearchLogic", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) AddMessage(ctx context.Context, in *MessageInfo, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/AddMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteUserMessage(ctx context.Context, in *DeleteUserMessageReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteUserMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteChannelMessage(ctx context.Context, in *DeleteChannelMessageReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteUserMessageByMsgIds(ctx context.Context, in *DeleteUserMessageByMsgIdsReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteUserMessageByMsgIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteUserMessageByUWT(ctx context.Context, in *DeleteUserMessageByUWTReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteUserMessageByUWT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteUserMessageByUuids(ctx context.Context, in *DeleteUserMessageByUuidsReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteUserMessageByUuids", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteChannelMessageByMsgIds(ctx context.Context, in *DeleteChannelMessageByMsgIdsReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteChannelMessageByMsgIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteChannelMessageByWithId(ctx context.Context, in *DeleteChannelMessageByWithIdReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteChannelMessageByWithId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteChannelMessageByUWM(ctx context.Context, in *DeleteChannelMessageByUWMReq, opts ...grpc.CallOption) (*NoUseResp, error) {
	out := new(NoUseResp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteChannelMessageByUWM", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) InsertGroupUsers(ctx context.Context, in *InsertGroupUsersReq, opts ...grpc.CallOption) (*HandlerReply, error) {
	out := new(HandlerReply)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/InsertGroupUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteGroupUsers(ctx context.Context, in *DeleteGroupUsersReq, opts ...grpc.CallOption) (*HandlerReply, error) {
	out := new(HandlerReply)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteGroupUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) UpdateGroupUser(ctx context.Context, in *UpdateGroupUserReq, opts ...grpc.CallOption) (*HandlerReply, error) {
	out := new(HandlerReply)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/UpdateGroupUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) RenameGroupUser(ctx context.Context, in *RenameGroupUserReq, opts ...grpc.CallOption) (*HandlerReply, error) {
	out := new(HandlerReply)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/RenameGroupUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchGroupUsers(ctx context.Context, in *SearchGroupUsersReq, opts ...grpc.CallOption) (*SearchGroupUsersRsp, error) {
	out := new(SearchGroupUsersRsp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/SearchGroupUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) InsertChanName(ctx context.Context, in *InsertChanNameReq, opts ...grpc.CallOption) (*HandlerReply, error) {
	out := new(HandlerReply)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/InsertChanName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) UpdateChanName(ctx context.Context, in *UpdateChanNameReq, opts ...grpc.CallOption) (*HandlerReply, error) {
	out := new(HandlerReply)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/UpdateChanName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) DeleteChanName(ctx context.Context, in *DeleteChanNameReq, opts ...grpc.CallOption) (*HandlerReply, error) {
	out := new(HandlerReply)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/DeleteChanName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) SearchChannels(ctx context.Context, in *SearchChannelsReq, opts ...grpc.CallOption) (*SearchChannelsRsp, error) {
	out := new(SearchChannelsRsp)
	err := grpc.Invoke(ctx, "/pbsearchserver.SearchService/SearchChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SearchService service

type SearchServiceServer interface {
	SearchMessage(context.Context, *SearchMessageReq) (*SearchResp, error)
	SearchUserMessageByMaxMsgId(context.Context, *SearchUserMessageByMaxMsgIdReq) (*SearchResp, error)
	SearchChannelMessageByMaxMsgId(context.Context, *SearchChannelMessageByMaxMsgIdReq) (*SearchResp, error)
	UpdateUserMessageMediaUnreadByMsgIds(context.Context, *UpdateUserMessageMediaUnreadByMsgIdsReq) (*NoUseResp, error)
	SearchUserMessageMedia(context.Context, *SearchUserMessageMediaReq) (*SearchMediaResp, error)
	SearchChannelMessageMedia(context.Context, *SearchChannelMessageMediaReq) (*SearchMediaResp, error)
	// 搜索logic协议处理
	HandleSearchLogic(context.Context, *HandleSearchLogicReq) (*HandleSearchLogicResp, error)
	// 新增消息
	AddMessage(context.Context, *MessageInfo) (*NoUseResp, error)
	// 单条删除普通消息
	DeleteUserMessage(context.Context, *DeleteUserMessageReq) (*NoUseResp, error)
	// 单条删除超级群消息
	DeleteChannelMessage(context.Context, *DeleteChannelMessageReq) (*NoUseResp, error)
	// 批量删除普通消息
	DeleteUserMessageByMsgIds(context.Context, *DeleteUserMessageByMsgIdsReq) (*NoUseResp, error)
	// 根据Userid、WithId、WithType删除普通消息-(清除历史消息)
	DeleteUserMessageByUWT(context.Context, *DeleteUserMessageByUWTReq) (*NoUseResp, error)
	DeleteUserMessageByUuids(context.Context, *DeleteUserMessageByUuidsReq) (*NoUseResp, error)
	// 批量删除超级群消息
	DeleteChannelMessageByMsgIds(context.Context, *DeleteChannelMessageByMsgIdsReq) (*NoUseResp, error)
	// 根据WithId删除超级群消息
	DeleteChannelMessageByWithId(context.Context, *DeleteChannelMessageByWithIdReq) (*NoUseResp, error)
	// 超级群清除历史
	DeleteChannelMessageByUWM(context.Context, *DeleteChannelMessageByUWMReq) (*NoUseResp, error)
	// 添加群组成员
	InsertGroupUsers(context.Context, *InsertGroupUsersReq) (*HandlerReply, error)
	// 移除群组成员
	DeleteGroupUsers(context.Context, *DeleteGroupUsersReq) (*HandlerReply, error)
	// 更新群组用户
	UpdateGroupUser(context.Context, *UpdateGroupUserReq) (*HandlerReply, error)
	// 更新用户昵称
	RenameGroupUser(context.Context, *RenameGroupUserReq) (*HandlerReply, error)
	// 群组成员搜索(昵称模糊匹配)
	SearchGroupUsers(context.Context, *SearchGroupUsersReq) (*SearchGroupUsersRsp, error)
	// @ add by qingsong at 2020-04-24 for fuzzy search channel by title or username /////////////////
	// 新增群组名称信息 for create channel
	InsertChanName(context.Context, *InsertChanNameReq) (*HandlerReply, error)
	// 更新群组名称信息 for edit channel title or username column
	UpdateChanName(context.Context, *UpdateChanNameReq) (*HandlerReply, error)
	// 删除群组名称信息 for dismiss channel
	DeleteChanName(context.Context, *DeleteChanNameReq) (*HandlerReply, error)
	// 根据名称搜索群组
	SearchChannels(context.Context, *SearchChannelsReq) (*SearchChannelsRsp, error)
}

func RegisterSearchServiceServer(s *grpc.Server, srv SearchServiceServer) {
	s.RegisterService(&_SearchService_serviceDesc, srv)
}

func _SearchService_SearchMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/SearchMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchMessage(ctx, req.(*SearchMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchUserMessageByMaxMsgId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchUserMessageByMaxMsgIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchUserMessageByMaxMsgId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/SearchUserMessageByMaxMsgId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchUserMessageByMaxMsgId(ctx, req.(*SearchUserMessageByMaxMsgIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchChannelMessageByMaxMsgId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchChannelMessageByMaxMsgIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchChannelMessageByMaxMsgId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/SearchChannelMessageByMaxMsgId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchChannelMessageByMaxMsgId(ctx, req.(*SearchChannelMessageByMaxMsgIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_UpdateUserMessageMediaUnreadByMsgIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserMessageMediaUnreadByMsgIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).UpdateUserMessageMediaUnreadByMsgIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/UpdateUserMessageMediaUnreadByMsgIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).UpdateUserMessageMediaUnreadByMsgIds(ctx, req.(*UpdateUserMessageMediaUnreadByMsgIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchUserMessageMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchUserMessageMediaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchUserMessageMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/SearchUserMessageMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchUserMessageMedia(ctx, req.(*SearchUserMessageMediaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchChannelMessageMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchChannelMessageMediaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchChannelMessageMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/SearchChannelMessageMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchChannelMessageMedia(ctx, req.(*SearchChannelMessageMediaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_HandleSearchLogic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleSearchLogicReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).HandleSearchLogic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/HandleSearchLogic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).HandleSearchLogic(ctx, req.(*HandleSearchLogicReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_AddMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).AddMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/AddMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).AddMessage(ctx, req.(*MessageInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteUserMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteUserMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteUserMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteUserMessage(ctx, req.(*DeleteUserMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteChannelMessage(ctx, req.(*DeleteChannelMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteUserMessageByMsgIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserMessageByMsgIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteUserMessageByMsgIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteUserMessageByMsgIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteUserMessageByMsgIds(ctx, req.(*DeleteUserMessageByMsgIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteUserMessageByUWT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserMessageByUWTReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteUserMessageByUWT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteUserMessageByUWT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteUserMessageByUWT(ctx, req.(*DeleteUserMessageByUWTReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteUserMessageByUuids_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserMessageByUuidsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteUserMessageByUuids(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteUserMessageByUuids",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteUserMessageByUuids(ctx, req.(*DeleteUserMessageByUuidsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteChannelMessageByMsgIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelMessageByMsgIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteChannelMessageByMsgIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteChannelMessageByMsgIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteChannelMessageByMsgIds(ctx, req.(*DeleteChannelMessageByMsgIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteChannelMessageByWithId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelMessageByWithIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteChannelMessageByWithId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteChannelMessageByWithId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteChannelMessageByWithId(ctx, req.(*DeleteChannelMessageByWithIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteChannelMessageByUWM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelMessageByUWMReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteChannelMessageByUWM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteChannelMessageByUWM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteChannelMessageByUWM(ctx, req.(*DeleteChannelMessageByUWMReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_InsertGroupUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertGroupUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).InsertGroupUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/InsertGroupUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).InsertGroupUsers(ctx, req.(*InsertGroupUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteGroupUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroupUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteGroupUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteGroupUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteGroupUsers(ctx, req.(*DeleteGroupUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_UpdateGroupUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).UpdateGroupUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/UpdateGroupUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).UpdateGroupUser(ctx, req.(*UpdateGroupUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_RenameGroupUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameGroupUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).RenameGroupUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/RenameGroupUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).RenameGroupUser(ctx, req.(*RenameGroupUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchGroupUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchGroupUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchGroupUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/SearchGroupUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchGroupUsers(ctx, req.(*SearchGroupUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_InsertChanName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertChanNameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).InsertChanName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/InsertChanName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).InsertChanName(ctx, req.(*InsertChanNameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_UpdateChanName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChanNameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).UpdateChanName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/UpdateChanName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).UpdateChanName(ctx, req.(*UpdateChanNameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_DeleteChanName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChanNameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).DeleteChanName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/DeleteChanName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).DeleteChanName(ctx, req.(*DeleteChanNameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_SearchChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchChannelsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).SearchChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbsearchserver.SearchService/SearchChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).SearchChannels(ctx, req.(*SearchChannelsReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _SearchService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pbsearchserver.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SearchMessage",
			Handler:    _SearchService_SearchMessage_Handler,
		},
		{
			MethodName: "SearchUserMessageByMaxMsgId",
			Handler:    _SearchService_SearchUserMessageByMaxMsgId_Handler,
		},
		{
			MethodName: "SearchChannelMessageByMaxMsgId",
			Handler:    _SearchService_SearchChannelMessageByMaxMsgId_Handler,
		},
		{
			MethodName: "UpdateUserMessageMediaUnreadByMsgIds",
			Handler:    _SearchService_UpdateUserMessageMediaUnreadByMsgIds_Handler,
		},
		{
			MethodName: "SearchUserMessageMedia",
			Handler:    _SearchService_SearchUserMessageMedia_Handler,
		},
		{
			MethodName: "SearchChannelMessageMedia",
			Handler:    _SearchService_SearchChannelMessageMedia_Handler,
		},
		{
			MethodName: "HandleSearchLogic",
			Handler:    _SearchService_HandleSearchLogic_Handler,
		},
		{
			MethodName: "AddMessage",
			Handler:    _SearchService_AddMessage_Handler,
		},
		{
			MethodName: "DeleteUserMessage",
			Handler:    _SearchService_DeleteUserMessage_Handler,
		},
		{
			MethodName: "DeleteChannelMessage",
			Handler:    _SearchService_DeleteChannelMessage_Handler,
		},
		{
			MethodName: "DeleteUserMessageByMsgIds",
			Handler:    _SearchService_DeleteUserMessageByMsgIds_Handler,
		},
		{
			MethodName: "DeleteUserMessageByUWT",
			Handler:    _SearchService_DeleteUserMessageByUWT_Handler,
		},
		{
			MethodName: "DeleteUserMessageByUuids",
			Handler:    _SearchService_DeleteUserMessageByUuids_Handler,
		},
		{
			MethodName: "DeleteChannelMessageByMsgIds",
			Handler:    _SearchService_DeleteChannelMessageByMsgIds_Handler,
		},
		{
			MethodName: "DeleteChannelMessageByWithId",
			Handler:    _SearchService_DeleteChannelMessageByWithId_Handler,
		},
		{
			MethodName: "DeleteChannelMessageByUWM",
			Handler:    _SearchService_DeleteChannelMessageByUWM_Handler,
		},
		{
			MethodName: "InsertGroupUsers",
			Handler:    _SearchService_InsertGroupUsers_Handler,
		},
		{
			MethodName: "DeleteGroupUsers",
			Handler:    _SearchService_DeleteGroupUsers_Handler,
		},
		{
			MethodName: "UpdateGroupUser",
			Handler:    _SearchService_UpdateGroupUser_Handler,
		},
		{
			MethodName: "RenameGroupUser",
			Handler:    _SearchService_RenameGroupUser_Handler,
		},
		{
			MethodName: "SearchGroupUsers",
			Handler:    _SearchService_SearchGroupUsers_Handler,
		},
		{
			MethodName: "InsertChanName",
			Handler:    _SearchService_InsertChanName_Handler,
		},
		{
			MethodName: "UpdateChanName",
			Handler:    _SearchService_UpdateChanName_Handler,
		},
		{
			MethodName: "DeleteChanName",
			Handler:    _SearchService_DeleteChanName_Handler,
		},
		{
			MethodName: "SearchChannels",
			Handler:    _SearchService_SearchChannels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/pbsearchserver/pbsearchserver.proto",
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithIdType))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MsgId))
	}
	if m.MessageType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MessageType))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.FromId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.FromId))
	}
	if m.ToId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ToId))
	}
	if m.Media != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Media))
	}
	if m.Date != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Date))
	}
	if m.Uuid != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Uuid))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Flags))
	}
	if m.Out {
		dAtA[i] = 0x68
		i++
		if m.Out {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mentioned {
		dAtA[i] = 0x70
		i++
		if m.Mentioned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MediaUnread {
		dAtA[i] = 0x78
		i++
		if m.MediaUnread {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Silent {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Post {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.Post {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Pts != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Pts))
	}
	if len(m.FwdFrom) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.FwdFrom)))
		i += copy(dAtA[i:], m.FwdFrom)
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ViaBotId))
	}
	if m.ReplyToMsgId != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ReplyToMsgId))
	}
	if len(m.MediaData) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.MediaData)))
		i += copy(dAtA[i:], m.MediaData)
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.Entities) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Entities)))
		i += copy(dAtA[i:], m.Entities)
	}
	if m.Views != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Views))
	}
	if m.EditDate != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.EditDate))
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0xda
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if m.RandomId != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.RandomId))
	}
	if m.InsertDate != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UpdateDate))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.GroupId))
	}
	if len(m.Combination) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Combination)))
		i += copy(dAtA[i:], m.Combination)
	}
	if m.Encry != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Encry))
	}
	if m.Flag != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Flag))
	}
	return i, nil
}

func (m *MessageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithIdType))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MsgId))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.FromId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.FromId))
	}
	if m.Media != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Media))
	}
	if m.Date != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Date))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Encry))
	}
	if m.Uuid != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Uuid))
	}
	return i, nil
}

func (m *HandleSearchLogicReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSearchLogicReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MessageId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.KeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.CrcId))
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if len(m.PhoneId) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.PhoneId)))
		i += copy(dAtA[i:], m.PhoneId)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Layer))
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	return i, nil
}

func (m *HandleSearchLogicResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSearchLogicResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.ErrCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrMsg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.ErrMsg)))
		i += copy(dAtA[i:], m.ErrMsg)
	}
	return i, nil
}

func (m *MessageSearchReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageSearchReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.KeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.FromId))
	}
	if m.PeerType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.PeerType))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithIdType))
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.MinDate != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MaxDate))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Offset))
	}
	if m.MaxId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MaxId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Limit))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Encry))
	}
	if len(m.MediaTypes) > 0 {
		dAtA2 := make([]byte, len(m.MediaTypes)*10)
		var j1 int
		for _, num1 := range m.MediaTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *NoUseResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoUseResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reserved != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Reserved))
	}
	return i, nil
}

func (m *DeleteUserMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MsgId))
	}
	return i, nil
}

func (m *DeleteChannelMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChannelMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WithId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MsgId))
	}
	return i, nil
}

func (m *SearchCursor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchCursor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Date != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Date))
	}
	if m.UWId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UWId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MsgId))
	}
	return i, nil
}

func (m *UserChannelMsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserChannelMsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.MsgIdStart != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MsgIdStart))
	}
	return i, nil
}

func (m *SearchMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.KeyId))
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.Cursor != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Cursor.Size()))
		n3, err := m.Cursor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Size_))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.FromId))
	}
	if m.Searchtype != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Searchtype))
	}
	if len(m.UserChannelMsgIds) > 0 {
		for _, msg := range m.UserChannelMsgIds {
			dAtA[i] = 0x42
			i++
			i = encodeVarintPbsearchserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SearchResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPbsearchserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Count))
	}
	if m.Cursor != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Cursor.Size()))
		n4, err := m.Cursor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *SearchUserMessageByMaxMsgIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUserMessageByMaxMsgIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.KeyId))
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Size_))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.FromId))
	}
	if m.MaxMsgId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MaxMsgId))
	}
	return i, nil
}

func (m *SearchChannelMessageByMaxMsgIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchChannelMessageByMaxMsgIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.KeyId))
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Size_))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.FromId))
	}
	if m.MsgIdStart != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MsgIdStart))
	}
	if m.MaxMsgId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MaxMsgId))
	}
	return i, nil
}

func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MediaUnread {
		dAtA[i] = 0x8
		i++
		if m.MediaUnread {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.MsgIds) > 0 {
		dAtA6 := make([]byte, len(m.MsgIds)*10)
		var j5 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *DeleteUserMessageByMsgIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMessageByMsgIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.MsgIds) > 0 {
		dAtA8 := make([]byte, len(m.MsgIds)*10)
		var j7 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *DeleteUserMessageByUuidsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMessageByUuidsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Uuids) > 0 {
		dAtA10 := make([]byte, len(m.Uuids)*10)
		var j9 int
		for _, num1 := range m.Uuids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *DeleteUserMessageByUWTReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserMessageByUWTReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithIdType))
	}
	return i, nil
}

func (m *DeleteChannelMessageByMsgIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChannelMessageByMsgIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WithId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if len(m.MsgIds) > 0 {
		dAtA12 := make([]byte, len(m.MsgIds)*10)
		var j11 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	return i, nil
}

func (m *DeleteChannelMessageByWithIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChannelMessageByWithIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WithId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	return i, nil
}

func (m *DeleteChannelMessageByUWMReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChannelMessageByUWMReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.MaxMsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MaxMsgId))
	}
	return i, nil
}

func (m *SearchUserMessageMediaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUserMessageMediaReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Size_))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithType))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Encry))
	}
	if m.MaxMsgId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MaxMsgId))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Offset))
	}
	if len(m.MediaTypes) > 0 {
		dAtA14 := make([]byte, len(m.MediaTypes)*10)
		var j13 int
		for _, num1 := range m.MediaTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if m.Debug != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Debug.Size()))
		n15, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *SearchChannelMessageMediaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchChannelMessageMediaReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keyword) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Size_))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.WithId))
	}
	if m.MaxMsgId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.MaxMsgId))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Encry))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Offset))
	}
	if len(m.MediaTypes) > 0 {
		dAtA17 := make([]byte, len(m.MediaTypes)*10)
		var j16 int
		for _, num1 := range m.MediaTypes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if m.Debug != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Debug.Size()))
		n18, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SearchMediaResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchMediaResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPbsearchserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *HandlerReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandlerReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ReplyCode))
	}
	if len(m.ReplyInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.ReplyInfo)))
		i += copy(dAtA[i:], m.ReplyInfo)
	}
	return i, nil
}

func (m *UserNameInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserNameInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.IsKick {
		dAtA[i] = 0x20
		i++
		if m.IsKick {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *InsertGroupUsersReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertGroupUsersReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.GroupId))
	}
	if len(m.UserArr) > 0 {
		for _, msg := range m.UserArr {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPbsearchserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeleteGroupUsersReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteGroupUsersReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.GroupId))
	}
	if len(m.UserIds) > 0 {
		dAtA20 := make([]byte, len(m.UserIds)*10)
		var j19 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	return i, nil
}

func (m *UpdateGroupUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupUserReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.GroupId))
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.User.Size()))
		n21, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *RenameGroupUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenameGroupUserReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.GroupId))
	}
	if m.User != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.User.Size()))
		n22, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *SearchGroupUsersReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchGroupUsersReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.GroupId))
	}
	if m.KickFlg {
		dAtA[i] = 0x10
		i++
		if m.KickFlg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.KeyWord) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.KeyWord)))
		i += copy(dAtA[i:], m.KeyWord)
	}
	if m.RetRows != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.RetRows))
	}
	return i, nil
}

func (m *SearchGroupUsersRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchGroupUsersRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.ErrInfo)))
		i += copy(dAtA[i:], m.ErrInfo)
	}
	if len(m.UserIds) > 0 {
		dAtA24 := make([]byte, len(m.UserIds)*10)
		var j23 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j23))
		i += copy(dAtA[i:], dAtA24[:j23])
	}
	return i, nil
}

func (m *InsertChanNameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertChanNameReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Uname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Uname)))
		i += copy(dAtA[i:], m.Uname)
	}
	return i, nil
}

func (m *UpdateChanNameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateChanNameReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Uname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.Uname)))
		i += copy(dAtA[i:], m.Uname)
	}
	return i, nil
}

func (m *DeleteChanNameReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChanNameReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ChannelId))
	}
	return i, nil
}

func (m *SearchChannelsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchChannelsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.KeyWord) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.KeyWord)))
		i += copy(dAtA[i:], m.KeyWord)
	}
	if m.RetRows != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.RetRows))
	}
	return i, nil
}

func (m *SearchChannelsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchChannelsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(len(m.ErrInfo)))
		i += copy(dAtA[i:], m.ErrInfo)
	}
	if len(m.ChanIds) > 0 {
		dAtA26 := make([]byte, len(m.ChanIds)*10)
		var j25 int
		for _, num1 := range m.ChanIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPbsearchserver(dAtA, i, uint64(j25))
		i += copy(dAtA[i:], dAtA26[:j25])
	}
	return i, nil
}

func encodeVarintPbsearchserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithIdType))
	}
	if m.MsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MsgId))
	}
	if m.MessageType != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MessageType))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.FromId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.FromId))
	}
	if m.ToId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ToId))
	}
	if m.Media != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Media))
	}
	if m.Date != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Date))
	}
	if m.Uuid != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Uuid))
	}
	if m.Flags != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Flags))
	}
	if m.Out {
		n += 2
	}
	if m.Mentioned {
		n += 2
	}
	if m.MediaUnread {
		n += 2
	}
	if m.Silent {
		n += 3
	}
	if m.Post {
		n += 3
	}
	if m.Pts != 0 {
		n += 2 + sovPbsearchserver(uint64(m.Pts))
	}
	l = len(m.FwdFrom)
	if l > 0 {
		n += 2 + l + sovPbsearchserver(uint64(l))
	}
	if m.ViaBotId != 0 {
		n += 2 + sovPbsearchserver(uint64(m.ViaBotId))
	}
	if m.ReplyToMsgId != 0 {
		n += 2 + sovPbsearchserver(uint64(m.ReplyToMsgId))
	}
	l = len(m.MediaData)
	if l > 0 {
		n += 2 + l + sovPbsearchserver(uint64(l))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 2 + l + sovPbsearchserver(uint64(l))
	}
	l = len(m.Entities)
	if l > 0 {
		n += 2 + l + sovPbsearchserver(uint64(l))
	}
	if m.Views != 0 {
		n += 2 + sovPbsearchserver(uint64(m.Views))
	}
	if m.EditDate != 0 {
		n += 2 + sovPbsearchserver(uint64(m.EditDate))
	}
	l = len(m.Action)
	if l > 0 {
		n += 2 + l + sovPbsearchserver(uint64(l))
	}
	if m.RandomId != 0 {
		n += 2 + sovPbsearchserver(uint64(m.RandomId))
	}
	if m.InsertDate != 0 {
		n += 2 + sovPbsearchserver(uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		n += 2 + sovPbsearchserver(uint64(m.UpdateDate))
	}
	if m.GroupId != 0 {
		n += 2 + sovPbsearchserver(uint64(m.GroupId))
	}
	l = len(m.Combination)
	if l > 0 {
		n += 2 + l + sovPbsearchserver(uint64(l))
	}
	if m.Encry != 0 {
		n += 2 + sovPbsearchserver(uint64(m.Encry))
	}
	if m.Flag != 0 {
		n += 2 + sovPbsearchserver(uint64(m.Flag))
	}
	return n
}

func (m *MessageInfo) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithIdType))
	}
	if m.MsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MsgId))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.FromId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.FromId))
	}
	if m.Media != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Media))
	}
	if m.Date != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Date))
	}
	if m.Encry != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Encry))
	}
	if m.Uuid != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Uuid))
	}
	return n
}

func (m *HandleSearchLogicReq) Size() (n int) {
	var l int
	_ = l
	if m.MessageId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MessageId))
	}
	if m.KeyId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.KeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.CrcId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.CrcId))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	l = len(m.PhoneId)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Layer))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *HandleSearchLogicResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.ErrCode != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ErrCode))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *MessageSearchReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.KeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.FromId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.FromId))
	}
	if m.PeerType != 0 {
		n += 1 + sovPbsearchserver(uint64(m.PeerType))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithIdType))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.MinDate != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MaxDate))
	}
	if m.Offset != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Offset))
	}
	if m.MaxId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MaxId))
	}
	if m.Limit != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Limit))
	}
	if m.Encry != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Encry))
	}
	if len(m.MediaTypes) > 0 {
		l = 0
		for _, e := range m.MediaTypes {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func (m *NoUseResp) Size() (n int) {
	var l int
	_ = l
	if m.Reserved != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Reserved))
	}
	return n
}

func (m *DeleteUserMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.MsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MsgId))
	}
	return n
}

func (m *DeleteChannelMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.MsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MsgId))
	}
	return n
}

func (m *SearchCursor) Size() (n int) {
	var l int
	_ = l
	if m.Date != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Date))
	}
	if m.UWId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UWId))
	}
	if m.MsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MsgId))
	}
	return n
}

func (m *UserChannelMsgId) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ChannelId))
	}
	if m.MsgIdStart != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MsgIdStart))
	}
	return n
}

func (m *SearchMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.KeyId))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.Cursor != nil {
		l = m.Cursor.Size()
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Size_))
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.FromId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.FromId))
	}
	if m.Searchtype != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Searchtype))
	}
	if len(m.UserChannelMsgIds) > 0 {
		for _, e := range m.UserChannelMsgIds {
			l = e.Size()
			n += 1 + l + sovPbsearchserver(uint64(l))
		}
	}
	return n
}

func (m *SearchResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovPbsearchserver(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Count))
	}
	if m.Cursor != nil {
		l = m.Cursor.Size()
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *SearchUserMessageByMaxMsgIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.KeyId))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Size_))
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.FromId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.FromId))
	}
	if m.MaxMsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MaxMsgId))
	}
	return n
}

func (m *SearchChannelMessageByMaxMsgIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.KeyId))
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Size_))
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.FromId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.FromId))
	}
	if m.MsgIdStart != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MsgIdStart))
	}
	if m.MaxMsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MaxMsgId))
	}
	return n
}

func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) Size() (n int) {
	var l int
	_ = l
	if m.MediaUnread {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func (m *DeleteUserMessageByMsgIdsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func (m *DeleteUserMessageByUuidsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if len(m.Uuids) > 0 {
		l = 0
		for _, e := range m.Uuids {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func (m *DeleteUserMessageByUWTReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithIdType))
	}
	return n
}

func (m *DeleteChannelMessageByMsgIdsReq) Size() (n int) {
	var l int
	_ = l
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func (m *DeleteChannelMessageByWithIdReq) Size() (n int) {
	var l int
	_ = l
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	return n
}

func (m *DeleteChannelMessageByUWMReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.MaxMsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MaxMsgId))
	}
	return n
}

func (m *SearchUserMessageMediaReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Size_))
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.WithType != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithType))
	}
	if m.Encry != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Encry))
	}
	if m.MaxMsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MaxMsgId))
	}
	if m.Offset != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Offset))
	}
	if len(m.MediaTypes) > 0 {
		l = 0
		for _, e := range m.MediaTypes {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *SearchChannelMessageMediaReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Size_))
	}
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.WithId))
	}
	if m.MaxMsgId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.MaxMsgId))
	}
	if m.Encry != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Encry))
	}
	if m.Offset != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Offset))
	}
	if len(m.MediaTypes) > 0 {
		l = 0
		for _, e := range m.MediaTypes {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *SearchMediaResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovPbsearchserver(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovPbsearchserver(uint64(m.Count))
	}
	return n
}

func (m *HandlerReply) Size() (n int) {
	var l int
	_ = l
	if m.ReplyCode != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ReplyCode))
	}
	l = len(m.ReplyInfo)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *UserNameInfo) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.UserId))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.IsKick {
		n += 2
	}
	return n
}

func (m *InsertGroupUsersReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.GroupId))
	}
	if len(m.UserArr) > 0 {
		for _, e := range m.UserArr {
			l = e.Size()
			n += 1 + l + sovPbsearchserver(uint64(l))
		}
	}
	return n
}

func (m *DeleteGroupUsersReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.GroupId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func (m *UpdateGroupUserReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.GroupId))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *RenameGroupUserReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.GroupId))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *SearchGroupUsersReq) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.GroupId))
	}
	if m.KickFlg {
		n += 2
	}
	l = len(m.KeyWord)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.RetRows != 0 {
		n += 1 + sovPbsearchserver(uint64(m.RetRows))
	}
	return n
}

func (m *SearchGroupUsersRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ErrCode))
	}
	l = len(m.ErrInfo)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func (m *InsertChanNameReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ChannelId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *UpdateChanNameReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ChannelId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	l = len(m.Uname)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	return n
}

func (m *DeleteChanNameReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ChannelId))
	}
	return n
}

func (m *SearchChannelsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.KeyWord)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if m.RetRows != 0 {
		n += 1 + sovPbsearchserver(uint64(m.RetRows))
	}
	return n
}

func (m *SearchChannelsRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovPbsearchserver(uint64(m.ErrCode))
	}
	l = len(m.ErrInfo)
	if l > 0 {
		n += 1 + l + sovPbsearchserver(uint64(l))
	}
	if len(m.ChanIds) > 0 {
		l = 0
		for _, e := range m.ChanIds {
			l += sovPbsearchserver(uint64(e))
		}
		n += 1 + sovPbsearchserver(uint64(l)) + l
	}
	return n
}

func sovPbsearchserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPbsearchserver(x uint64) (n int) {
	return sovPbsearchserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToId", wireType)
			}
			m.ToId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			m.Uuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Out = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentioned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mentioned = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaUnread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MediaUnread = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Post = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdFrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwdFrom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMsgId", wireType)
			}
			m.ReplyToMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			m.Views = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Views |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			m.EditDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertDate", wireType)
			}
			m.InsertDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDate", wireType)
			}
			m.UpdateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Combination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= (EMsgFlag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			m.Uuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSearchLogicReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSearchLogicReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSearchLogicReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSearchLogicResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSearchLogicResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSearchLogicResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageSearchReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageSearchReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageSearchReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= (PeerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDate", wireType)
			}
			m.MinDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDate", wireType)
			}
			m.MaxDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MediaTypes = append(m.MediaTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MediaTypes = append(m.MediaTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoUseResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoUseResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoUseResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchCursor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchCursor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchCursor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UWId", wireType)
			}
			m.UWId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UWId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserChannelMsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserChannelMsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserChannelMsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIdStart", wireType)
			}
			m.MsgIdStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgIdStart |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cursor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cursor == nil {
				m.Cursor = &SearchCursor{}
			}
			if err := m.Cursor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Searchtype", wireType)
			}
			m.Searchtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Searchtype |= (EMsgFlag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserChannelMsgIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserChannelMsgIds = append(m.UserChannelMsgIds, &UserChannelMsgId{})
			if err := m.UserChannelMsgIds[len(m.UserChannelMsgIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &Message{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cursor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cursor == nil {
				m.Cursor = &SearchCursor{}
			}
			if err := m.Cursor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUserMessageByMaxMsgIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUserMessageByMaxMsgIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUserMessageByMaxMsgIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgId", wireType)
			}
			m.MaxMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchChannelMessageByMaxMsgIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchChannelMessageByMaxMsgIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchChannelMessageByMaxMsgIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIdStart", wireType)
			}
			m.MsgIdStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgIdStart |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgId", wireType)
			}
			m.MaxMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserMessageMediaUnreadByMsgIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserMessageMediaUnreadByMsgIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserMessageMediaUnreadByMsgIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaUnread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MediaUnread = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMessageByMsgIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMessageByMsgIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMessageByMsgIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMessageByUuidsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMessageByUuidsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMessageByUuidsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uuids = append(m.Uuids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uuids = append(m.Uuids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuids", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserMessageByUWTReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserMessageByUWTReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserMessageByUWTReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelMessageByMsgIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelMessageByMsgIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelMessageByMsgIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelMessageByWithIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelMessageByWithIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelMessageByWithIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelMessageByUWMReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelMessageByUWMReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelMessageByUWMReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgId", wireType)
			}
			m.MaxMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUserMessageMediaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUserMessageMediaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUserMessageMediaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgId", wireType)
			}
			m.MaxMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MediaTypes = append(m.MediaTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MediaTypes = append(m.MediaTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaTypes", wireType)
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchChannelMessageMediaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchChannelMessageMediaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchChannelMessageMediaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgId", wireType)
			}
			m.MaxMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MediaTypes = append(m.MediaTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MediaTypes = append(m.MediaTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaTypes", wireType)
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchMediaResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchMediaResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchMediaResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &messagedb.UserMsg{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandlerReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandlerReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandlerReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserNameInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserNameInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserNameInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsKick", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsKick = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertGroupUsersReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertGroupUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertGroupUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserArr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserArr = append(m.UserArr, &UserNameInfo{})
			if err := m.UserArr[len(m.UserArr)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteGroupUsersReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteGroupUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteGroupUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &UserNameInfo{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenameGroupUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenameGroupUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenameGroupUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &UserNameInfo{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchGroupUsersReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchGroupUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchGroupUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KickFlg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KickFlg = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyWord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyWord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetRows", wireType)
			}
			m.RetRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetRows |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchGroupUsersRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchGroupUsersRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchGroupUsersRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertChanNameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertChanNameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertChanNameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateChanNameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateChanNameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateChanNameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChanNameReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChanNameReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChanNameReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchChannelsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchChannelsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchChannelsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyWord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyWord = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetRows", wireType)
			}
			m.RetRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetRows |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchChannelsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchChannelsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchChannelsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChanIds = append(m.ChanIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPbsearchserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPbsearchserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChanIds = append(m.ChanIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChanIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPbsearchserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPbsearchserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPbsearchserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPbsearchserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPbsearchserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPbsearchserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPbsearchserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPbsearchserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPbsearchserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPbsearchserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/pbsearchserver/pbsearchserver.proto", fileDescriptorPbsearchserver)
}

var fileDescriptorPbsearchserver = []byte{
	// 2520 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xdd, 0x6e, 0x1b, 0xc7,
	0xf5, 0xf7, 0xf2, 0x73, 0x79, 0xa8, 0x0f, 0x6a, 0x24, 0xdb, 0x2b, 0x4a, 0xb6, 0xe8, 0x4d, 0x82,
	0xe8, 0x9f, 0x7f, 0x20, 0xb5, 0x4a, 0x8a, 0x14, 0xcd, 0x95, 0x2d, 0x4b, 0x0e, 0x61, 0x4b, 0x4a,
	0x97, 0x62, 0x94, 0x8b, 0x22, 0xdb, 0x25, 0x77, 0x48, 0x6d, 0x44, 0x72, 0x37, 0xbb, 0x4b, 0xc9,
	0x2c, 0x82, 0x16, 0x45, 0x6f, 0x5b, 0xa0, 0xb7, 0x7d, 0x85, 0xa2, 0x0f, 0xd2, 0x8b, 0xa2, 0xe8,
	0x23, 0x14, 0xb9, 0xe9, 0x03, 0xf4, 0x01, 0x5a, 0xcc, 0x99, 0x1d, 0x72, 0x3f, 0x49, 0xc6, 0x80,
	0x83, 0x5e, 0x99, 0xe7, 0xcc, 0xcc, 0x39, 0x67, 0x7e, 0xe7, 0x63, 0xce, 0x59, 0x0b, 0x3e, 0xeb,
	0x5b, 0xfe, 0xc0, 0xe8, 0x1c, 0x74, 0xaf, 0x0d, 0xdf, 0xa3, 0xee, 0x2d, 0x75, 0x0f, 0xac, 0xe1,
	0xa1, 0x35, 0xf2, 0xa9, 0xdb, 0x33, 0xba, 0xd4, 0x71, 0xed, 0xce, 0xb8, 0x77, 0xe8, 0x74, 0x3c,
	0x6a, 0xb8, 0xdd, 0x6b, 0xbe, 0x23, 0x46, 0x1e, 0x38, 0xae, 0xed, 0xdb, 0x64, 0x2d, 0xca, 0xad,
	0x7f, 0x9a, 0x2e, 0x79, 0x78, 0xe8, 0xd8, 0xbe, 0xe1, 0xdb, 0x78, 0xa8, 0x33, 0xee, 0x79, 0x87,
	0x4e, 0xa7, 0x6b, 0x0f, 0x87, 0xc1, 0x3f, 0x5c, 0x58, 0xfd, 0xe9, 0xb2, 0x87, 0x87, 0xd4, 0xf3,
	0x8c, 0x3e, 0x35, 0x3b, 0xb3, 0x5f, 0x5c, 0x84, 0xfa, 0x97, 0x32, 0x94, 0xcf, 0x38, 0x8f, 0x3c,
	0x84, 0xf2, 0xd8, 0xa3, 0xae, 0x6e, 0x99, 0x8a, 0xd4, 0x90, 0xf6, 0x8b, 0x5a, 0x89, 0x91, 0x4d,
	0x93, 0x2d, 0xdc, 0x59, 0xfe, 0x35, 0x5b, 0xc8, 0xf1, 0x05, 0x46, 0x36, 0x4d, 0xd2, 0x80, 0x95,
	0x60, 0x41, 0xf7, 0x27, 0x0e, 0x55, 0xf2, 0xb8, 0x0a, 0x7c, 0xf5, 0x72, 0xe2, 0x50, 0x72, 0x1f,
	0x4a, 0x43, 0xaf, 0xcf, 0x4e, 0x16, 0x70, 0xad, 0x38, 0xf4, 0xfa, 0x4d, 0x93, 0x3c, 0x81, 0x95,
	0xc0, 0x12, 0x7e, 0xb0, 0x88, 0x8b, 0xd5, 0x80, 0x87, 0x27, 0x15, 0x28, 0x07, 0xa4, 0x52, 0x6a,
	0x48, 0xfb, 0x15, 0x4d, 0x90, 0xcc, 0x9c, 0x9e, 0x6b, 0x0f, 0x99, 0xd0, 0x32, 0x37, 0x87, 0x91,
	0x4d, 0x93, 0x6c, 0x42, 0xd1, 0xb7, 0x19, 0x5b, 0x46, 0x76, 0xc1, 0xb7, 0x9b, 0x26, 0xd9, 0x82,
	0xe2, 0x90, 0x9a, 0x96, 0xa1, 0x54, 0x02, 0x03, 0x18, 0x41, 0x08, 0x14, 0x4c, 0xc3, 0xa7, 0x0a,
	0xf0, 0x9d, 0xec, 0x37, 0xe3, 0x8d, 0xc7, 0x96, 0xa9, 0x54, 0x1b, 0xd2, 0x7e, 0x5e, 0xc3, 0xdf,
	0xec, 0x74, 0x6f, 0x60, 0xf4, 0x3d, 0x65, 0x85, 0x9f, 0x46, 0x82, 0xd4, 0x20, 0x6f, 0x8f, 0x7d,
	0x65, 0xb5, 0x21, 0xed, 0xcb, 0x1a, 0xfb, 0x49, 0x76, 0xa1, 0x32, 0xa4, 0x23, 0xdf, 0xb2, 0x47,
	0xd4, 0x54, 0xd6, 0x90, 0x3f, 0x63, 0x90, 0x06, 0x54, 0x51, 0x6d, 0x7b, 0xe4, 0x52, 0xc3, 0x54,
	0xd6, 0x71, 0x3d, 0xcc, 0x22, 0x0f, 0xa0, 0xe4, 0x59, 0x03, 0x3a, 0xf2, 0x95, 0x1a, 0x2e, 0x06,
	0x14, 0xb3, 0xc9, 0xb1, 0x3d, 0x5f, 0xd9, 0x40, 0x2e, 0xfe, 0x66, 0xda, 0x1d, 0xdf, 0x53, 0x08,
	0x5a, 0xc4, 0x7e, 0x92, 0x6d, 0x90, 0x7b, 0x77, 0xa6, 0xce, 0x60, 0x50, 0x36, 0x39, 0x58, 0xbd,
	0x3b, 0xf3, 0xd4, 0xb5, 0x87, 0x64, 0x17, 0xe0, 0xd6, 0x32, 0xf4, 0x8e, 0xed, 0x33, 0x60, 0xb6,
	0xf0, 0x8c, 0x7c, 0x6b, 0x19, 0xcf, 0x6c, 0xbf, 0x69, 0x92, 0xf7, 0x60, 0xdd, 0xa5, 0xce, 0x60,
	0xa2, 0xfb, 0xb6, 0x1e, 0xf8, 0xe9, 0x3e, 0x6e, 0x59, 0x41, 0xf6, 0xa5, 0x7d, 0x86, 0xee, 0x7a,
	0x04, 0x80, 0xc6, 0xea, 0xa6, 0xe1, 0x1b, 0xca, 0x03, 0xd4, 0x50, 0x41, 0xce, 0x73, 0xc3, 0x37,
	0x98, 0x37, 0xb9, 0x94, 0xa1, 0xe1, 0xde, 0x8c, 0x1d, 0xe5, 0x21, 0x6e, 0xa8, 0x22, 0xef, 0x0c,
	0x59, 0xa4, 0x0e, 0x32, 0x43, 0xc3, 0xb7, 0xa8, 0xa7, 0x28, 0xb8, 0x3c, 0xa5, 0x19, 0xc6, 0xb7,
	0x16, 0xbd, 0xf3, 0x94, 0x6d, 0x8e, 0x31, 0x12, 0x64, 0x07, 0x2a, 0xd4, 0xb4, 0x7c, 0x1d, 0xdd,
	0x54, 0xe7, 0x76, 0x33, 0xc6, 0x73, 0xe6, 0xaa, 0x07, 0x50, 0x32, 0xba, 0x0c, 0x5c, 0x65, 0x07,
	0x85, 0x05, 0x14, 0x3b, 0xe4, 0x1a, 0x23, 0x93, 0x07, 0xc7, 0x2e, 0xfa, 0x51, 0xe6, 0x8c, 0xa6,
	0x49, 0xf6, 0xa0, 0x6a, 0x8d, 0x3c, 0xea, 0x06, 0x32, 0x1f, 0xf1, 0x60, 0xe5, 0x2c, 0x94, 0xba,
	0x07, 0xd5, 0xb1, 0xc3, 0xd6, 0xf8, 0x86, 0xc7, 0x7c, 0x03, 0x67, 0xe1, 0x86, 0x6d, 0x90, 0xfb,
	0xae, 0x3d, 0x76, 0x98, 0xf4, 0x3d, 0x94, 0x5e, 0x46, 0x1a, 0x53, 0xa1, 0xda, 0xb5, 0x87, 0x1d,
	0x6b, 0x64, 0xa0, 0x59, 0x0d, 0x0e, 0x41, 0x88, 0xc5, 0xae, 0x49, 0x47, 0x5d, 0x77, 0xa2, 0x3c,
	0xe1, 0xd7, 0x44, 0x82, 0x7c, 0x08, 0x05, 0x16, 0x53, 0x8a, 0xda, 0x90, 0xf6, 0xd7, 0x8e, 0x94,
	0x83, 0x58, 0xd5, 0x38, 0x39, 0xf3, 0xfa, 0xa7, 0x03, 0xa3, 0xaf, 0xe1, 0x2e, 0xf5, 0x3f, 0x12,
	0x54, 0x83, 0x74, 0x6d, 0x8e, 0x7a, 0xf6, 0x0f, 0x99, 0xb2, 0xa1, 0x7c, 0x2c, 0x66, 0xe6, 0x63,
	0x29, 0x92, 0x8f, 0xd3, 0xd4, 0x2b, 0xa7, 0xa5, 0x9e, 0x1c, 0x4a, 0xbd, 0x29, 0x36, 0x95, 0x30,
	0x36, 0x22, 0x21, 0x61, 0x96, 0x90, 0xea, 0xbf, 0x24, 0xd8, 0xfa, 0xcc, 0x18, 0x99, 0x03, 0xda,
	0x42, 0x9c, 0x5e, 0xd9, 0x7d, 0xab, 0xab, 0xd1, 0x6f, 0x78, 0x8c, 0xf2, 0x92, 0x12, 0xa0, 0x91,
	0x67, 0x31, 0xca, 0xb1, 0x32, 0xd9, 0xad, 0x6e, 0xe8, 0x44, 0xe0, 0x91, 0xd7, 0x8a, 0x37, 0x74,
	0xc2, 0x71, 0x12, 0x00, 0xe6, 0x23, 0x00, 0xde, 0x87, 0x52, 0xd7, 0xed, 0x0a, 0x14, 0xf2, 0x5a,
	0xb1, 0xeb, 0x76, 0xf9, 0x7e, 0xbb, 0xf3, 0xb5, 0xde, 0xb1, 0x46, 0x88, 0xc2, 0x8a, 0x56, 0xb2,
	0x3b, 0x5f, 0x3f, 0xb3, 0x46, 0x2c, 0x34, 0x9c, 0x6b, 0x7b, 0x44, 0x05, 0x0a, 0x15, 0xad, 0x8c,
	0x34, 0x87, 0x61, 0x60, 0x4c, 0xa8, 0x2b, 0x60, 0x40, 0x82, 0x05, 0x9b, 0xe1, 0x38, 0xfa, 0x2d,
	0x75, 0x3d, 0x16, 0x30, 0x32, 0x9e, 0x01, 0xc3, 0x71, 0xbe, 0xe0, 0x1c, 0xb5, 0x0b, 0xf7, 0x53,
	0x2e, 0xea, 0x39, 0x2c, 0xf8, 0x5d, 0xea, 0x8d, 0x07, 0x3e, 0xde, 0x72, 0x45, 0x0b, 0x28, 0x66,
	0x02, 0x75, 0x5d, 0xbd, 0x6b, 0x9b, 0x34, 0x70, 0x7a, 0x99, 0xba, 0xee, 0xb1, 0x6d, 0xa2, 0x8b,
	0xd8, 0xd2, 0xd0, 0xeb, 0xe3, 0x35, 0x2b, 0x5a, 0x89, 0xba, 0xee, 0x99, 0xd7, 0x57, 0xff, 0x94,
	0x87, 0x5a, 0x10, 0x50, 0x5c, 0x0d, 0x83, 0x72, 0x86, 0x95, 0x94, 0x81, 0x55, 0x2e, 0x1e, 0x6c,
	0x22, 0x00, 0xf2, 0x91, 0x00, 0xf8, 0x09, 0x54, 0x1c, 0x4a, 0x5d, 0x1e, 0x69, 0x85, 0xf4, 0x08,
	0xff, 0x9c, 0x52, 0x97, 0xc5, 0x9d, 0x26, 0x3b, 0xc1, 0xaf, 0x70, 0xf0, 0x16, 0xe7, 0x06, 0x6f,
	0x29, 0x11, 0xbc, 0x0a, 0x94, 0x6f, 0xe8, 0xe4, 0xce, 0x76, 0xf9, 0xdb, 0x50, 0xd1, 0x04, 0xc9,
	0xd0, 0x19, 0x5a, 0x23, 0x3d, 0x14, 0x7a, 0xe5, 0xa1, 0x35, 0x12, 0x69, 0x3d, 0x34, 0x5e, 0xf3,
	0xa5, 0x4a, 0xb0, 0x64, 0xbc, 0x16, 0x85, 0xc6, 0xee, 0xf5, 0x3c, 0xea, 0x07, 0x2f, 0x45, 0x40,
	0x61, 0x92, 0x18, 0xaf, 0xf5, 0xe0, 0xb5, 0x60, 0xb1, 0x6d, 0xbc, 0x0e, 0x5c, 0x6d, 0x0d, 0x2d,
	0x5f, 0x3c, 0x17, 0x48, 0xcc, 0xa2, 0x7b, 0x35, 0x1c, 0xdd, 0x7b, 0xc1, 0xa3, 0x80, 0x57, 0xf1,
	0x94, 0xb5, 0x46, 0x9e, 0xdd, 0x05, 0x59, 0xec, 0x2a, 0x9e, 0xfa, 0x3e, 0x54, 0xce, 0xed, 0xb6,
	0x47, 0xd1, 0xe9, 0x75, 0x90, 0x5d, 0x8a, 0x90, 0x71, 0xaf, 0xac, 0x6a, 0x53, 0x5a, 0x3d, 0x85,
	0xad, 0xe7, 0x74, 0x40, 0x7d, 0xda, 0xf6, 0xa8, 0x1b, 0x78, 0x93, 0xf9, 0x31, 0xb3, 0x3a, 0xcc,
	0x52, 0x3c, 0x17, 0x4a, 0x71, 0xb5, 0x09, 0x0f, 0xb9, 0x9c, 0xe3, 0x6b, 0x63, 0x34, 0xa2, 0x83,
	0xa8, 0x28, 0xe1, 0x12, 0x29, 0xe2, 0x92, 0x0c, 0x51, 0x17, 0xb0, 0xc2, 0xe3, 0xe9, 0x78, 0xec,
	0x7a, 0xb6, 0x3b, 0x4d, 0x7a, 0x29, 0x92, 0xf4, 0xa5, 0xb1, 0x7e, 0x37, 0x3b, 0x5a, 0x18, 0x5f,
	0x45, 0x04, 0xe6, 0xc3, 0x02, 0x5b, 0x50, 0x63, 0xb7, 0x13, 0x96, 0x89, 0x67, 0xa9, 0xcb, 0xe9,
	0x99, 0x5d, 0x95, 0x80, 0xc3, 0xa3, 0x85, 0x4b, 0xd2, 0x3d, 0xdf, 0x70, 0xfd, 0x40, 0x0b, 0xa0,
	0xbc, 0x16, 0xe3, 0xa8, 0x7f, 0xcb, 0x41, 0x8d, 0x9b, 0x19, 0xba, 0x6a, 0x34, 0xfa, 0x0b, 0x22,
	0xfa, 0x43, 0x91, 0x95, 0x8b, 0x46, 0xd6, 0xc7, 0x50, 0xea, 0xe2, 0x2d, 0xd1, 0xe2, 0xea, 0xd1,
	0x6e, 0x3c, 0xc4, 0xc3, 0x48, 0x68, 0xc1, 0x5e, 0x86, 0x88, 0x67, 0xfd, 0x8a, 0x06, 0x45, 0x16,
	0x7f, 0x87, 0x1d, 0x56, 0xcc, 0xca, 0xb0, 0x68, 0x89, 0xfd, 0x29, 0x00, 0x57, 0x85, 0xf9, 0x50,
	0x5e, 0xf0, 0x88, 0x84, 0xf6, 0x92, 0x9f, 0xc3, 0x16, 0xea, 0x12, 0x08, 0x72, 0xa8, 0x3c, 0x45,
	0x6e, 0xe4, 0xf7, 0xab, 0x47, 0x8d, 0xb8, 0x8c, 0x38, 0xf8, 0xda, 0xc6, 0x38, 0xc6, 0xf1, 0xd4,
	0x3f, 0x48, 0x00, 0xa2, 0x8a, 0x78, 0x0e, 0xf9, 0x08, 0xe4, 0xa0, 0xfe, 0x7a, 0x8a, 0x84, 0x52,
	0x1f, 0xc6, 0xa5, 0x0a, 0xd8, 0xa7, 0x1b, 0x59, 0xae, 0x74, 0xed, 0xf1, 0x48, 0x78, 0x8b, 0x13,
	0x6f, 0x06, 0xb1, 0xfa, 0x77, 0x09, 0x1e, 0xf3, 0x85, 0x50, 0x62, 0x3c, 0x9b, 0x9c, 0x19, 0xaf,
	0xf9, 0x15, 0xde, 0xc4, 0xd9, 0xc2, 0x6d, 0xf9, 0x74, 0xb7, 0x15, 0xb2, 0x5e, 0xe1, 0x68, 0x21,
	0xcb, 0xf4, 0xe7, 0x2e, 0x00, 0xab, 0x2b, 0x41, 0x06, 0xf0, 0x07, 0x83, 0x15, 0x27, 0x34, 0x58,
	0xfd, 0xb7, 0x04, 0x4f, 0x82, 0x9b, 0x46, 0x32, 0xf4, 0x7f, 0xfb, 0x4e, 0xf1, 0x3c, 0x2c, 0xc7,
	0xf3, 0x30, 0x76, 0x6b, 0x39, 0x76, 0xeb, 0x5f, 0xc3, 0xfb, 0x6d, 0xec, 0xc1, 0x42, 0x5e, 0x3c,
	0x9b, 0xf5, 0xce, 0xcf, 0x26, 0x3c, 0xfc, 0xd8, 0xd5, 0x71, 0xae, 0x60, 0x35, 0x75, 0xcc, 0x3b,
	0x6d, 0x29, 0xd9, 0x69, 0xcf, 0x7b, 0xc5, 0x44, 0x0e, 0xe4, 0xb1, 0x16, 0x97, 0x86, 0x3c, 0xac,
	0x3f, 0x87, 0xdd, 0x44, 0x79, 0x0d, 0x2b, 0x9d, 0xd7, 0x84, 0x09, 0x89, 0xb9, 0x88, 0xc4, 0x57,
	0xb0, 0x93, 0x22, 0xb1, 0x3d, 0xb6, 0x16, 0x08, 0xdc, 0x82, 0x22, 0x6b, 0x82, 0x84, 0x38, 0x4e,
	0xa8, 0x36, 0x6c, 0xa7, 0x49, 0xbb, 0xba, 0x5c, 0x64, 0xdc, 0x1b, 0x76, 0x88, 0x6a, 0x0b, 0xf6,
	0xd2, 0xde, 0x89, 0x18, 0x26, 0xe9, 0xef, 0x45, 0x26, 0x26, 0x3f, 0xcb, 0x12, 0x7a, 0x85, 0x07,
	0xe7, 0x09, 0x55, 0x47, 0xc2, 0x43, 0xf1, 0xb3, 0xed, 0xab, 0xb3, 0x37, 0x03, 0x21, 0x1a, 0x91,
	0xf9, 0x58, 0x44, 0xfe, 0x39, 0x07, 0xdb, 0x89, 0xc2, 0x82, 0x21, 0xc9, 0xb4, 0x85, 0x12, 0x4d,
	0x4a, 0x4f, 0xb4, 0x5c, 0x7a, 0xa2, 0xe5, 0xb3, 0x6c, 0x2b, 0x44, 0x6c, 0xdb, 0x81, 0x0a, 0x2e,
	0x84, 0x26, 0x67, 0x99, 0x31, 0xb0, 0x01, 0x9a, 0xf6, 0x1a, 0xa5, 0x70, 0xaf, 0x31, 0xb7, 0xac,
	0x84, 0x9a, 0x1c, 0x39, 0xd2, 0xe4, 0xc4, 0x3a, 0x94, 0x4a, 0xbc, 0x43, 0x21, 0xef, 0x40, 0xf1,
	0x39, 0xed, 0x8c, 0xfb, 0xd8, 0x1c, 0x55, 0x8f, 0x56, 0x0f, 0x82, 0xcf, 0x13, 0xc8, 0xd4, 0xf8,
	0x9a, 0xfa, 0xc7, 0x1c, 0xec, 0xa6, 0x15, 0xad, 0x1f, 0x0c, 0xaf, 0xe8, 0xe5, 0x8b, 0xb1, 0xcb,
	0xa7, 0x03, 0x36, 0x83, 0xa4, 0x3c, 0x0f, 0x12, 0x39, 0x1b, 0x92, 0xca, 0x1c, 0x48, 0xae, 0x60,
	0x5d, 0xb4, 0x1d, 0x88, 0x81, 0xe7, 0x90, 0x83, 0xc4, 0x63, 0x49, 0x0e, 0x66, 0x1f, 0x6b, 0x30,
	0xcc, 0xbc, 0xfe, 0xa2, 0x77, 0x52, 0xed, 0xc3, 0x0a, 0x9f, 0x19, 0x5c, 0x8d, 0x0d, 0xdf, 0xac,
	0x3d, 0xc0, 0x1f, 0x7c, 0x28, 0x90, 0xb0, 0x3d, 0xd8, 0x4e, 0xb4, 0x07, 0xae, 0x6b, 0xe3, 0x98,
	0xa0, 0x55, 0x70, 0x33, 0x4e, 0x0c, 0x8f, 0xc4, 0x49, 0x6b, 0xd4, 0xb3, 0x83, 0x07, 0x83, 0x2f,
	0xb3, 0xc1, 0x53, 0xfd, 0x16, 0x56, 0x98, 0x4d, 0xe7, 0xc6, 0x70, 0x3a, 0x88, 0xb6, 0xa3, 0x19,
	0xd6, 0xe6, 0x5e, 0x79, 0x04, 0x70, 0x6a, 0xb9, 0x9e, 0xaf, 0x8f, 0x8c, 0x21, 0x15, 0x72, 0x90,
	0xc3, 0xce, 0xb2, 0x58, 0x7e, 0x65, 0x88, 0x55, 0x3e, 0x9a, 0xc8, 0x8c, 0x81, 0x8b, 0x0f, 0xa1,
	0xdc, 0xf4, 0xf4, 0x1b, 0xab, 0x7b, 0x83, 0x1e, 0x95, 0xb5, 0x52, 0xd3, 0x7b, 0x69, 0x75, 0x6f,
	0x54, 0x0b, 0x36, 0x9b, 0x38, 0xb6, 0xbf, 0x60, 0xd3, 0x37, 0xd3, 0x84, 0x45, 0x67, 0x1b, 0xe4,
	0x17, 0x62, 0x3c, 0xe7, 0x56, 0x94, 0x5f, 0x04, 0xe3, 0xf9, 0x27, 0x20, 0xa3, 0x7d, 0x86, 0xeb,
	0x62, 0xdd, 0x49, 0x69, 0x21, 0xc2, 0xf7, 0xd1, 0xf0, 0x36, 0x4f, 0x5d, 0x57, 0x7d, 0x09, 0x9b,
	0xbc, 0xb4, 0x2c, 0xad, 0x6a, 0x3b, 0x50, 0x35, 0x2b, 0x71, 0x65, 0x8e, 0x85, 0xa7, 0x1a, 0x40,
	0xf8, 0x4b, 0x36, 0x15, 0xb6, 0x40, 0xd6, 0x8f, 0xa0, 0xc0, 0x76, 0x21, 0x6e, 0x8b, 0x4c, 0xc6,
	0x9d, 0x4c, 0x85, 0x46, 0x19, 0x9a, 0x6f, 0x4f, 0xc5, 0x6f, 0x25, 0xd8, 0xe4, 0xe1, 0xfb, 0x7d,
	0x30, 0x61, 0x8e, 0xd3, 0x7b, 0x83, 0x3e, 0x2a, 0x92, 0xb5, 0x32, 0xa3, 0x4f, 0x07, 0x7d, 0x5c,
	0xa2, 0x13, 0x1d, 0xd3, 0x9f, 0x07, 0x40, 0xf9, 0x25, 0x9d, 0x5c, 0x05, 0x23, 0x9b, 0x46, 0x7d,
	0xdd, 0xb5, 0xef, 0xbc, 0x20, 0xa5, 0xcb, 0x1a, 0xf5, 0x35, 0xfb, 0xce, 0x4b, 0xb7, 0xc1, 0x73,
	0xc8, 0xc7, 0x20, 0x9f, 0x88, 0x19, 0x78, 0x61, 0xb8, 0x97, 0x4f, 0x82, 0xf1, 0x78, 0x9b, 0x9f,
	0x0a, 0x85, 0x3a, 0x5b, 0xc2, 0xc0, 0x0e, 0x7b, 0x33, 0x1f, 0xf5, 0xe6, 0x57, 0xb0, 0xc1, 0xa3,
	0x90, 0xd5, 0x35, 0x86, 0x51, 0xf0, 0x19, 0xe2, 0x38, 0x31, 0x93, 0x1c, 0x4f, 0x67, 0x92, 0x2d,
	0x28, 0x5e, 0x5a, 0xfe, 0x40, 0x64, 0x02, 0x27, 0x18, 0xb7, 0x1d, 0xca, 0x00, 0x4e, 0x30, 0xf9,
	0x3c, 0x5a, 0xde, 0x92, 0xfc, 0x23, 0xd8, 0x98, 0xbd, 0x9a, 0xcb, 0xc9, 0x57, 0x9b, 0xb0, 0x11,
	0xa9, 0xe5, 0xc2, 0xf1, 0x53, 0x17, 0x4a, 0xd9, 0x2e, 0xcc, 0x45, 0x5d, 0xf8, 0x9b, 0x84, 0xa8,
	0xb7, 0xe4, 0x3f, 0x26, 0x3f, 0xec, 0x3f, 0x46, 0x37, 0x4d, 0xef, 0x83, 0x4f, 0x41, 0x16, 0x1f,
	0x1f, 0x48, 0x05, 0x8a, 0x27, 0x43, 0xc7, 0x9f, 0xd4, 0xee, 0x91, 0x55, 0xa8, 0xb4, 0xe8, 0xa0,
	0xa7, 0x33, 0x37, 0xd7, 0x24, 0x22, 0x43, 0xe1, 0xf8, 0xda, 0xf0, 0x6b, 0x39, 0x52, 0x85, 0x72,
	0x60, 0x6a, 0x2d, 0xff, 0xc1, 0x21, 0xc8, 0x62, 0xac, 0x22, 0xeb, 0x50, 0x6d, 0xb7, 0x4e, 0xb4,
	0xb3, 0x93, 0x56, 0xeb, 0xe9, 0x8b, 0x93, 0xda, 0x3d, 0x42, 0x60, 0xed, 0xf8, 0xb3, 0xa7, 0xe7,
	0xe7, 0x27, 0xaf, 0x04, 0x4f, 0xfa, 0xe0, 0xf7, 0x12, 0x54, 0xa6, 0xa6, 0x13, 0x80, 0x92, 0xf6,
	0xf9, 0xb1, 0x7e, 0xf1, 0x92, 0x2b, 0x64, 0xbf, 0x4f, 0x34, 0xed, 0x42, 0xab, 0x49, 0xe2, 0xb0,
	0x7e, 0x7e, 0x71, 0xa9, 0x9f, 0x7c, 0xd9, 0x6c, 0x5d, 0xd6, 0x72, 0x8c, 0xc7, 0x34, 0x84, 0x78,
	0xf9, 0x08, 0xef, 0xf4, 0xa2, 0x7d, 0xfe, 0xbc, 0x56, 0x20, 0x9b, 0xb0, 0xfe, 0x92, 0xbf, 0x9d,
	0x7a, 0x73, 0x30, 0xa0, 0x7d, 0x63, 0x50, 0x2b, 0x32, 0xa6, 0x70, 0xa9, 0x60, 0x96, 0x8e, 0x7e,
	0xb7, 0x09, 0xab, 0x1c, 0xfe, 0x16, 0x75, 0x6f, 0xad, 0x2e, 0x25, 0x17, 0x82, 0x21, 0xfe, 0x3f,
	0xa0, 0x91, 0x3e, 0x64, 0xcd, 0x46, 0xe5, 0x7a, 0x3d, 0x7d, 0x07, 0x7b, 0xd0, 0xd4, 0x7b, 0xe4,
	0x06, 0x76, 0xe6, 0x4c, 0x5f, 0xe4, 0x20, 0xfd, 0x70, 0xd6, 0xa8, 0xb6, 0x40, 0xd9, 0x37, 0x62,
	0xd4, 0xcb, 0x9a, 0x8c, 0xc8, 0x8f, 0x33, 0x66, 0xc6, 0xec, 0x49, 0x6a, 0x81, 0xca, 0x6f, 0xe1,
	0xdd, 0x65, 0xe6, 0x12, 0xf2, 0x49, 0xa2, 0xa6, 0x2e, 0x37, 0xcd, 0xd4, 0x13, 0xa1, 0x3f, 0xfd,
	0x1c, 0xa4, 0xde, 0x23, 0x3d, 0x78, 0x90, 0xde, 0x82, 0x92, 0xff, 0x5b, 0x08, 0xac, 0x68, 0xbd,
	0xea, 0x7b, 0x59, 0x2e, 0x0e, 0xda, 0x12, 0xf5, 0x1e, 0x19, 0x88, 0x56, 0x37, 0xa5, 0x7b, 0x23,
	0x1f, 0x2e, 0x83, 0xe9, 0xf7, 0xd1, 0xd6, 0x81, 0x8d, 0xc4, 0x47, 0x4f, 0xf2, 0x6e, 0xfc, 0x5c,
	0xda, 0x07, 0xe0, 0xfa, 0x7b, 0x4b, 0xec, 0x42, 0x1d, 0xa7, 0x00, 0x4f, 0x4d, 0x53, 0x44, 0xf9,
	0x4e, 0xc6, 0x37, 0x09, 0x56, 0x3d, 0xe6, 0x7b, 0xe0, 0x0b, 0x51, 0x3f, 0x43, 0xc8, 0x26, 0x6d,
	0x4d, 0xfb, 0x32, 0x37, 0x5f, 0xee, 0x2f, 0xc4, 0xe7, 0xbc, 0x28, 0x8c, 0xe4, 0xfd, 0x74, 0xd1,
	0x89, 0x8f, 0x75, 0x8b, 0xe2, 0x66, 0x3b, 0x73, 0x9a, 0x4d, 0xfa, 0x73, 0xde, 0xe0, 0x3b, 0x5f,
	0xcf, 0x2f, 0xe1, 0x41, 0xfa, 0x54, 0x9a, 0x8c, 0xcf, 0xcc, 0xe9, 0x75, 0xbe, 0x06, 0x13, 0x94,
	0xac, 0x29, 0x9a, 0xfc, 0xff, 0x32, 0x3a, 0x82, 0x79, 0x7b, 0xbe, 0x96, 0x41, 0xd6, 0x6c, 0x19,
	0x40, 0x76, 0xb8, 0x8c, 0x57, 0x96, 0x46, 0x2d, 0x53, 0x1b, 0x9f, 0x82, 0x97, 0xd5, 0x36, 0x9d,
	0x99, 0x97, 0x8c, 0x85, 0x94, 0xb9, 0x39, 0x2b, 0x16, 0xd2, 0x47, 0xec, 0xf9, 0x7a, 0xae, 0xa0,
	0x16, 0xef, 0xd7, 0xc9, 0x3b, 0xf1, 0x03, 0x29, 0x1d, 0x7d, 0x7d, 0x37, 0x3d, 0xa7, 0xf9, 0x74,
	0xc3, 0x05, 0xc7, 0xbb, 0xf3, 0xa4, 0xe0, 0x94, 0xfe, 0x7d, 0xa1, 0xe0, 0x36, 0xac, 0xc7, 0x3a,
	0x75, 0xa2, 0xa6, 0x97, 0xf1, 0x70, 0x9f, 0xbd, 0x8c, 0xd8, 0x58, 0x77, 0x9e, 0x14, 0x9b, 0x6c,
	0xdf, 0x17, 0x8a, 0xfd, 0x4a, 0x7c, 0xc6, 0x9e, 0x07, 0x43, 0x4a, 0xcb, 0x5e, 0x5f, 0xbc, 0x09,
	0xfd, 0xd7, 0x82, 0xb5, 0x68, 0xa7, 0x4b, 0x9e, 0xa4, 0x7b, 0x2f, 0xd4, 0x49, 0x2e, 0x34, 0xba,
	0x05, 0x6b, 0xd1, 0xf6, 0x36, 0x29, 0x34, 0xd1, 0xfe, 0x2e, 0x23, 0x34, 0xda, 0xd3, 0x26, 0x85,
	0x26, 0x7a, 0xde, 0x85, 0x42, 0xbf, 0x84, 0xb5, 0x68, 0xa7, 0x9a, 0x14, 0x9a, 0x68, 0x8a, 0xeb,
	0x8b, 0xb6, 0x30, 0x60, 0x9f, 0xad, 0xfc, 0xf5, 0xbb, 0xc7, 0xd2, 0x3f, 0xbe, 0x7b, 0x2c, 0xfd,
	0xf3, 0xbb, 0xc7, 0x52, 0xa7, 0x84, 0x7f, 0x93, 0xf1, 0xd1, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0x93, 0xd4, 0x5c, 0x27, 0x6f, 0x22, 0x00, 0x00,
}
