// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: imvedioappserver.proto

/*
Package imvedioappserver is a generated protocol buffer package.

It is generated from these files:

	imvedioappserver.proto

It has these top-level messages:

	ChgModelReq
	ModelRsp
	ModelReq
	IdReq
	UserIdReq
	UsersIdReq
	BoolResult
	CreateRoomReq
	CreateRoomReply
	RtcToken
	GetTokenReq
	GetTokenReply
	BatchGetTokenReq
	BatchGetTokenReply
	VerifyTokenReq
	VerifyTokenReply
	GetUsersByRoomIdReq
	GetUsersByRoomIdReply
	GetRoomAdminUserReq
	GetRoomAdminUserReply
	SaveParticipantKeyIdReq
	SaveParticipantKeyIdReply
	GetParticipantKeyIdReq
	GetParticipantKeyIdReply
*/
package imvedioappserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 错误码
type ErrorCode int32

const (
	// 成功
	ErrorCode_SUCCESS ErrorCode = 0
	// 内部错误
	ErrorCode_INTERNAL_ERROR ErrorCode = 1
	// 房间不存在
	ErrorCode_ROOM_NOT_EXIST ErrorCode = 2
)

var ErrorCode_name = map[int32]string{
	0: "SUCCESS",
	1: "INTERNAL_ERROR",
	2: "ROOM_NOT_EXIST",
}
var ErrorCode_value = map[string]int32{
	"SUCCESS":        0,
	"INTERNAL_ERROR": 1,
	"ROOM_NOT_EXIST": 2,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}
func (ErrorCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{0} }

type ChgModelReq struct {
	// room id
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	Video  int32  `protobuf:"varint,2,opt,name=Video,proto3" json:"Video,omitempty"`
}

func (m *ChgModelReq) Reset()                    { *m = ChgModelReq{} }
func (m *ChgModelReq) String() string            { return proto.CompactTextString(m) }
func (*ChgModelReq) ProtoMessage()               {}
func (*ChgModelReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{0} }

func (m *ChgModelReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *ChgModelReq) GetVideo() int32 {
	if m != nil {
		return m.Video
	}
	return 0
}

type ModelRsp struct {
	// room id
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	Video  int32  `protobuf:"varint,2,opt,name=Video,proto3" json:"Video,omitempty"`
	Code   int32  `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Msg    string `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ModelRsp) Reset()                    { *m = ModelRsp{} }
func (m *ModelRsp) String() string            { return proto.CompactTextString(m) }
func (*ModelRsp) ProtoMessage()               {}
func (*ModelRsp) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{1} }

func (m *ModelRsp) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *ModelRsp) GetVideo() int32 {
	if m != nil {
		return m.Video
	}
	return 0
}

func (m *ModelRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ModelRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type ModelReq struct {
	// room id
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *ModelReq) Reset()                    { *m = ModelReq{} }
func (m *ModelReq) String() string            { return proto.CompactTextString(m) }
func (*ModelReq) ProtoMessage()               {}
func (*ModelReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{2} }

func (m *ModelReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

type IdReq struct {
	// room id
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *IdReq) Reset()                    { *m = IdReq{} }
func (m *IdReq) String() string            { return proto.CompactTextString(m) }
func (*IdReq) ProtoMessage()               {}
func (*IdReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{3} }

func (m *IdReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

type UserIdReq struct {
	// 用户id
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *UserIdReq) Reset()                    { *m = UserIdReq{} }
func (m *UserIdReq) String() string            { return proto.CompactTextString(m) }
func (*UserIdReq) ProtoMessage()               {}
func (*UserIdReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{4} }

func (m *UserIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type UsersIdReq struct {
	// 用户id
	UserId []int32 `protobuf:"varint,1,rep,packed,name=user_id,json=userId" json:"user_id,omitempty"`
	RoomId string  `protobuf:"bytes,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *UsersIdReq) Reset()                    { *m = UsersIdReq{} }
func (m *UsersIdReq) String() string            { return proto.CompactTextString(m) }
func (*UsersIdReq) ProtoMessage()               {}
func (*UsersIdReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{5} }

func (m *UsersIdReq) GetUserId() []int32 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *UsersIdReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

type BoolResult struct {
	// 用户id
	Code   ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	Result bool      `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *BoolResult) Reset()                    { *m = BoolResult{} }
func (m *BoolResult) String() string            { return proto.CompactTextString(m) }
func (*BoolResult) ProtoMessage()               {}
func (*BoolResult) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{6} }

func (m *BoolResult) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *BoolResult) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// 创建房间请求
type CreateRoomReq struct {
	// 房间创建者id
	AdminId int32 `protobuf:"varint,1,opt,name=admin_id,json=adminId,proto3" json:"admin_id,omitempty"`
	// 创建者key id
	AdminKeyId int64 `protobuf:"varint,2,opt,name=admin_key_id,json=adminKeyId,proto3" json:"admin_key_id,omitempty"`
	// 加入房间的用户
	UserIds []int32 `protobuf:"varint,3,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
	Video   int32   `protobuf:"varint,4,opt,name=Video,proto3" json:"Video,omitempty"`
}

func (m *CreateRoomReq) Reset()                    { *m = CreateRoomReq{} }
func (m *CreateRoomReq) String() string            { return proto.CompactTextString(m) }
func (*CreateRoomReq) ProtoMessage()               {}
func (*CreateRoomReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{7} }

func (m *CreateRoomReq) GetAdminId() int32 {
	if m != nil {
		return m.AdminId
	}
	return 0
}

func (m *CreateRoomReq) GetAdminKeyId() int64 {
	if m != nil {
		return m.AdminKeyId
	}
	return 0
}

func (m *CreateRoomReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *CreateRoomReq) GetVideo() int32 {
	if m != nil {
		return m.Video
	}
	return 0
}

// 创建房间回复
type CreateRoomReply struct {
	// 错误码
	Code ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	// 房间id
	RoomId string `protobuf:"bytes,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	// Token， key：用户id，value：用户对应Token
	Tokens map[int32]*RtcToken `protobuf:"bytes,3,rep,name=tokens" json:"tokens,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CreateRoomReply) Reset()                    { *m = CreateRoomReply{} }
func (m *CreateRoomReply) String() string            { return proto.CompactTextString(m) }
func (*CreateRoomReply) ProtoMessage()               {}
func (*CreateRoomReply) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{8} }

func (m *CreateRoomReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *CreateRoomReply) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *CreateRoomReply) GetTokens() map[int32]*RtcToken {
	if m != nil {
		return m.Tokens
	}
	return nil
}

// 音视频通信Token
type RtcToken struct {
	// 阿里rtc appId
	AppId string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"app_id,omitempty"`
	// 阿里rtc服务地址
	Gslb []string `protobuf:"bytes,2,rep,name=gslb" json:"gslb,omitempty"`
	// 房间id
	RoomId string `protobuf:"bytes,3,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	// 随机值以“AK-”（使用app key验证方式）开头，,格式：AK-xxx
	Nonce string `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Token过期时间
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// 用户id
	UserId int32 `protobuf:"varint,6,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// token
	Token string `protobuf:"bytes,7,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *RtcToken) Reset()                    { *m = RtcToken{} }
func (m *RtcToken) String() string            { return proto.CompactTextString(m) }
func (*RtcToken) ProtoMessage()               {}
func (*RtcToken) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{9} }

func (m *RtcToken) GetAppId() string {
	if m != nil {
		return m.AppId
	}
	return ""
}

func (m *RtcToken) GetGslb() []string {
	if m != nil {
		return m.Gslb
	}
	return nil
}

func (m *RtcToken) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *RtcToken) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *RtcToken) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RtcToken) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *RtcToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// 获取Token请求
type GetTokenReq struct {
	// 用户id
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// 房间id
	RoomId string `protobuf:"bytes,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *GetTokenReq) Reset()                    { *m = GetTokenReq{} }
func (m *GetTokenReq) String() string            { return proto.CompactTextString(m) }
func (*GetTokenReq) ProtoMessage()               {}
func (*GetTokenReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{10} }

func (m *GetTokenReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetTokenReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

// 获取Token响应
type GetTokenReply struct {
	// 错误码
	Code ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	// Token
	Token *RtcToken `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *GetTokenReply) Reset()                    { *m = GetTokenReply{} }
func (m *GetTokenReply) String() string            { return proto.CompactTextString(m) }
func (*GetTokenReply) ProtoMessage()               {}
func (*GetTokenReply) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{11} }

func (m *GetTokenReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *GetTokenReply) GetToken() *RtcToken {
	if m != nil {
		return m.Token
	}
	return nil
}

// 批量获取Token请求
type BatchGetTokenReq struct {
	// 用户id列表
	UserIds []int32 `protobuf:"varint,1,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
	// 房间id
	RoomId string `protobuf:"bytes,2,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *BatchGetTokenReq) Reset()         { *m = BatchGetTokenReq{} }
func (m *BatchGetTokenReq) String() string { return proto.CompactTextString(m) }
func (*BatchGetTokenReq) ProtoMessage()    {}
func (*BatchGetTokenReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{12}
}

func (m *BatchGetTokenReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *BatchGetTokenReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

// 批量获取Token请求
type BatchGetTokenReply struct {
	// 错误码
	Code ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	// Token， key：用户id，value：用户对应Token
	Tokens map[int32]*RtcToken `protobuf:"bytes,2,rep,name=tokens" json:"tokens,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *BatchGetTokenReply) Reset()         { *m = BatchGetTokenReply{} }
func (m *BatchGetTokenReply) String() string { return proto.CompactTextString(m) }
func (*BatchGetTokenReply) ProtoMessage()    {}
func (*BatchGetTokenReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{13}
}

func (m *BatchGetTokenReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *BatchGetTokenReply) GetTokens() map[int32]*RtcToken {
	if m != nil {
		return m.Tokens
	}
	return nil
}

// 校验Token请求
type VerifyTokenReq struct {
	// 房间id
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	// 用户ID
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Token值
	Token string `protobuf:"bytes,3,opt,name=token,proto3" json:"token,omitempty"`
	// 随机值以“AK-”（使用app key验证方式）开头，,格式：AK-xxx
	Nonce string `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Token过期时间
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *VerifyTokenReq) Reset()                    { *m = VerifyTokenReq{} }
func (m *VerifyTokenReq) String() string            { return proto.CompactTextString(m) }
func (*VerifyTokenReq) ProtoMessage()               {}
func (*VerifyTokenReq) Descriptor() ([]byte, []int) { return fileDescriptorImvedioappserver, []int{14} }

func (m *VerifyTokenReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *VerifyTokenReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *VerifyTokenReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *VerifyTokenReq) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *VerifyTokenReq) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// 校验Token响应
type VerifyTokenReply struct {
	Code ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	// 是否是有效的
	IsValid bool `protobuf:"varint,2,opt,name=is_valid,json=isValid,proto3" json:"is_valid,omitempty"`
}

func (m *VerifyTokenReply) Reset()         { *m = VerifyTokenReply{} }
func (m *VerifyTokenReply) String() string { return proto.CompactTextString(m) }
func (*VerifyTokenReply) ProtoMessage()    {}
func (*VerifyTokenReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{15}
}

func (m *VerifyTokenReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *VerifyTokenReply) GetIsValid() bool {
	if m != nil {
		return m.IsValid
	}
	return false
}

// room_id 获取用户请求
type GetUsersByRoomIdReq struct {
	// 房间ID
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *GetUsersByRoomIdReq) Reset()         { *m = GetUsersByRoomIdReq{} }
func (m *GetUsersByRoomIdReq) String() string { return proto.CompactTextString(m) }
func (*GetUsersByRoomIdReq) ProtoMessage()    {}
func (*GetUsersByRoomIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{16}
}

func (m *GetUsersByRoomIdReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

// room_id 获取用户回复
type GetUsersByRoomIdReply struct {
	Code ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	// 房间创建者id
	AdminId int32 `protobuf:"varint,2,opt,name=admin_id,json=adminId,proto3" json:"admin_id,omitempty"`
	// 房间里的用户列表
	UserIds []int32 `protobuf:"varint,3,rep,packed,name=user_ids,json=userIds" json:"user_ids,omitempty"`
}

func (m *GetUsersByRoomIdReply) Reset()         { *m = GetUsersByRoomIdReply{} }
func (m *GetUsersByRoomIdReply) String() string { return proto.CompactTextString(m) }
func (*GetUsersByRoomIdReply) ProtoMessage()    {}
func (*GetUsersByRoomIdReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{17}
}

func (m *GetUsersByRoomIdReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *GetUsersByRoomIdReply) GetAdminId() int32 {
	if m != nil {
		return m.AdminId
	}
	return 0
}

func (m *GetUsersByRoomIdReply) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

// 获取房间创建者信息请求
type GetRoomAdminUserReq struct {
	// 房间ID
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *GetRoomAdminUserReq) Reset()         { *m = GetRoomAdminUserReq{} }
func (m *GetRoomAdminUserReq) String() string { return proto.CompactTextString(m) }
func (*GetRoomAdminUserReq) ProtoMessage()    {}
func (*GetRoomAdminUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{18}
}

func (m *GetRoomAdminUserReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

// 获取房间创建者信息响应
type GetRoomAdminUserReply struct {
	Code ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	// 房间创建者id
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// 房间创建者 key id
	KeyId int64 `protobuf:"varint,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *GetRoomAdminUserReply) Reset()         { *m = GetRoomAdminUserReply{} }
func (m *GetRoomAdminUserReply) String() string { return proto.CompactTextString(m) }
func (*GetRoomAdminUserReply) ProtoMessage()    {}
func (*GetRoomAdminUserReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{19}
}

func (m *GetRoomAdminUserReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *GetRoomAdminUserReply) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetRoomAdminUserReply) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

// 保存参与者key id
type SaveParticipantKeyIdReq struct {
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	// 参与者key id
	KeyIds map[int32]int64 `protobuf:"bytes,2,rep,name=key_ids,json=keyIds" json:"key_ids,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *SaveParticipantKeyIdReq) Reset()         { *m = SaveParticipantKeyIdReq{} }
func (m *SaveParticipantKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SaveParticipantKeyIdReq) ProtoMessage()    {}
func (*SaveParticipantKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{20}
}

func (m *SaveParticipantKeyIdReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

func (m *SaveParticipantKeyIdReq) GetKeyIds() map[int32]int64 {
	if m != nil {
		return m.KeyIds
	}
	return nil
}

// 保存参与者 key ID 响应
type SaveParticipantKeyIdReply struct {
	Code ErrorCode `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	Ok   bool      `protobuf:"varint,2,opt,name=ok,proto3" json:"ok,omitempty"`
}

func (m *SaveParticipantKeyIdReply) Reset()         { *m = SaveParticipantKeyIdReply{} }
func (m *SaveParticipantKeyIdReply) String() string { return proto.CompactTextString(m) }
func (*SaveParticipantKeyIdReply) ProtoMessage()    {}
func (*SaveParticipantKeyIdReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{21}
}

func (m *SaveParticipantKeyIdReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *SaveParticipantKeyIdReply) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

// 获取参与者key id
type GetParticipantKeyIdReq struct {
	RoomId string `protobuf:"bytes,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
}

func (m *GetParticipantKeyIdReq) Reset()         { *m = GetParticipantKeyIdReq{} }
func (m *GetParticipantKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*GetParticipantKeyIdReq) ProtoMessage()    {}
func (*GetParticipantKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{22}
}

func (m *GetParticipantKeyIdReq) GetRoomId() string {
	if m != nil {
		return m.RoomId
	}
	return ""
}

type GetParticipantKeyIdReply struct {
	Code   ErrorCode       `protobuf:"varint,1,opt,name=code,proto3,enum=imvedioappserver.ErrorCode" json:"code,omitempty"`
	KeyIds map[int32]int64 `protobuf:"bytes,2,rep,name=key_ids,json=keyIds" json:"key_ids,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *GetParticipantKeyIdReply) Reset()         { *m = GetParticipantKeyIdReply{} }
func (m *GetParticipantKeyIdReply) String() string { return proto.CompactTextString(m) }
func (*GetParticipantKeyIdReply) ProtoMessage()    {}
func (*GetParticipantKeyIdReply) Descriptor() ([]byte, []int) {
	return fileDescriptorImvedioappserver, []int{23}
}

func (m *GetParticipantKeyIdReply) GetCode() ErrorCode {
	if m != nil {
		return m.Code
	}
	return ErrorCode_SUCCESS
}

func (m *GetParticipantKeyIdReply) GetKeyIds() map[int32]int64 {
	if m != nil {
		return m.KeyIds
	}
	return nil
}

func init() {
	proto.RegisterType((*ChgModelReq)(nil), "imvedioappserver.ChgModelReq")
	proto.RegisterType((*ModelRsp)(nil), "imvedioappserver.ModelRsp")
	proto.RegisterType((*ModelReq)(nil), "imvedioappserver.ModelReq")
	proto.RegisterType((*IdReq)(nil), "imvedioappserver.IdReq")
	proto.RegisterType((*UserIdReq)(nil), "imvedioappserver.UserIdReq")
	proto.RegisterType((*UsersIdReq)(nil), "imvedioappserver.UsersIdReq")
	proto.RegisterType((*BoolResult)(nil), "imvedioappserver.BoolResult")
	proto.RegisterType((*CreateRoomReq)(nil), "imvedioappserver.CreateRoomReq")
	proto.RegisterType((*CreateRoomReply)(nil), "imvedioappserver.CreateRoomReply")
	proto.RegisterType((*RtcToken)(nil), "imvedioappserver.RtcToken")
	proto.RegisterType((*GetTokenReq)(nil), "imvedioappserver.GetTokenReq")
	proto.RegisterType((*GetTokenReply)(nil), "imvedioappserver.GetTokenReply")
	proto.RegisterType((*BatchGetTokenReq)(nil), "imvedioappserver.BatchGetTokenReq")
	proto.RegisterType((*BatchGetTokenReply)(nil), "imvedioappserver.BatchGetTokenReply")
	proto.RegisterType((*VerifyTokenReq)(nil), "imvedioappserver.VerifyTokenReq")
	proto.RegisterType((*VerifyTokenReply)(nil), "imvedioappserver.VerifyTokenReply")
	proto.RegisterType((*GetUsersByRoomIdReq)(nil), "imvedioappserver.GetUsersByRoomIdReq")
	proto.RegisterType((*GetUsersByRoomIdReply)(nil), "imvedioappserver.GetUsersByRoomIdReply")
	proto.RegisterType((*GetRoomAdminUserReq)(nil), "imvedioappserver.GetRoomAdminUserReq")
	proto.RegisterType((*GetRoomAdminUserReply)(nil), "imvedioappserver.GetRoomAdminUserReply")
	proto.RegisterType((*SaveParticipantKeyIdReq)(nil), "imvedioappserver.SaveParticipantKeyIdReq")
	proto.RegisterType((*SaveParticipantKeyIdReply)(nil), "imvedioappserver.SaveParticipantKeyIdReply")
	proto.RegisterType((*GetParticipantKeyIdReq)(nil), "imvedioappserver.GetParticipantKeyIdReq")
	proto.RegisterType((*GetParticipantKeyIdReply)(nil), "imvedioappserver.GetParticipantKeyIdReply")
	proto.RegisterEnum("imvedioappserver.ErrorCode", ErrorCode_name, ErrorCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for VideoServer service

type VideoServerClient interface {
	// 创建房间
	CreateRoom(ctx context.Context, in *CreateRoomReq, opts ...grpc.CallOption) (*CreateRoomReply, error)
	// 获取进入房间的Token
	GetToken(ctx context.Context, in *GetTokenReq, opts ...grpc.CallOption) (*GetTokenReply, error)
	// 批量获取Token
	BatchGetToken(ctx context.Context, in *BatchGetTokenReq, opts ...grpc.CallOption) (*BatchGetTokenReply, error)
	// 校验Token
	VerifyToken(ctx context.Context, in *VerifyTokenReq, opts ...grpc.CallOption) (*VerifyTokenReply, error)
	// 通过room_id获取房间里的用户列表
	GetUsersByRoomId(ctx context.Context, in *GetUsersByRoomIdReq, opts ...grpc.CallOption) (*GetUsersByRoomIdReply, error)
	// 获取房间创建者信息
	GetRoomAdminUser(ctx context.Context, in *GetRoomAdminUserReq, opts ...grpc.CallOption) (*GetRoomAdminUserReply, error)
	// 保存参与者id
	SaveParticipantKeyId(ctx context.Context, in *SaveParticipantKeyIdReq, opts ...grpc.CallOption) (*SaveParticipantKeyIdReply, error)
	GetParticipantKeyId(ctx context.Context, in *GetParticipantKeyIdReq, opts ...grpc.CallOption) (*GetParticipantKeyIdReply, error)
	GetUserMeeting(ctx context.Context, in *UserIdReq, opts ...grpc.CallOption) (*BoolResult, error)
	LetUserOffLine(ctx context.Context, in *UsersIdReq, opts ...grpc.CallOption) (*BoolResult, error)
	KeepLive(ctx context.Context, in *IdReq, opts ...grpc.CallOption) (*BoolResult, error)
	ChangeModel(ctx context.Context, in *ChgModelReq, opts ...grpc.CallOption) (*BoolResult, error)
	GetModel(ctx context.Context, in *ModelReq, opts ...grpc.CallOption) (*ModelRsp, error)
}

type videoServerClient struct {
	cc *grpc.ClientConn
}

func NewVideoServerClient(cc *grpc.ClientConn) VideoServerClient {
	return &videoServerClient{cc}
}

func (c *videoServerClient) CreateRoom(ctx context.Context, in *CreateRoomReq, opts ...grpc.CallOption) (*CreateRoomReply, error) {
	out := new(CreateRoomReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/CreateRoom", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) GetToken(ctx context.Context, in *GetTokenReq, opts ...grpc.CallOption) (*GetTokenReply, error) {
	out := new(GetTokenReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/GetToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) BatchGetToken(ctx context.Context, in *BatchGetTokenReq, opts ...grpc.CallOption) (*BatchGetTokenReply, error) {
	out := new(BatchGetTokenReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/BatchGetToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) VerifyToken(ctx context.Context, in *VerifyTokenReq, opts ...grpc.CallOption) (*VerifyTokenReply, error) {
	out := new(VerifyTokenReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/VerifyToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) GetUsersByRoomId(ctx context.Context, in *GetUsersByRoomIdReq, opts ...grpc.CallOption) (*GetUsersByRoomIdReply, error) {
	out := new(GetUsersByRoomIdReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/GetUsersByRoomId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) GetRoomAdminUser(ctx context.Context, in *GetRoomAdminUserReq, opts ...grpc.CallOption) (*GetRoomAdminUserReply, error) {
	out := new(GetRoomAdminUserReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/GetRoomAdminUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) SaveParticipantKeyId(ctx context.Context, in *SaveParticipantKeyIdReq, opts ...grpc.CallOption) (*SaveParticipantKeyIdReply, error) {
	out := new(SaveParticipantKeyIdReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/SaveParticipantKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) GetParticipantKeyId(ctx context.Context, in *GetParticipantKeyIdReq, opts ...grpc.CallOption) (*GetParticipantKeyIdReply, error) {
	out := new(GetParticipantKeyIdReply)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/GetParticipantKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) GetUserMeeting(ctx context.Context, in *UserIdReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/GetUserMeeting", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) LetUserOffLine(ctx context.Context, in *UsersIdReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/LetUserOffLine", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) KeepLive(ctx context.Context, in *IdReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/KeepLive", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) ChangeModel(ctx context.Context, in *ChgModelReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/ChangeModel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *videoServerClient) GetModel(ctx context.Context, in *ModelReq, opts ...grpc.CallOption) (*ModelRsp, error) {
	out := new(ModelRsp)
	err := grpc.Invoke(ctx, "/imvedioappserver.VideoServer/GetModel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VideoServer service

type VideoServerServer interface {
	// 创建房间
	CreateRoom(context.Context, *CreateRoomReq) (*CreateRoomReply, error)
	// 获取进入房间的Token
	GetToken(context.Context, *GetTokenReq) (*GetTokenReply, error)
	// 批量获取Token
	BatchGetToken(context.Context, *BatchGetTokenReq) (*BatchGetTokenReply, error)
	// 校验Token
	VerifyToken(context.Context, *VerifyTokenReq) (*VerifyTokenReply, error)
	// 通过room_id获取房间里的用户列表
	GetUsersByRoomId(context.Context, *GetUsersByRoomIdReq) (*GetUsersByRoomIdReply, error)
	// 获取房间创建者信息
	GetRoomAdminUser(context.Context, *GetRoomAdminUserReq) (*GetRoomAdminUserReply, error)
	// 保存参与者id
	SaveParticipantKeyId(context.Context, *SaveParticipantKeyIdReq) (*SaveParticipantKeyIdReply, error)
	GetParticipantKeyId(context.Context, *GetParticipantKeyIdReq) (*GetParticipantKeyIdReply, error)
	GetUserMeeting(context.Context, *UserIdReq) (*BoolResult, error)
	LetUserOffLine(context.Context, *UsersIdReq) (*BoolResult, error)
	KeepLive(context.Context, *IdReq) (*BoolResult, error)
	ChangeModel(context.Context, *ChgModelReq) (*BoolResult, error)
	GetModel(context.Context, *ModelReq) (*ModelRsp, error)
}

func RegisterVideoServerServer(s *grpc.Server, srv VideoServerServer) {
	s.RegisterService(&_VideoServer_serviceDesc, srv)
}

func _VideoServer_CreateRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoomReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).CreateRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/CreateRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).CreateRoom(ctx, req.(*CreateRoomReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_GetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).GetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/GetToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).GetToken(ctx, req.(*GetTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_BatchGetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).BatchGetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/BatchGetToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).BatchGetToken(ctx, req.(*BatchGetTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_VerifyToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).VerifyToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/VerifyToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).VerifyToken(ctx, req.(*VerifyTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_GetUsersByRoomId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUsersByRoomIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).GetUsersByRoomId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/GetUsersByRoomId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).GetUsersByRoomId(ctx, req.(*GetUsersByRoomIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_GetRoomAdminUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoomAdminUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).GetRoomAdminUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/GetRoomAdminUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).GetRoomAdminUser(ctx, req.(*GetRoomAdminUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_SaveParticipantKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveParticipantKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).SaveParticipantKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/SaveParticipantKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).SaveParticipantKeyId(ctx, req.(*SaveParticipantKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_GetParticipantKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetParticipantKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).GetParticipantKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/GetParticipantKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).GetParticipantKeyId(ctx, req.(*GetParticipantKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_GetUserMeeting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).GetUserMeeting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/GetUserMeeting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).GetUserMeeting(ctx, req.(*UserIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_LetUserOffLine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).LetUserOffLine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/LetUserOffLine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).LetUserOffLine(ctx, req.(*UsersIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_KeepLive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).KeepLive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/KeepLive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).KeepLive(ctx, req.(*IdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_ChangeModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChgModelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).ChangeModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/ChangeModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).ChangeModel(ctx, req.(*ChgModelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _VideoServer_GetModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VideoServerServer).GetModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imvedioappserver.VideoServer/GetModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VideoServerServer).GetModel(ctx, req.(*ModelReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _VideoServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imvedioappserver.VideoServer",
	HandlerType: (*VideoServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRoom",
			Handler:    _VideoServer_CreateRoom_Handler,
		},
		{
			MethodName: "GetToken",
			Handler:    _VideoServer_GetToken_Handler,
		},
		{
			MethodName: "BatchGetToken",
			Handler:    _VideoServer_BatchGetToken_Handler,
		},
		{
			MethodName: "VerifyToken",
			Handler:    _VideoServer_VerifyToken_Handler,
		},
		{
			MethodName: "GetUsersByRoomId",
			Handler:    _VideoServer_GetUsersByRoomId_Handler,
		},
		{
			MethodName: "GetRoomAdminUser",
			Handler:    _VideoServer_GetRoomAdminUser_Handler,
		},
		{
			MethodName: "SaveParticipantKeyId",
			Handler:    _VideoServer_SaveParticipantKeyId_Handler,
		},
		{
			MethodName: "GetParticipantKeyId",
			Handler:    _VideoServer_GetParticipantKeyId_Handler,
		},
		{
			MethodName: "GetUserMeeting",
			Handler:    _VideoServer_GetUserMeeting_Handler,
		},
		{
			MethodName: "LetUserOffLine",
			Handler:    _VideoServer_LetUserOffLine_Handler,
		},
		{
			MethodName: "KeepLive",
			Handler:    _VideoServer_KeepLive_Handler,
		},
		{
			MethodName: "ChangeModel",
			Handler:    _VideoServer_ChangeModel_Handler,
		},
		{
			MethodName: "GetModel",
			Handler:    _VideoServer_GetModel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "imvedioappserver.proto",
}

func (m *ChgModelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChgModelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	if m.Video != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Video))
	}
	return i, nil
}

func (m *ModelRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	if m.Video != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Video))
	}
	if m.Code != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *ModelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *IdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *UserIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *UsersIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsersIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA2 := make([]byte, len(m.UserId)*10)
		var j1 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.RoomId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *BoolResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if m.Result {
		dAtA[i] = 0x10
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CreateRoomReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRoomReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AdminId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.AdminId))
	}
	if m.AdminKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.AdminKeyId))
	}
	if len(m.UserIds) > 0 {
		dAtA4 := make([]byte, len(m.UserIds)*10)
		var j3 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.Video != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Video))
	}
	return i, nil
}

func (m *CreateRoomReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRoomReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if len(m.RoomId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	if len(m.Tokens) > 0 {
		for k, _ := range m.Tokens {
			dAtA[i] = 0x1a
			i++
			v := m.Tokens[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovImvedioappserver(uint64(msgSize))
			}
			mapSize := 1 + sovImvedioappserver(uint64(k)) + msgSize
			i = encodeVarintImvedioappserver(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintImvedioappserver(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintImvedioappserver(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	return i, nil
}

func (m *RtcToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RtcToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.AppId)))
		i += copy(dAtA[i:], m.AppId)
	}
	if len(m.Gslb) > 0 {
		for _, s := range m.Gslb {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.RoomId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Timestamp))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *GetTokenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.RoomId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *GetTokenReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTokenReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if m.Token != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Token.Size()))
		n6, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *BatchGetTokenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetTokenReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA8 := make([]byte, len(m.UserIds)*10)
		var j7 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.RoomId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *BatchGetTokenReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchGetTokenReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if len(m.Tokens) > 0 {
		for k, _ := range m.Tokens {
			dAtA[i] = 0x12
			i++
			v := m.Tokens[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovImvedioappserver(uint64(msgSize))
			}
			mapSize := 1 + sovImvedioappserver(uint64(k)) + msgSize
			i = encodeVarintImvedioappserver(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintImvedioappserver(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintImvedioappserver(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func (m *VerifyTokenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTokenReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Token) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if len(m.Nonce) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *VerifyTokenReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTokenReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if m.IsValid {
		dAtA[i] = 0x10
		i++
		if m.IsValid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetUsersByRoomIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUsersByRoomIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *GetUsersByRoomIdReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUsersByRoomIdReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if m.AdminId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.AdminId))
	}
	if len(m.UserIds) > 0 {
		dAtA11 := make([]byte, len(m.UserIds)*10)
		var j10 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *GetRoomAdminUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoomAdminUserReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *GetRoomAdminUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRoomAdminUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SaveParticipantKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaveParticipantKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	if len(m.KeyIds) > 0 {
		for k, _ := range m.KeyIds {
			dAtA[i] = 0x12
			i++
			v := m.KeyIds[k]
			mapSize := 1 + sovImvedioappserver(uint64(k)) + 1 + sovImvedioappserver(uint64(v))
			i = encodeVarintImvedioappserver(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintImvedioappserver(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintImvedioappserver(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *SaveParticipantKeyIdReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaveParticipantKeyIdReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if m.Ok {
		dAtA[i] = 0x10
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetParticipantKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetParticipantKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(len(m.RoomId)))
		i += copy(dAtA[i:], m.RoomId)
	}
	return i, nil
}

func (m *GetParticipantKeyIdReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetParticipantKeyIdReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImvedioappserver(dAtA, i, uint64(m.Code))
	}
	if len(m.KeyIds) > 0 {
		for k, _ := range m.KeyIds {
			dAtA[i] = 0x12
			i++
			v := m.KeyIds[k]
			mapSize := 1 + sovImvedioappserver(uint64(k)) + 1 + sovImvedioappserver(uint64(v))
			i = encodeVarintImvedioappserver(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintImvedioappserver(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintImvedioappserver(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func encodeVarintImvedioappserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ChgModelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if m.Video != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Video))
	}
	return n
}

func (m *ModelRsp) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if m.Video != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Video))
	}
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *ModelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *IdReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *UserIdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.UserId))
	}
	return n
}

func (m *UsersIdReq) Size() (n int) {
	var l int
	_ = l
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovImvedioappserver(uint64(e))
		}
		n += 1 + sovImvedioappserver(uint64(l)) + l
	}
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *BoolResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if m.Result {
		n += 2
	}
	return n
}

func (m *CreateRoomReq) Size() (n int) {
	var l int
	_ = l
	if m.AdminId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.AdminId))
	}
	if m.AdminKeyId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.AdminKeyId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovImvedioappserver(uint64(e))
		}
		n += 1 + sovImvedioappserver(uint64(l)) + l
	}
	if m.Video != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Video))
	}
	return n
}

func (m *CreateRoomReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if len(m.Tokens) > 0 {
		for k, v := range m.Tokens {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovImvedioappserver(uint64(l))
			}
			mapEntrySize := 1 + sovImvedioappserver(uint64(k)) + l
			n += mapEntrySize + 1 + sovImvedioappserver(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RtcToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if len(m.Gslb) > 0 {
		for _, s := range m.Gslb {
			l = len(s)
			n += 1 + l + sovImvedioappserver(uint64(l))
		}
	}
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Timestamp))
	}
	if m.UserId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.UserId))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *GetTokenReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.UserId))
	}
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *GetTokenReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *BatchGetTokenReq) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovImvedioappserver(uint64(e))
		}
		n += 1 + sovImvedioappserver(uint64(l)) + l
	}
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *BatchGetTokenReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if len(m.Tokens) > 0 {
		for k, v := range m.Tokens {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovImvedioappserver(uint64(l))
			}
			mapEntrySize := 1 + sovImvedioappserver(uint64(k)) + l
			n += mapEntrySize + 1 + sovImvedioappserver(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VerifyTokenReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.UserId))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Timestamp))
	}
	return n
}

func (m *VerifyTokenReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if m.IsValid {
		n += 2
	}
	return n
}

func (m *GetUsersByRoomIdReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *GetUsersByRoomIdReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if m.AdminId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.AdminId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovImvedioappserver(uint64(e))
		}
		n += 1 + sovImvedioappserver(uint64(l)) + l
	}
	return n
}

func (m *GetRoomAdminUserReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *GetRoomAdminUserReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if m.UserId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImvedioappserver(uint64(m.KeyId))
	}
	return n
}

func (m *SaveParticipantKeyIdReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	if len(m.KeyIds) > 0 {
		for k, v := range m.KeyIds {
			_ = k
			_ = v
			mapEntrySize := 1 + sovImvedioappserver(uint64(k)) + 1 + sovImvedioappserver(uint64(v))
			n += mapEntrySize + 1 + sovImvedioappserver(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SaveParticipantKeyIdReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if m.Ok {
		n += 2
	}
	return n
}

func (m *GetParticipantKeyIdReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomId)
	if l > 0 {
		n += 1 + l + sovImvedioappserver(uint64(l))
	}
	return n
}

func (m *GetParticipantKeyIdReply) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImvedioappserver(uint64(m.Code))
	}
	if len(m.KeyIds) > 0 {
		for k, v := range m.KeyIds {
			_ = k
			_ = v
			mapEntrySize := 1 + sovImvedioappserver(uint64(k)) + 1 + sovImvedioappserver(uint64(v))
			n += mapEntrySize + 1 + sovImvedioappserver(uint64(mapEntrySize))
		}
	}
	return n
}

func sovImvedioappserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImvedioappserver(x uint64) (n int) {
	return sovImvedioappserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChgModelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChgModelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChgModelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			m.Video = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Video |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			m.Video = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Video |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImvedioappserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRoomReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRoomReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRoomReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			m.AdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminKeyId", wireType)
			}
			m.AdminKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImvedioappserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			m.Video = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Video |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRoomReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRoomReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRoomReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tokens == nil {
				m.Tokens = make(map[int32]*RtcToken)
			}
			var mapkey int32
			var mapvalue *RtcToken
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RtcToken{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipImvedioappserver(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tokens[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RtcToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RtcToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RtcToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gslb", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gslb = append(m.Gslb, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTokenReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTokenReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTokenReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &RtcToken{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetTokenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetTokenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetTokenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImvedioappserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchGetTokenReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchGetTokenReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchGetTokenReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tokens == nil {
				m.Tokens = make(map[int32]*RtcToken)
			}
			var mapkey int32
			var mapvalue *RtcToken
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &RtcToken{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipImvedioappserver(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Tokens[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTokenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTokenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTokenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTokenReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTokenReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTokenReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsValid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsValid = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUsersByRoomIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUsersByRoomIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUsersByRoomIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUsersByRoomIdReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUsersByRoomIdReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUsersByRoomIdReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			m.AdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImvedioappserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoomAdminUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRoomAdminUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRoomAdminUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRoomAdminUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetRoomAdminUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetRoomAdminUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaveParticipantKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaveParticipantKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaveParticipantKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyIds == nil {
				m.KeyIds = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipImvedioappserver(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KeyIds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaveParticipantKeyIdReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaveParticipantKeyIdReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaveParticipantKeyIdReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetParticipantKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetParticipantKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetParticipantKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetParticipantKeyIdReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetParticipantKeyIdReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetParticipantKeyIdReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyIds == nil {
				m.KeyIds = make(map[int32]int64)
			}
			var mapkey int32
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImvedioappserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipImvedioappserver(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthImvedioappserver
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.KeyIds[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImvedioappserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImvedioappserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImvedioappserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImvedioappserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImvedioappserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImvedioappserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImvedioappserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImvedioappserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImvedioappserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImvedioappserver   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("imvedioappserver.proto", fileDescriptorImvedioappserver) }

var fileDescriptorImvedioappserver = []byte{
	// 1072 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0x4b, 0x6f, 0xeb, 0x44,
	0x14, 0x8e, 0xed, 0xe6, 0x75, 0x72, 0x1b, 0xa2, 0xa1, 0x8f, 0xd4, 0x94, 0xde, 0x30, 0x5c, 0x44,
	0xb9, 0x88, 0x52, 0x8a, 0x40, 0x80, 0x10, 0x70, 0x1b, 0x42, 0x89, 0x6e, 0x9a, 0xa0, 0x49, 0x53,
	0x21, 0x81, 0x88, 0x7c, 0xe3, 0x69, 0xae, 0x95, 0xc7, 0xb8, 0xb6, 0x1b, 0x91, 0x05, 0xac, 0x59,
	0xf0, 0x67, 0xf8, 0x01, 0xec, 0x59, 0xb2, 0x63, 0x8b, 0xba, 0xe0, 0x3f, 0xb0, 0x43, 0x1e, 0x3b,
	0xc9, 0xc4, 0x8f, 0xd4, 0x8d, 0xd0, 0xdd, 0xcd, 0x8c, 0xcf, 0x9c, 0xf3, 0x9d, 0x33, 0xdf, 0xf9,
	0xc6, 0x03, 0x3b, 0xc6, 0x68, 0x42, 0x75, 0x83, 0x69, 0xa6, 0x69, 0x53, 0x6b, 0x42, 0xad, 0x23,
	0xd3, 0x62, 0x0e, 0x43, 0xa5, 0xe0, 0x3a, 0xfe, 0x14, 0x0a, 0xd5, 0xe7, 0xfd, 0x73, 0xa6, 0xd3,
	0x21, 0xa1, 0xd7, 0x68, 0x17, 0xb2, 0x16, 0x63, 0xa3, 0xae, 0xa1, 0x97, 0xa5, 0x8a, 0x74, 0x98,
	0x27, 0x19, 0x77, 0x5a, 0xd7, 0xd1, 0x16, 0xa4, 0x2f, 0x0d, 0x9d, 0xb2, 0xb2, 0x5c, 0x91, 0x0e,
	0xd3, 0xc4, 0x9b, 0xe0, 0x2e, 0xe4, 0xbc, 0xad, 0xb6, 0x79, 0xcf, 0xad, 0x08, 0xc1, 0x46, 0x8f,
	0xe9, 0xb4, 0xac, 0xf0, 0x45, 0x3e, 0x46, 0x25, 0x50, 0x46, 0x76, 0xbf, 0xbc, 0xc1, 0xb7, 0xbb,
	0x43, 0xfc, 0xfa, 0x2c, 0xc0, 0x0a, 0x6c, 0xb8, 0x02, 0xe9, 0xba, 0xbe, 0xd2, 0xe2, 0x11, 0xe4,
	0x3b, 0x36, 0xb5, 0xe6, 0x56, 0x37, 0x36, 0xb5, 0x66, 0x56, 0x69, 0x92, 0xb9, 0xe1, 0xdf, 0xf0,
	0x67, 0x00, 0xae, 0x95, 0x1d, 0x61, 0xa6, 0x2c, 0xcc, 0xc4, 0x28, 0xf2, 0x52, 0x94, 0x0e, 0xc0,
	0x29, 0x63, 0x43, 0x42, 0xed, 0x9b, 0xa1, 0x83, 0xde, 0xf5, 0x13, 0x74, 0x63, 0x14, 0x4f, 0x5e,
	0x39, 0x0a, 0x1d, 0x49, 0xcd, 0xb2, 0x98, 0x55, 0x65, 0x3a, 0xf5, 0xb3, 0xdf, 0x81, 0x8c, 0xc5,
	0xb7, 0x72, 0xb7, 0x39, 0xe2, 0xcf, 0xf0, 0x4f, 0xb0, 0x59, 0xb5, 0xa8, 0xe6, 0x50, 0xc2, 0xd8,
	0xc8, 0x45, 0xb6, 0x07, 0x39, 0x4d, 0x1f, 0x19, 0xe3, 0x45, 0x06, 0x59, 0x3e, 0xaf, 0xeb, 0xa8,
	0x02, 0x0f, 0xbc, 0x4f, 0x03, 0x3a, 0x9d, 0x01, 0x54, 0x08, 0xf0, 0xb5, 0xa7, 0x74, 0x5a, 0xd7,
	0xdd, 0xcd, 0x7e, 0x5a, 0x76, 0x59, 0xe1, 0x79, 0x65, 0xbd, 0xbc, 0xec, 0xc5, 0x41, 0x6d, 0x88,
	0x67, 0xfc, 0xaf, 0x04, 0x2f, 0x89, 0xf1, 0xcd, 0xe1, 0xf4, 0xfe, 0xb9, 0xc5, 0xd5, 0x0c, 0xd5,
	0x20, 0xe3, 0xb0, 0x01, 0x1d, 0x7b, 0x60, 0x0a, 0x27, 0xef, 0x84, 0x7d, 0x05, 0x82, 0x1f, 0x5d,
	0x70, 0xfb, 0xda, 0xd8, 0xb1, 0xa6, 0xc4, 0xdf, 0xac, 0x76, 0xa0, 0x20, 0x2c, 0xbb, 0x44, 0x1a,
	0xd0, 0xa9, 0x5f, 0x1c, 0x77, 0x88, 0x8e, 0x21, 0x3d, 0xd1, 0x86, 0x37, 0x94, 0x87, 0x2f, 0x9c,
	0xa8, 0xe1, 0x30, 0xc4, 0xe9, 0x71, 0x17, 0xc4, 0x33, 0xfc, 0x44, 0xfe, 0x48, 0xc2, 0xbf, 0x49,
	0x90, 0x9b, 0xad, 0xa3, 0x6d, 0xc8, 0x68, 0xa6, 0xb9, 0x20, 0x57, 0x5a, 0x33, 0xcd, 0xba, 0xee,
	0x12, 0xb9, 0x6f, 0x0f, 0x9f, 0x95, 0xe5, 0x8a, 0x72, 0x98, 0x27, 0x7c, 0x2c, 0xa6, 0xab, 0x04,
	0x7b, 0x61, 0xcc, 0xc6, 0x3d, 0xea, 0x73, 0xdc, 0x9b, 0xa0, 0x7d, 0xc8, 0x3b, 0xc6, 0x88, 0xda,
	0x8e, 0x36, 0x32, 0xcb, 0x69, 0x7e, 0x64, 0x8b, 0x05, 0x91, 0x88, 0x19, 0x91, 0xaf, 0xae, 0x33,
	0x9e, 0x7e, 0x39, 0xeb, 0x39, 0xe3, 0x13, 0xfc, 0x39, 0x14, 0xce, 0xa8, 0xe3, 0xa5, 0xb2, 0x82,
	0xed, 0xf1, 0x34, 0xb6, 0x60, 0x73, 0xe1, 0x60, 0xad, 0xd3, 0x3e, 0x9e, 0x01, 0x4b, 0x50, 0x6c,
	0x0f, 0xf4, 0x57, 0x50, 0x3a, 0xd5, 0x9c, 0xde, 0x73, 0x11, 0xb9, 0xc8, 0x54, 0x69, 0x99, 0xa9,
	0xb1, 0xd8, 0xff, 0x91, 0x00, 0x05, 0x1c, 0xad, 0x95, 0xc1, 0xd7, 0x73, 0x5a, 0xca, 0x9c, 0x96,
	0xc7, 0xe1, 0x2d, 0xe1, 0x30, 0x2f, 0x92, 0x99, 0xbf, 0x4a, 0x50, 0xbc, 0xa4, 0x96, 0x71, 0x35,
	0x15, 0x4f, 0x3a, 0x5a, 0x80, 0x05, 0x0a, 0xc8, 0xd1, 0x04, 0x52, 0x04, 0x02, 0xad, 0xc3, 0x51,
	0xfc, 0x03, 0x94, 0x96, 0xd0, 0xac, 0x55, 0xf4, 0x3d, 0xc8, 0x19, 0x76, 0x77, 0xa2, 0x0d, 0x7d,
	0xa0, 0x39, 0x92, 0x35, 0xec, 0x4b, 0x77, 0x8a, 0x8f, 0xe0, 0xe5, 0x33, 0xea, 0x70, 0x75, 0x3e,
	0x9d, 0x12, 0x9e, 0xd6, 0x4a, 0xc1, 0xff, 0x19, 0xb6, 0xc3, 0xf6, 0xeb, 0x82, 0x9a, 0x8b, 0xad,
	0xbc, 0x2c, 0xb6, 0xf1, 0x52, 0xea, 0xe3, 0x75, 0x03, 0x3f, 0x71, 0x8d, 0x5d, 0x20, 0x2b, 0xf1,
	0xfe, 0xc8, 0xf1, 0x06, 0xec, 0xd7, 0x55, 0xda, 0xe8, 0xc3, 0xde, 0x86, 0x8c, 0x7f, 0x29, 0x28,
	0xfc, 0xf4, 0xd2, 0x03, 0xf7, 0x3e, 0xc0, 0xbf, 0x4b, 0xb0, 0xdb, 0xd6, 0x26, 0xf4, 0x1b, 0xcd,
	0x72, 0x8c, 0x9e, 0x61, 0x6a, 0x63, 0x87, 0x5f, 0x14, 0x2b, 0x19, 0xd5, 0x84, 0xac, 0xe7, 0x6b,
	0xd6, 0x1f, 0x1f, 0x84, 0x81, 0xc5, 0x38, 0x3d, 0xe2, 0x83, 0x59, 0x93, 0x70, 0x0c, 0xb6, 0xfa,
	0x31, 0x14, 0x84, 0xe5, 0x88, 0x26, 0xd9, 0x12, 0x9b, 0x44, 0x11, 0x1b, 0xe1, 0x7b, 0xd8, 0x8b,
	0x8e, 0xb4, 0x56, 0xf5, 0x8a, 0x20, 0xb3, 0x81, 0x4f, 0x3e, 0x99, 0x0d, 0xf0, 0x7b, 0xb0, 0x73,
	0x46, 0x9d, 0xfb, 0xd4, 0x06, 0xff, 0x25, 0x41, 0x39, 0x72, 0xcf, 0x5a, 0x80, 0x5a, 0xc1, 0x4a,
	0x7f, 0x18, 0xde, 0x13, 0x17, 0xed, 0x7f, 0x2e, 0xf5, 0xe3, 0x2f, 0x20, 0x3f, 0x87, 0x87, 0x0a,
	0x90, 0x6d, 0x77, 0xaa, 0xd5, 0x5a, 0xbb, 0x5d, 0x4a, 0x21, 0x04, 0xc5, 0x7a, 0xf3, 0xa2, 0x46,
	0x9a, 0x4f, 0x1a, 0xdd, 0x1a, 0x21, 0x2d, 0x52, 0x92, 0xdc, 0x35, 0xd2, 0x6a, 0x9d, 0x77, 0x9b,
	0xad, 0x8b, 0x6e, 0xed, 0xdb, 0x7a, 0xfb, 0xa2, 0x24, 0x9f, 0xfc, 0x92, 0x87, 0x02, 0xff, 0xab,
	0x68, 0x73, 0xe4, 0x88, 0x00, 0x2c, 0x6e, 0x77, 0xf4, 0x70, 0xf5, 0xdd, 0x7f, 0xad, 0xbe, 0x76,
	0xe7, 0xcf, 0x01, 0x4e, 0xa1, 0x06, 0xe4, 0x66, 0xaa, 0x8c, 0x5e, 0x8d, 0x2c, 0xd6, 0x4c, 0x31,
	0xd5, 0x87, 0xab, 0x3e, 0x7b, 0xde, 0xbe, 0x83, 0xcd, 0x25, 0xa1, 0x47, 0xf8, 0xce, 0x9b, 0xe0,
	0x5a, 0x7d, 0x94, 0xe4, 0xb6, 0xc0, 0x29, 0xd4, 0x81, 0x82, 0xa0, 0x9a, 0xa8, 0x12, 0xde, 0xb6,
	0x2c, 0xf1, 0x2a, 0xbe, 0xc3, 0xc2, 0x73, 0xab, 0x43, 0x29, 0x28, 0x7e, 0xe8, 0x8d, 0xc8, 0x54,
	0x83, 0x82, 0xaa, 0xbe, 0x99, 0xc4, 0x4c, 0x8c, 0xb2, 0x24, 0x59, 0x31, 0x51, 0x82, 0x32, 0x18,
	0x13, 0x25, 0xac, 0x7e, 0x38, 0x85, 0x4c, 0xd8, 0x8a, 0x6a, 0x6f, 0xf4, 0x56, 0x62, 0xc1, 0x51,
	0xdf, 0x4e, 0x6a, 0xea, 0x45, 0x1c, 0x71, 0xe9, 0x0e, 0x05, 0x3c, 0x4c, 0xd8, 0x77, 0xd7, 0xea,
	0xe3, 0xe4, 0x1d, 0x8a, 0x53, 0xe8, 0x1c, 0x8a, 0x7e, 0x85, 0xcf, 0x29, 0x75, 0x8c, 0x71, 0x1f,
	0x45, 0xa8, 0xc2, 0xfc, 0xf1, 0xa2, 0xee, 0x47, 0x50, 0x6b, 0xfe, 0xe6, 0xc0, 0x29, 0xd4, 0x84,
	0x62, 0xc3, 0x73, 0xd7, 0xba, 0xba, 0x6a, 0x18, 0x63, 0x8a, 0xf6, 0xa3, 0xdd, 0xd9, 0xc9, 0xfc,
	0x55, 0x21, 0xf7, 0x94, 0x52, 0xb3, 0x61, 0x4c, 0x28, 0xda, 0x0d, 0xdb, 0x26, 0x73, 0xd2, 0x70,
	0x1f, 0x99, 0xda, 0xb8, 0x4f, 0xf9, 0x5b, 0x2e, 0xaa, 0x2b, 0x85, 0x37, 0xe8, 0x9d, 0xde, 0xbe,
	0xe4, 0x0d, 0xee, 0xb9, 0x8a, 0xf8, 0x5b, 0x9a, 0xfb, 0x89, 0xfd, 0x66, 0x9b, 0x38, 0x75, 0xfa,
	0xe0, 0x8f, 0xdb, 0x03, 0xe9, 0xcf, 0xdb, 0x03, 0xe9, 0xef, 0xdb, 0x03, 0xe9, 0x59, 0x86, 0xbf,
	0x8f, 0xdf, 0xff, 0x2f, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x56, 0x6e, 0x0d, 0x39, 0x0f, 0x00, 0x00,
}
