// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: imsession.proto

/*
Package imsession is a generated protocol buffer package.

It is generated from these files:

	imsession.proto

It has these top-level messages:

	ClearKeyIdSessionReq
	ClearKeyIdSessionResp
	SetLangCodeReq
	SetLangCodeResult
	GetLangCodeReq
	GetLangCodeResult
	GetUniqueNumberByKeyIdReq
	GetUniqueNumberByKeyIdResult
	SessionDisconnectReq
	SessionDisconnectResult
	SessionInitConnectionReq
	SessionInitConnectionResult
	SessionUpdateRegisterDeviceReq
	SessionUpdateRegisterDeviceResult
	SessionUpdateRegisterHuaweiDeviceReq
	SessionUpdateRegisterHuaweiDeviceResult
	SessionUpdateUserPhoneReq
	SessionUpdateUserPhoneResult
	SessionQueryApiIDbyKeyIdReq
	SessionQueryApiIDbyKeyIdResult
	SessionQueryUserIdByKeyIdReq
	SessionQueryUserIdByKeyIdResult
	SessionUpdateOnHandshakeDoneReq
	SessionUpdateOnHandshakeDoneResult
	SessionIncQtsReq
	SessionIncQtsResult
	SessionTerminateByKeyIdReq
	SessionTerminateByKeyIdResult
	SessionTerminateExceptKeyIdReq
	SessionTerminateExceptKeyIdResult
	SessionUpdateLogoutReq
	SessionUpdateLogoutResult
	CheckBanDeviceReq
	CheckBanDeviceResult
	AddBanDeviceReq
	AddBanDeviceResult
	SessionDeleteByKeyIdReq
	SessionDeleteByKeyIdResult
	SessionQueryByKeyIdReq
	SessionQueryByKeyIdResult
	SessionInformation
	SessionUpdateSignInReq
	SessionUpdateSignInResult
	SessionQueryByUserIdReq
	SessionQueryByUserIdResult
	SessionQueryBasicInfoByKeyIdReq
	SessionQueryBasicInfoByKeyIdResult
	SessionQueryDesByKeyIdReq
	SessionQueryDesByKeyIdResult
	SessionDeleteAuthKeysByUserIdReq
	SessionDeleteAuthKeysByUserIdResult
	SessionUpdatePingReq
	SessionUpdatePingReq2
	SessionUpdatePingResult
	GetCreatedByKeyIdReq
	GetCreatedByKeyIdResult
	UpdateSelfAppHashReq
	UpdateSelfAppHashResult
*/
package imsession

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SetLangCodeResult_ResultCode int32

const (
	SetLangCodeResult_Success       SetLangCodeResult_ResultCode = 0
	SetLangCodeResult_InternalError SetLangCodeResult_ResultCode = 1
)

var SetLangCodeResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SetLangCodeResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SetLangCodeResult_ResultCode) String() string {
	return proto.EnumName(SetLangCodeResult_ResultCode_name, int32(x))
}
func (SetLangCodeResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{3, 0}
}

type GetLangCodeResult_ResultCode int32

const (
	GetLangCodeResult_Success       GetLangCodeResult_ResultCode = 0
	GetLangCodeResult_InternalError GetLangCodeResult_ResultCode = 1
)

var GetLangCodeResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var GetLangCodeResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x GetLangCodeResult_ResultCode) String() string {
	return proto.EnumName(GetLangCodeResult_ResultCode_name, int32(x))
}
func (GetLangCodeResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{5, 0}
}

type SessionInitConnectionResult_ResultCode int32

const (
	SessionInitConnectionResult_Success       SessionInitConnectionResult_ResultCode = 0
	SessionInitConnectionResult_InternalError SessionInitConnectionResult_ResultCode = 1
)

var SessionInitConnectionResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionInitConnectionResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionInitConnectionResult_ResultCode) String() string {
	return proto.EnumName(SessionInitConnectionResult_ResultCode_name, int32(x))
}
func (SessionInitConnectionResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{11, 0}
}

type SessionUpdateRegisterDeviceResult_ResultCode int32

const (
	SessionUpdateRegisterDeviceResult_Success       SessionUpdateRegisterDeviceResult_ResultCode = 0
	SessionUpdateRegisterDeviceResult_InternalError SessionUpdateRegisterDeviceResult_ResultCode = 1
)

var SessionUpdateRegisterDeviceResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateRegisterDeviceResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateRegisterDeviceResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateRegisterDeviceResult_ResultCode_name, int32(x))
}
func (SessionUpdateRegisterDeviceResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{13, 0}
}

type SessionUpdateRegisterHuaweiDeviceResult_ResultCode int32

const (
	SessionUpdateRegisterHuaweiDeviceResult_Success       SessionUpdateRegisterHuaweiDeviceResult_ResultCode = 0
	SessionUpdateRegisterHuaweiDeviceResult_InternalError SessionUpdateRegisterHuaweiDeviceResult_ResultCode = 1
)

var SessionUpdateRegisterHuaweiDeviceResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateRegisterHuaweiDeviceResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateRegisterHuaweiDeviceResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateRegisterHuaweiDeviceResult_ResultCode_name, int32(x))
}
func (SessionUpdateRegisterHuaweiDeviceResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{15, 0}
}

type SessionUpdateUserPhoneResult_ResultCode int32

const (
	SessionUpdateUserPhoneResult_Success       SessionUpdateUserPhoneResult_ResultCode = 0
	SessionUpdateUserPhoneResult_InternalError SessionUpdateUserPhoneResult_ResultCode = 1
)

var SessionUpdateUserPhoneResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateUserPhoneResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateUserPhoneResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateUserPhoneResult_ResultCode_name, int32(x))
}
func (SessionUpdateUserPhoneResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{17, 0}
}

type SessionUpdateOnHandshakeDoneResult_FailCode int32

const (
	SessionUpdateOnHandshakeDoneResult_Internal       SessionUpdateOnHandshakeDoneResult_FailCode = 0
	SessionUpdateOnHandshakeDoneResult_DuplicateKeyid SessionUpdateOnHandshakeDoneResult_FailCode = 1
)

var SessionUpdateOnHandshakeDoneResult_FailCode_name = map[int32]string{
	0: "Internal",
	1: "DuplicateKeyid",
}
var SessionUpdateOnHandshakeDoneResult_FailCode_value = map[string]int32{
	"Internal":       0,
	"DuplicateKeyid": 1,
}

func (x SessionUpdateOnHandshakeDoneResult_FailCode) String() string {
	return proto.EnumName(SessionUpdateOnHandshakeDoneResult_FailCode_name, int32(x))
}
func (SessionUpdateOnHandshakeDoneResult_FailCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{23, 0}
}

type SessionIncQtsResult_ResultCode int32

const (
	SessionIncQtsResult_Success       SessionIncQtsResult_ResultCode = 0
	SessionIncQtsResult_InternalError SessionIncQtsResult_ResultCode = 1
)

var SessionIncQtsResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionIncQtsResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionIncQtsResult_ResultCode) String() string {
	return proto.EnumName(SessionIncQtsResult_ResultCode_name, int32(x))
}
func (SessionIncQtsResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{25, 0}
}

type SessionTerminateByKeyIdResult_ResultCode int32

const (
	SessionTerminateByKeyIdResult_Success       SessionTerminateByKeyIdResult_ResultCode = 0
	SessionTerminateByKeyIdResult_InternalError SessionTerminateByKeyIdResult_ResultCode = 1
)

var SessionTerminateByKeyIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionTerminateByKeyIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionTerminateByKeyIdResult_ResultCode) String() string {
	return proto.EnumName(SessionTerminateByKeyIdResult_ResultCode_name, int32(x))
}
func (SessionTerminateByKeyIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{27, 0}
}

type SessionTerminateExceptKeyIdResult_ResultCode int32

const (
	SessionTerminateExceptKeyIdResult_Success       SessionTerminateExceptKeyIdResult_ResultCode = 0
	SessionTerminateExceptKeyIdResult_InternalError SessionTerminateExceptKeyIdResult_ResultCode = 1
)

var SessionTerminateExceptKeyIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionTerminateExceptKeyIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionTerminateExceptKeyIdResult_ResultCode) String() string {
	return proto.EnumName(SessionTerminateExceptKeyIdResult_ResultCode_name, int32(x))
}
func (SessionTerminateExceptKeyIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{29, 0}
}

type SessionUpdateLogoutResult_ResultCode int32

const (
	SessionUpdateLogoutResult_Success       SessionUpdateLogoutResult_ResultCode = 0
	SessionUpdateLogoutResult_InternalError SessionUpdateLogoutResult_ResultCode = 1
)

var SessionUpdateLogoutResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateLogoutResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateLogoutResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateLogoutResult_ResultCode_name, int32(x))
}
func (SessionUpdateLogoutResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{31, 0}
}

type AddBanDeviceResult_ResultCode int32

const (
	AddBanDeviceResult_Success       AddBanDeviceResult_ResultCode = 0
	AddBanDeviceResult_InternalError AddBanDeviceResult_ResultCode = 1
)

var AddBanDeviceResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var AddBanDeviceResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x AddBanDeviceResult_ResultCode) String() string {
	return proto.EnumName(AddBanDeviceResult_ResultCode_name, int32(x))
}
func (AddBanDeviceResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{35, 0}
}

type SessionDeleteByKeyIdResult_ResultCode int32

const (
	SessionDeleteByKeyIdResult_Success       SessionDeleteByKeyIdResult_ResultCode = 0
	SessionDeleteByKeyIdResult_InternalError SessionDeleteByKeyIdResult_ResultCode = 1
)

var SessionDeleteByKeyIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionDeleteByKeyIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionDeleteByKeyIdResult_ResultCode) String() string {
	return proto.EnumName(SessionDeleteByKeyIdResult_ResultCode_name, int32(x))
}
func (SessionDeleteByKeyIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{37, 0}
}

type SessionQueryByKeyIdResult_ResultCode int32

const (
	SessionQueryByKeyIdResult_Success       SessionQueryByKeyIdResult_ResultCode = 0
	SessionQueryByKeyIdResult_InternalError SessionQueryByKeyIdResult_ResultCode = 1
)

var SessionQueryByKeyIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionQueryByKeyIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionQueryByKeyIdResult_ResultCode) String() string {
	return proto.EnumName(SessionQueryByKeyIdResult_ResultCode_name, int32(x))
}
func (SessionQueryByKeyIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{39, 0}
}

type SessionUpdateSignInResult_ResultCode int32

const (
	SessionUpdateSignInResult_Success       SessionUpdateSignInResult_ResultCode = 0
	SessionUpdateSignInResult_InternalError SessionUpdateSignInResult_ResultCode = 1
)

var SessionUpdateSignInResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateSignInResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateSignInResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateSignInResult_ResultCode_name, int32(x))
}
func (SessionUpdateSignInResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{42, 0}
}

type SessionQueryByUserIdResult_ResultCode int32

const (
	SessionQueryByUserIdResult_Success       SessionQueryByUserIdResult_ResultCode = 0
	SessionQueryByUserIdResult_InternalError SessionQueryByUserIdResult_ResultCode = 1
)

var SessionQueryByUserIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionQueryByUserIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionQueryByUserIdResult_ResultCode) String() string {
	return proto.EnumName(SessionQueryByUserIdResult_ResultCode_name, int32(x))
}
func (SessionQueryByUserIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{44, 0}
}

type SessionQueryBasicInfoByKeyIdResult_ResultCode int32

const (
	SessionQueryBasicInfoByKeyIdResult_Success       SessionQueryBasicInfoByKeyIdResult_ResultCode = 0
	SessionQueryBasicInfoByKeyIdResult_InternalError SessionQueryBasicInfoByKeyIdResult_ResultCode = 1
)

var SessionQueryBasicInfoByKeyIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionQueryBasicInfoByKeyIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionQueryBasicInfoByKeyIdResult_ResultCode) String() string {
	return proto.EnumName(SessionQueryBasicInfoByKeyIdResult_ResultCode_name, int32(x))
}
func (SessionQueryBasicInfoByKeyIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{46, 0}
}

type SessionQueryDesByKeyIdResult_ResultCode int32

const (
	SessionQueryDesByKeyIdResult_Success       SessionQueryDesByKeyIdResult_ResultCode = 0
	SessionQueryDesByKeyIdResult_InternalError SessionQueryDesByKeyIdResult_ResultCode = 1
)

var SessionQueryDesByKeyIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionQueryDesByKeyIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionQueryDesByKeyIdResult_ResultCode) String() string {
	return proto.EnumName(SessionQueryDesByKeyIdResult_ResultCode_name, int32(x))
}
func (SessionQueryDesByKeyIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{48, 0}
}

type SessionDeleteAuthKeysByUserIdResult_ResultCode int32

const (
	SessionDeleteAuthKeysByUserIdResult_Success       SessionDeleteAuthKeysByUserIdResult_ResultCode = 0
	SessionDeleteAuthKeysByUserIdResult_InternalError SessionDeleteAuthKeysByUserIdResult_ResultCode = 1
)

var SessionDeleteAuthKeysByUserIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionDeleteAuthKeysByUserIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionDeleteAuthKeysByUserIdResult_ResultCode) String() string {
	return proto.EnumName(SessionDeleteAuthKeysByUserIdResult_ResultCode_name, int32(x))
}
func (SessionDeleteAuthKeysByUserIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{50, 0}
}

type SessionUpdatePingResult_ResultCode int32

const (
	SessionUpdatePingResult_Success             SessionUpdatePingResult_ResultCode = 0
	SessionUpdatePingResult_InternalError       SessionUpdatePingResult_ResultCode = 1
	SessionUpdatePingResult_AuthkeyUnregistered SessionUpdatePingResult_ResultCode = 2
)

var SessionUpdatePingResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
	2: "AuthkeyUnregistered",
}
var SessionUpdatePingResult_ResultCode_value = map[string]int32{
	"Success":             0,
	"InternalError":       1,
	"AuthkeyUnregistered": 2,
}

func (x SessionUpdatePingResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdatePingResult_ResultCode_name, int32(x))
}
func (SessionUpdatePingResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{53, 0}
}

type GetCreatedByKeyIdResult_ResultCode int32

const (
	GetCreatedByKeyIdResult_Success       GetCreatedByKeyIdResult_ResultCode = 0
	GetCreatedByKeyIdResult_InternalError GetCreatedByKeyIdResult_ResultCode = 1
)

var GetCreatedByKeyIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var GetCreatedByKeyIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x GetCreatedByKeyIdResult_ResultCode) String() string {
	return proto.EnumName(GetCreatedByKeyIdResult_ResultCode_name, int32(x))
}
func (GetCreatedByKeyIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{55, 0}
}

type UpdateSelfAppHashResult_ResultCode int32

const (
	UpdateSelfAppHashResult_Success       UpdateSelfAppHashResult_ResultCode = 0
	UpdateSelfAppHashResult_InternalError UpdateSelfAppHashResult_ResultCode = 1
)

var UpdateSelfAppHashResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var UpdateSelfAppHashResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x UpdateSelfAppHashResult_ResultCode) String() string {
	return proto.EnumName(UpdateSelfAppHashResult_ResultCode_name, int32(x))
}
func (UpdateSelfAppHashResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{57, 0}
}

type ClearKeyIdSessionReq struct {
	Uid   int32  `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	KeyId uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *ClearKeyIdSessionReq) Reset()                    { *m = ClearKeyIdSessionReq{} }
func (m *ClearKeyIdSessionReq) String() string            { return proto.CompactTextString(m) }
func (*ClearKeyIdSessionReq) ProtoMessage()               {}
func (*ClearKeyIdSessionReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{0} }

func (m *ClearKeyIdSessionReq) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ClearKeyIdSessionReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type ClearKeyIdSessionResp struct {
	Sucess bool `protobuf:"varint,1,opt,name=sucess,proto3" json:"sucess,omitempty"`
}

func (m *ClearKeyIdSessionResp) Reset()                    { *m = ClearKeyIdSessionResp{} }
func (m *ClearKeyIdSessionResp) String() string            { return proto.CompactTextString(m) }
func (*ClearKeyIdSessionResp) ProtoMessage()               {}
func (*ClearKeyIdSessionResp) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{1} }

func (m *ClearKeyIdSessionResp) GetSucess() bool {
	if m != nil {
		return m.Sucess
	}
	return false
}

type SetLangCodeReq struct {
	KeyId    int64  `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	LangCode string `protobuf:"bytes,2,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
}

func (m *SetLangCodeReq) Reset()                    { *m = SetLangCodeReq{} }
func (m *SetLangCodeReq) String() string            { return proto.CompactTextString(m) }
func (*SetLangCodeReq) ProtoMessage()               {}
func (*SetLangCodeReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{2} }

func (m *SetLangCodeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SetLangCodeReq) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

type SetLangCodeResult struct {
	Code SetLangCodeResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SetLangCodeResult_ResultCode" json:"code,omitempty"`
}

func (m *SetLangCodeResult) Reset()                    { *m = SetLangCodeResult{} }
func (m *SetLangCodeResult) String() string            { return proto.CompactTextString(m) }
func (*SetLangCodeResult) ProtoMessage()               {}
func (*SetLangCodeResult) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{3} }

func (m *SetLangCodeResult) GetCode() SetLangCodeResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SetLangCodeResult_Success
}

type GetLangCodeReq struct {
	KeyId int64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *GetLangCodeReq) Reset()                    { *m = GetLangCodeReq{} }
func (m *GetLangCodeReq) String() string            { return proto.CompactTextString(m) }
func (*GetLangCodeReq) ProtoMessage()               {}
func (*GetLangCodeReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{4} }

func (m *GetLangCodeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type GetLangCodeResult struct {
	Code     GetLangCodeResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.GetLangCodeResult_ResultCode" json:"code,omitempty"`
	LangCode string                       `protobuf:"bytes,2,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
}

func (m *GetLangCodeResult) Reset()                    { *m = GetLangCodeResult{} }
func (m *GetLangCodeResult) String() string            { return proto.CompactTextString(m) }
func (*GetLangCodeResult) ProtoMessage()               {}
func (*GetLangCodeResult) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{5} }

func (m *GetLangCodeResult) GetCode() GetLangCodeResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return GetLangCodeResult_Success
}

func (m *GetLangCodeResult) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

type GetUniqueNumberByKeyIdReq struct {
	KeyId int64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *GetUniqueNumberByKeyIdReq) Reset()         { *m = GetUniqueNumberByKeyIdReq{} }
func (m *GetUniqueNumberByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*GetUniqueNumberByKeyIdReq) ProtoMessage()    {}
func (*GetUniqueNumberByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{6}
}

func (m *GetUniqueNumberByKeyIdReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type GetUniqueNumberByKeyIdResult struct {
	UniqueNumber string `protobuf:"bytes,1,opt,name=unique_number,json=uniqueNumber,proto3" json:"unique_number,omitempty"`
}

func (m *GetUniqueNumberByKeyIdResult) Reset()         { *m = GetUniqueNumberByKeyIdResult{} }
func (m *GetUniqueNumberByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*GetUniqueNumberByKeyIdResult) ProtoMessage()    {}
func (*GetUniqueNumberByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{7}
}

func (m *GetUniqueNumberByKeyIdResult) GetUniqueNumber() string {
	if m != nil {
		return m.UniqueNumber
	}
	return ""
}

type SessionDisconnectReq struct {
	KeyId       uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	PhoneNumber string `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Disconnect  bool   `protobuf:"varint,3,opt,name=disconnect,proto3" json:"disconnect,omitempty"`
	ClientIp    string `protobuf:"bytes,4,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	Country     string `protobuf:"bytes,5,opt,name=country,proto3" json:"country,omitempty"`
}

func (m *SessionDisconnectReq) Reset()                    { *m = SessionDisconnectReq{} }
func (m *SessionDisconnectReq) String() string            { return proto.CompactTextString(m) }
func (*SessionDisconnectReq) ProtoMessage()               {}
func (*SessionDisconnectReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{8} }

func (m *SessionDisconnectReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionDisconnectReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionDisconnectReq) GetDisconnect() bool {
	if m != nil {
		return m.Disconnect
	}
	return false
}

func (m *SessionDisconnectReq) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *SessionDisconnectReq) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

type SessionDisconnectResult struct {
}

func (m *SessionDisconnectResult) Reset()         { *m = SessionDisconnectResult{} }
func (m *SessionDisconnectResult) String() string { return proto.CompactTextString(m) }
func (*SessionDisconnectResult) ProtoMessage()    {}
func (*SessionDisconnectResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{9}
}

type SessionInitConnectionReq struct {
	ApiId         int32  `protobuf:"varint,1,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel   string `protobuf:"bytes,2,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion string `protobuf:"bytes,3,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion    string `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	LangCode      string `protobuf:"bytes,5,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Ip            string `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	Country       string `protobuf:"bytes,7,opt,name=country,proto3" json:"country,omitempty"`
	Layer         int32  `protobuf:"varint,8,opt,name=layer,proto3" json:"layer,omitempty"`
	KeyId         uint64 `protobuf:"varint,9,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	AppName       string `protobuf:"bytes,10,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
}

func (m *SessionInitConnectionReq) Reset()         { *m = SessionInitConnectionReq{} }
func (m *SessionInitConnectionReq) String() string { return proto.CompactTextString(m) }
func (*SessionInitConnectionReq) ProtoMessage()    {}
func (*SessionInitConnectionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{10}
}

func (m *SessionInitConnectionReq) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *SessionInitConnectionReq) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *SessionInitConnectionReq) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *SessionInitConnectionReq) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *SessionInitConnectionReq) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *SessionInitConnectionReq) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *SessionInitConnectionReq) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *SessionInitConnectionReq) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *SessionInitConnectionReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionInitConnectionReq) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

type SessionInitConnectionResult struct {
	Code SessionInitConnectionResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionInitConnectionResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionInitConnectionResult) Reset()         { *m = SessionInitConnectionResult{} }
func (m *SessionInitConnectionResult) String() string { return proto.CompactTextString(m) }
func (*SessionInitConnectionResult) ProtoMessage()    {}
func (*SessionInitConnectionResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{11}
}

func (m *SessionInitConnectionResult) GetCode() SessionInitConnectionResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionInitConnectionResult_Success
}

type SessionUpdateRegisterDeviceReq struct {
	PushTokenType int32  `protobuf:"varint,1,opt,name=push_token_type,json=pushTokenType,proto3" json:"push_token_type,omitempty"`
	PushToken     string `protobuf:"bytes,2,opt,name=push_token,json=pushToken,proto3" json:"push_token,omitempty"`
	KeyId         uint64 `protobuf:"varint,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	CallTokenType int32  `protobuf:"varint,4,opt,name=call_token_type,json=callTokenType,proto3" json:"call_token_type,omitempty"`
	CallToken     string `protobuf:"bytes,5,opt,name=call_token,json=callToken,proto3" json:"call_token,omitempty"`
}

func (m *SessionUpdateRegisterDeviceReq) Reset()         { *m = SessionUpdateRegisterDeviceReq{} }
func (m *SessionUpdateRegisterDeviceReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateRegisterDeviceReq) ProtoMessage()    {}
func (*SessionUpdateRegisterDeviceReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{12}
}

func (m *SessionUpdateRegisterDeviceReq) GetPushTokenType() int32 {
	if m != nil {
		return m.PushTokenType
	}
	return 0
}

func (m *SessionUpdateRegisterDeviceReq) GetPushToken() string {
	if m != nil {
		return m.PushToken
	}
	return ""
}

func (m *SessionUpdateRegisterDeviceReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateRegisterDeviceReq) GetCallTokenType() int32 {
	if m != nil {
		return m.CallTokenType
	}
	return 0
}

func (m *SessionUpdateRegisterDeviceReq) GetCallToken() string {
	if m != nil {
		return m.CallToken
	}
	return ""
}

type SessionUpdateRegisterDeviceResult struct {
	Code SessionUpdateRegisterDeviceResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionUpdateRegisterDeviceResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateRegisterDeviceResult) Reset()         { *m = SessionUpdateRegisterDeviceResult{} }
func (m *SessionUpdateRegisterDeviceResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateRegisterDeviceResult) ProtoMessage()    {}
func (*SessionUpdateRegisterDeviceResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{13}
}

func (m *SessionUpdateRegisterDeviceResult) GetCode() SessionUpdateRegisterDeviceResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateRegisterDeviceResult_Success
}

type SessionUpdateRegisterHuaweiDeviceReq struct {
	PushTokenType int32  `protobuf:"varint,1,opt,name=push_token_type,json=pushTokenType,proto3" json:"push_token_type,omitempty"`
	PushToken     string `protobuf:"bytes,2,opt,name=push_token,json=pushToken,proto3" json:"push_token,omitempty"`
	KeyId         uint64 `protobuf:"varint,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	CallTokenType int32  `protobuf:"varint,4,opt,name=call_token_type,json=callTokenType,proto3" json:"call_token_type,omitempty"`
	CallToken     string `protobuf:"bytes,5,opt,name=call_token,json=callToken,proto3" json:"call_token,omitempty"`
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) Reset()         { *m = SessionUpdateRegisterHuaweiDeviceReq{} }
func (m *SessionUpdateRegisterHuaweiDeviceReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateRegisterHuaweiDeviceReq) ProtoMessage()    {}
func (*SessionUpdateRegisterHuaweiDeviceReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{14}
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) GetPushTokenType() int32 {
	if m != nil {
		return m.PushTokenType
	}
	return 0
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) GetPushToken() string {
	if m != nil {
		return m.PushToken
	}
	return ""
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) GetCallTokenType() int32 {
	if m != nil {
		return m.CallTokenType
	}
	return 0
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) GetCallToken() string {
	if m != nil {
		return m.CallToken
	}
	return ""
}

type SessionUpdateRegisterHuaweiDeviceResult struct {
	Code   SessionUpdateRegisterHuaweiDeviceResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionUpdateRegisterHuaweiDeviceResult_ResultCode" json:"code,omitempty"`
	UserId int32                                              `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId  uint64                                             `protobuf:"varint,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionUpdateRegisterHuaweiDeviceResult) Reset() {
	*m = SessionUpdateRegisterHuaweiDeviceResult{}
}
func (m *SessionUpdateRegisterHuaweiDeviceResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateRegisterHuaweiDeviceResult) ProtoMessage()    {}
func (*SessionUpdateRegisterHuaweiDeviceResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{15}
}

func (m *SessionUpdateRegisterHuaweiDeviceResult) GetCode() SessionUpdateRegisterHuaweiDeviceResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateRegisterHuaweiDeviceResult_Success
}

func (m *SessionUpdateRegisterHuaweiDeviceResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdateRegisterHuaweiDeviceResult) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionUpdateUserPhoneReq struct {
	UserId   int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	NewPhone string `protobuf:"bytes,2,opt,name=new_phone,json=newPhone,proto3" json:"new_phone,omitempty"`
}

func (m *SessionUpdateUserPhoneReq) Reset()         { *m = SessionUpdateUserPhoneReq{} }
func (m *SessionUpdateUserPhoneReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateUserPhoneReq) ProtoMessage()    {}
func (*SessionUpdateUserPhoneReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{16}
}

func (m *SessionUpdateUserPhoneReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdateUserPhoneReq) GetNewPhone() string {
	if m != nil {
		return m.NewPhone
	}
	return ""
}

type SessionUpdateUserPhoneResult struct {
	Code SessionUpdateUserPhoneResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionUpdateUserPhoneResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateUserPhoneResult) Reset()         { *m = SessionUpdateUserPhoneResult{} }
func (m *SessionUpdateUserPhoneResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateUserPhoneResult) ProtoMessage()    {}
func (*SessionUpdateUserPhoneResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{17}
}

func (m *SessionUpdateUserPhoneResult) GetCode() SessionUpdateUserPhoneResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateUserPhoneResult_Success
}

type SessionQueryApiIDbyKeyIdReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionQueryApiIDbyKeyIdReq) Reset()         { *m = SessionQueryApiIDbyKeyIdReq{} }
func (m *SessionQueryApiIDbyKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryApiIDbyKeyIdReq) ProtoMessage()    {}
func (*SessionQueryApiIDbyKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{18}
}

func (m *SessionQueryApiIDbyKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionQueryApiIDbyKeyIdResult struct {
	ApiId         int32 `protobuf:"varint,1,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	InternalError bool  `protobuf:"varint,2,opt,name=internal_error,json=internalError,proto3" json:"internal_error,omitempty"`
}

func (m *SessionQueryApiIDbyKeyIdResult) Reset()         { *m = SessionQueryApiIDbyKeyIdResult{} }
func (m *SessionQueryApiIDbyKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryApiIDbyKeyIdResult) ProtoMessage()    {}
func (*SessionQueryApiIDbyKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{19}
}

func (m *SessionQueryApiIDbyKeyIdResult) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *SessionQueryApiIDbyKeyIdResult) GetInternalError() bool {
	if m != nil {
		return m.InternalError
	}
	return false
}

type SessionQueryUserIdByKeyIdReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionQueryUserIdByKeyIdReq) Reset()         { *m = SessionQueryUserIdByKeyIdReq{} }
func (m *SessionQueryUserIdByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryUserIdByKeyIdReq) ProtoMessage()    {}
func (*SessionQueryUserIdByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{20}
}

func (m *SessionQueryUserIdByKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionQueryUserIdByKeyIdResult struct {
	InternalError bool  `protobuf:"varint,1,opt,name=internal_error,json=internalError,proto3" json:"internal_error,omitempty"`
	UserId        int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionQueryUserIdByKeyIdResult) Reset()         { *m = SessionQueryUserIdByKeyIdResult{} }
func (m *SessionQueryUserIdByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryUserIdByKeyIdResult) ProtoMessage()    {}
func (*SessionQueryUserIdByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{21}
}

func (m *SessionQueryUserIdByKeyIdResult) GetInternalError() bool {
	if m != nil {
		return m.InternalError
	}
	return false
}

func (m *SessionQueryUserIdByKeyIdResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionUpdateOnHandshakeDoneReq struct {
	KeyId   uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	AuthKey []byte `protobuf:"bytes,2,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
}

func (m *SessionUpdateOnHandshakeDoneReq) Reset()         { *m = SessionUpdateOnHandshakeDoneReq{} }
func (m *SessionUpdateOnHandshakeDoneReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateOnHandshakeDoneReq) ProtoMessage()    {}
func (*SessionUpdateOnHandshakeDoneReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{22}
}

func (m *SessionUpdateOnHandshakeDoneReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateOnHandshakeDoneReq) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

type SessionUpdateOnHandshakeDoneResult struct {
	Success bool                                        `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Code    SessionUpdateOnHandshakeDoneResult_FailCode `protobuf:"varint,2,opt,name=code,proto3,enum=imsession.SessionUpdateOnHandshakeDoneResult_FailCode" json:"code,omitempty"`
}

func (m *SessionUpdateOnHandshakeDoneResult) Reset()         { *m = SessionUpdateOnHandshakeDoneResult{} }
func (m *SessionUpdateOnHandshakeDoneResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateOnHandshakeDoneResult) ProtoMessage()    {}
func (*SessionUpdateOnHandshakeDoneResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{23}
}

func (m *SessionUpdateOnHandshakeDoneResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *SessionUpdateOnHandshakeDoneResult) GetCode() SessionUpdateOnHandshakeDoneResult_FailCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateOnHandshakeDoneResult_Internal
}

type SessionIncQtsReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionIncQtsReq) Reset()                    { *m = SessionIncQtsReq{} }
func (m *SessionIncQtsReq) String() string            { return proto.CompactTextString(m) }
func (*SessionIncQtsReq) ProtoMessage()               {}
func (*SessionIncQtsReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{24} }

func (m *SessionIncQtsReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionIncQtsResult struct {
	Code SessionIncQtsResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionIncQtsResult_ResultCode" json:"code,omitempty"`
	Qts  int32                          `protobuf:"varint,2,opt,name=qts,proto3" json:"qts,omitempty"`
}

func (m *SessionIncQtsResult) Reset()                    { *m = SessionIncQtsResult{} }
func (m *SessionIncQtsResult) String() string            { return proto.CompactTextString(m) }
func (*SessionIncQtsResult) ProtoMessage()               {}
func (*SessionIncQtsResult) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{25} }

func (m *SessionIncQtsResult) GetCode() SessionIncQtsResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionIncQtsResult_Success
}

func (m *SessionIncQtsResult) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

type SessionTerminateByKeyIdReq struct {
	KeyId        uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	PhoneNumber  string `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	UserId       int32  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CurrentKeyId uint64 `protobuf:"varint,4,opt,name=current_key_id,json=currentKeyId,proto3" json:"current_key_id,omitempty"`
}

func (m *SessionTerminateByKeyIdReq) Reset()         { *m = SessionTerminateByKeyIdReq{} }
func (m *SessionTerminateByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateByKeyIdReq) ProtoMessage()    {}
func (*SessionTerminateByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{26}
}

func (m *SessionTerminateByKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionTerminateByKeyIdReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionTerminateByKeyIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionTerminateByKeyIdReq) GetCurrentKeyId() uint64 {
	if m != nil {
		return m.CurrentKeyId
	}
	return 0
}

type SessionTerminateByKeyIdResult struct {
	Code SessionTerminateByKeyIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionTerminateByKeyIdResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionTerminateByKeyIdResult) Reset()         { *m = SessionTerminateByKeyIdResult{} }
func (m *SessionTerminateByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateByKeyIdResult) ProtoMessage()    {}
func (*SessionTerminateByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{27}
}

func (m *SessionTerminateByKeyIdResult) GetCode() SessionTerminateByKeyIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionTerminateByKeyIdResult_Success
}

type SessionTerminateExceptKeyIdReq struct {
	KeyId       uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	PhoneNumber string `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	UserId      int32  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionTerminateExceptKeyIdReq) Reset()         { *m = SessionTerminateExceptKeyIdReq{} }
func (m *SessionTerminateExceptKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateExceptKeyIdReq) ProtoMessage()    {}
func (*SessionTerminateExceptKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{28}
}

func (m *SessionTerminateExceptKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionTerminateExceptKeyIdReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionTerminateExceptKeyIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionTerminateExceptKeyIdResult struct {
	Code SessionTerminateExceptKeyIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionTerminateExceptKeyIdResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionTerminateExceptKeyIdResult) Reset()         { *m = SessionTerminateExceptKeyIdResult{} }
func (m *SessionTerminateExceptKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateExceptKeyIdResult) ProtoMessage()    {}
func (*SessionTerminateExceptKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{29}
}

func (m *SessionTerminateExceptKeyIdResult) GetCode() SessionTerminateExceptKeyIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionTerminateExceptKeyIdResult_Success
}

type SessionUpdateLogoutReq struct {
	KeyId  uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionUpdateLogoutReq) Reset()         { *m = SessionUpdateLogoutReq{} }
func (m *SessionUpdateLogoutReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateLogoutReq) ProtoMessage()    {}
func (*SessionUpdateLogoutReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{30}
}

func (m *SessionUpdateLogoutReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateLogoutReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionUpdateLogoutResult struct {
	Code SessionUpdateLogoutResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionUpdateLogoutResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateLogoutResult) Reset()         { *m = SessionUpdateLogoutResult{} }
func (m *SessionUpdateLogoutResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateLogoutResult) ProtoMessage()    {}
func (*SessionUpdateLogoutResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{31}
}

func (m *SessionUpdateLogoutResult) GetCode() SessionUpdateLogoutResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateLogoutResult_Success
}

type CheckBanDeviceReq struct {
	KeyId        uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	UniqueNumber string `protobuf:"bytes,2,opt,name=unique_number,json=uniqueNumber,proto3" json:"unique_number,omitempty"`
}

func (m *CheckBanDeviceReq) Reset()                    { *m = CheckBanDeviceReq{} }
func (m *CheckBanDeviceReq) String() string            { return proto.CompactTextString(m) }
func (*CheckBanDeviceReq) ProtoMessage()               {}
func (*CheckBanDeviceReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{32} }

func (m *CheckBanDeviceReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *CheckBanDeviceReq) GetUniqueNumber() string {
	if m != nil {
		return m.UniqueNumber
	}
	return ""
}

type CheckBanDeviceResult struct {
	Banned bool `protobuf:"varint,1,opt,name=Banned,proto3" json:"Banned,omitempty"`
}

func (m *CheckBanDeviceResult) Reset()                    { *m = CheckBanDeviceResult{} }
func (m *CheckBanDeviceResult) String() string            { return proto.CompactTextString(m) }
func (*CheckBanDeviceResult) ProtoMessage()               {}
func (*CheckBanDeviceResult) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{33} }

func (m *CheckBanDeviceResult) GetBanned() bool {
	if m != nil {
		return m.Banned
	}
	return false
}

type AddBanDeviceReq struct {
	UniqueNumber string `protobuf:"bytes,1,opt,name=unique_number,json=uniqueNumber,proto3" json:"unique_number,omitempty"`
}

func (m *AddBanDeviceReq) Reset()                    { *m = AddBanDeviceReq{} }
func (m *AddBanDeviceReq) String() string            { return proto.CompactTextString(m) }
func (*AddBanDeviceReq) ProtoMessage()               {}
func (*AddBanDeviceReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{34} }

func (m *AddBanDeviceReq) GetUniqueNumber() string {
	if m != nil {
		return m.UniqueNumber
	}
	return ""
}

type AddBanDeviceResult struct {
	Code AddBanDeviceResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.AddBanDeviceResult_ResultCode" json:"code,omitempty"`
}

func (m *AddBanDeviceResult) Reset()                    { *m = AddBanDeviceResult{} }
func (m *AddBanDeviceResult) String() string            { return proto.CompactTextString(m) }
func (*AddBanDeviceResult) ProtoMessage()               {}
func (*AddBanDeviceResult) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{35} }

func (m *AddBanDeviceResult) GetCode() AddBanDeviceResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return AddBanDeviceResult_Success
}

type SessionDeleteByKeyIdReq struct {
	KeyId  uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionDeleteByKeyIdReq) Reset()         { *m = SessionDeleteByKeyIdReq{} }
func (m *SessionDeleteByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionDeleteByKeyIdReq) ProtoMessage()    {}
func (*SessionDeleteByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{36}
}

func (m *SessionDeleteByKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionDeleteByKeyIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionDeleteByKeyIdResult struct {
	Code SessionDeleteByKeyIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionDeleteByKeyIdResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionDeleteByKeyIdResult) Reset()         { *m = SessionDeleteByKeyIdResult{} }
func (m *SessionDeleteByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionDeleteByKeyIdResult) ProtoMessage()    {}
func (*SessionDeleteByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{37}
}

func (m *SessionDeleteByKeyIdResult) GetCode() SessionDeleteByKeyIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionDeleteByKeyIdResult_Success
}

type SessionQueryByKeyIdReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionQueryByKeyIdReq) Reset()         { *m = SessionQueryByKeyIdReq{} }
func (m *SessionQueryByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryByKeyIdReq) ProtoMessage()    {}
func (*SessionQueryByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{38}
}

func (m *SessionQueryByKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionQueryByKeyIdResult struct {
	Code SessionQueryByKeyIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionQueryByKeyIdResult_ResultCode" json:"code,omitempty"`
	Info *SessionInformation                  `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
}

func (m *SessionQueryByKeyIdResult) Reset()         { *m = SessionQueryByKeyIdResult{} }
func (m *SessionQueryByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryByKeyIdResult) ProtoMessage()    {}
func (*SessionQueryByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{39}
}

func (m *SessionQueryByKeyIdResult) GetCode() SessionQueryByKeyIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionQueryByKeyIdResult_Success
}

func (m *SessionQueryByKeyIdResult) GetInfo() *SessionInformation {
	if m != nil {
		return m.Info
	}
	return nil
}

type SessionInformation struct {
	ApiId         int32  `protobuf:"varint,1,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel   string `protobuf:"bytes,2,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion string `protobuf:"bytes,3,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion    string `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	LangCode      string `protobuf:"bytes,5,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Ip            string `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	Country       string `protobuf:"bytes,7,opt,name=country,proto3" json:"country,omitempty"`
	Layer         int32  `protobuf:"varint,8,opt,name=layer,proto3" json:"layer,omitempty"`
	AuthKey       []byte `protobuf:"bytes,9,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	Qts           int32  `protobuf:"varint,10,opt,name=qts,proto3" json:"qts,omitempty"`
	PushTokenType int32  `protobuf:"varint,11,opt,name=push_token_type,json=pushTokenType,proto3" json:"push_token_type,omitempty"`
	PushToken     string `protobuf:"bytes,12,opt,name=push_token,json=pushToken,proto3" json:"push_token,omitempty"`
	CallTokenType int32  `protobuf:"varint,13,opt,name=call_token_type,json=callTokenType,proto3" json:"call_token_type,omitempty"`
	CallToken     string `protobuf:"bytes,14,opt,name=call_token,json=callToken,proto3" json:"call_token,omitempty"`
	PingTime      int64  `protobuf:"varint,15,opt,name=ping_time,json=pingTime,proto3" json:"ping_time,omitempty"`
	PhoneNumber   string `protobuf:"bytes,16,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	UserId        int32  `protobuf:"varint,17,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AccessHash    int64  `protobuf:"varint,18,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Seq           int32  `protobuf:"varint,19,opt,name=seq,proto3" json:"seq,omitempty"`
	KeyId         uint64 `protobuf:"varint,20,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	AppName       string `protobuf:"bytes,21,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	Disconnect    bool   `protobuf:"varint,22,opt,name=disconnect,proto3" json:"disconnect,omitempty"`
}

func (m *SessionInformation) Reset()                    { *m = SessionInformation{} }
func (m *SessionInformation) String() string            { return proto.CompactTextString(m) }
func (*SessionInformation) ProtoMessage()               {}
func (*SessionInformation) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{40} }

func (m *SessionInformation) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *SessionInformation) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *SessionInformation) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *SessionInformation) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *SessionInformation) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *SessionInformation) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *SessionInformation) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *SessionInformation) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *SessionInformation) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *SessionInformation) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

func (m *SessionInformation) GetPushTokenType() int32 {
	if m != nil {
		return m.PushTokenType
	}
	return 0
}

func (m *SessionInformation) GetPushToken() string {
	if m != nil {
		return m.PushToken
	}
	return ""
}

func (m *SessionInformation) GetCallTokenType() int32 {
	if m != nil {
		return m.CallTokenType
	}
	return 0
}

func (m *SessionInformation) GetCallToken() string {
	if m != nil {
		return m.CallToken
	}
	return ""
}

func (m *SessionInformation) GetPingTime() int64 {
	if m != nil {
		return m.PingTime
	}
	return 0
}

func (m *SessionInformation) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionInformation) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionInformation) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *SessionInformation) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SessionInformation) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionInformation) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *SessionInformation) GetDisconnect() bool {
	if m != nil {
		return m.Disconnect
	}
	return false
}

type SessionUpdateSignInReq struct {
	PhoneNumber         string `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	KeyId               uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	UserId              int32  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AccessHash          int64  `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	IsPrivilegedVersion bool   `protobuf:"varint,5,opt,name=is_privileged_version,json=isPrivilegedVersion,proto3" json:"is_privileged_version,omitempty"`
}

func (m *SessionUpdateSignInReq) Reset()         { *m = SessionUpdateSignInReq{} }
func (m *SessionUpdateSignInReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateSignInReq) ProtoMessage()    {}
func (*SessionUpdateSignInReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{41}
}

func (m *SessionUpdateSignInReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionUpdateSignInReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateSignInReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdateSignInReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *SessionUpdateSignInReq) GetIsPrivilegedVersion() bool {
	if m != nil {
		return m.IsPrivilegedVersion
	}
	return false
}

type SessionUpdateSignInResult struct {
	Code SessionUpdateSignInResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionUpdateSignInResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateSignInResult) Reset()         { *m = SessionUpdateSignInResult{} }
func (m *SessionUpdateSignInResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateSignInResult) ProtoMessage()    {}
func (*SessionUpdateSignInResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{42}
}

func (m *SessionUpdateSignInResult) GetCode() SessionUpdateSignInResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateSignInResult_Success
}

type SessionQueryByUserIdReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionQueryByUserIdReq) Reset()         { *m = SessionQueryByUserIdReq{} }
func (m *SessionQueryByUserIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryByUserIdReq) ProtoMessage()    {}
func (*SessionQueryByUserIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{43}
}

func (m *SessionQueryByUserIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionQueryByUserIdResult struct {
	Code  SessionQueryByUserIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionQueryByUserIdResult_ResultCode" json:"code,omitempty"`
	Infos []*SessionInformation                 `protobuf:"bytes,2,rep,name=infos" json:"infos,omitempty"`
}

func (m *SessionQueryByUserIdResult) Reset()         { *m = SessionQueryByUserIdResult{} }
func (m *SessionQueryByUserIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryByUserIdResult) ProtoMessage()    {}
func (*SessionQueryByUserIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{44}
}

func (m *SessionQueryByUserIdResult) GetCode() SessionQueryByUserIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionQueryByUserIdResult_Success
}

func (m *SessionQueryByUserIdResult) GetInfos() []*SessionInformation {
	if m != nil {
		return m.Infos
	}
	return nil
}

type SessionQueryBasicInfoByKeyIdReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionQueryBasicInfoByKeyIdReq) Reset()         { *m = SessionQueryBasicInfoByKeyIdReq{} }
func (m *SessionQueryBasicInfoByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryBasicInfoByKeyIdReq) ProtoMessage()    {}
func (*SessionQueryBasicInfoByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{45}
}

func (m *SessionQueryBasicInfoByKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionQueryBasicInfoByKeyIdResult struct {
	Code        SessionQueryBasicInfoByKeyIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionQueryBasicInfoByKeyIdResult_ResultCode" json:"code,omitempty"`
	UserId      int32                                         `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PhoneNumber string                                        `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	AppVersion  string                                        `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
}

func (m *SessionQueryBasicInfoByKeyIdResult) Reset()         { *m = SessionQueryBasicInfoByKeyIdResult{} }
func (m *SessionQueryBasicInfoByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryBasicInfoByKeyIdResult) ProtoMessage()    {}
func (*SessionQueryBasicInfoByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{46}
}

func (m *SessionQueryBasicInfoByKeyIdResult) GetCode() SessionQueryBasicInfoByKeyIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionQueryBasicInfoByKeyIdResult_Success
}

func (m *SessionQueryBasicInfoByKeyIdResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionQueryBasicInfoByKeyIdResult) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionQueryBasicInfoByKeyIdResult) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

type SessionQueryDesByKeyIdReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionQueryDesByKeyIdReq) Reset()         { *m = SessionQueryDesByKeyIdReq{} }
func (m *SessionQueryDesByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryDesByKeyIdReq) ProtoMessage()    {}
func (*SessionQueryDesByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{47}
}

func (m *SessionQueryDesByKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionQueryDesByKeyIdResult struct {
	Code          SessionQueryDesByKeyIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionQueryDesByKeyIdResult_ResultCode" json:"code,omitempty"`
	DeviceModel   string                                  `protobuf:"bytes,2,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion string                                  `protobuf:"bytes,3,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion    string                                  `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
}

func (m *SessionQueryDesByKeyIdResult) Reset()         { *m = SessionQueryDesByKeyIdResult{} }
func (m *SessionQueryDesByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryDesByKeyIdResult) ProtoMessage()    {}
func (*SessionQueryDesByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{48}
}

func (m *SessionQueryDesByKeyIdResult) GetCode() SessionQueryDesByKeyIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionQueryDesByKeyIdResult_Success
}

func (m *SessionQueryDesByKeyIdResult) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *SessionQueryDesByKeyIdResult) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *SessionQueryDesByKeyIdResult) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

type SessionDeleteAuthKeysByUserIdReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionDeleteAuthKeysByUserIdReq) Reset()         { *m = SessionDeleteAuthKeysByUserIdReq{} }
func (m *SessionDeleteAuthKeysByUserIdReq) String() string { return proto.CompactTextString(m) }
func (*SessionDeleteAuthKeysByUserIdReq) ProtoMessage()    {}
func (*SessionDeleteAuthKeysByUserIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{49}
}

func (m *SessionDeleteAuthKeysByUserIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionDeleteAuthKeysByUserIdResult struct {
	Code   SessionDeleteAuthKeysByUserIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionDeleteAuthKeysByUserIdResult_ResultCode" json:"code,omitempty"`
	KeyIds []int64                                        `protobuf:"varint,2,rep,packed,name=keyIds" json:"keyIds,omitempty"`
}

func (m *SessionDeleteAuthKeysByUserIdResult) Reset()         { *m = SessionDeleteAuthKeysByUserIdResult{} }
func (m *SessionDeleteAuthKeysByUserIdResult) String() string { return proto.CompactTextString(m) }
func (*SessionDeleteAuthKeysByUserIdResult) ProtoMessage()    {}
func (*SessionDeleteAuthKeysByUserIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{50}
}

func (m *SessionDeleteAuthKeysByUserIdResult) GetCode() SessionDeleteAuthKeysByUserIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionDeleteAuthKeysByUserIdResult_Success
}

func (m *SessionDeleteAuthKeysByUserIdResult) GetKeyIds() []int64 {
	if m != nil {
		return m.KeyIds
	}
	return nil
}

type SessionUpdatePingReq struct {
	UserId     int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId      uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	PingTime   int64  `protobuf:"varint,3,opt,name=ping_time,json=pingTime,proto3" json:"ping_time,omitempty"`
	UpdateTime bool   `protobuf:"varint,4,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
}

func (m *SessionUpdatePingReq) Reset()                    { *m = SessionUpdatePingReq{} }
func (m *SessionUpdatePingReq) String() string            { return proto.CompactTextString(m) }
func (*SessionUpdatePingReq) ProtoMessage()               {}
func (*SessionUpdatePingReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{51} }

func (m *SessionUpdatePingReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdatePingReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdatePingReq) GetPingTime() int64 {
	if m != nil {
		return m.PingTime
	}
	return 0
}

func (m *SessionUpdatePingReq) GetUpdateTime() bool {
	if m != nil {
		return m.UpdateTime
	}
	return false
}

type SessionUpdatePingReq2 struct {
	UserId     int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId      uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	PingTime   int64  `protobuf:"varint,3,opt,name=ping_time,json=pingTime,proto3" json:"ping_time,omitempty"`
	UpdateTime bool   `protobuf:"varint,4,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
}

func (m *SessionUpdatePingReq2) Reset()                    { *m = SessionUpdatePingReq2{} }
func (m *SessionUpdatePingReq2) String() string            { return proto.CompactTextString(m) }
func (*SessionUpdatePingReq2) ProtoMessage()               {}
func (*SessionUpdatePingReq2) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{52} }

func (m *SessionUpdatePingReq2) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdatePingReq2) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdatePingReq2) GetPingTime() int64 {
	if m != nil {
		return m.PingTime
	}
	return 0
}

func (m *SessionUpdatePingReq2) GetUpdateTime() bool {
	if m != nil {
		return m.UpdateTime
	}
	return false
}

type SessionUpdatePingResult struct {
	Code   SessionUpdatePingResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.SessionUpdatePingResult_ResultCode" json:"code,omitempty"`
	UserId int32                              `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Phone  string                             `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
}

func (m *SessionUpdatePingResult) Reset()         { *m = SessionUpdatePingResult{} }
func (m *SessionUpdatePingResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdatePingResult) ProtoMessage()    {}
func (*SessionUpdatePingResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{53}
}

func (m *SessionUpdatePingResult) GetCode() SessionUpdatePingResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdatePingResult_Success
}

func (m *SessionUpdatePingResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdatePingResult) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// 25根据keyId获取创建时间
type GetCreatedByKeyIdReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *GetCreatedByKeyIdReq) Reset()                    { *m = GetCreatedByKeyIdReq{} }
func (m *GetCreatedByKeyIdReq) String() string            { return proto.CompactTextString(m) }
func (*GetCreatedByKeyIdReq) ProtoMessage()               {}
func (*GetCreatedByKeyIdReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{54} }

func (m *GetCreatedByKeyIdReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

// 25根据keyId获取创建时间
type GetCreatedByKeyIdResult struct {
	Code    GetCreatedByKeyIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.GetCreatedByKeyIdResult_ResultCode" json:"code,omitempty"`
	Created int32                              `protobuf:"varint,2,opt,name=created,proto3" json:"created,omitempty"`
}

func (m *GetCreatedByKeyIdResult) Reset()         { *m = GetCreatedByKeyIdResult{} }
func (m *GetCreatedByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*GetCreatedByKeyIdResult) ProtoMessage()    {}
func (*GetCreatedByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{55}
}

func (m *GetCreatedByKeyIdResult) GetCode() GetCreatedByKeyIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return GetCreatedByKeyIdResult_Success
}

func (m *GetCreatedByKeyIdResult) GetCreated() int32 {
	if m != nil {
		return m.Created
	}
	return 0
}

// 26更新app完整校验字段
type UpdateSelfAppHashReq struct {
	KeyId   uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	AppHash string `protobuf:"bytes,2,opt,name=app_hash,json=appHash,proto3" json:"app_hash,omitempty"`
}

func (m *UpdateSelfAppHashReq) Reset()                    { *m = UpdateSelfAppHashReq{} }
func (m *UpdateSelfAppHashReq) String() string            { return proto.CompactTextString(m) }
func (*UpdateSelfAppHashReq) ProtoMessage()               {}
func (*UpdateSelfAppHashReq) Descriptor() ([]byte, []int) { return fileDescriptorImsession, []int{56} }

func (m *UpdateSelfAppHashReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *UpdateSelfAppHashReq) GetAppHash() string {
	if m != nil {
		return m.AppHash
	}
	return ""
}

// 26更新app完整校验字段
type UpdateSelfAppHashResult struct {
	Code UpdateSelfAppHashResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsession.UpdateSelfAppHashResult_ResultCode" json:"code,omitempty"`
}

func (m *UpdateSelfAppHashResult) Reset()         { *m = UpdateSelfAppHashResult{} }
func (m *UpdateSelfAppHashResult) String() string { return proto.CompactTextString(m) }
func (*UpdateSelfAppHashResult) ProtoMessage()    {}
func (*UpdateSelfAppHashResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsession, []int{57}
}

func (m *UpdateSelfAppHashResult) GetCode() UpdateSelfAppHashResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return UpdateSelfAppHashResult_Success
}

func init() {
	proto.RegisterType((*ClearKeyIdSessionReq)(nil), "imsession.ClearKeyIdSessionReq")
	proto.RegisterType((*ClearKeyIdSessionResp)(nil), "imsession.ClearKeyIdSessionResp")
	proto.RegisterType((*SetLangCodeReq)(nil), "imsession.SetLangCodeReq")
	proto.RegisterType((*SetLangCodeResult)(nil), "imsession.SetLangCodeResult")
	proto.RegisterType((*GetLangCodeReq)(nil), "imsession.GetLangCodeReq")
	proto.RegisterType((*GetLangCodeResult)(nil), "imsession.GetLangCodeResult")
	proto.RegisterType((*GetUniqueNumberByKeyIdReq)(nil), "imsession.GetUniqueNumberByKeyIdReq")
	proto.RegisterType((*GetUniqueNumberByKeyIdResult)(nil), "imsession.GetUniqueNumberByKeyIdResult")
	proto.RegisterType((*SessionDisconnectReq)(nil), "imsession.SessionDisconnectReq")
	proto.RegisterType((*SessionDisconnectResult)(nil), "imsession.SessionDisconnectResult")
	proto.RegisterType((*SessionInitConnectionReq)(nil), "imsession.SessionInitConnectionReq")
	proto.RegisterType((*SessionInitConnectionResult)(nil), "imsession.SessionInitConnectionResult")
	proto.RegisterType((*SessionUpdateRegisterDeviceReq)(nil), "imsession.SessionUpdateRegisterDeviceReq")
	proto.RegisterType((*SessionUpdateRegisterDeviceResult)(nil), "imsession.SessionUpdateRegisterDeviceResult")
	proto.RegisterType((*SessionUpdateRegisterHuaweiDeviceReq)(nil), "imsession.SessionUpdateRegisterHuaweiDeviceReq")
	proto.RegisterType((*SessionUpdateRegisterHuaweiDeviceResult)(nil), "imsession.SessionUpdateRegisterHuaweiDeviceResult")
	proto.RegisterType((*SessionUpdateUserPhoneReq)(nil), "imsession.SessionUpdateUserPhoneReq")
	proto.RegisterType((*SessionUpdateUserPhoneResult)(nil), "imsession.SessionUpdateUserPhoneResult")
	proto.RegisterType((*SessionQueryApiIDbyKeyIdReq)(nil), "imsession.SessionQueryApiIDbyKeyIdReq")
	proto.RegisterType((*SessionQueryApiIDbyKeyIdResult)(nil), "imsession.SessionQueryApiIDbyKeyIdResult")
	proto.RegisterType((*SessionQueryUserIdByKeyIdReq)(nil), "imsession.SessionQueryUserIdByKeyIdReq")
	proto.RegisterType((*SessionQueryUserIdByKeyIdResult)(nil), "imsession.SessionQueryUserIdByKeyIdResult")
	proto.RegisterType((*SessionUpdateOnHandshakeDoneReq)(nil), "imsession.SessionUpdateOnHandshakeDoneReq")
	proto.RegisterType((*SessionUpdateOnHandshakeDoneResult)(nil), "imsession.SessionUpdateOnHandshakeDoneResult")
	proto.RegisterType((*SessionIncQtsReq)(nil), "imsession.SessionIncQtsReq")
	proto.RegisterType((*SessionIncQtsResult)(nil), "imsession.SessionIncQtsResult")
	proto.RegisterType((*SessionTerminateByKeyIdReq)(nil), "imsession.SessionTerminateByKeyIdReq")
	proto.RegisterType((*SessionTerminateByKeyIdResult)(nil), "imsession.SessionTerminateByKeyIdResult")
	proto.RegisterType((*SessionTerminateExceptKeyIdReq)(nil), "imsession.SessionTerminateExceptKeyIdReq")
	proto.RegisterType((*SessionTerminateExceptKeyIdResult)(nil), "imsession.SessionTerminateExceptKeyIdResult")
	proto.RegisterType((*SessionUpdateLogoutReq)(nil), "imsession.SessionUpdateLogoutReq")
	proto.RegisterType((*SessionUpdateLogoutResult)(nil), "imsession.SessionUpdateLogoutResult")
	proto.RegisterType((*CheckBanDeviceReq)(nil), "imsession.CheckBanDeviceReq")
	proto.RegisterType((*CheckBanDeviceResult)(nil), "imsession.CheckBanDeviceResult")
	proto.RegisterType((*AddBanDeviceReq)(nil), "imsession.AddBanDeviceReq")
	proto.RegisterType((*AddBanDeviceResult)(nil), "imsession.AddBanDeviceResult")
	proto.RegisterType((*SessionDeleteByKeyIdReq)(nil), "imsession.SessionDeleteByKeyIdReq")
	proto.RegisterType((*SessionDeleteByKeyIdResult)(nil), "imsession.SessionDeleteByKeyIdResult")
	proto.RegisterType((*SessionQueryByKeyIdReq)(nil), "imsession.SessionQueryByKeyIdReq")
	proto.RegisterType((*SessionQueryByKeyIdResult)(nil), "imsession.SessionQueryByKeyIdResult")
	proto.RegisterType((*SessionInformation)(nil), "imsession.SessionInformation")
	proto.RegisterType((*SessionUpdateSignInReq)(nil), "imsession.SessionUpdateSignInReq")
	proto.RegisterType((*SessionUpdateSignInResult)(nil), "imsession.SessionUpdateSignInResult")
	proto.RegisterType((*SessionQueryByUserIdReq)(nil), "imsession.SessionQueryByUserIdReq")
	proto.RegisterType((*SessionQueryByUserIdResult)(nil), "imsession.SessionQueryByUserIdResult")
	proto.RegisterType((*SessionQueryBasicInfoByKeyIdReq)(nil), "imsession.SessionQueryBasicInfoByKeyIdReq")
	proto.RegisterType((*SessionQueryBasicInfoByKeyIdResult)(nil), "imsession.SessionQueryBasicInfoByKeyIdResult")
	proto.RegisterType((*SessionQueryDesByKeyIdReq)(nil), "imsession.SessionQueryDesByKeyIdReq")
	proto.RegisterType((*SessionQueryDesByKeyIdResult)(nil), "imsession.SessionQueryDesByKeyIdResult")
	proto.RegisterType((*SessionDeleteAuthKeysByUserIdReq)(nil), "imsession.SessionDeleteAuthKeysByUserIdReq")
	proto.RegisterType((*SessionDeleteAuthKeysByUserIdResult)(nil), "imsession.SessionDeleteAuthKeysByUserIdResult")
	proto.RegisterType((*SessionUpdatePingReq)(nil), "imsession.SessionUpdatePingReq")
	proto.RegisterType((*SessionUpdatePingReq2)(nil), "imsession.SessionUpdatePingReq2")
	proto.RegisterType((*SessionUpdatePingResult)(nil), "imsession.SessionUpdatePingResult")
	proto.RegisterType((*GetCreatedByKeyIdReq)(nil), "imsession.GetCreatedByKeyIdReq")
	proto.RegisterType((*GetCreatedByKeyIdResult)(nil), "imsession.GetCreatedByKeyIdResult")
	proto.RegisterType((*UpdateSelfAppHashReq)(nil), "imsession.UpdateSelfAppHashReq")
	proto.RegisterType((*UpdateSelfAppHashResult)(nil), "imsession.UpdateSelfAppHashResult")
	proto.RegisterEnum("imsession.SetLangCodeResult_ResultCode", SetLangCodeResult_ResultCode_name, SetLangCodeResult_ResultCode_value)
	proto.RegisterEnum("imsession.GetLangCodeResult_ResultCode", GetLangCodeResult_ResultCode_name, GetLangCodeResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionInitConnectionResult_ResultCode", SessionInitConnectionResult_ResultCode_name, SessionInitConnectionResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionUpdateRegisterDeviceResult_ResultCode", SessionUpdateRegisterDeviceResult_ResultCode_name, SessionUpdateRegisterDeviceResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionUpdateRegisterHuaweiDeviceResult_ResultCode", SessionUpdateRegisterHuaweiDeviceResult_ResultCode_name, SessionUpdateRegisterHuaweiDeviceResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionUpdateUserPhoneResult_ResultCode", SessionUpdateUserPhoneResult_ResultCode_name, SessionUpdateUserPhoneResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionUpdateOnHandshakeDoneResult_FailCode", SessionUpdateOnHandshakeDoneResult_FailCode_name, SessionUpdateOnHandshakeDoneResult_FailCode_value)
	proto.RegisterEnum("imsession.SessionIncQtsResult_ResultCode", SessionIncQtsResult_ResultCode_name, SessionIncQtsResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionTerminateByKeyIdResult_ResultCode", SessionTerminateByKeyIdResult_ResultCode_name, SessionTerminateByKeyIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionTerminateExceptKeyIdResult_ResultCode", SessionTerminateExceptKeyIdResult_ResultCode_name, SessionTerminateExceptKeyIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionUpdateLogoutResult_ResultCode", SessionUpdateLogoutResult_ResultCode_name, SessionUpdateLogoutResult_ResultCode_value)
	proto.RegisterEnum("imsession.AddBanDeviceResult_ResultCode", AddBanDeviceResult_ResultCode_name, AddBanDeviceResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionDeleteByKeyIdResult_ResultCode", SessionDeleteByKeyIdResult_ResultCode_name, SessionDeleteByKeyIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionQueryByKeyIdResult_ResultCode", SessionQueryByKeyIdResult_ResultCode_name, SessionQueryByKeyIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionUpdateSignInResult_ResultCode", SessionUpdateSignInResult_ResultCode_name, SessionUpdateSignInResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionQueryByUserIdResult_ResultCode", SessionQueryByUserIdResult_ResultCode_name, SessionQueryByUserIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionQueryBasicInfoByKeyIdResult_ResultCode", SessionQueryBasicInfoByKeyIdResult_ResultCode_name, SessionQueryBasicInfoByKeyIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionQueryDesByKeyIdResult_ResultCode", SessionQueryDesByKeyIdResult_ResultCode_name, SessionQueryDesByKeyIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionDeleteAuthKeysByUserIdResult_ResultCode", SessionDeleteAuthKeysByUserIdResult_ResultCode_name, SessionDeleteAuthKeysByUserIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.SessionUpdatePingResult_ResultCode", SessionUpdatePingResult_ResultCode_name, SessionUpdatePingResult_ResultCode_value)
	proto.RegisterEnum("imsession.GetCreatedByKeyIdResult_ResultCode", GetCreatedByKeyIdResult_ResultCode_name, GetCreatedByKeyIdResult_ResultCode_value)
	proto.RegisterEnum("imsession.UpdateSelfAppHashResult_ResultCode", UpdateSelfAppHashResult_ResultCode_name, UpdateSelfAppHashResult_ResultCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Imsession service

type ImsessionClient interface {
	// ！！！清除keyId的操作
	ClearKeyIdSession(ctx context.Context, in *ClearKeyIdSessionReq, opts ...grpc.CallOption) (*ClearKeyIdSessionResp, error)
	// 1初始化连接添加session
	SessionInitConnection(ctx context.Context, in *SessionInitConnectionReq, opts ...grpc.CallOption) (*SessionInitConnectionResult, error)
	// 2注册设备信息
	SessionUpdateRegisterDevice(ctx context.Context, in *SessionUpdateRegisterDeviceReq, opts ...grpc.CallOption) (*SessionUpdateRegisterDeviceResult, error)
	// 2注册设备信息
	SessionUpdateRegisterHuaweiDevice(ctx context.Context, in *SessionUpdateRegisterHuaweiDeviceReq, opts ...grpc.CallOption) (*SessionUpdateRegisterHuaweiDeviceResult, error)
	// 3更新手机号码
	SessionUpdateUserPhone(ctx context.Context, in *SessionUpdateUserPhoneReq, opts ...grpc.CallOption) (*SessionUpdateUserPhoneResult, error)
	// 4logout 调用
	SessionUpdateLogout(ctx context.Context, in *SessionUpdateLogoutReq, opts ...grpc.CallOption) (*SessionUpdateLogoutResult, error)
	// 5客户端握手完成时保存auth key
	SessionUpdateOnHandshakeDone(ctx context.Context, in *SessionUpdateOnHandshakeDoneReq, opts ...grpc.CallOption) (*SessionUpdateOnHandshakeDoneResult, error)
	// 6剔除单个
	SessionTerminateByKeyId(ctx context.Context, in *SessionTerminateByKeyIdReq, opts ...grpc.CallOption) (*SessionTerminateByKeyIdResult, error)
	// 7剔除多个
	SessionTerminateExceptKeyId(ctx context.Context, in *SessionTerminateExceptKeyIdReq, opts ...grpc.CallOption) (*SessionTerminateExceptKeyIdResult, error)
	// 8根据keyid删除session
	SessionDeleteByKeyId(ctx context.Context, in *SessionDeleteByKeyIdReq, opts ...grpc.CallOption) (*SessionDeleteByKeyIdResult, error)
	// 9更新qts
	SessionIncQts(ctx context.Context, in *SessionIncQtsReq, opts ...grpc.CallOption) (*SessionIncQtsResult, error)
	// 10根据keyId查询session
	SessionQueryByKeyId(ctx context.Context, in *SessionQueryByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryByKeyIdResult, error)
	// 11根据UserId查询session
	SessionQueryByUserId(ctx context.Context, in *SessionQueryByUserIdReq, opts ...grpc.CallOption) (*SessionQueryByUserIdResult, error)
	// 12根据KeyId查询session 的  BasicInfo
	SessionQueryBasicInfoByKeyId(ctx context.Context, in *SessionQueryBasicInfoByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryBasicInfoByKeyIdResult, error)
	// 13根据KeyId查询session描述信息
	SessionQueryDesByKeyId(ctx context.Context, in *SessionQueryDesByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryDesByKeyIdResult, error)
	// 14根据userId删除auth keys
	SessionDeleteAuthKeysByUserId(ctx context.Context, in *SessionDeleteAuthKeysByUserIdReq, opts ...grpc.CallOption) (*SessionDeleteAuthKeysByUserIdResult, error)
	// 15更新ping
	SessionUpdatePing(ctx context.Context, in *SessionUpdatePingReq, opts ...grpc.CallOption) (*SessionUpdatePingResult, error)
	// 15更新ping
	SessionUpdatePing2(ctx context.Context, in *SessionUpdatePingReq2, opts ...grpc.CallOption) (*SessionUpdatePingResult, error)
	// 16更新登陆
	SessionUpdateSignIn(ctx context.Context, in *SessionUpdateSignInReq, opts ...grpc.CallOption) (*SessionUpdateSignInResult, error)
	// 17根据keyId获取apiID
	SessionQueryApiIDbyKeyId(ctx context.Context, in *SessionQueryApiIDbyKeyIdReq, opts ...grpc.CallOption) (*SessionQueryApiIDbyKeyIdResult, error)
	// 18根据keyId查找userId
	SessionQueryUserIdByKeyId(ctx context.Context, in *SessionQueryUserIdByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryUserIdByKeyIdResult, error)
	// 19客户端连接断开
	SessionDisconnect(ctx context.Context, in *SessionDisconnectReq, opts ...grpc.CallOption) (*SessionDisconnectResult, error)
	// 20BanDevice:根据uniqueNumber设置禁止登陆的设备
	AddBanDevice(ctx context.Context, in *AddBanDeviceReq, opts ...grpc.CallOption) (*AddBanDeviceResult, error)
	// 21BanDevice:根据uniqueNumber查询是否是禁止登陆的设备:true是false不是
	CheckBanDevice(ctx context.Context, in *CheckBanDeviceReq, opts ...grpc.CallOption) (*CheckBanDeviceResult, error)
	// 22get unique number by key id
	GetUniqueNumberByKeyId(ctx context.Context, in *GetUniqueNumberByKeyIdReq, opts ...grpc.CallOption) (*GetUniqueNumberByKeyIdResult, error)
	// 23设置langcode
	SetLangCode(ctx context.Context, in *SetLangCodeReq, opts ...grpc.CallOption) (*SetLangCodeResult, error)
	// 24获取langCode
	GetLangCode(ctx context.Context, in *GetLangCodeReq, opts ...grpc.CallOption) (*GetLangCodeResult, error)
	// 25根据keyId获取创建时间
	GetCreatedByKeyId(ctx context.Context, in *GetCreatedByKeyIdReq, opts ...grpc.CallOption) (*GetCreatedByKeyIdResult, error)
	// 26更新app完整校验字段
	UpdateSelfAppHash(ctx context.Context, in *UpdateSelfAppHashReq, opts ...grpc.CallOption) (*UpdateSelfAppHashResult, error)
}

type imsessionClient struct {
	cc *grpc.ClientConn
}

func NewImsessionClient(cc *grpc.ClientConn) ImsessionClient {
	return &imsessionClient{cc}
}

func (c *imsessionClient) ClearKeyIdSession(ctx context.Context, in *ClearKeyIdSessionReq, opts ...grpc.CallOption) (*ClearKeyIdSessionResp, error) {
	out := new(ClearKeyIdSessionResp)
	err := grpc.Invoke(ctx, "/imsession.imsession/ClearKeyIdSession", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionInitConnection(ctx context.Context, in *SessionInitConnectionReq, opts ...grpc.CallOption) (*SessionInitConnectionResult, error) {
	out := new(SessionInitConnectionResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionInitConnection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdateRegisterDevice(ctx context.Context, in *SessionUpdateRegisterDeviceReq, opts ...grpc.CallOption) (*SessionUpdateRegisterDeviceResult, error) {
	out := new(SessionUpdateRegisterDeviceResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdateRegisterDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdateRegisterHuaweiDevice(ctx context.Context, in *SessionUpdateRegisterHuaweiDeviceReq, opts ...grpc.CallOption) (*SessionUpdateRegisterHuaweiDeviceResult, error) {
	out := new(SessionUpdateRegisterHuaweiDeviceResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdateRegisterHuaweiDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdateUserPhone(ctx context.Context, in *SessionUpdateUserPhoneReq, opts ...grpc.CallOption) (*SessionUpdateUserPhoneResult, error) {
	out := new(SessionUpdateUserPhoneResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdateUserPhone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdateLogout(ctx context.Context, in *SessionUpdateLogoutReq, opts ...grpc.CallOption) (*SessionUpdateLogoutResult, error) {
	out := new(SessionUpdateLogoutResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdateLogout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdateOnHandshakeDone(ctx context.Context, in *SessionUpdateOnHandshakeDoneReq, opts ...grpc.CallOption) (*SessionUpdateOnHandshakeDoneResult, error) {
	out := new(SessionUpdateOnHandshakeDoneResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdateOnHandshakeDone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionTerminateByKeyId(ctx context.Context, in *SessionTerminateByKeyIdReq, opts ...grpc.CallOption) (*SessionTerminateByKeyIdResult, error) {
	out := new(SessionTerminateByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionTerminateByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionTerminateExceptKeyId(ctx context.Context, in *SessionTerminateExceptKeyIdReq, opts ...grpc.CallOption) (*SessionTerminateExceptKeyIdResult, error) {
	out := new(SessionTerminateExceptKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionTerminateExceptKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionDeleteByKeyId(ctx context.Context, in *SessionDeleteByKeyIdReq, opts ...grpc.CallOption) (*SessionDeleteByKeyIdResult, error) {
	out := new(SessionDeleteByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionDeleteByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionIncQts(ctx context.Context, in *SessionIncQtsReq, opts ...grpc.CallOption) (*SessionIncQtsResult, error) {
	out := new(SessionIncQtsResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionIncQts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionQueryByKeyId(ctx context.Context, in *SessionQueryByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryByKeyIdResult, error) {
	out := new(SessionQueryByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionQueryByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionQueryByUserId(ctx context.Context, in *SessionQueryByUserIdReq, opts ...grpc.CallOption) (*SessionQueryByUserIdResult, error) {
	out := new(SessionQueryByUserIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionQueryByUserId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionQueryBasicInfoByKeyId(ctx context.Context, in *SessionQueryBasicInfoByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryBasicInfoByKeyIdResult, error) {
	out := new(SessionQueryBasicInfoByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionQueryBasicInfoByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionQueryDesByKeyId(ctx context.Context, in *SessionQueryDesByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryDesByKeyIdResult, error) {
	out := new(SessionQueryDesByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionQueryDesByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionDeleteAuthKeysByUserId(ctx context.Context, in *SessionDeleteAuthKeysByUserIdReq, opts ...grpc.CallOption) (*SessionDeleteAuthKeysByUserIdResult, error) {
	out := new(SessionDeleteAuthKeysByUserIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionDeleteAuthKeysByUserId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdatePing(ctx context.Context, in *SessionUpdatePingReq, opts ...grpc.CallOption) (*SessionUpdatePingResult, error) {
	out := new(SessionUpdatePingResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdatePing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdatePing2(ctx context.Context, in *SessionUpdatePingReq2, opts ...grpc.CallOption) (*SessionUpdatePingResult, error) {
	out := new(SessionUpdatePingResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdatePing2", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionUpdateSignIn(ctx context.Context, in *SessionUpdateSignInReq, opts ...grpc.CallOption) (*SessionUpdateSignInResult, error) {
	out := new(SessionUpdateSignInResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionUpdateSignIn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionQueryApiIDbyKeyId(ctx context.Context, in *SessionQueryApiIDbyKeyIdReq, opts ...grpc.CallOption) (*SessionQueryApiIDbyKeyIdResult, error) {
	out := new(SessionQueryApiIDbyKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionQueryApiIDbyKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionQueryUserIdByKeyId(ctx context.Context, in *SessionQueryUserIdByKeyIdReq, opts ...grpc.CallOption) (*SessionQueryUserIdByKeyIdResult, error) {
	out := new(SessionQueryUserIdByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionQueryUserIdByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SessionDisconnect(ctx context.Context, in *SessionDisconnectReq, opts ...grpc.CallOption) (*SessionDisconnectResult, error) {
	out := new(SessionDisconnectResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SessionDisconnect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) AddBanDevice(ctx context.Context, in *AddBanDeviceReq, opts ...grpc.CallOption) (*AddBanDeviceResult, error) {
	out := new(AddBanDeviceResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/AddBanDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) CheckBanDevice(ctx context.Context, in *CheckBanDeviceReq, opts ...grpc.CallOption) (*CheckBanDeviceResult, error) {
	out := new(CheckBanDeviceResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/CheckBanDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) GetUniqueNumberByKeyId(ctx context.Context, in *GetUniqueNumberByKeyIdReq, opts ...grpc.CallOption) (*GetUniqueNumberByKeyIdResult, error) {
	out := new(GetUniqueNumberByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/GetUniqueNumberByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) SetLangCode(ctx context.Context, in *SetLangCodeReq, opts ...grpc.CallOption) (*SetLangCodeResult, error) {
	out := new(SetLangCodeResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/SetLangCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) GetLangCode(ctx context.Context, in *GetLangCodeReq, opts ...grpc.CallOption) (*GetLangCodeResult, error) {
	out := new(GetLangCodeResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/GetLangCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) GetCreatedByKeyId(ctx context.Context, in *GetCreatedByKeyIdReq, opts ...grpc.CallOption) (*GetCreatedByKeyIdResult, error) {
	out := new(GetCreatedByKeyIdResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/GetCreatedByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imsessionClient) UpdateSelfAppHash(ctx context.Context, in *UpdateSelfAppHashReq, opts ...grpc.CallOption) (*UpdateSelfAppHashResult, error) {
	out := new(UpdateSelfAppHashResult)
	err := grpc.Invoke(ctx, "/imsession.imsession/UpdateSelfAppHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Imsession service

type ImsessionServer interface {
	// ！！！清除keyId的操作
	ClearKeyIdSession(context.Context, *ClearKeyIdSessionReq) (*ClearKeyIdSessionResp, error)
	// 1初始化连接添加session
	SessionInitConnection(context.Context, *SessionInitConnectionReq) (*SessionInitConnectionResult, error)
	// 2注册设备信息
	SessionUpdateRegisterDevice(context.Context, *SessionUpdateRegisterDeviceReq) (*SessionUpdateRegisterDeviceResult, error)
	// 2注册设备信息
	SessionUpdateRegisterHuaweiDevice(context.Context, *SessionUpdateRegisterHuaweiDeviceReq) (*SessionUpdateRegisterHuaweiDeviceResult, error)
	// 3更新手机号码
	SessionUpdateUserPhone(context.Context, *SessionUpdateUserPhoneReq) (*SessionUpdateUserPhoneResult, error)
	// 4logout 调用
	SessionUpdateLogout(context.Context, *SessionUpdateLogoutReq) (*SessionUpdateLogoutResult, error)
	// 5客户端握手完成时保存auth key
	SessionUpdateOnHandshakeDone(context.Context, *SessionUpdateOnHandshakeDoneReq) (*SessionUpdateOnHandshakeDoneResult, error)
	// 6剔除单个
	SessionTerminateByKeyId(context.Context, *SessionTerminateByKeyIdReq) (*SessionTerminateByKeyIdResult, error)
	// 7剔除多个
	SessionTerminateExceptKeyId(context.Context, *SessionTerminateExceptKeyIdReq) (*SessionTerminateExceptKeyIdResult, error)
	// 8根据keyid删除session
	SessionDeleteByKeyId(context.Context, *SessionDeleteByKeyIdReq) (*SessionDeleteByKeyIdResult, error)
	// 9更新qts
	SessionIncQts(context.Context, *SessionIncQtsReq) (*SessionIncQtsResult, error)
	// 10根据keyId查询session
	SessionQueryByKeyId(context.Context, *SessionQueryByKeyIdReq) (*SessionQueryByKeyIdResult, error)
	// 11根据UserId查询session
	SessionQueryByUserId(context.Context, *SessionQueryByUserIdReq) (*SessionQueryByUserIdResult, error)
	// 12根据KeyId查询session 的  BasicInfo
	SessionQueryBasicInfoByKeyId(context.Context, *SessionQueryBasicInfoByKeyIdReq) (*SessionQueryBasicInfoByKeyIdResult, error)
	// 13根据KeyId查询session描述信息
	SessionQueryDesByKeyId(context.Context, *SessionQueryDesByKeyIdReq) (*SessionQueryDesByKeyIdResult, error)
	// 14根据userId删除auth keys
	SessionDeleteAuthKeysByUserId(context.Context, *SessionDeleteAuthKeysByUserIdReq) (*SessionDeleteAuthKeysByUserIdResult, error)
	// 15更新ping
	SessionUpdatePing(context.Context, *SessionUpdatePingReq) (*SessionUpdatePingResult, error)
	// 15更新ping
	SessionUpdatePing2(context.Context, *SessionUpdatePingReq2) (*SessionUpdatePingResult, error)
	// 16更新登陆
	SessionUpdateSignIn(context.Context, *SessionUpdateSignInReq) (*SessionUpdateSignInResult, error)
	// 17根据keyId获取apiID
	SessionQueryApiIDbyKeyId(context.Context, *SessionQueryApiIDbyKeyIdReq) (*SessionQueryApiIDbyKeyIdResult, error)
	// 18根据keyId查找userId
	SessionQueryUserIdByKeyId(context.Context, *SessionQueryUserIdByKeyIdReq) (*SessionQueryUserIdByKeyIdResult, error)
	// 19客户端连接断开
	SessionDisconnect(context.Context, *SessionDisconnectReq) (*SessionDisconnectResult, error)
	// 20BanDevice:根据uniqueNumber设置禁止登陆的设备
	AddBanDevice(context.Context, *AddBanDeviceReq) (*AddBanDeviceResult, error)
	// 21BanDevice:根据uniqueNumber查询是否是禁止登陆的设备:true是false不是
	CheckBanDevice(context.Context, *CheckBanDeviceReq) (*CheckBanDeviceResult, error)
	// 22get unique number by key id
	GetUniqueNumberByKeyId(context.Context, *GetUniqueNumberByKeyIdReq) (*GetUniqueNumberByKeyIdResult, error)
	// 23设置langcode
	SetLangCode(context.Context, *SetLangCodeReq) (*SetLangCodeResult, error)
	// 24获取langCode
	GetLangCode(context.Context, *GetLangCodeReq) (*GetLangCodeResult, error)
	// 25根据keyId获取创建时间
	GetCreatedByKeyId(context.Context, *GetCreatedByKeyIdReq) (*GetCreatedByKeyIdResult, error)
	// 26更新app完整校验字段
	UpdateSelfAppHash(context.Context, *UpdateSelfAppHashReq) (*UpdateSelfAppHashResult, error)
}

func RegisterImsessionServer(s *grpc.Server, srv ImsessionServer) {
	s.RegisterService(&_Imsession_serviceDesc, srv)
}

func _Imsession_ClearKeyIdSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearKeyIdSessionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).ClearKeyIdSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/ClearKeyIdSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).ClearKeyIdSession(ctx, req.(*ClearKeyIdSessionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionInitConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionInitConnectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionInitConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionInitConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionInitConnection(ctx, req.(*SessionInitConnectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdateRegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateRegisterDeviceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdateRegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdateRegisterDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdateRegisterDevice(ctx, req.(*SessionUpdateRegisterDeviceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdateRegisterHuaweiDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateRegisterHuaweiDeviceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdateRegisterHuaweiDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdateRegisterHuaweiDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdateRegisterHuaweiDevice(ctx, req.(*SessionUpdateRegisterHuaweiDeviceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdateUserPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateUserPhoneReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdateUserPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdateUserPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdateUserPhone(ctx, req.(*SessionUpdateUserPhoneReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdateLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateLogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdateLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdateLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdateLogout(ctx, req.(*SessionUpdateLogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdateOnHandshakeDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateOnHandshakeDoneReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdateOnHandshakeDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdateOnHandshakeDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdateOnHandshakeDone(ctx, req.(*SessionUpdateOnHandshakeDoneReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionTerminateByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionTerminateByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionTerminateByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionTerminateByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionTerminateByKeyId(ctx, req.(*SessionTerminateByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionTerminateExceptKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionTerminateExceptKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionTerminateExceptKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionTerminateExceptKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionTerminateExceptKeyId(ctx, req.(*SessionTerminateExceptKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionDeleteByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDeleteByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionDeleteByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionDeleteByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionDeleteByKeyId(ctx, req.(*SessionDeleteByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionIncQts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionIncQtsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionIncQts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionIncQts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionIncQts(ctx, req.(*SessionIncQtsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionQueryByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionQueryByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionQueryByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionQueryByKeyId(ctx, req.(*SessionQueryByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionQueryByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryByUserIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionQueryByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionQueryByUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionQueryByUserId(ctx, req.(*SessionQueryByUserIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionQueryBasicInfoByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryBasicInfoByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionQueryBasicInfoByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionQueryBasicInfoByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionQueryBasicInfoByKeyId(ctx, req.(*SessionQueryBasicInfoByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionQueryDesByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryDesByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionQueryDesByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionQueryDesByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionQueryDesByKeyId(ctx, req.(*SessionQueryDesByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionDeleteAuthKeysByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDeleteAuthKeysByUserIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionDeleteAuthKeysByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionDeleteAuthKeysByUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionDeleteAuthKeysByUserId(ctx, req.(*SessionDeleteAuthKeysByUserIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdatePing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdatePingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdatePing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdatePing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdatePing(ctx, req.(*SessionUpdatePingReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdatePing2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdatePingReq2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdatePing2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdatePing2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdatePing2(ctx, req.(*SessionUpdatePingReq2))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionUpdateSignIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateSignInReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionUpdateSignIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionUpdateSignIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionUpdateSignIn(ctx, req.(*SessionUpdateSignInReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionQueryApiIDbyKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryApiIDbyKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionQueryApiIDbyKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionQueryApiIDbyKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionQueryApiIDbyKeyId(ctx, req.(*SessionQueryApiIDbyKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionQueryUserIdByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryUserIdByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionQueryUserIdByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionQueryUserIdByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionQueryUserIdByKeyId(ctx, req.(*SessionQueryUserIdByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SessionDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDisconnectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SessionDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SessionDisconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SessionDisconnect(ctx, req.(*SessionDisconnectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_AddBanDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBanDeviceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).AddBanDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/AddBanDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).AddBanDevice(ctx, req.(*AddBanDeviceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_CheckBanDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckBanDeviceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).CheckBanDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/CheckBanDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).CheckBanDevice(ctx, req.(*CheckBanDeviceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_GetUniqueNumberByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUniqueNumberByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).GetUniqueNumberByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/GetUniqueNumberByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).GetUniqueNumberByKeyId(ctx, req.(*GetUniqueNumberByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_SetLangCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLangCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).SetLangCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/SetLangCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).SetLangCode(ctx, req.(*SetLangCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_GetLangCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLangCodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).GetLangCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/GetLangCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).GetLangCode(ctx, req.(*GetLangCodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_GetCreatedByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCreatedByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).GetCreatedByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/GetCreatedByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).GetCreatedByKeyId(ctx, req.(*GetCreatedByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Imsession_UpdateSelfAppHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSelfAppHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImsessionServer).UpdateSelfAppHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsession.imsession/UpdateSelfAppHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImsessionServer).UpdateSelfAppHash(ctx, req.(*UpdateSelfAppHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Imsession_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imsession.imsession",
	HandlerType: (*ImsessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ClearKeyIdSession",
			Handler:    _Imsession_ClearKeyIdSession_Handler,
		},
		{
			MethodName: "SessionInitConnection",
			Handler:    _Imsession_SessionInitConnection_Handler,
		},
		{
			MethodName: "SessionUpdateRegisterDevice",
			Handler:    _Imsession_SessionUpdateRegisterDevice_Handler,
		},
		{
			MethodName: "SessionUpdateRegisterHuaweiDevice",
			Handler:    _Imsession_SessionUpdateRegisterHuaweiDevice_Handler,
		},
		{
			MethodName: "SessionUpdateUserPhone",
			Handler:    _Imsession_SessionUpdateUserPhone_Handler,
		},
		{
			MethodName: "SessionUpdateLogout",
			Handler:    _Imsession_SessionUpdateLogout_Handler,
		},
		{
			MethodName: "SessionUpdateOnHandshakeDone",
			Handler:    _Imsession_SessionUpdateOnHandshakeDone_Handler,
		},
		{
			MethodName: "SessionTerminateByKeyId",
			Handler:    _Imsession_SessionTerminateByKeyId_Handler,
		},
		{
			MethodName: "SessionTerminateExceptKeyId",
			Handler:    _Imsession_SessionTerminateExceptKeyId_Handler,
		},
		{
			MethodName: "SessionDeleteByKeyId",
			Handler:    _Imsession_SessionDeleteByKeyId_Handler,
		},
		{
			MethodName: "SessionIncQts",
			Handler:    _Imsession_SessionIncQts_Handler,
		},
		{
			MethodName: "SessionQueryByKeyId",
			Handler:    _Imsession_SessionQueryByKeyId_Handler,
		},
		{
			MethodName: "SessionQueryByUserId",
			Handler:    _Imsession_SessionQueryByUserId_Handler,
		},
		{
			MethodName: "SessionQueryBasicInfoByKeyId",
			Handler:    _Imsession_SessionQueryBasicInfoByKeyId_Handler,
		},
		{
			MethodName: "SessionQueryDesByKeyId",
			Handler:    _Imsession_SessionQueryDesByKeyId_Handler,
		},
		{
			MethodName: "SessionDeleteAuthKeysByUserId",
			Handler:    _Imsession_SessionDeleteAuthKeysByUserId_Handler,
		},
		{
			MethodName: "SessionUpdatePing",
			Handler:    _Imsession_SessionUpdatePing_Handler,
		},
		{
			MethodName: "SessionUpdatePing2",
			Handler:    _Imsession_SessionUpdatePing2_Handler,
		},
		{
			MethodName: "SessionUpdateSignIn",
			Handler:    _Imsession_SessionUpdateSignIn_Handler,
		},
		{
			MethodName: "SessionQueryApiIDbyKeyId",
			Handler:    _Imsession_SessionQueryApiIDbyKeyId_Handler,
		},
		{
			MethodName: "SessionQueryUserIdByKeyId",
			Handler:    _Imsession_SessionQueryUserIdByKeyId_Handler,
		},
		{
			MethodName: "SessionDisconnect",
			Handler:    _Imsession_SessionDisconnect_Handler,
		},
		{
			MethodName: "AddBanDevice",
			Handler:    _Imsession_AddBanDevice_Handler,
		},
		{
			MethodName: "CheckBanDevice",
			Handler:    _Imsession_CheckBanDevice_Handler,
		},
		{
			MethodName: "GetUniqueNumberByKeyId",
			Handler:    _Imsession_GetUniqueNumberByKeyId_Handler,
		},
		{
			MethodName: "SetLangCode",
			Handler:    _Imsession_SetLangCode_Handler,
		},
		{
			MethodName: "GetLangCode",
			Handler:    _Imsession_GetLangCode_Handler,
		},
		{
			MethodName: "GetCreatedByKeyId",
			Handler:    _Imsession_GetCreatedByKeyId_Handler,
		},
		{
			MethodName: "UpdateSelfAppHash",
			Handler:    _Imsession_UpdateSelfAppHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "imsession.proto",
}

func (m *ClearKeyIdSessionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearKeyIdSessionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Uid))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *ClearKeyIdSessionResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearKeyIdSessionResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Sucess {
		dAtA[i] = 0x8
		i++
		if m.Sucess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetLangCodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetLangCodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	return i, nil
}

func (m *SetLangCodeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetLangCodeResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *GetLangCodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLangCodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *GetLangCodeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLangCodeResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	return i, nil
}

func (m *GetUniqueNumberByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUniqueNumberByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *GetUniqueNumberByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUniqueNumberByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.UniqueNumber)))
		i += copy(dAtA[i:], m.UniqueNumber)
	}
	return i, nil
}

func (m *SessionDisconnectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDisconnectReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.Disconnect {
		dAtA[i] = 0x18
		i++
		if m.Disconnect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ClientIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.ClientIp)))
		i += copy(dAtA[i:], m.ClientIp)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	return i, nil
}

func (m *SessionDisconnectResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDisconnectResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SessionInitConnectionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionInitConnectionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.ApiId))
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Layer))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	return i, nil
}

func (m *SessionInitConnectionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionInitConnectionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionUpdateRegisterDeviceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateRegisterDeviceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PushTokenType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.PushTokenType))
	}
	if len(m.PushToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PushToken)))
		i += copy(dAtA[i:], m.PushToken)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if m.CallTokenType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.CallTokenType))
	}
	if len(m.CallToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.CallToken)))
		i += copy(dAtA[i:], m.CallToken)
	}
	return i, nil
}

func (m *SessionUpdateRegisterDeviceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateRegisterDeviceResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PushTokenType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.PushTokenType))
	}
	if len(m.PushToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PushToken)))
		i += copy(dAtA[i:], m.PushToken)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if m.CallTokenType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.CallTokenType))
	}
	if len(m.CallToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.CallToken)))
		i += copy(dAtA[i:], m.CallToken)
	}
	return i, nil
}

func (m *SessionUpdateRegisterHuaweiDeviceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateRegisterHuaweiDeviceResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionUpdateUserPhoneReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateUserPhoneReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if len(m.NewPhone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.NewPhone)))
		i += copy(dAtA[i:], m.NewPhone)
	}
	return i, nil
}

func (m *SessionUpdateUserPhoneResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateUserPhoneResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionQueryApiIDbyKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryApiIDbyKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionQueryApiIDbyKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryApiIDbyKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.ApiId))
	}
	if m.InternalError {
		dAtA[i] = 0x10
		i++
		if m.InternalError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionQueryUserIdByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryUserIdByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionQueryUserIdByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryUserIdByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InternalError {
		dAtA[i] = 0x8
		i++
		if m.InternalError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionUpdateOnHandshakeDoneReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateOnHandshakeDoneReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	return i, nil
}

func (m *SessionUpdateOnHandshakeDoneResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateOnHandshakeDoneResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionIncQtsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionIncQtsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionIncQtsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionIncQtsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if m.Qts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Qts))
	}
	return i, nil
}

func (m *SessionTerminateByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if m.CurrentKeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.CurrentKeyId))
	}
	return i, nil
}

func (m *SessionTerminateByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionTerminateExceptKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateExceptKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionTerminateExceptKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateExceptKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionUpdateLogoutReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateLogoutReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionUpdateLogoutResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateLogoutResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *CheckBanDeviceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckBanDeviceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.UniqueNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.UniqueNumber)))
		i += copy(dAtA[i:], m.UniqueNumber)
	}
	return i, nil
}

func (m *CheckBanDeviceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckBanDeviceResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Banned {
		dAtA[i] = 0x8
		i++
		if m.Banned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AddBanDeviceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddBanDeviceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.UniqueNumber)))
		i += copy(dAtA[i:], m.UniqueNumber)
	}
	return i, nil
}

func (m *AddBanDeviceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddBanDeviceResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionDeleteByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDeleteByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionDeleteByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDeleteByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionQueryByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionQueryByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Info.Size()))
		n1, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *SessionInformation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionInformation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.ApiId))
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Layer))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if m.Qts != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Qts))
	}
	if m.PushTokenType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.PushTokenType))
	}
	if len(m.PushToken) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PushToken)))
		i += copy(dAtA[i:], m.PushToken)
	}
	if m.CallTokenType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.CallTokenType))
	}
	if len(m.CallToken) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.CallToken)))
		i += copy(dAtA[i:], m.CallToken)
	}
	if m.PingTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.PingTime))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.AccessHash))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Seq))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if m.Disconnect {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.Disconnect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionUpdateSignInReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateSignInReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.AccessHash))
	}
	if m.IsPrivilegedVersion {
		dAtA[i] = 0x28
		i++
		if m.IsPrivilegedVersion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionUpdateSignInResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateSignInResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionQueryByUserIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByUserIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionQueryByUserIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByUserIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImsession(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SessionQueryBasicInfoByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryBasicInfoByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionQueryBasicInfoByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryBasicInfoByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	return i, nil
}

func (m *SessionQueryDesByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryDesByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionQueryDesByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryDesByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	return i, nil
}

func (m *SessionDeleteAuthKeysByUserIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDeleteAuthKeysByUserIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionDeleteAuthKeysByUserIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDeleteAuthKeysByUserIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if len(m.KeyIds) > 0 {
		dAtA3 := make([]byte, len(m.KeyIds)*10)
		var j2 int
		for _, num1 := range m.KeyIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *SessionUpdatePingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdatePingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if m.PingTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.PingTime))
	}
	if m.UpdateTime {
		dAtA[i] = 0x20
		i++
		if m.UpdateTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionUpdatePingReq2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdatePingReq2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if m.PingTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.PingTime))
	}
	if m.UpdateTime {
		dAtA[i] = 0x20
		i++
		if m.UpdateTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionUpdatePingResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdatePingResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.UserId))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	return i, nil
}

func (m *GetCreatedByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCreatedByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *GetCreatedByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCreatedByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	if m.Created != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Created))
	}
	return i, nil
}

func (m *UpdateSelfAppHashReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSelfAppHashReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.KeyId))
	}
	if len(m.AppHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsession(dAtA, i, uint64(len(m.AppHash)))
		i += copy(dAtA[i:], m.AppHash)
	}
	return i, nil
}

func (m *UpdateSelfAppHashResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSelfAppHashResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsession(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func encodeVarintImsession(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ClearKeyIdSessionReq) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovImsession(uint64(m.Uid))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *ClearKeyIdSessionResp) Size() (n int) {
	var l int
	_ = l
	if m.Sucess {
		n += 2
	}
	return n
}

func (m *SetLangCodeReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SetLangCodeResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *GetLangCodeReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *GetLangCodeResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *GetUniqueNumberByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *GetUniqueNumberByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionDisconnectReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.Disconnect {
		n += 2
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionDisconnectResult) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SessionInitConnectionReq) Size() (n int) {
	var l int
	_ = l
	if m.ApiId != 0 {
		n += 1 + sovImsession(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovImsession(uint64(m.Layer))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionInitConnectionResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionUpdateRegisterDeviceReq) Size() (n int) {
	var l int
	_ = l
	if m.PushTokenType != 0 {
		n += 1 + sovImsession(uint64(m.PushTokenType))
	}
	l = len(m.PushToken)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	if m.CallTokenType != 0 {
		n += 1 + sovImsession(uint64(m.CallTokenType))
	}
	l = len(m.CallToken)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionUpdateRegisterDeviceResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionUpdateRegisterHuaweiDeviceReq) Size() (n int) {
	var l int
	_ = l
	if m.PushTokenType != 0 {
		n += 1 + sovImsession(uint64(m.PushTokenType))
	}
	l = len(m.PushToken)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	if m.CallTokenType != 0 {
		n += 1 + sovImsession(uint64(m.CallTokenType))
	}
	l = len(m.CallToken)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionUpdateRegisterHuaweiDeviceResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *SessionUpdateUserPhoneReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	l = len(m.NewPhone)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionUpdateUserPhoneResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionQueryApiIDbyKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *SessionQueryApiIDbyKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.ApiId != 0 {
		n += 1 + sovImsession(uint64(m.ApiId))
	}
	if m.InternalError {
		n += 2
	}
	return n
}

func (m *SessionQueryUserIdByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *SessionQueryUserIdByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.InternalError {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	return n
}

func (m *SessionUpdateOnHandshakeDoneReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionUpdateOnHandshakeDoneResult) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionIncQtsReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *SessionIncQtsResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if m.Qts != 0 {
		n += 1 + sovImsession(uint64(m.Qts))
	}
	return n
}

func (m *SessionTerminateByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	if m.CurrentKeyId != 0 {
		n += 1 + sovImsession(uint64(m.CurrentKeyId))
	}
	return n
}

func (m *SessionTerminateByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionTerminateExceptKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	return n
}

func (m *SessionTerminateExceptKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionUpdateLogoutReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	return n
}

func (m *SessionUpdateLogoutResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *CheckBanDeviceReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.UniqueNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *CheckBanDeviceResult) Size() (n int) {
	var l int
	_ = l
	if m.Banned {
		n += 2
	}
	return n
}

func (m *AddBanDeviceReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *AddBanDeviceResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionDeleteByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	return n
}

func (m *SessionDeleteByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionQueryByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *SessionQueryByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionInformation) Size() (n int) {
	var l int
	_ = l
	if m.ApiId != 0 {
		n += 1 + sovImsession(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovImsession(uint64(m.Layer))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.Qts != 0 {
		n += 1 + sovImsession(uint64(m.Qts))
	}
	if m.PushTokenType != 0 {
		n += 1 + sovImsession(uint64(m.PushTokenType))
	}
	l = len(m.PushToken)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.CallTokenType != 0 {
		n += 1 + sovImsession(uint64(m.CallTokenType))
	}
	l = len(m.CallToken)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.PingTime != 0 {
		n += 1 + sovImsession(uint64(m.PingTime))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 2 + l + sovImsession(uint64(l))
	}
	if m.UserId != 0 {
		n += 2 + sovImsession(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 2 + sovImsession(uint64(m.AccessHash))
	}
	if m.Seq != 0 {
		n += 2 + sovImsession(uint64(m.Seq))
	}
	if m.KeyId != 0 {
		n += 2 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 2 + l + sovImsession(uint64(l))
	}
	if m.Disconnect {
		n += 3
	}
	return n
}

func (m *SessionUpdateSignInReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsession(uint64(m.AccessHash))
	}
	if m.IsPrivilegedVersion {
		n += 2
	}
	return n
}

func (m *SessionUpdateSignInResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func (m *SessionQueryByUserIdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	return n
}

func (m *SessionQueryByUserIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovImsession(uint64(l))
		}
	}
	return n
}

func (m *SessionQueryBasicInfoByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *SessionQueryBasicInfoByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionQueryDesByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *SessionQueryDesByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *SessionDeleteAuthKeysByUserIdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	return n
}

func (m *SessionDeleteAuthKeysByUserIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if len(m.KeyIds) > 0 {
		l = 0
		for _, e := range m.KeyIds {
			l += sovImsession(uint64(e))
		}
		n += 1 + sovImsession(uint64(l)) + l
	}
	return n
}

func (m *SessionUpdatePingReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	if m.PingTime != 0 {
		n += 1 + sovImsession(uint64(m.PingTime))
	}
	if m.UpdateTime {
		n += 2
	}
	return n
}

func (m *SessionUpdatePingReq2) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	if m.PingTime != 0 {
		n += 1 + sovImsession(uint64(m.PingTime))
	}
	if m.UpdateTime {
		n += 2
	}
	return n
}

func (m *SessionUpdatePingResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if m.UserId != 0 {
		n += 1 + sovImsession(uint64(m.UserId))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *GetCreatedByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	return n
}

func (m *GetCreatedByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	if m.Created != 0 {
		n += 1 + sovImsession(uint64(m.Created))
	}
	return n
}

func (m *UpdateSelfAppHashReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsession(uint64(m.KeyId))
	}
	l = len(m.AppHash)
	if l > 0 {
		n += 1 + l + sovImsession(uint64(l))
	}
	return n
}

func (m *UpdateSelfAppHashResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsession(uint64(m.Code))
	}
	return n
}

func sovImsession(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImsession(x uint64) (n int) {
	return sovImsession(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClearKeyIdSessionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearKeyIdSessionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearKeyIdSessionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearKeyIdSessionResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearKeyIdSessionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearKeyIdSessionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sucess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sucess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetLangCodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetLangCodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetLangCodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetLangCodeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetLangCodeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetLangCodeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SetLangCodeResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLangCodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLangCodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLangCodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLangCodeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLangCodeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLangCodeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (GetLangCodeResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUniqueNumberByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUniqueNumberByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDisconnectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDisconnectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDisconnectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disconnect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disconnect = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDisconnectResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDisconnectResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDisconnectResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionInitConnectionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionInitConnectionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionInitConnectionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionInitConnectionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionInitConnectionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionInitConnectionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionInitConnectionResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateRegisterDeviceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTokenType", wireType)
			}
			m.PushTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallTokenType", wireType)
			}
			m.CallTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateRegisterDeviceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateRegisterDeviceResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateRegisterHuaweiDeviceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateRegisterHuaweiDeviceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateRegisterHuaweiDeviceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTokenType", wireType)
			}
			m.PushTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallTokenType", wireType)
			}
			m.CallTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateRegisterHuaweiDeviceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateRegisterHuaweiDeviceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateRegisterHuaweiDeviceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateRegisterHuaweiDeviceResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateUserPhoneReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateUserPhoneReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateUserPhoneReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateUserPhoneResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateUserPhoneResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateUserPhoneResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateUserPhoneResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryApiIDbyKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryApiIDbyKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalError = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryUserIdByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryUserIdByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryUserIdByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryUserIdByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryUserIdByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryUserIdByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalError = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateOnHandshakeDoneReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateOnHandshakeDoneResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateOnHandshakeDoneResult_FailCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionIncQtsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionIncQtsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionIncQtsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionIncQtsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionIncQtsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionIncQtsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionIncQtsResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentKeyId", wireType)
			}
			m.CurrentKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentKeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionTerminateByKeyIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateExceptKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateExceptKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionTerminateExceptKeyIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateLogoutReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateLogoutReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateLogoutReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateLogoutResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateLogoutResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateLogoutResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateLogoutResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckBanDeviceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckBanDeviceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckBanDeviceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckBanDeviceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckBanDeviceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckBanDeviceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Banned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Banned = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddBanDeviceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBanDeviceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBanDeviceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddBanDeviceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBanDeviceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBanDeviceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (AddBanDeviceResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDeleteByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDeleteByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDeleteByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDeleteByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDeleteByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDeleteByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionDeleteByKeyIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionQueryByKeyIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SessionInformation{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionInformation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionInformation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionInformation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTokenType", wireType)
			}
			m.PushTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallTokenType", wireType)
			}
			m.CallTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingTime", wireType)
			}
			m.PingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disconnect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disconnect = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateSignInReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateSignInReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateSignInReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrivilegedVersion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrivilegedVersion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateSignInResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateSignInResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateSignInResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateSignInResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByUserIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByUserIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByUserIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByUserIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByUserIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByUserIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionQueryByUserIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &SessionInformation{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryBasicInfoByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryBasicInfoByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryBasicInfoByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryBasicInfoByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryBasicInfoByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryBasicInfoByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionQueryBasicInfoByKeyIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryDesByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryDesByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryDesByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryDesByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryDesByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryDesByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionQueryDesByKeyIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDeleteAuthKeysByUserIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDeleteAuthKeysByUserIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDeleteAuthKeysByUserIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDeleteAuthKeysByUserIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDeleteAuthKeysByUserIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDeleteAuthKeysByUserIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionDeleteAuthKeysByUserIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImsession
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyIds = append(m.KeyIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImsession
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImsession
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImsession
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyIds = append(m.KeyIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdatePingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdatePingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdatePingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingTime", wireType)
			}
			m.PingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateTime = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdatePingReq2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdatePingReq2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdatePingReq2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingTime", wireType)
			}
			m.PingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateTime = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdatePingResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdatePingResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdatePingResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdatePingResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCreatedByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCreatedByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCreatedByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCreatedByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCreatedByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCreatedByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (GetCreatedByKeyIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSelfAppHashReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSelfAppHashReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSelfAppHashReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImsession
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSelfAppHashResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSelfAppHashResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSelfAppHashResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (UpdateSelfAppHashResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsession(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsession
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImsession(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImsession
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImsession
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImsession
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImsession
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImsession(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImsession = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImsession   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("imsession.proto", fileDescriptorImsession) }

var fileDescriptorImsession = []byte{
	// 2319 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0xcd, 0x6f, 0x1c, 0x49,
	0x15, 0x9f, 0xf6, 0x78, 0x6c, 0xcf, 0xb3, 0x3d, 0xb1, 0x2b, 0xfe, 0x18, 0x77, 0x12, 0xdb, 0xa9,
	0x38, 0x71, 0xb2, 0x6c, 0x1c, 0x76, 0x02, 0xcb, 0xa2, 0x65, 0x85, 0xfc, 0x91, 0xb5, 0x07, 0x67,
	0xb3, 0xf1, 0x38, 0x46, 0x68, 0x85, 0x18, 0x3a, 0xd3, 0x15, 0xbb, 0xe5, 0x99, 0x9e, 0x9e, 0xee,
	0x9e, 0x64, 0x47, 0x48, 0x2b, 0x0e, 0x70, 0x59, 0x21, 0x84, 0xd0, 0xc2, 0x05, 0x69, 0x4f, 0x48,
	0x1c, 0xf8, 0x07, 0x10, 0x27, 0x38, 0xac, 0x84, 0xc4, 0x05, 0x71, 0xe4, 0x84, 0xf2, 0x7f, 0x20,
	0x50, 0x57, 0xf5, 0x74, 0x77, 0x75, 0x57, 0x4d, 0x77, 0x6b, 0xc4, 0x4a, 0x70, 0xb2, 0xbb, 0xa6,
	0xde, 0xeb, 0x7a, 0xbf, 0x7a, 0xf5, 0x3e, 0x7e, 0xd5, 0x70, 0xc5, 0xe8, 0x38, 0xc4, 0x71, 0x8c,
	0xae, 0xb9, 0x63, 0xd9, 0x5d, 0xb7, 0x8b, 0xca, 0xc1, 0x00, 0xfe, 0x36, 0x2c, 0xed, 0xb7, 0x89,
	0x66, 0x1f, 0x93, 0x41, 0x5d, 0x3f, 0x65, 0x83, 0x0d, 0xd2, 0x43, 0x0b, 0x50, 0x3c, 0x33, 0xf4,
	0xaa, 0xb2, 0xa9, 0xdc, 0x2d, 0x35, 0xbc, 0x7f, 0xd1, 0x32, 0x4c, 0x5d, 0x92, 0x41, 0xd3, 0xd0,
	0xab, 0x13, 0x9b, 0xca, 0xdd, 0xc9, 0x46, 0xe9, 0xd2, 0x13, 0xc1, 0x0f, 0x60, 0x59, 0xa0, 0xc0,
	0xb1, 0xd0, 0x0a, 0x4c, 0x39, 0xfd, 0x16, 0x71, 0x1c, 0xaa, 0x64, 0xa6, 0xe1, 0x3f, 0xe1, 0x03,
	0xa8, 0x9c, 0x12, 0xf7, 0xb1, 0x66, 0x9e, 0xef, 0x77, 0x75, 0xe2, 0xbd, 0x2b, 0xd4, 0xec, 0xcd,
	0x2c, 0xfa, 0x9a, 0xd1, 0x35, 0x28, 0xb7, 0x35, 0xf3, 0xbc, 0xd9, 0xea, 0xea, 0x84, 0xbe, 0xb3,
	0xdc, 0x98, 0x69, 0xfb, 0x62, 0xf8, 0x13, 0x58, 0xe4, 0xb4, 0x38, 0xfd, 0xb6, 0x8b, 0xde, 0x85,
	0x49, 0x3a, 0xd9, 0x53, 0x53, 0xa9, 0x6d, 0xef, 0x84, 0x76, 0x27, 0xe6, 0xee, 0xb0, 0x3f, 0x74,
	0x80, 0x0a, 0xe1, 0x37, 0x01, 0xc2, 0x31, 0x34, 0x0b, 0xd3, 0xa7, 0xfd, 0x96, 0xb7, 0xe0, 0x85,
	0x02, 0x5a, 0x84, 0xf9, 0xba, 0xe9, 0x12, 0xdb, 0xd4, 0xda, 0x8f, 0x6c, 0xbb, 0x6b, 0x2f, 0x28,
	0x78, 0x1b, 0x2a, 0x87, 0x59, 0xac, 0xc0, 0xbf, 0x51, 0x60, 0xf1, 0x30, 0xc7, 0x4a, 0x0f, 0x53,
	0x57, 0x3a, 0x1a, 0x98, 0x7c, 0x66, 0xd4, 0x60, 0xed, 0x90, 0xb8, 0x67, 0xa6, 0xd1, 0xeb, 0x93,
	0x27, 0xfd, 0xce, 0x73, 0x62, 0xef, 0x0d, 0xe8, 0x4e, 0x8e, 0xb0, 0x68, 0x1f, 0xae, 0xcb, 0x64,
	0xa8, 0x6d, 0xb7, 0x60, 0xbe, 0x4f, 0x7f, 0x6c, 0x9a, 0xf4, 0x57, 0x2a, 0x5d, 0x6e, 0xcc, 0xf5,
	0x23, 0x12, 0xf8, 0x77, 0x0a, 0x2c, 0xf9, 0xde, 0x72, 0x60, 0x38, 0xad, 0xae, 0x69, 0x92, 0x96,
	0x9b, 0x7c, 0xe9, 0xd0, 0xcd, 0xd0, 0x4d, 0x98, 0xb3, 0x2e, 0xba, 0x66, 0xa0, 0x93, 0x99, 0x3d,
	0x4b, 0xc7, 0x98, 0x4a, 0xb4, 0x0e, 0xa0, 0x07, 0xaa, 0xaa, 0x45, 0xea, 0x74, 0x91, 0x11, 0x0f,
	0xb6, 0x56, 0xdb, 0x20, 0xa6, 0xdb, 0x34, 0xac, 0xea, 0x24, 0x83, 0x8d, 0x0d, 0xd4, 0x2d, 0x54,
	0x85, 0xe9, 0x56, 0xb7, 0x6f, 0xba, 0xf6, 0xa0, 0x5a, 0xa2, 0x3f, 0x0d, 0x1f, 0xf1, 0x1a, 0xac,
	0x0a, 0x16, 0xea, 0x59, 0x8a, 0x7f, 0x3f, 0x01, 0x55, 0xff, 0xb7, 0xba, 0x69, 0xb8, 0xfb, 0xec,
	0x47, 0xff, 0x04, 0x2d, 0xc3, 0x94, 0x66, 0x19, 0xcd, 0xe0, 0x10, 0x95, 0x34, 0xcb, 0x60, 0x86,
	0xe8, 0xe4, 0xa5, 0xd1, 0x22, 0xcd, 0x4e, 0x57, 0x27, 0xed, 0xa1, 0x21, 0x6c, 0xec, 0x03, 0x6f,
	0x08, 0xdd, 0x86, 0x8a, 0x33, 0x70, 0x5c, 0xd2, 0x69, 0xbe, 0x24, 0xb6, 0xa7, 0x9c, 0x1a, 0x53,
	0x6e, 0xcc, 0xb3, 0xd1, 0xef, 0xb2, 0x41, 0xb4, 0x01, 0xb3, 0x9a, 0x65, 0x05, 0x73, 0x98, 0x45,
	0xa0, 0x59, 0xd6, 0x70, 0x02, 0xe7, 0x27, 0x25, 0xde, 0x4f, 0x50, 0x05, 0x26, 0x0c, 0xab, 0x3a,
	0x45, 0x47, 0x27, 0x0c, 0x0e, 0x80, 0x69, 0x0e, 0x00, 0xb4, 0x04, 0xa5, 0xb6, 0x36, 0x20, 0x76,
	0x75, 0x86, 0xd9, 0x41, 0x1f, 0x22, 0xfb, 0x54, 0x8e, 0xee, 0xd3, 0x1a, 0xcc, 0x78, 0x8b, 0x32,
	0xb5, 0x0e, 0xa9, 0x02, 0xd3, 0xa3, 0x59, 0xd6, 0x13, 0xad, 0x43, 0xf0, 0x2f, 0x15, 0xb8, 0x26,
	0x41, 0x8b, 0xfa, 0xcd, 0x23, 0xee, 0x4c, 0xbc, 0xc5, 0x9d, 0x5e, 0xa9, 0xd4, 0xb8, 0xe7, 0xf8,
	0x0b, 0x05, 0xd6, 0x7d, 0xf5, 0x67, 0x96, 0xae, 0xb9, 0xa4, 0x41, 0xce, 0x0d, 0xc7, 0x25, 0xf6,
	0x01, 0xdd, 0x10, 0x6f, 0x23, 0xef, 0xc0, 0x15, 0xab, 0xef, 0x5c, 0x34, 0xdd, 0xee, 0x25, 0x31,
	0x9b, 0xee, 0xc0, 0x22, 0xfe, 0x8e, 0xce, 0x7b, 0xc3, 0xcf, 0xbc, 0xd1, 0x67, 0x03, 0x8b, 0xa0,
	0x1b, 0x00, 0xe1, 0x3c, 0x7f, 0x5f, 0xcb, 0xc1, 0x94, 0x08, 0x60, 0xc5, 0x28, 0x60, 0x77, 0xe0,
	0x4a, 0x4b, 0x6b, 0xb7, 0xa3, 0xda, 0x27, 0x99, 0x76, 0x6f, 0x98, 0xd3, 0x1e, 0xce, 0xf3, 0x77,
	0xb3, 0x1c, 0x4c, 0xc1, 0x9f, 0x2b, 0x70, 0x73, 0xa4, 0x1d, 0x14, 0xe2, 0x63, 0x0e, 0xe2, 0x6f,
	0x24, 0x21, 0x96, 0xcb, 0x8e, 0x0b, 0xf4, 0x5f, 0x15, 0xd8, 0x12, 0xbe, 0xe4, 0xa8, 0xaf, 0xbd,
	0x22, 0xc6, 0xff, 0x18, 0xdc, 0xff, 0x50, 0x60, 0x3b, 0x83, 0x35, 0x14, 0xf4, 0x13, 0x0e, 0xf4,
	0xf7, 0xd2, 0x40, 0x4f, 0x6a, 0x48, 0x66, 0x80, 0x55, 0x98, 0xee, 0x3b, 0xc4, 0x1e, 0x26, 0xe3,
	0x52, 0x63, 0xca, 0x7b, 0xac, 0xeb, 0x12, 0xab, 0x73, 0x6e, 0xd5, 0x09, 0xac, 0x71, 0x2b, 0x3b,
	0x73, 0x88, 0xfd, 0xd4, 0x0b, 0xb4, 0xde, 0xf6, 0x44, 0x5e, 0xad, 0x70, 0xaf, 0xbe, 0x06, 0x65,
	0x93, 0xbc, 0x6a, 0xd2, 0x88, 0x3c, 0xcc, 0x4a, 0x26, 0x79, 0x45, 0x05, 0xf1, 0x67, 0x0a, 0x5c,
	0x97, 0xe9, 0xa4, 0x20, 0xbd, 0xcf, 0x81, 0x54, 0x93, 0x81, 0x14, 0x13, 0x1b, 0xd7, 0x29, 0xbf,
	0x16, 0x44, 0xa4, 0x93, 0x3e, 0xb1, 0x07, 0xbb, 0x96, 0x51, 0x3f, 0x78, 0x2e, 0x4b, 0x80, 0x01,
	0x9a, 0x3f, 0x08, 0x42, 0x86, 0x40, 0x8a, 0x5a, 0x23, 0x89, 0xfd, 0xb7, 0xa1, 0x62, 0xf8, 0x2b,
	0x68, 0x12, 0x6f, 0x09, 0x14, 0xa7, 0x99, 0xc6, 0xbc, 0x11, 0x5d, 0x17, 0xfe, 0x7a, 0x80, 0x15,
	0xd5, 0x7f, 0x46, 0xf1, 0xdd, 0x4b, 0x5d, 0x96, 0x06, 0x1b, 0x23, 0xc4, 0xe8, 0xba, 0x92, 0x0b,
	0x50, 0x04, 0x0b, 0x90, 0xba, 0x17, 0x3e, 0x0d, 0x5e, 0xc1, 0xb6, 0xe3, 0x43, 0xf3, 0x48, 0x33,
	0x75, 0xe7, 0x42, 0xbb, 0x24, 0x07, 0xbe, 0x7f, 0x48, 0xf2, 0xb7, 0x97, 0x17, 0xfa, 0xee, 0x45,
	0xf3, 0x92, 0x0c, 0xa8, 0xce, 0xb9, 0xc6, 0xb4, 0xf7, 0x7c, 0x4c, 0x06, 0xf8, 0x0f, 0x0a, 0xe0,
	0xd1, 0x5a, 0xe9, 0xda, 0xab, 0x30, 0xed, 0xb0, 0xbd, 0xf4, 0x17, 0x3d, 0x7c, 0x44, 0xdf, 0xf1,
	0x7d, 0x67, 0x82, 0xfa, 0xce, 0xdb, 0x32, 0xdf, 0x11, 0xaa, 0xdd, 0x79, 0x5f, 0x33, 0xda, 0x9c,
	0xff, 0xcc, 0x0c, 0x47, 0xd0, 0x1c, 0xcc, 0x0c, 0x1d, 0x66, 0xa1, 0x80, 0x10, 0x54, 0x0e, 0xfa,
	0x56, 0xdb, 0x68, 0x69, 0x2e, 0x39, 0x26, 0x03, 0x43, 0x5f, 0x50, 0xf0, 0x3d, 0x58, 0x08, 0x72,
	0x53, 0xeb, 0xc4, 0x75, 0x46, 0xec, 0xce, 0x67, 0x0a, 0x5c, 0x8d, 0xcd, 0xa5, 0x66, 0xbd, 0xc7,
	0x39, 0xfe, 0x3d, 0x51, 0xd6, 0x0b, 0x67, 0x27, 0x23, 0xc1, 0x02, 0x14, 0x7b, 0xae, 0xe3, 0x6f,
	0x93, 0xf7, 0x6f, 0xce, 0x13, 0xf0, 0x2b, 0x05, 0x54, 0xff, 0x45, 0xcf, 0x88, 0xdd, 0x31, 0x4c,
	0xcd, 0x25, 0xa9, 0xae, 0x96, 0xa5, 0x1a, 0x8b, 0xf8, 0x50, 0x91, 0x8b, 0x13, 0x5b, 0x50, 0x69,
	0xf5, 0x6d, 0xdb, 0xab, 0xc3, 0x7c, 0xd5, 0x93, 0x54, 0xf5, 0x9c, 0x3f, 0x4a, 0xdf, 0x8d, 0x7f,
	0xad, 0xc0, 0x0d, 0xe9, 0xba, 0x28, 0x70, 0x87, 0x1c, 0x70, 0x0f, 0x93, 0xc0, 0x89, 0xe5, 0xc6,
	0x0d, 0x19, 0x4e, 0x70, 0xf8, 0x03, 0xfd, 0x8f, 0x3e, 0x6e, 0x11, 0xcb, 0xfd, 0x2f, 0x62, 0x16,
	0xcd, 0xee, 0xe2, 0xb7, 0x66, 0xcb, 0xee, 0x72, 0xd9, 0x71, 0x51, 0x39, 0x82, 0x15, 0xee, 0xac,
	0x3d, 0xee, 0x9e, 0x77, 0xfb, 0xa3, 0xea, 0x79, 0x69, 0x88, 0xf9, 0xb9, 0x12, 0xcb, 0x3e, 0x43,
	0x55, 0xd4, 0xc4, 0x7d, 0xce, 0xc4, 0x07, 0xb2, 0xa3, 0x1e, 0x95, 0x19, 0xd7, 0xb4, 0x0f, 0x61,
	0x71, 0xff, 0x82, 0xb4, 0x2e, 0xf7, 0x34, 0x33, 0x2c, 0x52, 0x24, 0x56, 0x25, 0x5a, 0x9f, 0x09,
	0x41, 0xeb, 0xb3, 0x03, 0x4b, 0x71, 0x85, 0xd4, 0xb6, 0x15, 0x98, 0xda, 0xd3, 0x4c, 0x93, 0xe8,
	0xc3, 0x86, 0x99, 0x3d, 0xe1, 0xb7, 0xe1, 0xca, 0xae, 0xae, 0x73, 0xaf, 0xcf, 0xd4, 0x62, 0xfd,
	0x58, 0x01, 0xc4, 0x0b, 0xd2, 0xd7, 0x7c, 0x8b, 0x83, 0xf0, 0x6e, 0x04, 0xc2, 0xe4, 0xe4, 0x71,
	0xb1, 0xab, 0x87, 0xbd, 0x13, 0x69, 0x93, 0x2c, 0x91, 0x45, 0xea, 0x17, 0xbf, 0x08, 0x03, 0x55,
	0x4c, 0x17, 0xb5, 0xea, 0x80, 0xb3, 0xea, 0xab, 0x49, 0xc7, 0x10, 0x08, 0x8d, 0x6b, 0xdd, 0x83,
	0xc0, 0xe9, 0x69, 0xc2, 0x4d, 0xcf, 0xd0, 0x7f, 0x0e, 0x7d, 0x9b, 0x97, 0xc8, 0xe6, 0xdb, 0x49,
	0x99, 0x64, 0x3e, 0x78, 0x0b, 0x26, 0x0d, 0xf3, 0x45, 0x97, 0x82, 0x37, 0x5b, 0xbb, 0x21, 0x4a,
	0x27, 0x2f, 0xba, 0x76, 0x47, 0xa3, 0x1d, 0x14, 0x9d, 0x9a, 0xd3, 0xe8, 0x9f, 0x95, 0x00, 0x25,
	0x55, 0xfd, 0xbf, 0x77, 0xbb, 0xd1, 0xf2, 0xa5, 0xcc, 0x95, 0x2f, 0xc3, 0x0c, 0x0c, 0x41, 0x06,
	0x16, 0x75, 0x30, 0xb3, 0xe9, 0x1d, 0xcc, 0x5c, 0xbc, 0x83, 0x11, 0xb4, 0x2a, 0xf3, 0xe9, 0xad,
	0x4a, 0x25, 0xd6, 0xaa, 0x78, 0xb8, 0x58, 0x86, 0x79, 0xde, 0x74, 0x8d, 0x0e, 0xa9, 0x5e, 0xa1,
	0x44, 0xce, 0x8c, 0x37, 0xf0, 0xcc, 0xe8, 0x90, 0x44, 0x52, 0x5a, 0x18, 0x99, 0x94, 0x16, 0xb9,
	0x44, 0xee, 0xed, 0x08, 0x75, 0x94, 0xe6, 0x85, 0xe6, 0x5c, 0x54, 0x11, 0x55, 0x0d, 0x6c, 0xe8,
	0x48, 0x73, 0x2e, 0x3c, 0x64, 0x1c, 0xd2, 0xab, 0x5e, 0x65, 0xc8, 0x38, 0xdc, 0xb9, 0x58, 0x92,
	0x91, 0x06, 0xcb, 0x1c, 0x69, 0x10, 0x23, 0x75, 0x56, 0xe2, 0xa4, 0x0e, 0xfe, 0x93, 0x12, 0xcb,
	0x3c, 0xa7, 0xc6, 0xb9, 0x59, 0xa7, 0x04, 0x4c, 0xdc, 0x36, 0x25, 0x69, 0x9b, 0x98, 0xd3, 0x94,
	0xd7, 0x2e, 0x31, 0x93, 0x27, 0x13, 0x26, 0xd7, 0x60, 0xd9, 0x70, 0x9a, 0x96, 0x6d, 0xbc, 0x34,
	0xda, 0xe4, 0x9c, 0xe8, 0x81, 0xbf, 0x96, 0xe8, 0xca, 0xaf, 0x1a, 0xce, 0xd3, 0xe0, 0x37, 0xdf,
	0x71, 0x93, 0x19, 0x6f, 0x68, 0x42, 0x9e, 0x8c, 0x17, 0x95, 0x19, 0x37, 0xae, 0xd5, 0x82, 0xa8,
	0xed, 0x47, 0x1c, 0xd6, 0x4a, 0x8c, 0xea, 0xfe, 0xf0, 0x17, 0x61, 0x78, 0x8e, 0x09, 0x65, 0x0b,
	0xcf, 0x02, 0xa1, 0x64, 0x70, 0x7b, 0x08, 0x25, 0x2f, 0x62, 0x79, 0xe5, 0x6e, 0x31, 0x3d, 0xba,
	0xb1, 0xb9, 0x39, 0x6d, 0x7f, 0x87, 0x6f, 0xa2, 0xf6, 0x34, 0xc7, 0x68, 0x79, 0x4a, 0xd3, 0x83,
	0xfb, 0xbf, 0xc2, 0x36, 0x46, 0x22, 0x4a, 0x91, 0x78, 0xcc, 0x21, 0xf1, 0x8e, 0x0c, 0x09, 0xa1,
	0x70, 0x0e, 0x22, 0x20, 0xee, 0xfc, 0xc5, 0xa4, 0xf3, 0xa7, 0x45, 0xd4, 0xfc, 0x54, 0x72, 0xd4,
	0x82, 0x03, 0xe2, 0xa4, 0x63, 0xf6, 0x6f, 0x85, 0x6f, 0x75, 0xa3, 0x42, 0xd9, 0x68, 0x01, 0xa1,
	0x58, 0x12, 0xa7, 0x2f, 0x2f, 0x0f, 0xe5, 0x44, 0xed, 0x5d, 0xd8, 0xe4, 0x0a, 0x94, 0x5d, 0x96,
	0x55, 0x9c, 0x4c, 0x87, 0xee, 0x8f, 0x0a, 0xdc, 0x4a, 0x91, 0xa6, 0x28, 0x7e, 0xc0, 0xa1, 0xf8,
	0x4d, 0x59, 0x71, 0x24, 0x96, 0x4e, 0x82, 0xb9, 0x42, 0x37, 0xb3, 0xae, 0xb3, 0x73, 0x58, 0x6c,
	0xf8, 0x4f, 0x39, 0x2d, 0xff, 0x49, 0x78, 0x03, 0xc0, 0x42, 0xd8, 0x53, 0xc3, 0x3c, 0x1f, 0xc9,
	0x30, 0x49, 0xa2, 0x35, 0x97, 0xe0, 0x8a, 0xb1, 0x04, 0xb7, 0x01, 0xb3, 0x7d, 0xaa, 0x9d, 0xfd,
	0x3c, 0xc9, 0x12, 0x08, 0x1b, 0xf2, 0x26, 0xe0, 0x9f, 0x2a, 0xb0, 0x2c, 0x5a, 0x46, 0xed, 0x4b,
	0x5e, 0xc7, 0xdf, 0x95, 0x20, 0xea, 0x46, 0xd7, 0x41, 0xf7, 0x6f, 0x97, 0xdb, 0xbf, 0xfb, 0xb2,
	0x1c, 0x10, 0x4a, 0xe4, 0x08, 0x14, 0x4b, 0x50, 0x62, 0x94, 0x1d, 0xf3, 0x76, 0xf6, 0x80, 0x1f,
	0xe5, 0xd9, 0x4a, 0xb4, 0x0a, 0x57, 0x3d, 0xdf, 0xb9, 0x24, 0x83, 0x33, 0xd3, 0xf6, 0x69, 0x4c,
	0xa2, 0x2f, 0x4c, 0xe0, 0xfb, 0xb0, 0x74, 0x48, 0xdc, 0x7d, 0x9b, 0x68, 0x2e, 0xc9, 0xc0, 0x60,
	0xfd, 0x56, 0x81, 0x55, 0xc1, 0xfc, 0x14, 0x0c, 0x24, 0x12, 0x49, 0x0c, 0xbc, 0xa2, 0x8f, 0x4d,
	0xf4, 0x31, 0x18, 0x3e, 0xe6, 0x6e, 0x76, 0x97, 0xfc, 0xa4, 0x4b, 0xda, 0x2f, 0x76, 0x2d, 0xcb,
	0xcb, 0xfc, 0x29, 0xd4, 0x97, 0x65, 0xb1, 0x8a, 0x61, 0x22, 0xa8, 0x6e, 0x3c, 0x21, 0xfc, 0xa9,
	0x02, 0xab, 0x02, 0x55, 0x29, 0x06, 0x4b, 0x24, 0xc6, 0x4c, 0xfb, 0xb5, 0xcf, 0x57, 0x21, 0xbc,
	0x18, 0x46, 0xdf, 0x83, 0xc5, 0xc4, 0xbd, 0x2e, 0xda, 0x88, 0xac, 0x42, 0x74, 0x6d, 0xac, 0x6e,
	0x8e, 0x9e, 0xe0, 0x58, 0xb8, 0x80, 0x5e, 0x04, 0x07, 0x8e, 0xbf, 0xd0, 0x41, 0xb7, 0xd2, 0xaf,
	0x7c, 0x7a, 0xea, 0x9d, 0x6c, 0xf7, 0x42, 0xb8, 0x80, 0x3e, 0x0e, 0xc8, 0x5d, 0xd1, 0xad, 0x06,
	0xba, 0x97, 0xf5, 0xf6, 0xa3, 0xa7, 0xbe, 0x99, 0xe7, 0xa2, 0x04, 0x17, 0xd0, 0xa7, 0xb2, 0xcb,
	0x98, 0x28, 0xb7, 0x8f, 0x1e, 0xe4, 0xbb, 0x09, 0xe8, 0xa9, 0xb5, 0xfc, 0x57, 0x07, 0xb8, 0x80,
	0x8c, 0x58, 0x81, 0x1c, 0x50, 0xe8, 0x68, 0x2b, 0x03, 0xcb, 0xde, 0x53, 0xb7, 0x33, 0x72, 0xf1,
	0xb8, 0x80, 0x7e, 0x18, 0x50, 0x9c, 0x51, 0x1a, 0x06, 0xdd, 0x4c, 0xa3, 0x69, 0x7a, 0xea, 0x56,
	0x16, 0x26, 0x07, 0x17, 0xd0, 0x8f, 0x62, 0xd7, 0x08, 0x31, 0x4e, 0x17, 0xbd, 0x91, 0x99, 0xfc,
	0xed, 0xa9, 0xf7, 0x73, 0x11, 0xc5, 0xb8, 0x80, 0xda, 0x41, 0x84, 0x8e, 0x53, 0x8b, 0xe8, 0x76,
	0x16, 0xfa, 0xb1, 0xa7, 0xde, 0xcd, 0xca, 0x52, 0x72, 0xee, 0x2b, 0xa2, 0xed, 0x44, 0xee, 0x2b,
	0x21, 0x24, 0x45, 0xee, 0x2b, 0x67, 0x02, 0x71, 0x01, 0xb5, 0xc2, 0xab, 0xf9, 0x28, 0x69, 0x82,
	0x70, 0x2a, 0xab, 0xd2, 0x53, 0x6f, 0x67, 0x62, 0x5e, 0x70, 0x01, 0x3d, 0x81, 0x79, 0x8e, 0xe0,
	0x46, 0xd7, 0xe4, 0xd4, 0x77, 0x4f, 0x5d, 0x1f, 0xcd, 0x8b, 0x73, 0xbe, 0x17, 0xa5, 0x49, 0x44,
	0xbe, 0x17, 0x23, 0x6b, 0x44, 0xbe, 0x97, 0x64, 0x5a, 0x38, 0x58, 0xb8, 0x66, 0x45, 0x04, 0x4b,
	0xbc, 0x6f, 0x12, 0xc1, 0x22, 0xe8, 0x78, 0x38, 0x07, 0x17, 0xf6, 0x01, 0x22, 0x07, 0x97, 0x35,
	0x2a, 0x22, 0x07, 0x1f, 0xd1, 0x5c, 0x70, 0xa1, 0x22, 0x56, 0x56, 0xa3, 0xad, 0x0c, 0x95, 0xb7,
	0x30, 0x54, 0x08, 0xeb, 0x73, 0x5c, 0x40, 0x9f, 0x04, 0xf4, 0xbe, 0xb8, 0xf6, 0x44, 0x5f, 0xc9,
	0x5e, 0xa5, 0xf6, 0xd4, 0x9d, 0x7c, 0x25, 0x2d, 0x2e, 0xa0, 0x8f, 0x60, 0x31, 0x51, 0x3b, 0x71,
	0xe9, 0x4d, 0x54, 0x13, 0xaa, 0x38, 0xbd, 0xf4, 0xc2, 0x05, 0xf4, 0xfd, 0x80, 0x21, 0x0b, 0x7f,
	0xac, 0xa1, 0xcd, 0x14, 0xe5, 0xb5, 0x8c, 0xda, 0xe3, 0x41, 0x96, 0x75, 0xfe, 0xf2, 0x20, 0x1b,
	0x10, 0x22, 0xf2, 0x20, 0x1b, 0x25, 0x0f, 0x70, 0x01, 0x75, 0x83, 0xaf, 0x5a, 0x12, 0xf7, 0x9b,
	0xe8, 0x8e, 0x64, 0x8b, 0x63, 0x57, 0xa7, 0xea, 0xbd, 0x4c, 0xf3, 0xfc, 0x17, 0xda, 0x7c, 0xeb,
	0xc8, 0xdd, 0x5c, 0x22, 0x99, 0x53, 0xc5, 0xaf, 0x45, 0xd5, 0x37, 0xb2, 0x4d, 0x4c, 0x38, 0x40,
	0xf8, 0x59, 0x8f, 0xc8, 0x01, 0xb8, 0xaf, 0x93, 0x44, 0x5b, 0x94, 0xf8, 0x2a, 0xa8, 0x80, 0x8e,
	0x61, 0x2e, 0xca, 0xa5, 0x23, 0x55, 0x4a, 0xb2, 0xf7, 0xd4, 0x1b, 0x23, 0x09, 0x78, 0x5c, 0x40,
	0x27, 0x50, 0xe1, 0xaf, 0x0b, 0xd0, 0xf5, 0x68, 0x91, 0x15, 0xbf, 0x9a, 0x50, 0x37, 0x46, 0xfc,
	0x1a, 0x9e, 0x73, 0xf1, 0x17, 0x5c, 0xdc, 0x39, 0x97, 0x7e, 0x18, 0xa6, 0x6e, 0x67, 0x98, 0xe5,
	0xbf, 0xea, 0x08, 0x66, 0x23, 0xdf, 0xde, 0xa1, 0x35, 0xd9, 0x37, 0x79, 0x3d, 0xf5, 0xfa, 0xa8,
	0xcf, 0xf5, 0x98, 0xa6, 0x43, 0x89, 0xa6, 0x43, 0xb9, 0xa6, 0x43, 0x81, 0xa6, 0x8f, 0xe8, 0x17,
	0x79, 0x7c, 0xcf, 0xc0, 0x6d, 0xbd, 0xa8, 0x67, 0xe1, 0xb6, 0x5e, 0xd2, 0x72, 0x30, 0xdd, 0x89,
	0xf2, 0x9c, 0xd3, 0x2d, 0xea, 0x1c, 0x38, 0xdd, 0x92, 0xea, 0x1e, 0x17, 0xf6, 0xe6, 0xfe, 0xf2,
	0x7a, 0x5d, 0xf9, 0xdb, 0xeb, 0x75, 0xe5, 0x9f, 0xaf, 0xd7, 0x95, 0xe7, 0x53, 0xf4, 0x5b, 0xce,
	0x87, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x86, 0x81, 0x14, 0xde, 0x29, 0x00, 0x00,
}
