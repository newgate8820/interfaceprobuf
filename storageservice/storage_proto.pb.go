// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/storageservice/storage_proto.proto

/*
Package storageservice is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/storageservice/storage_proto.proto

It has these top-level messages:

	MsgServiceLimitReq
	MsgServiceLimitResp
	MsgQueryFileIsExistReq
	MsgQueryFileIsExistResp
	MsgApplyFidReq
	ApplyFidRespPara
	MsgApplyFidResp
	UploadReqPara1
	UploadReqPara2
	MsgUploadFileReq
	FileUploadRespPara
	MsgUploadFileResp
	MsgDownloadFileReq
	DownloadFileRespPara1
	DownloadFileRespPara2
	MsgDownloadFileResp
	MsgDeleteFileReq
	MsgDeleteFileResp
	MsgCancelUploadReq
	MsgCancelUploadResp
	MsgAddRefCountReq
	MsgAddRefCountResp
	MsgModifyTTLReq
	MsgModifyTTLResp
	MsgQueryObjInfoReq
	QueryObjInfoRespPara
	MsgQueryObjInfoResp
	MsgFilePartsReq
	MsgFilePartsResp
	MsgGetFidReq
	MsgGetFidResp
	MsgFileDescReq
	MsgFileDescResp
	MsgGetFileDescReq
	MsgGetFileDescResp
	MsgCutPictureMapReq
	MsgCutPictureMapResp
	MsgGetCutPictureMapReq
	MsgGetCutPictureMapResp
	MsgDelCutPictureMapReq
	MsgDelCutPictureMapResp
	MsgGetWebPhotoReq
	MsgGetWebPhotoResp
	MsgGetSendPhotoSizeReq
	MsgGetSendPhotoSizeResp
	MsgGetPhotoCachedSizeReq
	MsgGetPhotoCachedSizeResp
	MsgGetPhotoReq
	MsgGetPhotoResp
*/
package storageservice

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ----------------------------------------------------
// 服务上传下载限制请求
type MsgServiceLimitReq struct {
	Reserved uint32 `protobuf:"varint,1,opt,name=reserved,proto3" json:"reserved,omitempty"`
}

func (m *MsgServiceLimitReq) Reset()                    { *m = MsgServiceLimitReq{} }
func (m *MsgServiceLimitReq) String() string            { return proto.CompactTextString(m) }
func (*MsgServiceLimitReq) ProtoMessage()               {}
func (*MsgServiceLimitReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{0} }

func (m *MsgServiceLimitReq) GetReserved() uint32 {
	if m != nil {
		return m.Reserved
	}
	return 0
}

// 服务上传下载限制响应(单位：Byte)
type MsgServiceLimitResp struct {
	Usfsl  uint32 `protobuf:"varint,1,opt,name=usfsl,proto3" json:"usfsl,omitempty"`
	Ubfssl uint32 `protobuf:"varint,2,opt,name=ubfssl,proto3" json:"ubfssl,omitempty"`
	Dssl   uint32 `protobuf:"varint,3,opt,name=dssl,proto3" json:"dssl,omitempty"`
}

func (m *MsgServiceLimitResp) Reset()                    { *m = MsgServiceLimitResp{} }
func (m *MsgServiceLimitResp) String() string            { return proto.CompactTextString(m) }
func (*MsgServiceLimitResp) ProtoMessage()               {}
func (*MsgServiceLimitResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{1} }

func (m *MsgServiceLimitResp) GetUsfsl() uint32 {
	if m != nil {
		return m.Usfsl
	}
	return 0
}

func (m *MsgServiceLimitResp) GetUbfssl() uint32 {
	if m != nil {
		return m.Ubfssl
	}
	return 0
}

func (m *MsgServiceLimitResp) GetDssl() uint32 {
	if m != nil {
		return m.Dssl
	}
	return 0
}

// 查询文件是否存在请求（仅用于非分片上传文件时）
type MsgQueryFileIsExistReq struct {
	FileHash string `protobuf:"bytes,1,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
}

func (m *MsgQueryFileIsExistReq) Reset()         { *m = MsgQueryFileIsExistReq{} }
func (m *MsgQueryFileIsExistReq) String() string { return proto.CompactTextString(m) }
func (*MsgQueryFileIsExistReq) ProtoMessage()    {}
func (*MsgQueryFileIsExistReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{2}
}

func (m *MsgQueryFileIsExistReq) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

// 查询文件是否存在响应
type MsgQueryFileIsExistResp struct {
	Para       *FileHashPara `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Fid        uint64        `protobuf:"varint,2,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64        `protobuf:"varint,3,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	IsExist    bool          `protobuf:"varint,4,opt,name=is_exist,json=isExist,proto3" json:"is_exist,omitempty"`
}

func (m *MsgQueryFileIsExistResp) Reset()         { *m = MsgQueryFileIsExistResp{} }
func (m *MsgQueryFileIsExistResp) String() string { return proto.CompactTextString(m) }
func (*MsgQueryFileIsExistResp) ProtoMessage()    {}
func (*MsgQueryFileIsExistResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{3}
}

func (m *MsgQueryFileIsExistResp) GetPara() *FileHashPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgQueryFileIsExistResp) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgQueryFileIsExistResp) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgQueryFileIsExistResp) GetIsExist() bool {
	if m != nil {
		return m.IsExist
	}
	return false
}

// 申请fid请求（仅用于分片上传文件时）
type MsgApplyFidReq struct {
	FileName  string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	PartTotal uint32 `protobuf:"varint,2,opt,name=part_total,json=partTotal,proto3" json:"part_total,omitempty"`
	Ttl       uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
}

func (m *MsgApplyFidReq) Reset()                    { *m = MsgApplyFidReq{} }
func (m *MsgApplyFidReq) String() string            { return proto.CompactTextString(m) }
func (*MsgApplyFidReq) ProtoMessage()               {}
func (*MsgApplyFidReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{4} }

func (m *MsgApplyFidReq) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *MsgApplyFidReq) GetPartTotal() uint32 {
	if m != nil {
		return m.PartTotal
	}
	return 0
}

func (m *MsgApplyFidReq) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// 申请fid响应参数
type ApplyFidRespPara struct {
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (m *ApplyFidRespPara) Reset()                    { *m = ApplyFidRespPara{} }
func (m *ApplyFidRespPara) String() string            { return proto.CompactTextString(m) }
func (*ApplyFidRespPara) ProtoMessage()               {}
func (*ApplyFidRespPara) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{5} }

func (m *ApplyFidRespPara) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

// 申请fid响应
type MsgApplyFidResp struct {
	Para       *ApplyFidRespPara `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Fid        uint64            `protobuf:"varint,2,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64            `protobuf:"varint,3,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgApplyFidResp) Reset()                    { *m = MsgApplyFidResp{} }
func (m *MsgApplyFidResp) String() string            { return proto.CompactTextString(m) }
func (*MsgApplyFidResp) ProtoMessage()               {}
func (*MsgApplyFidResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{6} }

func (m *MsgApplyFidResp) GetPara() *ApplyFidRespPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgApplyFidResp) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgApplyFidResp) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 上传请求参数1（仅用于分片上传文件时）
type UploadReqPara1 struct {
	Fid      uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	PartId   uint32 `protobuf:"varint,2,opt,name=part_id,json=partId,proto3" json:"part_id,omitempty"`
	PartSize uint32 `protobuf:"varint,3,opt,name=part_size,json=partSize,proto3" json:"part_size,omitempty"`
}

func (m *UploadReqPara1) Reset()                    { *m = UploadReqPara1{} }
func (m *UploadReqPara1) String() string            { return proto.CompactTextString(m) }
func (*UploadReqPara1) ProtoMessage()               {}
func (*UploadReqPara1) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{7} }

func (m *UploadReqPara1) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *UploadReqPara1) GetPartId() uint32 {
	if m != nil {
		return m.PartId
	}
	return 0
}

func (m *UploadReqPara1) GetPartSize() uint32 {
	if m != nil {
		return m.PartSize
	}
	return 0
}

// 上传请求参数2（仅用于非分片上传文件时）
type UploadReqPara2 struct {
	FileName string `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	FileSize uint32 `protobuf:"varint,2,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	FileHash string `protobuf:"bytes,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	Ttl      uint32 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
}

func (m *UploadReqPara2) Reset()                    { *m = UploadReqPara2{} }
func (m *UploadReqPara2) String() string            { return proto.CompactTextString(m) }
func (*UploadReqPara2) ProtoMessage()               {}
func (*UploadReqPara2) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{8} }

func (m *UploadReqPara2) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *UploadReqPara2) GetFileSize() uint32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *UploadReqPara2) GetFileHash() string {
	if m != nil {
		return m.FileHash
	}
	return ""
}

func (m *UploadReqPara2) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// 上传文件请求
type MsgUploadFileReq struct {
	Para1 *UploadReqPara1 `protobuf:"bytes,1,opt,name=para1" json:"para1,omitempty"`
	Para2 *UploadReqPara2 `protobuf:"bytes,2,opt,name=para2" json:"para2,omitempty"`
	Data  []byte          `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgUploadFileReq) Reset()                    { *m = MsgUploadFileReq{} }
func (m *MsgUploadFileReq) String() string            { return proto.CompactTextString(m) }
func (*MsgUploadFileReq) ProtoMessage()               {}
func (*MsgUploadFileReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{9} }

func (m *MsgUploadFileReq) GetPara1() *UploadReqPara1 {
	if m != nil {
		return m.Para1
	}
	return nil
}

func (m *MsgUploadFileReq) GetPara2() *UploadReqPara2 {
	if m != nil {
		return m.Para2
	}
	return nil
}

func (m *MsgUploadFileReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 文件上传响应参数1（仅用于分片上传文件时）
type FileUploadRespPara struct {
	Fid    uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	PartId uint32 `protobuf:"varint,2,opt,name=part_id,json=partId,proto3" json:"part_id,omitempty"`
}

func (m *FileUploadRespPara) Reset()                    { *m = FileUploadRespPara{} }
func (m *FileUploadRespPara) String() string            { return proto.CompactTextString(m) }
func (*FileUploadRespPara) ProtoMessage()               {}
func (*FileUploadRespPara) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{10} }

func (m *FileUploadRespPara) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *FileUploadRespPara) GetPartId() uint32 {
	if m != nil {
		return m.PartId
	}
	return 0
}

// 上传文件响应
type MsgUploadFileResp struct {
	Result     ERpcResultCode      `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
	Para1      *FileUploadRespPara `protobuf:"bytes,2,opt,name=para1" json:"para1,omitempty"`
	Para2      *FidPara            `protobuf:"bytes,3,opt,name=para2" json:"para2,omitempty"`
	AccessHash uint64              `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgUploadFileResp) Reset()                    { *m = MsgUploadFileResp{} }
func (m *MsgUploadFileResp) String() string            { return proto.CompactTextString(m) }
func (*MsgUploadFileResp) ProtoMessage()               {}
func (*MsgUploadFileResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{11} }

func (m *MsgUploadFileResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func (m *MsgUploadFileResp) GetPara1() *FileUploadRespPara {
	if m != nil {
		return m.Para1
	}
	return nil
}

func (m *MsgUploadFileResp) GetPara2() *FidPara {
	if m != nil {
		return m.Para2
	}
	return nil
}

func (m *MsgUploadFileResp) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 下载文件请求
type MsgDownloadFileReq struct {
	Fid           uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash    uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Offset        uint32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	Length        uint32 `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
	Reserve       uint64 `protobuf:"varint,5,opt,name=reserve,proto3" json:"reserve,omitempty"`
	ReserveString string `protobuf:"bytes,6,opt,name=reserve_string,json=reserveString,proto3" json:"reserve_string,omitempty"`
}

func (m *MsgDownloadFileReq) Reset()                    { *m = MsgDownloadFileReq{} }
func (m *MsgDownloadFileReq) String() string            { return proto.CompactTextString(m) }
func (*MsgDownloadFileReq) ProtoMessage()               {}
func (*MsgDownloadFileReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{12} }

func (m *MsgDownloadFileReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgDownloadFileReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgDownloadFileReq) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *MsgDownloadFileReq) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *MsgDownloadFileReq) GetReserve() uint64 {
	if m != nil {
		return m.Reserve
	}
	return 0
}

func (m *MsgDownloadFileReq) GetReserveString() string {
	if m != nil {
		return m.ReserveString
	}
	return ""
}

// 下载文件响应参数1
type DownloadFileRespPara1 struct {
	Fid      uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	Offset   uint32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	FileName string `protobuf:"bytes,3,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (m *DownloadFileRespPara1) Reset()         { *m = DownloadFileRespPara1{} }
func (m *DownloadFileRespPara1) String() string { return proto.CompactTextString(m) }
func (*DownloadFileRespPara1) ProtoMessage()    {}
func (*DownloadFileRespPara1) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{13}
}

func (m *DownloadFileRespPara1) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *DownloadFileRespPara1) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *DownloadFileRespPara1) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

// 下载文件响应参数2
type DownloadFileRespPara2 struct {
	Length uint32 `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	Data   []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *DownloadFileRespPara2) Reset()         { *m = DownloadFileRespPara2{} }
func (m *DownloadFileRespPara2) String() string { return proto.CompactTextString(m) }
func (*DownloadFileRespPara2) ProtoMessage()    {}
func (*DownloadFileRespPara2) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{14}
}

func (m *DownloadFileRespPara2) GetLength() uint32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *DownloadFileRespPara2) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 下载文件响应
type MsgDownloadFileResp struct {
	Result ERpcResultCode         `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
	Para1  *DownloadFileRespPara1 `protobuf:"bytes,2,opt,name=para1" json:"para1,omitempty"`
	Para2  *DownloadFileRespPara2 `protobuf:"bytes,3,opt,name=para2" json:"para2,omitempty"`
}

func (m *MsgDownloadFileResp) Reset()         { *m = MsgDownloadFileResp{} }
func (m *MsgDownloadFileResp) String() string { return proto.CompactTextString(m) }
func (*MsgDownloadFileResp) ProtoMessage()    {}
func (*MsgDownloadFileResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{15}
}

func (m *MsgDownloadFileResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func (m *MsgDownloadFileResp) GetPara1() *DownloadFileRespPara1 {
	if m != nil {
		return m.Para1
	}
	return nil
}

func (m *MsgDownloadFileResp) GetPara2() *DownloadFileRespPara2 {
	if m != nil {
		return m.Para2
	}
	return nil
}

// 删除文件请求
type MsgDeleteFileReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	RefNum     uint32 `protobuf:"varint,3,opt,name=ref_num,json=refNum,proto3" json:"ref_num,omitempty"`
}

func (m *MsgDeleteFileReq) Reset()                    { *m = MsgDeleteFileReq{} }
func (m *MsgDeleteFileReq) String() string            { return proto.CompactTextString(m) }
func (*MsgDeleteFileReq) ProtoMessage()               {}
func (*MsgDeleteFileReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{16} }

func (m *MsgDeleteFileReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgDeleteFileReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgDeleteFileReq) GetRefNum() uint32 {
	if m != nil {
		return m.RefNum
	}
	return 0
}

// 删除文件响应
type MsgDeleteFileResp struct {
	Para   *FidPara       `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Result ERpcResultCode `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgDeleteFileResp) Reset()                    { *m = MsgDeleteFileResp{} }
func (m *MsgDeleteFileResp) String() string            { return proto.CompactTextString(m) }
func (*MsgDeleteFileResp) ProtoMessage()               {}
func (*MsgDeleteFileResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{17} }

func (m *MsgDeleteFileResp) GetPara() *FidPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgDeleteFileResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 取消文件分片上传请求（仅用于正准备或正在分片上传的文件场景）
type MsgCancelUploadReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgCancelUploadReq) Reset()                    { *m = MsgCancelUploadReq{} }
func (m *MsgCancelUploadReq) String() string            { return proto.CompactTextString(m) }
func (*MsgCancelUploadReq) ProtoMessage()               {}
func (*MsgCancelUploadReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{18} }

func (m *MsgCancelUploadReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgCancelUploadReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 取消文件分片上传响应
type MsgCancelUploadResp struct {
	Para   *FidPara       `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Result ERpcResultCode `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgCancelUploadResp) Reset()         { *m = MsgCancelUploadResp{} }
func (m *MsgCancelUploadResp) String() string { return proto.CompactTextString(m) }
func (*MsgCancelUploadResp) ProtoMessage()    {}
func (*MsgCancelUploadResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{19}
}

func (m *MsgCancelUploadResp) GetPara() *FidPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgCancelUploadResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 增加文件引用计数请求
type MsgAddRefCountReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	RefNum     uint32 `protobuf:"varint,3,opt,name=ref_num,json=refNum,proto3" json:"ref_num,omitempty"`
}

func (m *MsgAddRefCountReq) Reset()                    { *m = MsgAddRefCountReq{} }
func (m *MsgAddRefCountReq) String() string            { return proto.CompactTextString(m) }
func (*MsgAddRefCountReq) ProtoMessage()               {}
func (*MsgAddRefCountReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{20} }

func (m *MsgAddRefCountReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgAddRefCountReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgAddRefCountReq) GetRefNum() uint32 {
	if m != nil {
		return m.RefNum
	}
	return 0
}

// 增加文件引用计数响应
type MsgAddRefCountResp struct {
	Para   *FidPara       `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Result ERpcResultCode `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgAddRefCountResp) Reset()                    { *m = MsgAddRefCountResp{} }
func (m *MsgAddRefCountResp) String() string            { return proto.CompactTextString(m) }
func (*MsgAddRefCountResp) ProtoMessage()               {}
func (*MsgAddRefCountResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{21} }

func (m *MsgAddRefCountResp) GetPara() *FidPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgAddRefCountResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 修改fid的TTL请求
type MsgModifyTTLReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Ttl        uint32 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
}

func (m *MsgModifyTTLReq) Reset()                    { *m = MsgModifyTTLReq{} }
func (m *MsgModifyTTLReq) String() string            { return proto.CompactTextString(m) }
func (*MsgModifyTTLReq) ProtoMessage()               {}
func (*MsgModifyTTLReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{22} }

func (m *MsgModifyTTLReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgModifyTTLReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgModifyTTLReq) GetTtl() uint32 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

// 修改fid的TTL响应
type MsgModifyTTLResp struct {
	Para   *FidPara       `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Result ERpcResultCode `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgModifyTTLResp) Reset()                    { *m = MsgModifyTTLResp{} }
func (m *MsgModifyTTLResp) String() string            { return proto.CompactTextString(m) }
func (*MsgModifyTTLResp) ProtoMessage()               {}
func (*MsgModifyTTLResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{23} }

func (m *MsgModifyTTLResp) GetPara() *FidPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgModifyTTLResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 查询对象信息请求
type MsgQueryObjInfoReq struct {
	Fid uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
}

func (m *MsgQueryObjInfoReq) Reset()                    { *m = MsgQueryObjInfoReq{} }
func (m *MsgQueryObjInfoReq) String() string            { return proto.CompactTextString(m) }
func (*MsgQueryObjInfoReq) ProtoMessage()               {}
func (*MsgQueryObjInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{24} }

func (m *MsgQueryObjInfoReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

// 查询对象信息响应参数
type QueryObjInfoRespPara struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Size_      uint64 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	AccessHash uint64 `protobuf:"varint,3,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *QueryObjInfoRespPara) Reset()         { *m = QueryObjInfoRespPara{} }
func (m *QueryObjInfoRespPara) String() string { return proto.CompactTextString(m) }
func (*QueryObjInfoRespPara) ProtoMessage()    {}
func (*QueryObjInfoRespPara) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{25}
}

func (m *QueryObjInfoRespPara) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryObjInfoRespPara) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *QueryObjInfoRespPara) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 查询对象信息响应
type MsgQueryObjInfoResp struct {
	Para   *QueryObjInfoRespPara `protobuf:"bytes,1,opt,name=para" json:"para,omitempty"`
	Result ERpcResultCode        `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgQueryObjInfoResp) Reset()         { *m = MsgQueryObjInfoResp{} }
func (m *MsgQueryObjInfoResp) String() string { return proto.CompactTextString(m) }
func (*MsgQueryObjInfoResp) ProtoMessage()    {}
func (*MsgQueryObjInfoResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{26}
}

func (m *MsgQueryObjInfoResp) GetPara() *QueryObjInfoRespPara {
	if m != nil {
		return m.Para
	}
	return nil
}

func (m *MsgQueryObjInfoResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 网关上传文件请求
type MsgFilePartsReq struct {
	Keyid     uint64 `protobuf:"varint,1,opt,name=keyid,proto3" json:"keyid,omitempty"`
	Fileid    int64  `protobuf:"varint,2,opt,name=fileid,proto3" json:"fileid,omitempty"`
	PartId    uint32 `protobuf:"varint,3,opt,name=part_id,json=partId,proto3" json:"part_id,omitempty"`
	FileType  uint32 `protobuf:"varint,4,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"`
	PartTotal uint32 `protobuf:"varint,5,opt,name=part_total,json=partTotal,proto3" json:"part_total,omitempty"`
	Data      []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgFilePartsReq) Reset()                    { *m = MsgFilePartsReq{} }
func (m *MsgFilePartsReq) String() string            { return proto.CompactTextString(m) }
func (*MsgFilePartsReq) ProtoMessage()               {}
func (*MsgFilePartsReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{27} }

func (m *MsgFilePartsReq) GetKeyid() uint64 {
	if m != nil {
		return m.Keyid
	}
	return 0
}

func (m *MsgFilePartsReq) GetFileid() int64 {
	if m != nil {
		return m.Fileid
	}
	return 0
}

func (m *MsgFilePartsReq) GetPartId() uint32 {
	if m != nil {
		return m.PartId
	}
	return 0
}

func (m *MsgFilePartsReq) GetFileType() uint32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *MsgFilePartsReq) GetPartTotal() uint32 {
	if m != nil {
		return m.PartTotal
	}
	return 0
}

func (m *MsgFilePartsReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 网关上传文件响应
type MsgFilePartsResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgFilePartsResp) Reset()                    { *m = MsgFilePartsResp{} }
func (m *MsgFilePartsResp) String() string            { return proto.CompactTextString(m) }
func (*MsgFilePartsResp) ProtoMessage()               {}
func (*MsgFilePartsResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{28} }

func (m *MsgFilePartsResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 网关取Fid请求
type MsgGetFidReq struct {
	Keyid     uint64 `protobuf:"varint,1,opt,name=keyid,proto3" json:"keyid,omitempty"`
	Fileid    int64  `protobuf:"varint,2,opt,name=fileid,proto3" json:"fileid,omitempty"`
	FileType  uint32 `protobuf:"varint,3,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"`
	Md5       string `protobuf:"bytes,4,opt,name=md5,proto3" json:"md5,omitempty"`
	PartTotal uint32 `protobuf:"varint,5,opt,name=part_total,json=partTotal,proto3" json:"part_total,omitempty"`
}

func (m *MsgGetFidReq) Reset()                    { *m = MsgGetFidReq{} }
func (m *MsgGetFidReq) String() string            { return proto.CompactTextString(m) }
func (*MsgGetFidReq) ProtoMessage()               {}
func (*MsgGetFidReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{29} }

func (m *MsgGetFidReq) GetKeyid() uint64 {
	if m != nil {
		return m.Keyid
	}
	return 0
}

func (m *MsgGetFidReq) GetFileid() int64 {
	if m != nil {
		return m.Fileid
	}
	return 0
}

func (m *MsgGetFidReq) GetFileType() uint32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *MsgGetFidReq) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *MsgGetFidReq) GetPartTotal() uint32 {
	if m != nil {
		return m.PartTotal
	}
	return 0
}

// 网关取Fid响应
type MsgGetFidResp struct {
	Fid        uint64         `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64         `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	FileSize   uint64         `protobuf:"varint,3,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Result     ERpcResultCode `protobuf:"varint,4,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgGetFidResp) Reset()                    { *m = MsgGetFidResp{} }
func (m *MsgGetFidResp) String() string            { return proto.CompactTextString(m) }
func (*MsgGetFidResp) ProtoMessage()               {}
func (*MsgGetFidResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{30} }

func (m *MsgGetFidResp) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgGetFidResp) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgGetFidResp) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *MsgGetFidResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 网关上传文件描述信息请求
type MsgFileDescReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Data       []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	FromId     int32  `protobuf:"varint,4,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	WithId     int32  `protobuf:"varint,5,opt,name=with_id,json=withId,proto3" json:"with_id,omitempty"`
	ChatType   string `protobuf:"bytes,6,opt,name=chat_type,json=chatType,proto3" json:"chat_type,omitempty"`
	MediaType  int32  `protobuf:"varint,7,opt,name=media_type,json=mediaType,proto3" json:"media_type,omitempty"`
	MessageId  int32  `protobuf:"varint,8,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *MsgFileDescReq) Reset()                    { *m = MsgFileDescReq{} }
func (m *MsgFileDescReq) String() string            { return proto.CompactTextString(m) }
func (*MsgFileDescReq) ProtoMessage()               {}
func (*MsgFileDescReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{31} }

func (m *MsgFileDescReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgFileDescReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgFileDescReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *MsgFileDescReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *MsgFileDescReq) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *MsgFileDescReq) GetChatType() string {
	if m != nil {
		return m.ChatType
	}
	return ""
}

func (m *MsgFileDescReq) GetMediaType() int32 {
	if m != nil {
		return m.MediaType
	}
	return 0
}

func (m *MsgFileDescReq) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 网关上传文件描述信息响应
type MsgFileDescResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgFileDescResp) Reset()                    { *m = MsgFileDescResp{} }
func (m *MsgFileDescResp) String() string            { return proto.CompactTextString(m) }
func (*MsgFileDescResp) ProtoMessage()               {}
func (*MsgFileDescResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{32} }

func (m *MsgFileDescResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 网关获取文件描述信息请求
type MsgGetFileDescReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgGetFileDescReq) Reset()                    { *m = MsgGetFileDescReq{} }
func (m *MsgGetFileDescReq) String() string            { return proto.CompactTextString(m) }
func (*MsgGetFileDescReq) ProtoMessage()               {}
func (*MsgGetFileDescReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{33} }

func (m *MsgGetFileDescReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgGetFileDescReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 网关获取文件描述信息响应
type MsgGetFileDescResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
	Data   []byte         `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgGetFileDescResp) Reset()                    { *m = MsgGetFileDescResp{} }
func (m *MsgGetFileDescResp) String() string            { return proto.CompactTextString(m) }
func (*MsgGetFileDescResp) ProtoMessage()               {}
func (*MsgGetFileDescResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{34} }

func (m *MsgGetFileDescResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func (m *MsgGetFileDescResp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 存储裁剪图与原图映射请求
type MsgCutPictureMapReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Data       []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgCutPictureMapReq) Reset()         { *m = MsgCutPictureMapReq{} }
func (m *MsgCutPictureMapReq) String() string { return proto.CompactTextString(m) }
func (*MsgCutPictureMapReq) ProtoMessage()    {}
func (*MsgCutPictureMapReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{35}
}

func (m *MsgCutPictureMapReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgCutPictureMapReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *MsgCutPictureMapReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 存储裁剪图与原图映射响应
type MsgCutPictureMapResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgCutPictureMapResp) Reset()         { *m = MsgCutPictureMapResp{} }
func (m *MsgCutPictureMapResp) String() string { return proto.CompactTextString(m) }
func (*MsgCutPictureMapResp) ProtoMessage()    {}
func (*MsgCutPictureMapResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{36}
}

func (m *MsgCutPictureMapResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// 获取裁剪图与原图映射请求
type MsgGetCutPictureMapReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgGetCutPictureMapReq) Reset()         { *m = MsgGetCutPictureMapReq{} }
func (m *MsgGetCutPictureMapReq) String() string { return proto.CompactTextString(m) }
func (*MsgGetCutPictureMapReq) ProtoMessage()    {}
func (*MsgGetCutPictureMapReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{37}
}

func (m *MsgGetCutPictureMapReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgGetCutPictureMapReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 获取裁剪图与原图映射响应
type MsgGetCutPictureMapResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
	Data   []byte         `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgGetCutPictureMapResp) Reset()         { *m = MsgGetCutPictureMapResp{} }
func (m *MsgGetCutPictureMapResp) String() string { return proto.CompactTextString(m) }
func (*MsgGetCutPictureMapResp) ProtoMessage()    {}
func (*MsgGetCutPictureMapResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{38}
}

func (m *MsgGetCutPictureMapResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func (m *MsgGetCutPictureMapResp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 删除裁剪图与原图映射请求
type MsgDelCutPictureMapReq struct {
	Fid        uint64 `protobuf:"varint,1,opt,name=fid,proto3" json:"fid,omitempty"`
	AccessHash uint64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *MsgDelCutPictureMapReq) Reset()         { *m = MsgDelCutPictureMapReq{} }
func (m *MsgDelCutPictureMapReq) String() string { return proto.CompactTextString(m) }
func (*MsgDelCutPictureMapReq) ProtoMessage()    {}
func (*MsgDelCutPictureMapReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{39}
}

func (m *MsgDelCutPictureMapReq) GetFid() uint64 {
	if m != nil {
		return m.Fid
	}
	return 0
}

func (m *MsgDelCutPictureMapReq) GetAccessHash() uint64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// 删除裁剪图与原图映射响应
type MsgDelCutPictureMapResp struct {
	Result ERpcResultCode `protobuf:"varint,1,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgDelCutPictureMapResp) Reset()         { *m = MsgDelCutPictureMapResp{} }
func (m *MsgDelCutPictureMapResp) String() string { return proto.CompactTextString(m) }
func (*MsgDelCutPictureMapResp) ProtoMessage()    {}
func (*MsgDelCutPictureMapResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{40}
}

func (m *MsgDelCutPictureMapResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// GetWebPhoto
type MsgGetWebPhotoReq struct {
	PhotoType string `protobuf:"bytes,1,opt,name=PhotoType,proto3" json:"PhotoType,omitempty"`
	KeyId     uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	DcId      int32  `protobuf:"varint,3,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	Data      []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *MsgGetWebPhotoReq) Reset()                    { *m = MsgGetWebPhotoReq{} }
func (m *MsgGetWebPhotoReq) String() string            { return proto.CompactTextString(m) }
func (*MsgGetWebPhotoReq) ProtoMessage()               {}
func (*MsgGetWebPhotoReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{41} }

func (m *MsgGetWebPhotoReq) GetPhotoType() string {
	if m != nil {
		return m.PhotoType
	}
	return ""
}

func (m *MsgGetWebPhotoReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *MsgGetWebPhotoReq) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *MsgGetWebPhotoReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type MsgGetWebPhotoResp struct {
	OtherPhotoData []byte         `protobuf:"bytes,1,opt,name=OtherPhotoData,proto3" json:"OtherPhotoData,omitempty"`
	Result         ERpcResultCode `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgGetWebPhotoResp) Reset()                    { *m = MsgGetWebPhotoResp{} }
func (m *MsgGetWebPhotoResp) String() string            { return proto.CompactTextString(m) }
func (*MsgGetWebPhotoResp) ProtoMessage()               {}
func (*MsgGetWebPhotoResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{42} }

func (m *MsgGetWebPhotoResp) GetOtherPhotoData() []byte {
	if m != nil {
		return m.OtherPhotoData
	}
	return nil
}

func (m *MsgGetWebPhotoResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// ----------------------------------------------------
// GetSendPhotoSize
type MsgGetSendPhotoSizeReq struct {
	Keyid     uint64 `protobuf:"varint,1,opt,name=keyid,proto3" json:"keyid,omitempty"`
	Fileid    int64  `protobuf:"varint,2,opt,name=fileid,proto3" json:"fileid,omitempty"`
	FileType  uint32 `protobuf:"varint,3,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"`
	Md5       string `protobuf:"bytes,4,opt,name=md5,proto3" json:"md5,omitempty"`
	PartTotal uint32 `protobuf:"varint,5,opt,name=part_total,json=partTotal,proto3" json:"part_total,omitempty"`
	DcId      int32  `protobuf:"varint,6,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
}

func (m *MsgGetSendPhotoSizeReq) Reset()         { *m = MsgGetSendPhotoSizeReq{} }
func (m *MsgGetSendPhotoSizeReq) String() string { return proto.CompactTextString(m) }
func (*MsgGetSendPhotoSizeReq) ProtoMessage()    {}
func (*MsgGetSendPhotoSizeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{43}
}

func (m *MsgGetSendPhotoSizeReq) GetKeyid() uint64 {
	if m != nil {
		return m.Keyid
	}
	return 0
}

func (m *MsgGetSendPhotoSizeReq) GetFileid() int64 {
	if m != nil {
		return m.Fileid
	}
	return 0
}

func (m *MsgGetSendPhotoSizeReq) GetFileType() uint32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *MsgGetSendPhotoSizeReq) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *MsgGetSendPhotoSizeReq) GetPartTotal() uint32 {
	if m != nil {
		return m.PartTotal
	}
	return 0
}

func (m *MsgGetSendPhotoSizeReq) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

type MsgGetSendPhotoSizeResp struct {
	SelfPhotoData  []byte         `protobuf:"bytes,1,opt,name=SelfPhotoData,proto3" json:"SelfPhotoData,omitempty"`
	OtherPhotoData []byte         `protobuf:"bytes,2,opt,name=OtherPhotoData,proto3" json:"OtherPhotoData,omitempty"`
	Result         ERpcResultCode `protobuf:"varint,3,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgGetSendPhotoSizeResp) Reset()         { *m = MsgGetSendPhotoSizeResp{} }
func (m *MsgGetSendPhotoSizeResp) String() string { return proto.CompactTextString(m) }
func (*MsgGetSendPhotoSizeResp) ProtoMessage()    {}
func (*MsgGetSendPhotoSizeResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{44}
}

func (m *MsgGetSendPhotoSizeResp) GetSelfPhotoData() []byte {
	if m != nil {
		return m.SelfPhotoData
	}
	return nil
}

func (m *MsgGetSendPhotoSizeResp) GetOtherPhotoData() []byte {
	if m != nil {
		return m.OtherPhotoData
	}
	return nil
}

func (m *MsgGetSendPhotoSizeResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// ----------------------------------------------------
// GetPhotoCachedSize
type MsgGetPhotoCachedSizeReq struct {
	KeyId int64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	DcId  int32 `protobuf:"varint,2,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	NewId int64 `protobuf:"varint,3,opt,name=new_id,json=newId,proto3" json:"new_id,omitempty"`
	Size_ int32 `protobuf:"varint,4,opt,name=size,proto3" json:"size,omitempty"`
}

func (m *MsgGetPhotoCachedSizeReq) Reset()         { *m = MsgGetPhotoCachedSizeReq{} }
func (m *MsgGetPhotoCachedSizeReq) String() string { return proto.CompactTextString(m) }
func (*MsgGetPhotoCachedSizeReq) ProtoMessage()    {}
func (*MsgGetPhotoCachedSizeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{45}
}

func (m *MsgGetPhotoCachedSizeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *MsgGetPhotoCachedSizeReq) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *MsgGetPhotoCachedSizeReq) GetNewId() int64 {
	if m != nil {
		return m.NewId
	}
	return 0
}

func (m *MsgGetPhotoCachedSizeReq) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type MsgGetPhotoCachedSizeResp struct {
	CachePhotoData []byte         `protobuf:"bytes,1,opt,name=CachePhotoData,proto3" json:"CachePhotoData,omitempty"`
	Result         ERpcResultCode `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgGetPhotoCachedSizeResp) Reset()         { *m = MsgGetPhotoCachedSizeResp{} }
func (m *MsgGetPhotoCachedSizeResp) String() string { return proto.CompactTextString(m) }
func (*MsgGetPhotoCachedSizeResp) ProtoMessage()    {}
func (*MsgGetPhotoCachedSizeResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStorageProto, []int{46}
}

func (m *MsgGetPhotoCachedSizeResp) GetCachePhotoData() []byte {
	if m != nil {
		return m.CachePhotoData
	}
	return nil
}

func (m *MsgGetPhotoCachedSizeResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

// ----------------------------------------------------
// GetPhoto
type MsgGetPhotoReq struct {
	Keyid     uint64 `protobuf:"varint,1,opt,name=keyid,proto3" json:"keyid,omitempty"`
	Fileid    int64  `protobuf:"varint,2,opt,name=fileid,proto3" json:"fileid,omitempty"`
	FileType  uint32 `protobuf:"varint,3,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty"`
	Md5       string `protobuf:"bytes,4,opt,name=md5,proto3" json:"md5,omitempty"`
	PartTotal uint32 `protobuf:"varint,5,opt,name=part_total,json=partTotal,proto3" json:"part_total,omitempty"`
	DcId      int32  `protobuf:"varint,6,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
}

func (m *MsgGetPhotoReq) Reset()                    { *m = MsgGetPhotoReq{} }
func (m *MsgGetPhotoReq) String() string            { return proto.CompactTextString(m) }
func (*MsgGetPhotoReq) ProtoMessage()               {}
func (*MsgGetPhotoReq) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{47} }

func (m *MsgGetPhotoReq) GetKeyid() uint64 {
	if m != nil {
		return m.Keyid
	}
	return 0
}

func (m *MsgGetPhotoReq) GetFileid() int64 {
	if m != nil {
		return m.Fileid
	}
	return 0
}

func (m *MsgGetPhotoReq) GetFileType() uint32 {
	if m != nil {
		return m.FileType
	}
	return 0
}

func (m *MsgGetPhotoReq) GetMd5() string {
	if m != nil {
		return m.Md5
	}
	return ""
}

func (m *MsgGetPhotoReq) GetPartTotal() uint32 {
	if m != nil {
		return m.PartTotal
	}
	return 0
}

func (m *MsgGetPhotoReq) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

type MsgGetPhotoResp struct {
	OtherPhotoData []byte         `protobuf:"bytes,1,opt,name=OtherPhotoData,proto3" json:"OtherPhotoData,omitempty"`
	Result         ERpcResultCode `protobuf:"varint,2,opt,name=result,proto3,enum=storageservice.ERpcResultCode" json:"result,omitempty"`
}

func (m *MsgGetPhotoResp) Reset()                    { *m = MsgGetPhotoResp{} }
func (m *MsgGetPhotoResp) String() string            { return proto.CompactTextString(m) }
func (*MsgGetPhotoResp) ProtoMessage()               {}
func (*MsgGetPhotoResp) Descriptor() ([]byte, []int) { return fileDescriptorStorageProto, []int{48} }

func (m *MsgGetPhotoResp) GetOtherPhotoData() []byte {
	if m != nil {
		return m.OtherPhotoData
	}
	return nil
}

func (m *MsgGetPhotoResp) GetResult() ERpcResultCode {
	if m != nil {
		return m.Result
	}
	return ERpcResultCode_RRC_OK
}

func init() {
	proto.RegisterType((*MsgServiceLimitReq)(nil), "storageservice.MsgServiceLimitReq")
	proto.RegisterType((*MsgServiceLimitResp)(nil), "storageservice.MsgServiceLimitResp")
	proto.RegisterType((*MsgQueryFileIsExistReq)(nil), "storageservice.MsgQueryFileIsExistReq")
	proto.RegisterType((*MsgQueryFileIsExistResp)(nil), "storageservice.MsgQueryFileIsExistResp")
	proto.RegisterType((*MsgApplyFidReq)(nil), "storageservice.MsgApplyFidReq")
	proto.RegisterType((*ApplyFidRespPara)(nil), "storageservice.ApplyFidRespPara")
	proto.RegisterType((*MsgApplyFidResp)(nil), "storageservice.MsgApplyFidResp")
	proto.RegisterType((*UploadReqPara1)(nil), "storageservice.UploadReqPara1")
	proto.RegisterType((*UploadReqPara2)(nil), "storageservice.UploadReqPara2")
	proto.RegisterType((*MsgUploadFileReq)(nil), "storageservice.MsgUploadFileReq")
	proto.RegisterType((*FileUploadRespPara)(nil), "storageservice.FileUploadRespPara")
	proto.RegisterType((*MsgUploadFileResp)(nil), "storageservice.MsgUploadFileResp")
	proto.RegisterType((*MsgDownloadFileReq)(nil), "storageservice.MsgDownloadFileReq")
	proto.RegisterType((*DownloadFileRespPara1)(nil), "storageservice.DownloadFileRespPara1")
	proto.RegisterType((*DownloadFileRespPara2)(nil), "storageservice.DownloadFileRespPara2")
	proto.RegisterType((*MsgDownloadFileResp)(nil), "storageservice.MsgDownloadFileResp")
	proto.RegisterType((*MsgDeleteFileReq)(nil), "storageservice.MsgDeleteFileReq")
	proto.RegisterType((*MsgDeleteFileResp)(nil), "storageservice.MsgDeleteFileResp")
	proto.RegisterType((*MsgCancelUploadReq)(nil), "storageservice.MsgCancelUploadReq")
	proto.RegisterType((*MsgCancelUploadResp)(nil), "storageservice.MsgCancelUploadResp")
	proto.RegisterType((*MsgAddRefCountReq)(nil), "storageservice.MsgAddRefCountReq")
	proto.RegisterType((*MsgAddRefCountResp)(nil), "storageservice.MsgAddRefCountResp")
	proto.RegisterType((*MsgModifyTTLReq)(nil), "storageservice.MsgModifyTTLReq")
	proto.RegisterType((*MsgModifyTTLResp)(nil), "storageservice.MsgModifyTTLResp")
	proto.RegisterType((*MsgQueryObjInfoReq)(nil), "storageservice.MsgQueryObjInfoReq")
	proto.RegisterType((*QueryObjInfoRespPara)(nil), "storageservice.QueryObjInfoRespPara")
	proto.RegisterType((*MsgQueryObjInfoResp)(nil), "storageservice.MsgQueryObjInfoResp")
	proto.RegisterType((*MsgFilePartsReq)(nil), "storageservice.MsgFilePartsReq")
	proto.RegisterType((*MsgFilePartsResp)(nil), "storageservice.MsgFilePartsResp")
	proto.RegisterType((*MsgGetFidReq)(nil), "storageservice.MsgGetFidReq")
	proto.RegisterType((*MsgGetFidResp)(nil), "storageservice.MsgGetFidResp")
	proto.RegisterType((*MsgFileDescReq)(nil), "storageservice.MsgFileDescReq")
	proto.RegisterType((*MsgFileDescResp)(nil), "storageservice.MsgFileDescResp")
	proto.RegisterType((*MsgGetFileDescReq)(nil), "storageservice.MsgGetFileDescReq")
	proto.RegisterType((*MsgGetFileDescResp)(nil), "storageservice.MsgGetFileDescResp")
	proto.RegisterType((*MsgCutPictureMapReq)(nil), "storageservice.MsgCutPictureMapReq")
	proto.RegisterType((*MsgCutPictureMapResp)(nil), "storageservice.MsgCutPictureMapResp")
	proto.RegisterType((*MsgGetCutPictureMapReq)(nil), "storageservice.MsgGetCutPictureMapReq")
	proto.RegisterType((*MsgGetCutPictureMapResp)(nil), "storageservice.MsgGetCutPictureMapResp")
	proto.RegisterType((*MsgDelCutPictureMapReq)(nil), "storageservice.MsgDelCutPictureMapReq")
	proto.RegisterType((*MsgDelCutPictureMapResp)(nil), "storageservice.MsgDelCutPictureMapResp")
	proto.RegisterType((*MsgGetWebPhotoReq)(nil), "storageservice.MsgGetWebPhotoReq")
	proto.RegisterType((*MsgGetWebPhotoResp)(nil), "storageservice.MsgGetWebPhotoResp")
	proto.RegisterType((*MsgGetSendPhotoSizeReq)(nil), "storageservice.MsgGetSendPhotoSizeReq")
	proto.RegisterType((*MsgGetSendPhotoSizeResp)(nil), "storageservice.MsgGetSendPhotoSizeResp")
	proto.RegisterType((*MsgGetPhotoCachedSizeReq)(nil), "storageservice.MsgGetPhotoCachedSizeReq")
	proto.RegisterType((*MsgGetPhotoCachedSizeResp)(nil), "storageservice.MsgGetPhotoCachedSizeResp")
	proto.RegisterType((*MsgGetPhotoReq)(nil), "storageservice.MsgGetPhotoReq")
	proto.RegisterType((*MsgGetPhotoResp)(nil), "storageservice.MsgGetPhotoResp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FileStorageService service

type FileStorageServiceClient interface {
	// ServiceLimit 服务上传下载限制
	ServiceLimit(ctx context.Context, in *MsgServiceLimitReq, opts ...grpc.CallOption) (*MsgServiceLimitResp, error)
	// UploadFile 上传文件或文件片
	UploadFile(ctx context.Context, in *MsgUploadFileReq, opts ...grpc.CallOption) (*MsgUploadFileResp, error)
	// DownloadFile 下载文件或文件片
	DownloadFile(ctx context.Context, in *MsgDownloadFileReq, opts ...grpc.CallOption) (*MsgDownloadFileResp, error)
	// DownloadFile 下载大块文件到缓存
	DownloadFileCache(ctx context.Context, in *MsgDownloadFileReq, opts ...grpc.CallOption) (*MsgDownloadFileResp, error)
	// QueryObjInfo 查询对象信息
	QueryObjInfo(ctx context.Context, in *MsgQueryObjInfoReq, opts ...grpc.CallOption) (*MsgQueryObjInfoResp, error)
	// 网关上传文件
	GatewayUploadFile(ctx context.Context, in *MsgFilePartsReq, opts ...grpc.CallOption) (*MsgFilePartsResp, error)
	// 网关取上传文件的Fid, 与DC约定：1.收到此消息认为文件片已经传完；2.keyid+fileid与存储fid映射关系丢弃
	GatewayGetUploadFileFid(ctx context.Context, in *MsgGetFidReq, opts ...grpc.CallOption) (*MsgGetFidResp, error)
	// 网关上传文件描述信息
	GatewayUploadFileDesc(ctx context.Context, in *MsgFileDescReq, opts ...grpc.CallOption) (*MsgFileDescResp, error)
	// 网关获取文件描述信息
	GatewayGetFileDesc(ctx context.Context, in *MsgGetFileDescReq, opts ...grpc.CallOption) (*MsgGetFileDescResp, error)
}

type fileStorageServiceClient struct {
	cc *grpc.ClientConn
}

func NewFileStorageServiceClient(cc *grpc.ClientConn) FileStorageServiceClient {
	return &fileStorageServiceClient{cc}
}

func (c *fileStorageServiceClient) ServiceLimit(ctx context.Context, in *MsgServiceLimitReq, opts ...grpc.CallOption) (*MsgServiceLimitResp, error) {
	out := new(MsgServiceLimitResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/ServiceLimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) UploadFile(ctx context.Context, in *MsgUploadFileReq, opts ...grpc.CallOption) (*MsgUploadFileResp, error) {
	out := new(MsgUploadFileResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/UploadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) DownloadFile(ctx context.Context, in *MsgDownloadFileReq, opts ...grpc.CallOption) (*MsgDownloadFileResp, error) {
	out := new(MsgDownloadFileResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/DownloadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) DownloadFileCache(ctx context.Context, in *MsgDownloadFileReq, opts ...grpc.CallOption) (*MsgDownloadFileResp, error) {
	out := new(MsgDownloadFileResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/DownloadFileCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) QueryObjInfo(ctx context.Context, in *MsgQueryObjInfoReq, opts ...grpc.CallOption) (*MsgQueryObjInfoResp, error) {
	out := new(MsgQueryObjInfoResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/QueryObjInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GatewayUploadFile(ctx context.Context, in *MsgFilePartsReq, opts ...grpc.CallOption) (*MsgFilePartsResp, error) {
	out := new(MsgFilePartsResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/GatewayUploadFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GatewayGetUploadFileFid(ctx context.Context, in *MsgGetFidReq, opts ...grpc.CallOption) (*MsgGetFidResp, error) {
	out := new(MsgGetFidResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/GatewayGetUploadFileFid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GatewayUploadFileDesc(ctx context.Context, in *MsgFileDescReq, opts ...grpc.CallOption) (*MsgFileDescResp, error) {
	out := new(MsgFileDescResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/GatewayUploadFileDesc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageServiceClient) GatewayGetFileDesc(ctx context.Context, in *MsgGetFileDescReq, opts ...grpc.CallOption) (*MsgGetFileDescResp, error) {
	out := new(MsgGetFileDescResp)
	err := grpc.Invoke(ctx, "/storageservice.FileStorageService/GatewayGetFileDesc", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileStorageService service

type FileStorageServiceServer interface {
	// ServiceLimit 服务上传下载限制
	ServiceLimit(context.Context, *MsgServiceLimitReq) (*MsgServiceLimitResp, error)
	// UploadFile 上传文件或文件片
	UploadFile(context.Context, *MsgUploadFileReq) (*MsgUploadFileResp, error)
	// DownloadFile 下载文件或文件片
	DownloadFile(context.Context, *MsgDownloadFileReq) (*MsgDownloadFileResp, error)
	// DownloadFile 下载大块文件到缓存
	DownloadFileCache(context.Context, *MsgDownloadFileReq) (*MsgDownloadFileResp, error)
	// QueryObjInfo 查询对象信息
	QueryObjInfo(context.Context, *MsgQueryObjInfoReq) (*MsgQueryObjInfoResp, error)
	// 网关上传文件
	GatewayUploadFile(context.Context, *MsgFilePartsReq) (*MsgFilePartsResp, error)
	// 网关取上传文件的Fid, 与DC约定：1.收到此消息认为文件片已经传完；2.keyid+fileid与存储fid映射关系丢弃
	GatewayGetUploadFileFid(context.Context, *MsgGetFidReq) (*MsgGetFidResp, error)
	// 网关上传文件描述信息
	GatewayUploadFileDesc(context.Context, *MsgFileDescReq) (*MsgFileDescResp, error)
	// 网关获取文件描述信息
	GatewayGetFileDesc(context.Context, *MsgGetFileDescReq) (*MsgGetFileDescResp, error)
}

func RegisterFileStorageServiceServer(s *grpc.Server, srv FileStorageServiceServer) {
	s.RegisterService(&_FileStorageService_serviceDesc, srv)
}

func _FileStorageService_ServiceLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgServiceLimitReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).ServiceLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/ServiceLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).ServiceLimit(ctx, req.(*MsgServiceLimitReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_UploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUploadFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).UploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/UploadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).UploadFile(ctx, req.(*MsgUploadFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_DownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDownloadFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).DownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/DownloadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).DownloadFile(ctx, req.(*MsgDownloadFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_DownloadFileCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDownloadFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).DownloadFileCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/DownloadFileCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).DownloadFileCache(ctx, req.(*MsgDownloadFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_QueryObjInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgQueryObjInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).QueryObjInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/QueryObjInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).QueryObjInfo(ctx, req.(*MsgQueryObjInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GatewayUploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFilePartsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GatewayUploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/GatewayUploadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GatewayUploadFile(ctx, req.(*MsgFilePartsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GatewayGetUploadFileFid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGetFidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GatewayGetUploadFileFid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/GatewayGetUploadFileFid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GatewayGetUploadFileFid(ctx, req.(*MsgGetFidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GatewayUploadFileDesc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFileDescReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GatewayUploadFileDesc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/GatewayUploadFileDesc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GatewayUploadFileDesc(ctx, req.(*MsgFileDescReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageService_GatewayGetFileDesc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgGetFileDescReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageServiceServer).GatewayGetFileDesc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storageservice.FileStorageService/GatewayGetFileDesc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageServiceServer).GatewayGetFileDesc(ctx, req.(*MsgGetFileDescReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileStorageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storageservice.FileStorageService",
	HandlerType: (*FileStorageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServiceLimit",
			Handler:    _FileStorageService_ServiceLimit_Handler,
		},
		{
			MethodName: "UploadFile",
			Handler:    _FileStorageService_UploadFile_Handler,
		},
		{
			MethodName: "DownloadFile",
			Handler:    _FileStorageService_DownloadFile_Handler,
		},
		{
			MethodName: "DownloadFileCache",
			Handler:    _FileStorageService_DownloadFileCache_Handler,
		},
		{
			MethodName: "QueryObjInfo",
			Handler:    _FileStorageService_QueryObjInfo_Handler,
		},
		{
			MethodName: "GatewayUploadFile",
			Handler:    _FileStorageService_GatewayUploadFile_Handler,
		},
		{
			MethodName: "GatewayGetUploadFileFid",
			Handler:    _FileStorageService_GatewayGetUploadFileFid_Handler,
		},
		{
			MethodName: "GatewayUploadFileDesc",
			Handler:    _FileStorageService_GatewayUploadFileDesc_Handler,
		},
		{
			MethodName: "GatewayGetFileDesc",
			Handler:    _FileStorageService_GatewayGetFileDesc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/storageservice/storage_proto.proto",
}

func (m *MsgServiceLimitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgServiceLimitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reserved != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Reserved))
	}
	return i, nil
}

func (m *MsgServiceLimitResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgServiceLimitResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Usfsl != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Usfsl))
	}
	if m.Ubfssl != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Ubfssl))
	}
	if m.Dssl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Dssl))
	}
	return i, nil
}

func (m *MsgQueryFileIsExistReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgQueryFileIsExistReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	return i, nil
}

func (m *MsgQueryFileIsExistResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgQueryFileIsExistResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para.Size()))
		n1, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Fid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if m.IsExist {
		dAtA[i] = 0x20
		i++
		if m.IsExist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *MsgApplyFidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApplyFidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if m.PartTotal != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartTotal))
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Ttl))
	}
	return i, nil
}

func (m *ApplyFidRespPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyFidRespPara) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	return i, nil
}

func (m *MsgApplyFidResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApplyFidResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para.Size()))
		n2, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Fid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *UploadReqPara1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadReqPara1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.PartId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartId))
	}
	if m.PartSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartSize))
	}
	return i, nil
}

func (m *UploadReqPara2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadReqPara2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.FileSize))
	}
	if len(m.FileHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.FileHash)))
		i += copy(dAtA[i:], m.FileHash)
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Ttl))
	}
	return i, nil
}

func (m *MsgUploadFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUploadFileReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para1 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para1.Size()))
		n3, err := m.Para1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Para2 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para2.Size()))
		n4, err := m.Para2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *FileUploadRespPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileUploadRespPara) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.PartId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartId))
	}
	return i, nil
}

func (m *MsgUploadFileResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUploadFileResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	if m.Para1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para1.Size()))
		n5, err := m.Para1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Para2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para2.Size()))
		n6, err := m.Para2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgDownloadFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDownloadFileReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Offset))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Length))
	}
	if m.Reserve != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Reserve))
	}
	if len(m.ReserveString) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.ReserveString)))
		i += copy(dAtA[i:], m.ReserveString)
	}
	return i, nil
}

func (m *DownloadFileRespPara1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileRespPara1) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Offset))
	}
	if len(m.FileName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.FileName)))
		i += copy(dAtA[i:], m.FileName)
	}
	return i, nil
}

func (m *DownloadFileRespPara2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadFileRespPara2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Length))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgDownloadFileResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDownloadFileResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	if m.Para1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para1.Size()))
		n7, err := m.Para1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Para2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para2.Size()))
		n8, err := m.Para2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *MsgDeleteFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteFileReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if m.RefNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.RefNum))
	}
	return i, nil
}

func (m *MsgDeleteFileResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeleteFileResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para.Size()))
		n9, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgCancelUploadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelUploadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgCancelUploadResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelUploadResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para.Size()))
		n10, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgAddRefCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddRefCountReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if m.RefNum != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.RefNum))
	}
	return i, nil
}

func (m *MsgAddRefCountResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddRefCountResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para.Size()))
		n11, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgModifyTTLReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyTTLReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if m.Ttl != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Ttl))
	}
	return i, nil
}

func (m *MsgModifyTTLResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgModifyTTLResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para.Size()))
		n12, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgQueryObjInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgQueryObjInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	return i, nil
}

func (m *QueryObjInfoRespPara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryObjInfoRespPara) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Size_))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgQueryObjInfoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgQueryObjInfoResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Para != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Para.Size()))
		n13, err := m.Para.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgFilePartsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFilePartsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fileid))
	}
	if m.PartId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartId))
	}
	if m.FileType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.FileType))
	}
	if m.PartTotal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartTotal))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgFilePartsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFilePartsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetFidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fileid))
	}
	if m.FileType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.FileType))
	}
	if len(m.Md5) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Md5)))
		i += copy(dAtA[i:], m.Md5)
	}
	if m.PartTotal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartTotal))
	}
	return i, nil
}

func (m *MsgGetFidResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFidResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.FileSize))
	}
	if m.Result != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgFileDescReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFileDescReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.FromId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.FromId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.WithId))
	}
	if len(m.ChatType) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.ChatType)))
		i += copy(dAtA[i:], m.ChatType)
	}
	if m.MediaType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.MediaType))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *MsgFileDescResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFileDescResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetFileDescReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFileDescReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgGetFileDescResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetFileDescResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgCutPictureMapReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCutPictureMapReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgCutPictureMapResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCutPictureMapResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetCutPictureMapReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetCutPictureMapReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgGetCutPictureMapResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetCutPictureMapResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgDelCutPictureMapReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDelCutPictureMapReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *MsgDelCutPictureMapResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDelCutPictureMapResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetWebPhotoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetWebPhotoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhotoType) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.PhotoType)))
		i += copy(dAtA[i:], m.PhotoType)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.KeyId))
	}
	if m.DcId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.DcId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *MsgGetWebPhotoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetWebPhotoResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OtherPhotoData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.OtherPhotoData)))
		i += copy(dAtA[i:], m.OtherPhotoData)
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetSendPhotoSizeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetSendPhotoSizeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fileid))
	}
	if m.FileType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.FileType))
	}
	if len(m.Md5) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Md5)))
		i += copy(dAtA[i:], m.Md5)
	}
	if m.PartTotal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartTotal))
	}
	if m.DcId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.DcId))
	}
	return i, nil
}

func (m *MsgGetSendPhotoSizeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetSendPhotoSizeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SelfPhotoData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.SelfPhotoData)))
		i += copy(dAtA[i:], m.SelfPhotoData)
	}
	if len(m.OtherPhotoData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.OtherPhotoData)))
		i += copy(dAtA[i:], m.OtherPhotoData)
	}
	if m.Result != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetPhotoCachedSizeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetPhotoCachedSizeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.KeyId))
	}
	if m.DcId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.DcId))
	}
	if m.NewId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.NewId))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Size_))
	}
	return i, nil
}

func (m *MsgGetPhotoCachedSizeResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetPhotoCachedSizeResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CachePhotoData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.CachePhotoData)))
		i += copy(dAtA[i:], m.CachePhotoData)
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func (m *MsgGetPhotoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetPhotoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Keyid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Fileid))
	}
	if m.FileType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.FileType))
	}
	if len(m.Md5) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.Md5)))
		i += copy(dAtA[i:], m.Md5)
	}
	if m.PartTotal != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.PartTotal))
	}
	if m.DcId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.DcId))
	}
	return i, nil
}

func (m *MsgGetPhotoResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgGetPhotoResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OtherPhotoData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(len(m.OtherPhotoData)))
		i += copy(dAtA[i:], m.OtherPhotoData)
	}
	if m.Result != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStorageProto(dAtA, i, uint64(m.Result))
	}
	return i, nil
}

func encodeVarintStorageProto(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MsgServiceLimitReq) Size() (n int) {
	var l int
	_ = l
	if m.Reserved != 0 {
		n += 1 + sovStorageProto(uint64(m.Reserved))
	}
	return n
}

func (m *MsgServiceLimitResp) Size() (n int) {
	var l int
	_ = l
	if m.Usfsl != 0 {
		n += 1 + sovStorageProto(uint64(m.Usfsl))
	}
	if m.Ubfssl != 0 {
		n += 1 + sovStorageProto(uint64(m.Ubfssl))
	}
	if m.Dssl != 0 {
		n += 1 + sovStorageProto(uint64(m.Dssl))
	}
	return n
}

func (m *MsgQueryFileIsExistReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgQueryFileIsExistResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	if m.IsExist {
		n += 2
	}
	return n
}

func (m *MsgApplyFidReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.PartTotal != 0 {
		n += 1 + sovStorageProto(uint64(m.PartTotal))
	}
	if m.Ttl != 0 {
		n += 1 + sovStorageProto(uint64(m.Ttl))
	}
	return n
}

func (m *ApplyFidRespPara) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgApplyFidResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	return n
}

func (m *UploadReqPara1) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.PartId != 0 {
		n += 1 + sovStorageProto(uint64(m.PartId))
	}
	if m.PartSize != 0 {
		n += 1 + sovStorageProto(uint64(m.PartSize))
	}
	return n
}

func (m *UploadReqPara2) Size() (n int) {
	var l int
	_ = l
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovStorageProto(uint64(m.FileSize))
	}
	l = len(m.FileHash)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Ttl != 0 {
		n += 1 + sovStorageProto(uint64(m.Ttl))
	}
	return n
}

func (m *MsgUploadFileReq) Size() (n int) {
	var l int
	_ = l
	if m.Para1 != nil {
		l = m.Para1.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Para2 != nil {
		l = m.Para2.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *FileUploadRespPara) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.PartId != 0 {
		n += 1 + sovStorageProto(uint64(m.PartId))
	}
	return n
}

func (m *MsgUploadFileResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	if m.Para1 != nil {
		l = m.Para1.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Para2 != nil {
		l = m.Para2.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgDownloadFileReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	if m.Offset != 0 {
		n += 1 + sovStorageProto(uint64(m.Offset))
	}
	if m.Length != 0 {
		n += 1 + sovStorageProto(uint64(m.Length))
	}
	if m.Reserve != 0 {
		n += 1 + sovStorageProto(uint64(m.Reserve))
	}
	l = len(m.ReserveString)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *DownloadFileRespPara1) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.Offset != 0 {
		n += 1 + sovStorageProto(uint64(m.Offset))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *DownloadFileRespPara2) Size() (n int) {
	var l int
	_ = l
	if m.Length != 0 {
		n += 1 + sovStorageProto(uint64(m.Length))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgDownloadFileResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	if m.Para1 != nil {
		l = m.Para1.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Para2 != nil {
		l = m.Para2.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgDeleteFileReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	if m.RefNum != 0 {
		n += 1 + sovStorageProto(uint64(m.RefNum))
	}
	return n
}

func (m *MsgDeleteFileResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgCancelUploadReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgCancelUploadResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgAddRefCountReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	if m.RefNum != 0 {
		n += 1 + sovStorageProto(uint64(m.RefNum))
	}
	return n
}

func (m *MsgAddRefCountResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgModifyTTLReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	if m.Ttl != 0 {
		n += 1 + sovStorageProto(uint64(m.Ttl))
	}
	return n
}

func (m *MsgModifyTTLResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgQueryObjInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	return n
}

func (m *QueryObjInfoRespPara) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovStorageProto(uint64(m.Size_))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgQueryObjInfoResp) Size() (n int) {
	var l int
	_ = l
	if m.Para != nil {
		l = m.Para.Size()
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgFilePartsReq) Size() (n int) {
	var l int
	_ = l
	if m.Keyid != 0 {
		n += 1 + sovStorageProto(uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fileid))
	}
	if m.PartId != 0 {
		n += 1 + sovStorageProto(uint64(m.PartId))
	}
	if m.FileType != 0 {
		n += 1 + sovStorageProto(uint64(m.FileType))
	}
	if m.PartTotal != 0 {
		n += 1 + sovStorageProto(uint64(m.PartTotal))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgFilePartsResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgGetFidReq) Size() (n int) {
	var l int
	_ = l
	if m.Keyid != 0 {
		n += 1 + sovStorageProto(uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fileid))
	}
	if m.FileType != 0 {
		n += 1 + sovStorageProto(uint64(m.FileType))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.PartTotal != 0 {
		n += 1 + sovStorageProto(uint64(m.PartTotal))
	}
	return n
}

func (m *MsgGetFidResp) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	if m.FileSize != 0 {
		n += 1 + sovStorageProto(uint64(m.FileSize))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgFileDescReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.FromId != 0 {
		n += 1 + sovStorageProto(uint64(m.FromId))
	}
	if m.WithId != 0 {
		n += 1 + sovStorageProto(uint64(m.WithId))
	}
	l = len(m.ChatType)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.MediaType != 0 {
		n += 1 + sovStorageProto(uint64(m.MediaType))
	}
	if m.MessageId != 0 {
		n += 1 + sovStorageProto(uint64(m.MessageId))
	}
	return n
}

func (m *MsgFileDescResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgGetFileDescReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgGetFileDescResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgCutPictureMapReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgCutPictureMapResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgGetCutPictureMapReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgGetCutPictureMapResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgDelCutPictureMapReq) Size() (n int) {
	var l int
	_ = l
	if m.Fid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovStorageProto(uint64(m.AccessHash))
	}
	return n
}

func (m *MsgDelCutPictureMapResp) Size() (n int) {
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgGetWebPhotoReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhotoType)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovStorageProto(uint64(m.KeyId))
	}
	if m.DcId != 0 {
		n += 1 + sovStorageProto(uint64(m.DcId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	return n
}

func (m *MsgGetWebPhotoResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.OtherPhotoData)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgGetSendPhotoSizeReq) Size() (n int) {
	var l int
	_ = l
	if m.Keyid != 0 {
		n += 1 + sovStorageProto(uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fileid))
	}
	if m.FileType != 0 {
		n += 1 + sovStorageProto(uint64(m.FileType))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.PartTotal != 0 {
		n += 1 + sovStorageProto(uint64(m.PartTotal))
	}
	if m.DcId != 0 {
		n += 1 + sovStorageProto(uint64(m.DcId))
	}
	return n
}

func (m *MsgGetSendPhotoSizeResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.SelfPhotoData)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	l = len(m.OtherPhotoData)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgGetPhotoCachedSizeReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovStorageProto(uint64(m.KeyId))
	}
	if m.DcId != 0 {
		n += 1 + sovStorageProto(uint64(m.DcId))
	}
	if m.NewId != 0 {
		n += 1 + sovStorageProto(uint64(m.NewId))
	}
	if m.Size_ != 0 {
		n += 1 + sovStorageProto(uint64(m.Size_))
	}
	return n
}

func (m *MsgGetPhotoCachedSizeResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.CachePhotoData)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func (m *MsgGetPhotoReq) Size() (n int) {
	var l int
	_ = l
	if m.Keyid != 0 {
		n += 1 + sovStorageProto(uint64(m.Keyid))
	}
	if m.Fileid != 0 {
		n += 1 + sovStorageProto(uint64(m.Fileid))
	}
	if m.FileType != 0 {
		n += 1 + sovStorageProto(uint64(m.FileType))
	}
	l = len(m.Md5)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.PartTotal != 0 {
		n += 1 + sovStorageProto(uint64(m.PartTotal))
	}
	if m.DcId != 0 {
		n += 1 + sovStorageProto(uint64(m.DcId))
	}
	return n
}

func (m *MsgGetPhotoResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.OtherPhotoData)
	if l > 0 {
		n += 1 + l + sovStorageProto(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovStorageProto(uint64(m.Result))
	}
	return n
}

func sovStorageProto(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStorageProto(x uint64) (n int) {
	return sovStorageProto(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgServiceLimitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgServiceLimitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgServiceLimitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			m.Reserved = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgServiceLimitResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgServiceLimitResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgServiceLimitResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usfsl", wireType)
			}
			m.Usfsl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usfsl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ubfssl", wireType)
			}
			m.Ubfssl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ubfssl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dssl", wireType)
			}
			m.Dssl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dssl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgQueryFileIsExistReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgQueryFileIsExistReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgQueryFileIsExistReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgQueryFileIsExistResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgQueryFileIsExistResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgQueryFileIsExistResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &FileHashPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExist = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApplyFidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApplyFidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApplyFidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartTotal", wireType)
			}
			m.PartTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyFidRespPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyFidRespPara: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyFidRespPara: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApplyFidResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApplyFidResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApplyFidResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &ApplyFidRespPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadReqPara1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadReqPara1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadReqPara1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartId", wireType)
			}
			m.PartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartSize", wireType)
			}
			m.PartSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadReqPara2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadReqPara2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadReqPara2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUploadFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUploadFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUploadFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para1 == nil {
				m.Para1 = &UploadReqPara1{}
			}
			if err := m.Para1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para2 == nil {
				m.Para2 = &UploadReqPara2{}
			}
			if err := m.Para2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileUploadRespPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileUploadRespPara: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileUploadRespPara: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartId", wireType)
			}
			m.PartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUploadFileResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUploadFileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUploadFileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para1 == nil {
				m.Para1 = &FileUploadRespPara{}
			}
			if err := m.Para1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para2 == nil {
				m.Para2 = &FidPara{}
			}
			if err := m.Para2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDownloadFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDownloadFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDownloadFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			m.Reserve = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserve |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReserveString", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReserveString = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileRespPara1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileRespPara1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileRespPara1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadFileRespPara2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadFileRespPara2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadFileRespPara2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDownloadFileResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDownloadFileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDownloadFileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para1 == nil {
				m.Para1 = &DownloadFileRespPara1{}
			}
			if err := m.Para1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para2 == nil {
				m.Para2 = &DownloadFileRespPara2{}
			}
			if err := m.Para2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefNum", wireType)
			}
			m.RefNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeleteFileResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeleteFileResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeleteFileResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &FidPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelUploadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelUploadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelUploadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelUploadResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelUploadResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelUploadResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &FidPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddRefCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddRefCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddRefCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefNum", wireType)
			}
			m.RefNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddRefCountResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddRefCountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddRefCountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &FidPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyTTLReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyTTLReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyTTLReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgModifyTTLResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgModifyTTLResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgModifyTTLResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &FidPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgQueryObjInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgQueryObjInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgQueryObjInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryObjInfoRespPara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryObjInfoRespPara: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryObjInfoRespPara: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgQueryObjInfoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgQueryObjInfoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgQueryObjInfoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Para", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Para == nil {
				m.Para = &QueryObjInfoRespPara{}
			}
			if err := m.Para.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFilePartsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFilePartsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFilePartsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyid", wireType)
			}
			m.Keyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fileid", wireType)
			}
			m.Fileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartId", wireType)
			}
			m.PartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartTotal", wireType)
			}
			m.PartTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFilePartsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFilePartsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFilePartsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyid", wireType)
			}
			m.Keyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fileid", wireType)
			}
			m.Fileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartTotal", wireType)
			}
			m.PartTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFidResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFidResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFidResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFileDescReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFileDescReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFileDescReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaType", wireType)
			}
			m.MediaType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFileDescResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFileDescResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFileDescResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFileDescReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFileDescReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFileDescReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetFileDescResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetFileDescResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetFileDescResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCutPictureMapReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCutPictureMapReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCutPictureMapReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCutPictureMapResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCutPictureMapResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCutPictureMapResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetCutPictureMapReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetCutPictureMapReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetCutPictureMapReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetCutPictureMapResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetCutPictureMapResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetCutPictureMapResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDelCutPictureMapReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDelCutPictureMapReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDelCutPictureMapReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fid", wireType)
			}
			m.Fid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDelCutPictureMapResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDelCutPictureMapResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDelCutPictureMapResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetWebPhotoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetWebPhotoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetWebPhotoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetWebPhotoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetWebPhotoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetWebPhotoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherPhotoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherPhotoData = append(m.OtherPhotoData[:0], dAtA[iNdEx:postIndex]...)
			if m.OtherPhotoData == nil {
				m.OtherPhotoData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetSendPhotoSizeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetSendPhotoSizeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetSendPhotoSizeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyid", wireType)
			}
			m.Keyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fileid", wireType)
			}
			m.Fileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartTotal", wireType)
			}
			m.PartTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetSendPhotoSizeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetSendPhotoSizeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetSendPhotoSizeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfPhotoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfPhotoData = append(m.SelfPhotoData[:0], dAtA[iNdEx:postIndex]...)
			if m.SelfPhotoData == nil {
				m.SelfPhotoData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherPhotoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherPhotoData = append(m.OtherPhotoData[:0], dAtA[iNdEx:postIndex]...)
			if m.OtherPhotoData == nil {
				m.OtherPhotoData = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetPhotoCachedSizeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetPhotoCachedSizeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetPhotoCachedSizeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewId", wireType)
			}
			m.NewId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetPhotoCachedSizeResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetPhotoCachedSizeResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetPhotoCachedSizeResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachePhotoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CachePhotoData = append(m.CachePhotoData[:0], dAtA[iNdEx:postIndex]...)
			if m.CachePhotoData == nil {
				m.CachePhotoData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetPhotoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetPhotoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetPhotoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyid", wireType)
			}
			m.Keyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Keyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fileid", wireType)
			}
			m.Fileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartTotal", wireType)
			}
			m.PartTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartTotal |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgGetPhotoResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgGetPhotoResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgGetPhotoResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherPhotoData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorageProto
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherPhotoData = append(m.OtherPhotoData[:0], dAtA[iNdEx:postIndex]...)
			if m.OtherPhotoData == nil {
				m.OtherPhotoData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= (ERpcResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorageProto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorageProto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStorageProto(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStorageProto
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorageProto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStorageProto
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStorageProto
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStorageProto(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStorageProto = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStorageProto   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/storageservice/storage_proto.proto", fileDescriptorStorageProto)
}

var fileDescriptorStorageProto = []byte{
	// 1607 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x5d, 0x73, 0x1b, 0x35,
	0x17, 0xee, 0xfa, 0x2b, 0x89, 0x9a, 0xe4, 0x4d, 0xd5, 0xa4, 0x71, 0xfd, 0xb6, 0x69, 0xaa, 0xb7,
	0xed, 0x74, 0xe6, 0x1d, 0xd2, 0xd6, 0xb4, 0x4c, 0x67, 0x7a, 0xc1, 0x94, 0xa4, 0x09, 0x86, 0xba,
	0x4d, 0xd7, 0x81, 0xb6, 0x0c, 0xc4, 0xac, 0xbd, 0x5a, 0x7b, 0xa9, 0xed, 0xdd, 0xae, 0x64, 0x52,
	0x87, 0x1f, 0xc0, 0x0c, 0x97, 0xdc, 0x30, 0x5c, 0x31, 0xdc, 0xc1, 0x3f, 0xe0, 0x1f, 0x00, 0x77,
	0xdc, 0x70, 0xcf, 0x74, 0xf8, 0x21, 0x8c, 0x8e, 0x56, 0xde, 0xcf, 0xc4, 0x8d, 0x1d, 0x0a, 0x37,
	0x1e, 0xe9, 0x48, 0x7a, 0x74, 0xce, 0xa3, 0x47, 0x3a, 0xd2, 0x1a, 0x6d, 0xb5, 0x6c, 0xde, 0x31,
	0x1a, 0x6b, 0xcd, 0xb6, 0xc1, 0x19, 0xf5, 0x3e, 0xa7, 0xde, 0x9a, 0xdd, 0xbd, 0x66, 0xf7, 0x38,
	0xf5, 0x2c, 0xa3, 0x49, 0x5d, 0xcf, 0x69, 0xf4, 0xad, 0x6b, 0x8c, 0x3b, 0x9e, 0xd1, 0xa2, 0xa2,
	0x83, 0xdd, 0xa4, 0xaa, 0x5a, 0x77, 0x3d, 0x87, 0x3b, 0x6b, 0xf0, 0x8b, 0xe7, 0xa3, 0x7d, 0x4a,
	0xf7, 0x26, 0x02, 0xee, 0x37, 0x24, 0x2c, 0xb9, 0x8e, 0x70, 0x95, 0xb5, 0x6a, 0xb2, 0xfd, 0xbe,
	0xdd, 0xb5, 0xb9, 0x4e, 0x9f, 0xe3, 0x12, 0x9a, 0xf6, 0x60, 0x10, 0x35, 0x8b, 0xda, 0xaa, 0x76,
	0x75, 0x4e, 0x1f, 0xd6, 0xc9, 0x63, 0x74, 0x3a, 0x31, 0x82, 0xb9, 0x78, 0x11, 0xe5, 0xfb, 0xcc,
	0x62, 0x1d, 0xbf, 0xbf, 0xac, 0xe0, 0x33, 0xa8, 0xd0, 0x6f, 0x58, 0x8c, 0x75, 0x8a, 0x19, 0x30,
	0xfb, 0x35, 0x8c, 0x51, 0xce, 0x14, 0xd6, 0x2c, 0x58, 0xa1, 0x4c, 0x6e, 0xa1, 0x33, 0x55, 0xd6,
	0x7a, 0xd4, 0xa7, 0xde, 0x60, 0xd3, 0xee, 0xd0, 0x0a, 0xbb, 0xf7, 0xc2, 0x66, 0xe0, 0xce, 0x7f,
	0xd1, 0x8c, 0x65, 0x77, 0x68, 0xbd, 0x6d, 0xb0, 0x36, 0xe0, 0xcf, 0xe8, 0xd3, 0xc2, 0xf0, 0xae,
	0xc1, 0xda, 0xe4, 0x5b, 0x0d, 0x2d, 0xa7, 0x8e, 0x63, 0x2e, 0xbe, 0x8e, 0x72, 0xae, 0xe1, 0x19,
	0x30, 0xe6, 0x64, 0xf9, 0xdc, 0x5a, 0x94, 0x8e, 0xb5, 0x4d, 0x1f, 0x63, 0xdb, 0xf0, 0x0c, 0x1d,
	0x7a, 0xe2, 0x05, 0x94, 0xb5, 0x6c, 0x13, 0xbc, 0xcd, 0xe9, 0xa2, 0x88, 0x2f, 0xa0, 0x93, 0x46,
	0xb3, 0x49, 0x19, 0x93, 0xd3, 0x67, 0xa1, 0x05, 0x49, 0x93, 0x18, 0x8c, 0xcf, 0xa2, 0x69, 0x9b,
	0xd5, 0xa9, 0x98, 0xb4, 0x98, 0x5b, 0xd5, 0xae, 0x4e, 0xeb, 0x53, 0xb6, 0xf4, 0x81, 0xec, 0xa2,
	0xf9, 0x2a, 0x6b, 0xdd, 0x75, 0xdd, 0xce, 0x60, 0xd3, 0x36, 0xc3, 0xa1, 0xf4, 0x8c, 0x2e, 0x0d,
	0x87, 0xf2, 0xc0, 0xe8, 0x52, 0x7c, 0x1e, 0x21, 0xd7, 0xf0, 0x78, 0x9d, 0x3b, 0xdc, 0x50, 0x8c,
	0xcd, 0x08, 0xcb, 0x8e, 0x30, 0x08, 0xdf, 0x38, 0x57, 0x9c, 0x89, 0x22, 0xb9, 0x86, 0x16, 0x02,
	0x70, 0xe6, 0x8a, 0x38, 0x0e, 0x9d, 0x81, 0xec, 0xa3, 0xff, 0x44, 0x1c, 0x62, 0x2e, 0xbe, 0x19,
	0xe1, 0x68, 0x35, 0xce, 0x51, 0x1c, 0x7f, 0x6c, 0x9e, 0xc8, 0x13, 0x34, 0xff, 0x81, 0xdb, 0x71,
	0x0c, 0xc1, 0x83, 0x40, 0xba, 0xa1, 0x40, 0xb4, 0x00, 0x64, 0x19, 0x4d, 0x01, 0x03, 0x3e, 0xf4,
	0x9c, 0x5e, 0x10, 0xd5, 0x8a, 0x29, 0xa2, 0x82, 0x06, 0x66, 0xef, 0x53, 0x9f, 0x81, 0x69, 0x61,
	0xa8, 0xd9, 0xfb, 0x94, 0x0c, 0x62, 0xc8, 0xe5, 0xc3, 0x69, 0x56, 0x8d, 0x80, 0x25, 0xa7, 0x81,
	0x46, 0x81, 0x15, 0xd5, 0x5a, 0x36, 0xaa, 0x35, 0xb5, 0x02, 0xb9, 0x60, 0x05, 0xbe, 0xd6, 0xd0,
	0x42, 0x95, 0xb5, 0xe4, 0xf4, 0x42, 0x4f, 0x62, 0x91, 0x6f, 0xa2, 0xbc, 0x20, 0xe9, 0x86, 0xcf,
	0xe9, 0x4a, 0x9c, 0xd3, 0x28, 0x0d, 0xba, 0xec, 0xac, 0x46, 0x95, 0xc1, 0xa5, 0x51, 0xa3, 0xca,
	0x72, 0x54, 0x19, 0x76, 0x92, 0xc1, 0x0d, 0x70, 0x75, 0x56, 0x87, 0x32, 0x79, 0x1b, 0x61, 0xe1,
	0x8a, 0x1a, 0xe0, 0x0b, 0xe3, 0xd5, 0xd9, 0x26, 0xbf, 0x6b, 0xe8, 0x54, 0x2c, 0x2a, 0xe6, 0xe2,
	0xb7, 0x50, 0xc1, 0xa3, 0xac, 0xdf, 0xe1, 0x80, 0x31, 0x9f, 0xf4, 0xf0, 0x9e, 0xee, 0x36, 0x75,
	0xe8, 0xb1, 0xee, 0x98, 0x54, 0xf7, 0x7b, 0xe3, 0xdb, 0x8a, 0x0e, 0x19, 0x18, 0x49, 0xdb, 0x86,
	0x51, 0x5f, 0x15, 0x25, 0x6f, 0x28, 0x4a, 0xb2, 0x30, 0x72, 0x39, 0x39, 0xd2, 0x0c, 0xba, 0x97,
	0xe3, 0x12, 0xcc, 0x25, 0x24, 0xf8, 0x93, 0x06, 0xc7, 0xdd, 0x86, 0xb3, 0xd7, 0x0b, 0xaf, 0x57,
	0x92, 0x99, 0x18, 0x52, 0x26, 0xb1, 0xe9, 0xcf, 0xa0, 0x82, 0x63, 0x59, 0x8c, 0x72, 0x5f, 0x8c,
	0x7e, 0x4d, 0xd8, 0x3b, 0xb4, 0xd7, 0xe2, 0x6d, 0x5f, 0x24, 0x7e, 0x0d, 0x17, 0xd1, 0x94, 0x7f,
	0x82, 0x16, 0xf3, 0x00, 0xa6, 0xaa, 0xf8, 0x32, 0x9a, 0xf7, 0x8b, 0x75, 0xc6, 0x3d, 0xbb, 0xd7,
	0x2a, 0x16, 0x40, 0x75, 0x73, 0xbe, 0xb5, 0x06, 0x46, 0xb2, 0x8b, 0x96, 0xa2, 0x6e, 0x4b, 0xa6,
	0xd2, 0x36, 0x51, 0xe0, 0x5b, 0x26, 0xe2, 0x5b, 0x64, 0x53, 0x64, 0x63, 0x27, 0xc3, 0x7a, 0x3a,
	0x7e, 0x39, 0x14, 0x51, 0x26, 0x12, 0x51, 0x9a, 0xf0, 0x7e, 0xd6, 0x20, 0x39, 0xc4, 0x81, 0xc6,
	0x56, 0xce, 0x9d, 0xa8, 0x72, 0x2e, 0xc7, 0x87, 0xa5, 0x32, 0xa2, 0xc4, 0x73, 0x27, 0x2a, 0x9e,
	0x57, 0x1a, 0xac, 0xb6, 0x15, 0xd9, 0x85, 0x6d, 0xbd, 0x41, 0x3b, 0x94, 0xd3, 0x09, 0x64, 0xb2,
	0x2c, 0x96, 0xdd, 0xaa, 0xf7, 0xfa, 0x5d, 0xa5, 0x13, 0x8f, 0x5a, 0x0f, 0xfa, 0x5d, 0xf2, 0x02,
	0x36, 0x58, 0x18, 0x9f, 0xb9, 0xf8, 0xff, 0x91, 0xa3, 0xf8, 0x40, 0xb5, 0xcb, 0x13, 0x38, 0xe0,
	0x34, 0x73, 0x14, 0x4e, 0xc9, 0x16, 0x6c, 0x81, 0x75, 0xa3, 0xd7, 0xa4, 0x9d, 0xe1, 0x91, 0x32,
	0x46, 0x6c, 0x64, 0x1f, 0xd6, 0x3a, 0x0a, 0xf4, 0xba, 0x82, 0xa8, 0x03, 0x7d, 0x77, 0x4d, 0x53,
	0xa7, 0xd6, 0xba, 0xd3, 0xef, 0xf1, 0xe3, 0x5e, 0x9f, 0x01, 0xb0, 0x14, 0x99, 0xe0, 0x75, 0xc5,
	0xf6, 0x21, 0xe4, 0xe8, 0xaa, 0x63, 0xda, 0xd6, 0x60, 0x67, 0xe7, 0xfe, 0x98, 0x91, 0x25, 0x2f,
	0x0b, 0x7b, 0x20, 0xe9, 0x10, 0xee, 0xeb, 0x0a, 0xe8, 0x0a, 0x70, 0x09, 0x17, 0xb4, 0x87, 0x8d,
	0xcf, 0x2a, 0x3d, 0xcb, 0x49, 0x8d, 0x89, 0xd4, 0xd1, 0x62, 0xb4, 0x93, 0x9f, 0xb8, 0x30, 0xca,
	0x85, 0xf2, 0x38, 0x94, 0x85, 0x6d, 0x98, 0xbe, 0x73, 0x3a, 0x94, 0x47, 0xdf, 0x40, 0xbe, 0x94,
	0xc7, 0x53, 0x7c, 0x12, 0x7c, 0x3b, 0xc2, 0xc2, 0xa5, 0x78, 0x58, 0x69, 0x4e, 0x4d, 0x48, 0xc9,
	0x0f, 0x1a, 0x2c, 0xb2, 0xd8, 0xf9, 0xdb, 0x86, 0xc7, 0x99, 0x20, 0x64, 0x11, 0xe5, 0x9f, 0xd1,
	0xc1, 0x90, 0x12, 0x59, 0x11, 0xc7, 0xaf, 0x38, 0xa3, 0xfd, 0x14, 0x9d, 0xd5, 0xfd, 0x5a, 0x38,
	0x77, 0x67, 0xe3, 0x37, 0x25, 0x38, 0xe5, 0xf9, 0xc0, 0xa5, 0x7e, 0x12, 0x82, 0x53, 0x7e, 0x67,
	0xe0, 0xc6, 0x6f, 0x98, 0xf9, 0xf8, 0x0d, 0x53, 0x9d, 0xe9, 0x85, 0xd0, 0x99, 0xfe, 0x1e, 0xc8,
	0x26, 0xe4, 0xe9, 0xf8, 0xe7, 0x39, 0xf9, 0x4a, 0x43, 0xb3, 0x55, 0xd6, 0xda, 0xa2, 0xdc, 0xbf,
	0x0e, 0x1f, 0x2d, 0xe6, 0x48, 0x68, 0xd9, 0x58, 0x68, 0x0b, 0x28, 0xdb, 0x35, 0x6f, 0x41, 0xc4,
	0x33, 0xba, 0x28, 0x8e, 0x08, 0x96, 0x7c, 0xa3, 0xa1, 0xb9, 0x90, 0x33, 0xcc, 0x1d, 0x67, 0x9b,
	0x45, 0xee, 0x92, 0x52, 0x71, 0xc1, 0x5d, 0x32, 0xa0, 0x29, 0x77, 0x24, 0x9a, 0xfe, 0xd4, 0xe0,
	0xdd, 0x20, 0x38, 0xdf, 0xa0, 0xac, 0x39, 0xe6, 0x09, 0x90, 0x92, 0xa0, 0x85, 0x6a, 0x2c, 0xcf,
	0xe9, 0x0a, 0xd5, 0x08, 0x97, 0xf2, 0x7a, 0x41, 0x54, 0x2b, 0x20, 0xa7, 0x3d, 0x9b, 0xb7, 0x45,
	0x43, 0x5e, 0x36, 0x88, 0xaa, 0x94, 0x93, 0x78, 0x62, 0x4a, 0xce, 0xe5, 0xcd, 0x64, 0x5a, 0x18,
	0x94, 0x9c, 0xba, 0xd4, 0xb4, 0x0d, 0xd9, 0x3a, 0x05, 0x03, 0x67, 0xc0, 0x12, 0x34, 0x33, 0x26,
	0x5e, 0x9c, 0xb6, 0x59, 0x9c, 0x56, 0xcd, 0x60, 0xa9, 0x98, 0xa4, 0x32, 0xdc, 0x03, 0x32, 0xca,
	0x09, 0x84, 0xb5, 0x09, 0xf9, 0x00, 0x96, 0x72, 0x12, 0xce, 0xc8, 0xa7, 0x70, 0x54, 0x45, 0x70,
	0x26, 0xb8, 0xbe, 0xa8, 0x15, 0xc8, 0x84, 0xb6, 0xd3, 0xc7, 0x32, 0x6b, 0xf6, 0xf9, 0xb6, 0xdd,
	0xe4, 0x7d, 0x8f, 0x56, 0x0d, 0xf7, 0xf8, 0xd6, 0x97, 0x3c, 0x40, 0x8b, 0x49, 0xf4, 0x09, 0x78,
	0x7d, 0x1f, 0xde, 0xe4, 0x5b, 0x94, 0x1f, 0x83, 0xc3, 0x84, 0xc2, 0x43, 0x3d, 0x09, 0x76, 0xcc,
	0x0c, 0x4b, 0x9f, 0x37, 0x68, 0xe7, 0x38, 0x7c, 0x7e, 0x04, 0x3e, 0x27, 0xc1, 0x26, 0xe0, 0xf4,
	0xb9, 0xd2, 0xea, 0x63, 0xda, 0xd8, 0x6e, 0x3b, 0x1c, 0xb2, 0xe1, 0x39, 0x34, 0x03, 0x65, 0xb1,
	0x6f, 0xfc, 0x44, 0x17, 0x18, 0xf0, 0x12, 0x2a, 0x3c, 0xa3, 0x83, 0xfa, 0xf0, 0xc1, 0x2d, 0xce,
	0xc9, 0x8a, 0x89, 0x4f, 0xa3, 0xbc, 0xd9, 0x54, 0x19, 0x20, 0xaf, 0xe7, 0xcc, 0x66, 0xc5, 0x1c,
	0x52, 0x92, 0x0b, 0x51, 0xc2, 0x95, 0xac, 0x83, 0x29, 0x99, 0x8b, 0xaf, 0xa0, 0xf9, 0x87, 0xbc,
	0x4d, 0x3d, 0xb0, 0x6c, 0x88, 0x31, 0x1a, 0x8c, 0x89, 0x59, 0xc7, 0x4e, 0x72, 0x3f, 0x6a, 0x4a,
	0x3d, 0x35, 0xda, 0x33, 0x01, 0x4f, 0x1c, 0x8b, 0xff, 0xf0, 0xb9, 0x1f, 0xb0, 0x56, 0x08, 0x58,
	0x23, 0xdf, 0x69, 0x4a, 0x9c, 0x31, 0x5f, 0x99, 0x8b, 0x2f, 0xa1, 0xb9, 0x1a, 0xed, 0x58, 0x71,
	0x9a, 0xa2, 0xc6, 0x14, 0x36, 0x33, 0x23, 0xd8, 0xcc, 0x1e, 0x51, 0x36, 0x45, 0xe9, 0x20, 0x40,
	0xad, 0x1b, 0xcd, 0x36, 0x35, 0x15, 0x9d, 0x81, 0x3e, 0x34, 0x20, 0x2e, 0xae, 0x8f, 0x4c, 0x48,
	0x1f, 0x4b, 0xa8, 0xd0, 0xa3, 0x7b, 0x4a, 0x35, 0x59, 0x3d, 0xdf, 0xa3, 0x7b, 0x52, 0x36, 0x90,
	0xc3, 0x64, 0x5a, 0x80, 0x32, 0xf9, 0x02, 0x9d, 0x3d, 0x60, 0x4a, 0xa9, 0x1e, 0xb0, 0x24, 0xd4,
	0x13, 0xb5, 0x8e, 0xad, 0x9e, 0xef, 0x65, 0x12, 0x54, 0xb3, 0xff, 0x2b, 0x55, 0xf3, 0x1c, 0x32,
	0x58, 0xe0, 0xe2, 0xdf, 0xbf, 0xa9, 0xca, 0xbf, 0x16, 0xe4, 0xc7, 0x9d, 0x9a, 0xec, 0xed, 0x7f,
	0x87, 0xc5, 0x4f, 0xd1, 0x6c, 0xf8, 0x93, 0x2c, 0x4e, 0x7c, 0x64, 0x49, 0x7e, 0xe5, 0x2d, 0xfd,
	0x6f, 0x64, 0x1f, 0xe6, 0x92, 0x13, 0xb8, 0x86, 0x50, 0xf0, 0x21, 0x08, 0xaf, 0xa6, 0x0c, 0x8a,
	0x7c, 0xfd, 0x2a, 0x5d, 0x1c, 0xd1, 0x03, 0x40, 0x9f, 0xa2, 0xd9, 0xf0, 0xfb, 0x3b, 0xd5, 0xdf,
	0xd8, 0x67, 0x9a, 0x54, 0x7f, 0xe3, 0x8f, 0x78, 0x72, 0x02, 0xef, 0xa2, 0x53, 0x61, 0x2b, 0xc8,
	0xf1, 0x38, 0xf1, 0x9f, 0xa2, 0xd9, 0xf0, 0x8b, 0x20, 0x15, 0x3a, 0xf6, 0xd8, 0x49, 0x85, 0x8e,
	0x3f, 0x2b, 0xc8, 0x09, 0xfc, 0x04, 0x9d, 0xda, 0x32, 0x38, 0xdd, 0x33, 0x06, 0x21, 0xc6, 0x2f,
	0xa4, 0x8c, 0x0d, 0x3f, 0x1c, 0x4a, 0xab, 0x87, 0x77, 0xf0, 0x91, 0x97, 0x7d, 0xe4, 0x2d, 0xca,
	0x03, 0xf0, 0x4d, 0xdb, 0xc4, 0xe7, 0x52, 0x86, 0x0f, 0x6f, 0xe8, 0xa5, 0xf3, 0x87, 0xb4, 0x02,
	0xf2, 0x47, 0x68, 0x29, 0xe1, 0xb3, 0xb8, 0x39, 0xe1, 0x95, 0x03, 0xdc, 0xf2, 0xaf, 0x67, 0xa5,
	0x0b, 0x87, 0xb6, 0x03, 0xf6, 0x27, 0x08, 0x07, 0x5e, 0x0f, 0x81, 0x2f, 0x1e, 0xe4, 0x52, 0x80,
	0x4d, 0x46, 0x75, 0x11, 0xf0, 0xef, 0xcc, 0xfe, 0xf2, 0x72, 0x45, 0xfb, 0xed, 0xe5, 0x8a, 0xf6,
	0xc7, 0xcb, 0x15, 0xad, 0x51, 0x80, 0x7f, 0x44, 0xde, 0xfc, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x6d,
	0x09, 0x7b, 0xc4, 0xb3, 0x19, 0x00, 0x00,
}
