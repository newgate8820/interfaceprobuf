// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: route/route.proto

/*
Package route is a generated protocol buffer package.

It is generated from these files:

	route/route.proto

It has these top-level messages:

	DelUserRequest
	DelUserReply
	FindUserRequest
	FindUserReply
	UpdateUserRequest
	UpdateUserReply
	FindUserExRequest
	FindUserExReply
	KeyInfo
	UpdateUserExRequest
	UpdateUserExReply
	UpdateUserExV2Request
	UpdateUserExV2Reply
	FindUsersRequest
	FindUsersReply
	UpdateUsersRequest
	UpdateUsersReply
	Route
	RegisterClient
	PeerUser
	RegisterUser
	UnregisterUser
	Message
	MessageContent
*/
package route

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type DelUserRequest_OpType int32

const (
	DelUserRequest_DelOne   DelUserRequest_OpType = 0
	DelUserRequest_DelOther DelUserRequest_OpType = 1
)

var DelUserRequest_OpType_name = map[int32]string{
	0: "DelOne",
	1: "DelOther",
}
var DelUserRequest_OpType_value = map[string]int32{
	"DelOne":   0,
	"DelOther": 1,
}

func (x DelUserRequest_OpType) String() string {
	return proto.EnumName(DelUserRequest_OpType_name, int32(x))
}
func (DelUserRequest_OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRoute, []int{0, 0}
}

type FindUserRequest_OpType int32

const (
	FindUserRequest_FindAll   FindUserRequest_OpType = 0
	FindUserRequest_FindOne   FindUserRequest_OpType = 1
	FindUserRequest_FindOther FindUserRequest_OpType = 2
)

var FindUserRequest_OpType_name = map[int32]string{
	0: "FindAll",
	1: "FindOne",
	2: "FindOther",
}
var FindUserRequest_OpType_value = map[string]int32{
	"FindAll":   0,
	"FindOne":   1,
	"FindOther": 2,
}

func (x FindUserRequest_OpType) String() string {
	return proto.EnumName(FindUserRequest_OpType_name, int32(x))
}
func (FindUserRequest_OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRoute, []int{2, 0}
}

type FindUserExRequest_OpType int32

const (
	FindUserExRequest_FindAll   FindUserExRequest_OpType = 0
	FindUserExRequest_FindOne   FindUserExRequest_OpType = 1
	FindUserExRequest_FindOther FindUserExRequest_OpType = 2
)

var FindUserExRequest_OpType_name = map[int32]string{
	0: "FindAll",
	1: "FindOne",
	2: "FindOther",
}
var FindUserExRequest_OpType_value = map[string]int32{
	"FindAll":   0,
	"FindOne":   1,
	"FindOther": 2,
}

func (x FindUserExRequest_OpType) String() string {
	return proto.EnumName(FindUserExRequest_OpType_name, int32(x))
}
func (FindUserExRequest_OpType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorRoute, []int{6, 0}
}

type Route_Kind int32

const (
	Route_RegisterUser   Route_Kind = 0
	Route_UnregisterUser Route_Kind = 1
	Route_Data           Route_Kind = 2
	Route_RegisterClient Route_Kind = 3
)

var Route_Kind_name = map[int32]string{
	0: "RegisterUser",
	1: "UnregisterUser",
	2: "Data",
	3: "RegisterClient",
}
var Route_Kind_value = map[string]int32{
	"RegisterUser":   0,
	"UnregisterUser": 1,
	"Data":           2,
	"RegisterClient": 3,
}

func (x Route_Kind) String() string {
	return proto.EnumName(Route_Kind_name, int32(x))
}
func (Route_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorRoute, []int{17, 0} }

type Message_Kind int32

const (
	Message_SendUser      Message_Kind = 0
	Message_SendUserOne   Message_Kind = 1
	Message_SendUserOther Message_Kind = 3
)

var Message_Kind_name = map[int32]string{
	0: "SendUser",
	1: "SendUserOne",
	3: "SendUserOther",
}
var Message_Kind_value = map[string]int32{
	"SendUser":      0,
	"SendUserOne":   1,
	"SendUserOther": 3,
}

func (x Message_Kind) String() string {
	return proto.EnumName(Message_Kind_name, int32(x))
}
func (Message_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorRoute, []int{22, 0} }

type DelUserRequest struct {
	Peer *PeerUser             `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	How  DelUserRequest_OpType `protobuf:"varint,2,opt,name=how,proto3,enum=route.DelUserRequest_OpType" json:"how,omitempty"`
}

func (m *DelUserRequest) Reset()                    { *m = DelUserRequest{} }
func (m *DelUserRequest) String() string            { return proto.CompactTextString(m) }
func (*DelUserRequest) ProtoMessage()               {}
func (*DelUserRequest) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{0} }

func (m *DelUserRequest) GetPeer() *PeerUser {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *DelUserRequest) GetHow() DelUserRequest_OpType {
	if m != nil {
		return m.How
	}
	return DelUserRequest_DelOne
}

type DelUserReply struct {
}

func (m *DelUserReply) Reset()                    { *m = DelUserReply{} }
func (m *DelUserReply) String() string            { return proto.CompactTextString(m) }
func (*DelUserReply) ProtoMessage()               {}
func (*DelUserReply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{1} }

type FindUserRequest struct {
	Peer *PeerUser              `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	How  FindUserRequest_OpType `protobuf:"varint,2,opt,name=how,proto3,enum=route.FindUserRequest_OpType" json:"how,omitempty"`
}

func (m *FindUserRequest) Reset()                    { *m = FindUserRequest{} }
func (m *FindUserRequest) String() string            { return proto.CompactTextString(m) }
func (*FindUserRequest) ProtoMessage()               {}
func (*FindUserRequest) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{2} }

func (m *FindUserRequest) GetPeer() *PeerUser {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *FindUserRequest) GetHow() FindUserRequest_OpType {
	if m != nil {
		return m.How
	}
	return FindUserRequest_FindAll
}

type FindUserReply struct {
	TopicIdentifiers []uint32 `protobuf:"varint,1,rep,packed,name=topic_identifiers,json=topicIdentifiers" json:"topic_identifiers,omitempty"`
}

func (m *FindUserReply) Reset()                    { *m = FindUserReply{} }
func (m *FindUserReply) String() string            { return proto.CompactTextString(m) }
func (*FindUserReply) ProtoMessage()               {}
func (*FindUserReply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{3} }

func (m *FindUserReply) GetTopicIdentifiers() []uint32 {
	if m != nil {
		return m.TopicIdentifiers
	}
	return nil
}

type UpdateUserRequest struct {
	Peer       *PeerUser `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	Online     bool      `protobuf:"varint,2,opt,name=online,proto3" json:"online,omitempty"`
	Updated    int64     `protobuf:"varint,3,opt,name=updated,proto3" json:"updated,omitempty"`
	TopicId    uint32    `protobuf:"varint,4,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	DelayDeath bool      `protobuf:"varint,5,opt,name=delay_death,json=delayDeath,proto3" json:"delay_death,omitempty"`
}

func (m *UpdateUserRequest) Reset()                    { *m = UpdateUserRequest{} }
func (m *UpdateUserRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserRequest) ProtoMessage()               {}
func (*UpdateUserRequest) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{4} }

func (m *UpdateUserRequest) GetPeer() *PeerUser {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateUserRequest) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *UpdateUserRequest) GetUpdated() int64 {
	if m != nil {
		return m.Updated
	}
	return 0
}

func (m *UpdateUserRequest) GetTopicId() uint32 {
	if m != nil {
		return m.TopicId
	}
	return 0
}

func (m *UpdateUserRequest) GetDelayDeath() bool {
	if m != nil {
		return m.DelayDeath
	}
	return false
}

type UpdateUserReply struct {
}

func (m *UpdateUserReply) Reset()                    { *m = UpdateUserReply{} }
func (m *UpdateUserReply) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserReply) ProtoMessage()               {}
func (*UpdateUserReply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{5} }

type FindUserExRequest struct {
	Peer *PeerUser                `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	How  FindUserExRequest_OpType `protobuf:"varint,2,opt,name=how,proto3,enum=route.FindUserExRequest_OpType" json:"how,omitempty"`
}

func (m *FindUserExRequest) Reset()                    { *m = FindUserExRequest{} }
func (m *FindUserExRequest) String() string            { return proto.CompactTextString(m) }
func (*FindUserExRequest) ProtoMessage()               {}
func (*FindUserExRequest) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{6} }

func (m *FindUserExRequest) GetPeer() *PeerUser {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *FindUserExRequest) GetHow() FindUserExRequest_OpType {
	if m != nil {
		return m.How
	}
	return FindUserExRequest_FindAll
}

type FindUserExReply struct {
	Keys []*KeyInfo `protobuf:"bytes,1,rep,name=keys" json:"keys,omitempty"`
}

func (m *FindUserExReply) Reset()                    { *m = FindUserExReply{} }
func (m *FindUserExReply) String() string            { return proto.CompactTextString(m) }
func (*FindUserExReply) ProtoMessage()               {}
func (*FindUserExReply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{7} }

func (m *FindUserExReply) GetKeys() []*KeyInfo {
	if m != nil {
		return m.Keys
	}
	return nil
}

type KeyInfo struct {
	AuthKeyId       uint64 `protobuf:"varint,1,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	TopicIdentifier uint32 `protobuf:"varint,2,opt,name=topic_identifier,json=topicIdentifier,proto3" json:"topic_identifier,omitempty"`
	Layer           uint32 `protobuf:"varint,3,opt,name=layer,proto3" json:"layer,omitempty"`
	Version         string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	ApiId           int32  `protobuf:"varint,5,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
}

func (m *KeyInfo) Reset()                    { *m = KeyInfo{} }
func (m *KeyInfo) String() string            { return proto.CompactTextString(m) }
func (*KeyInfo) ProtoMessage()               {}
func (*KeyInfo) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{8} }

func (m *KeyInfo) GetAuthKeyId() uint64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *KeyInfo) GetTopicIdentifier() uint32 {
	if m != nil {
		return m.TopicIdentifier
	}
	return 0
}

func (m *KeyInfo) GetLayer() uint32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *KeyInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *KeyInfo) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

type UpdateUserExRequest struct {
	Peer       *PeerUser `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	Online     bool      `protobuf:"varint,2,opt,name=online,proto3" json:"online,omitempty"`
	Updated    int64     `protobuf:"varint,3,opt,name=updated,proto3" json:"updated,omitempty"`
	TopicId    uint32    `protobuf:"varint,4,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	DelayDeath bool      `protobuf:"varint,5,opt,name=delay_death,json=delayDeath,proto3" json:"delay_death,omitempty"`
	Layer      uint32    `protobuf:"varint,6,opt,name=layer,proto3" json:"layer,omitempty"`
	Version    string    `protobuf:"bytes,7,opt,name=version,proto3" json:"version,omitempty"`
	ApiId      int32     `protobuf:"varint,8,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
}

func (m *UpdateUserExRequest) Reset()                    { *m = UpdateUserExRequest{} }
func (m *UpdateUserExRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserExRequest) ProtoMessage()               {}
func (*UpdateUserExRequest) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{9} }

func (m *UpdateUserExRequest) GetPeer() *PeerUser {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateUserExRequest) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *UpdateUserExRequest) GetUpdated() int64 {
	if m != nil {
		return m.Updated
	}
	return 0
}

func (m *UpdateUserExRequest) GetTopicId() uint32 {
	if m != nil {
		return m.TopicId
	}
	return 0
}

func (m *UpdateUserExRequest) GetDelayDeath() bool {
	if m != nil {
		return m.DelayDeath
	}
	return false
}

func (m *UpdateUserExRequest) GetLayer() uint32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *UpdateUserExRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *UpdateUserExRequest) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

type UpdateUserExReply struct {
}

func (m *UpdateUserExReply) Reset()                    { *m = UpdateUserExReply{} }
func (m *UpdateUserExReply) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserExReply) ProtoMessage()               {}
func (*UpdateUserExReply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{10} }

type UpdateUserExV2Request struct {
	Peer       *PeerUser `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	Online     bool      `protobuf:"varint,2,opt,name=online,proto3" json:"online,omitempty"`
	Delay      int64     `protobuf:"varint,3,opt,name=delay,proto3" json:"delay,omitempty"`
	TopicId    uint32    `protobuf:"varint,4,opt,name=topic_id,json=topicId,proto3" json:"topic_id,omitempty"`
	DelayDeath bool      `protobuf:"varint,5,opt,name=delay_death,json=delayDeath,proto3" json:"delay_death,omitempty"`
	Layer      uint32    `protobuf:"varint,6,opt,name=layer,proto3" json:"layer,omitempty"`
	Version    string    `protobuf:"bytes,7,opt,name=version,proto3" json:"version,omitempty"`
	ApiId      int32     `protobuf:"varint,8,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
}

func (m *UpdateUserExV2Request) Reset()                    { *m = UpdateUserExV2Request{} }
func (m *UpdateUserExV2Request) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserExV2Request) ProtoMessage()               {}
func (*UpdateUserExV2Request) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{11} }

func (m *UpdateUserExV2Request) GetPeer() *PeerUser {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *UpdateUserExV2Request) GetOnline() bool {
	if m != nil {
		return m.Online
	}
	return false
}

func (m *UpdateUserExV2Request) GetDelay() int64 {
	if m != nil {
		return m.Delay
	}
	return 0
}

func (m *UpdateUserExV2Request) GetTopicId() uint32 {
	if m != nil {
		return m.TopicId
	}
	return 0
}

func (m *UpdateUserExV2Request) GetDelayDeath() bool {
	if m != nil {
		return m.DelayDeath
	}
	return false
}

func (m *UpdateUserExV2Request) GetLayer() uint32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *UpdateUserExV2Request) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *UpdateUserExV2Request) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

type UpdateUserExV2Reply struct {
}

func (m *UpdateUserExV2Reply) Reset()                    { *m = UpdateUserExV2Reply{} }
func (m *UpdateUserExV2Reply) String() string            { return proto.CompactTextString(m) }
func (*UpdateUserExV2Reply) ProtoMessage()               {}
func (*UpdateUserExV2Reply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{12} }

type FindUsersRequest struct {
	Peers []*PeerUser `protobuf:"bytes,1,rep,name=peers" json:"peers,omitempty"`
}

func (m *FindUsersRequest) Reset()                    { *m = FindUsersRequest{} }
func (m *FindUsersRequest) String() string            { return proto.CompactTextString(m) }
func (*FindUsersRequest) ProtoMessage()               {}
func (*FindUsersRequest) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{13} }

func (m *FindUsersRequest) GetPeers() []*PeerUser {
	if m != nil {
		return m.Peers
	}
	return nil
}

type FindUsersReply struct {
	UserKeys map[int32]*FindUserExReply `protobuf:"bytes,1,rep,name=user_keys,json=userKeys" json:"user_keys,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FindUsersReply) Reset()                    { *m = FindUsersReply{} }
func (m *FindUsersReply) String() string            { return proto.CompactTextString(m) }
func (*FindUsersReply) ProtoMessage()               {}
func (*FindUsersReply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{14} }

func (m *FindUsersReply) GetUserKeys() map[int32]*FindUserExReply {
	if m != nil {
		return m.UserKeys
	}
	return nil
}

type UpdateUsersRequest struct {
	Requests []*UpdateUserExV2Request `protobuf:"bytes,1,rep,name=requests" json:"requests,omitempty"`
}

func (m *UpdateUsersRequest) Reset()                    { *m = UpdateUsersRequest{} }
func (m *UpdateUsersRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateUsersRequest) ProtoMessage()               {}
func (*UpdateUsersRequest) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{15} }

func (m *UpdateUsersRequest) GetRequests() []*UpdateUserExV2Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

type UpdateUsersReply struct {
	Replies map[int32]*UpdateUserExV2Reply `protobuf:"bytes,1,rep,name=replies" json:"replies,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *UpdateUsersReply) Reset()                    { *m = UpdateUsersReply{} }
func (m *UpdateUsersReply) String() string            { return proto.CompactTextString(m) }
func (*UpdateUsersReply) ProtoMessage()               {}
func (*UpdateUsersReply) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{16} }

func (m *UpdateUsersReply) GetReplies() map[int32]*UpdateUserExV2Reply {
	if m != nil {
		return m.Replies
	}
	return nil
}

// //////////////////////////////////////TCP////////////////////////////////
type Route struct {
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{17} }

// router client
type RegisterClient struct {
	HostName string `protobuf:"bytes,1,opt,name=host_name,json=hostName,proto3" json:"host_name,omitempty"`
}

func (m *RegisterClient) Reset()                    { *m = RegisterClient{} }
func (m *RegisterClient) String() string            { return proto.CompactTextString(m) }
func (*RegisterClient) ProtoMessage()               {}
func (*RegisterClient) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{18} }

func (m *RegisterClient) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

type PeerUser struct {
	UserId int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId  uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *PeerUser) Reset()                    { *m = PeerUser{} }
func (m *PeerUser) String() string            { return proto.CompactTextString(m) }
func (*PeerUser) ProtoMessage()               {}
func (*PeerUser) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{19} }

func (m *PeerUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PeerUser) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type RegisterUser struct {
	User      *PeerUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	SessionId uint64    `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (m *RegisterUser) Reset()                    { *m = RegisterUser{} }
func (m *RegisterUser) String() string            { return proto.CompactTextString(m) }
func (*RegisterUser) ProtoMessage()               {}
func (*RegisterUser) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{20} }

func (m *RegisterUser) GetUser() *PeerUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RegisterUser) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

type UnregisterUser struct {
	User      *PeerUser `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	SessionId uint64    `protobuf:"varint,3,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (m *UnregisterUser) Reset()                    { *m = UnregisterUser{} }
func (m *UnregisterUser) String() string            { return proto.CompactTextString(m) }
func (*UnregisterUser) ProtoMessage()               {}
func (*UnregisterUser) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{21} }

func (m *UnregisterUser) GetUser() *PeerUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UnregisterUser) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

type Message struct {
	User    *PeerUser    `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Content []byte       `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	Kind    Message_Kind `protobuf:"varint,3,opt,name=kind,proto3,enum=route.Message_Kind" json:"kind,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{22} }

func (m *Message) GetUser() *PeerUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Message) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Message) GetKind() Message_Kind {
	if m != nil {
		return m.Kind
	}
	return Message_SendUser
}

type MessageContent struct {
	ShootTime int64  `protobuf:"varint,1,opt,name=shoot_time,json=shootTime,proto3" json:"shoot_time,omitempty"`
	Content   []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *MessageContent) Reset()                    { *m = MessageContent{} }
func (m *MessageContent) String() string            { return proto.CompactTextString(m) }
func (*MessageContent) ProtoMessage()               {}
func (*MessageContent) Descriptor() ([]byte, []int) { return fileDescriptorRoute, []int{23} }

func (m *MessageContent) GetShootTime() int64 {
	if m != nil {
		return m.ShootTime
	}
	return 0
}

func (m *MessageContent) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func init() {
	proto.RegisterType((*DelUserRequest)(nil), "route.DelUserRequest")
	proto.RegisterType((*DelUserReply)(nil), "route.DelUserReply")
	proto.RegisterType((*FindUserRequest)(nil), "route.FindUserRequest")
	proto.RegisterType((*FindUserReply)(nil), "route.FindUserReply")
	proto.RegisterType((*UpdateUserRequest)(nil), "route.UpdateUserRequest")
	proto.RegisterType((*UpdateUserReply)(nil), "route.UpdateUserReply")
	proto.RegisterType((*FindUserExRequest)(nil), "route.FindUserExRequest")
	proto.RegisterType((*FindUserExReply)(nil), "route.FindUserExReply")
	proto.RegisterType((*KeyInfo)(nil), "route.KeyInfo")
	proto.RegisterType((*UpdateUserExRequest)(nil), "route.UpdateUserExRequest")
	proto.RegisterType((*UpdateUserExReply)(nil), "route.UpdateUserExReply")
	proto.RegisterType((*UpdateUserExV2Request)(nil), "route.UpdateUserExV2Request")
	proto.RegisterType((*UpdateUserExV2Reply)(nil), "route.UpdateUserExV2Reply")
	proto.RegisterType((*FindUsersRequest)(nil), "route.FindUsersRequest")
	proto.RegisterType((*FindUsersReply)(nil), "route.FindUsersReply")
	proto.RegisterType((*UpdateUsersRequest)(nil), "route.UpdateUsersRequest")
	proto.RegisterType((*UpdateUsersReply)(nil), "route.UpdateUsersReply")
	proto.RegisterType((*Route)(nil), "route.Route")
	proto.RegisterType((*RegisterClient)(nil), "route.RegisterClient")
	proto.RegisterType((*PeerUser)(nil), "route.PeerUser")
	proto.RegisterType((*RegisterUser)(nil), "route.RegisterUser")
	proto.RegisterType((*UnregisterUser)(nil), "route.UnregisterUser")
	proto.RegisterType((*Message)(nil), "route.Message")
	proto.RegisterType((*MessageContent)(nil), "route.MessageContent")
	proto.RegisterEnum("route.DelUserRequest_OpType", DelUserRequest_OpType_name, DelUserRequest_OpType_value)
	proto.RegisterEnum("route.FindUserRequest_OpType", FindUserRequest_OpType_name, FindUserRequest_OpType_value)
	proto.RegisterEnum("route.FindUserExRequest_OpType", FindUserExRequest_OpType_name, FindUserExRequest_OpType_value)
	proto.RegisterEnum("route.Route_Kind", Route_Kind_name, Route_Kind_value)
	proto.RegisterEnum("route.Message_Kind", Message_Kind_name, Message_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for RouteTable service

type RouteTableClient interface {
	Del(ctx context.Context, in *DelUserRequest, opts ...grpc.CallOption) (*DelUserReply, error)
	Find(ctx context.Context, in *FindUserRequest, opts ...grpc.CallOption) (*FindUserReply, error)
	FindEx(ctx context.Context, in *FindUserExRequest, opts ...grpc.CallOption) (*FindUserExReply, error)
	//    rpc UpdateEx(UpdateUserExRequest) returns (UpdateUserExReply);
	FindUsers(ctx context.Context, in *FindUsersRequest, opts ...grpc.CallOption) (*FindUsersReply, error)
	UpdateExV2(ctx context.Context, in *UpdateUserExV2Request, opts ...grpc.CallOption) (*UpdateUserExV2Reply, error)
	UpdateUsers(ctx context.Context, in *UpdateUsersRequest, opts ...grpc.CallOption) (*UpdateUsersReply, error)
}

type routeTableClient struct {
	cc *grpc.ClientConn
}

func NewRouteTableClient(cc *grpc.ClientConn) RouteTableClient {
	return &routeTableClient{cc}
}

func (c *routeTableClient) Del(ctx context.Context, in *DelUserRequest, opts ...grpc.CallOption) (*DelUserReply, error) {
	out := new(DelUserReply)
	err := grpc.Invoke(ctx, "/route.RouteTable/Del", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeTableClient) Find(ctx context.Context, in *FindUserRequest, opts ...grpc.CallOption) (*FindUserReply, error) {
	out := new(FindUserReply)
	err := grpc.Invoke(ctx, "/route.RouteTable/Find", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeTableClient) FindEx(ctx context.Context, in *FindUserExRequest, opts ...grpc.CallOption) (*FindUserExReply, error) {
	out := new(FindUserExReply)
	err := grpc.Invoke(ctx, "/route.RouteTable/FindEx", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeTableClient) FindUsers(ctx context.Context, in *FindUsersRequest, opts ...grpc.CallOption) (*FindUsersReply, error) {
	out := new(FindUsersReply)
	err := grpc.Invoke(ctx, "/route.RouteTable/FindUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeTableClient) UpdateExV2(ctx context.Context, in *UpdateUserExV2Request, opts ...grpc.CallOption) (*UpdateUserExV2Reply, error) {
	out := new(UpdateUserExV2Reply)
	err := grpc.Invoke(ctx, "/route.RouteTable/UpdateExV2", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routeTableClient) UpdateUsers(ctx context.Context, in *UpdateUsersRequest, opts ...grpc.CallOption) (*UpdateUsersReply, error) {
	out := new(UpdateUsersReply)
	err := grpc.Invoke(ctx, "/route.RouteTable/UpdateUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RouteTable service

type RouteTableServer interface {
	Del(context.Context, *DelUserRequest) (*DelUserReply, error)
	Find(context.Context, *FindUserRequest) (*FindUserReply, error)
	FindEx(context.Context, *FindUserExRequest) (*FindUserExReply, error)
	//    rpc UpdateEx(UpdateUserExRequest) returns (UpdateUserExReply);
	FindUsers(context.Context, *FindUsersRequest) (*FindUsersReply, error)
	UpdateExV2(context.Context, *UpdateUserExV2Request) (*UpdateUserExV2Reply, error)
	UpdateUsers(context.Context, *UpdateUsersRequest) (*UpdateUsersReply, error)
}

func RegisterRouteTableServer(s *grpc.Server, srv RouteTableServer) {
	s.RegisterService(&_RouteTable_serviceDesc, srv)
}

func _RouteTable_Del_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteTableServer).Del(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/route.RouteTable/Del",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteTableServer).Del(ctx, req.(*DelUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteTable_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteTableServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/route.RouteTable/Find",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteTableServer).Find(ctx, req.(*FindUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteTable_FindEx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUserExRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteTableServer).FindEx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/route.RouteTable/FindEx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteTableServer).FindEx(ctx, req.(*FindUserExRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteTable_FindUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteTableServer).FindUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/route.RouteTable/FindUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteTableServer).FindUsers(ctx, req.(*FindUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteTable_UpdateExV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserExV2Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteTableServer).UpdateExV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/route.RouteTable/UpdateExV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteTableServer).UpdateExV2(ctx, req.(*UpdateUserExV2Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RouteTable_UpdateUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RouteTableServer).UpdateUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/route.RouteTable/UpdateUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RouteTableServer).UpdateUsers(ctx, req.(*UpdateUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RouteTable_serviceDesc = grpc.ServiceDesc{
	ServiceName: "route.RouteTable",
	HandlerType: (*RouteTableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Del",
			Handler:    _RouteTable_Del_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _RouteTable_Find_Handler,
		},
		{
			MethodName: "FindEx",
			Handler:    _RouteTable_FindEx_Handler,
		},
		{
			MethodName: "FindUsers",
			Handler:    _RouteTable_FindUsers_Handler,
		},
		{
			MethodName: "UpdateExV2",
			Handler:    _RouteTable_UpdateExV2_Handler,
		},
		{
			MethodName: "UpdateUsers",
			Handler:    _RouteTable_UpdateUsers_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "route/route.proto",
}

func (m *DelUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelUserRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Peer.Size()))
		n1, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.How != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.How))
	}
	return i, nil
}

func (m *DelUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FindUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindUserRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Peer.Size()))
		n2, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.How != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.How))
	}
	return i, nil
}

func (m *FindUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TopicIdentifiers) > 0 {
		dAtA4 := make([]byte, len(m.TopicIdentifiers)*10)
		var j3 int
		for _, num := range m.TopicIdentifiers {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *UpdateUserRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Peer.Size()))
		n5, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Online {
		dAtA[i] = 0x10
		i++
		if m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Updated != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Updated))
	}
	if m.TopicId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.TopicId))
	}
	if m.DelayDeath {
		dAtA[i] = 0x28
		i++
		if m.DelayDeath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UpdateUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FindUserExRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindUserExRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Peer.Size()))
		n6, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.How != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.How))
	}
	return i, nil
}

func (m *FindUserExReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindUserExReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, msg := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *KeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.TopicIdentifier != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.TopicIdentifier))
	}
	if m.Layer != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Layer))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ApiId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiId))
	}
	return i, nil
}

func (m *UpdateUserExRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserExRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Peer.Size()))
		n7, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Online {
		dAtA[i] = 0x10
		i++
		if m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Updated != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Updated))
	}
	if m.TopicId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.TopicId))
	}
	if m.DelayDeath {
		dAtA[i] = 0x28
		i++
		if m.DelayDeath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Layer != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Layer))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ApiId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiId))
	}
	return i, nil
}

func (m *UpdateUserExReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserExReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UpdateUserExV2Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserExV2Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Peer.Size()))
		n8, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.Online {
		dAtA[i] = 0x10
		i++
		if m.Online {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Delay != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Delay))
	}
	if m.TopicId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.TopicId))
	}
	if m.DelayDeath {
		dAtA[i] = 0x28
		i++
		if m.DelayDeath {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Layer != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Layer))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.ApiId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.ApiId))
	}
	return i, nil
}

func (m *UpdateUserExV2Reply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUserExV2Reply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *FindUsersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindUsersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FindUsersReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindUsersReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserKeys) > 0 {
		for k, _ := range m.UserKeys {
			dAtA[i] = 0xa
			i++
			v := m.UserKeys[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRoute(uint64(msgSize))
			}
			mapSize := 1 + sovRoute(uint64(k)) + msgSize
			i = encodeVarintRoute(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRoute(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRoute(dAtA, i, uint64(v.Size()))
				n9, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n9
			}
		}
	}
	return i, nil
}

func (m *UpdateUsersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUsersRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRoute(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateUsersReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateUsersReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Replies) > 0 {
		for k, _ := range m.Replies {
			dAtA[i] = 0xa
			i++
			v := m.Replies[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovRoute(uint64(msgSize))
			}
			mapSize := 1 + sovRoute(uint64(k)) + msgSize
			i = encodeVarintRoute(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRoute(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintRoute(dAtA, i, uint64(v.Size()))
				n10, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RegisterClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterClient) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.HostName)))
		i += copy(dAtA[i:], m.HostName)
	}
	return i, nil
}

func (m *PeerUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *RegisterUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.User.Size()))
		n11, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.SessionId))
	}
	return i, nil
}

func (m *UnregisterUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.User.Size()))
		n12, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.SessionId))
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.User.Size()))
		n13, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Kind != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.Kind))
	}
	return i, nil
}

func (m *MessageContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShootTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRoute(dAtA, i, uint64(m.ShootTime))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRoute(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func encodeVarintRoute(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *DelUserRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.How != 0 {
		n += 1 + sovRoute(uint64(m.How))
	}
	return n
}

func (m *DelUserReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FindUserRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.How != 0 {
		n += 1 + sovRoute(uint64(m.How))
	}
	return n
}

func (m *FindUserReply) Size() (n int) {
	var l int
	_ = l
	if len(m.TopicIdentifiers) > 0 {
		l = 0
		for _, e := range m.TopicIdentifiers {
			l += sovRoute(uint64(e))
		}
		n += 1 + sovRoute(uint64(l)) + l
	}
	return n
}

func (m *UpdateUserRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Online {
		n += 2
	}
	if m.Updated != 0 {
		n += 1 + sovRoute(uint64(m.Updated))
	}
	if m.TopicId != 0 {
		n += 1 + sovRoute(uint64(m.TopicId))
	}
	if m.DelayDeath {
		n += 2
	}
	return n
}

func (m *UpdateUserReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FindUserExRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.How != 0 {
		n += 1 + sovRoute(uint64(m.How))
	}
	return n
}

func (m *FindUserExReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, e := range m.Keys {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *KeyInfo) Size() (n int) {
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovRoute(uint64(m.AuthKeyId))
	}
	if m.TopicIdentifier != 0 {
		n += 1 + sovRoute(uint64(m.TopicIdentifier))
	}
	if m.Layer != 0 {
		n += 1 + sovRoute(uint64(m.Layer))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ApiId != 0 {
		n += 1 + sovRoute(uint64(m.ApiId))
	}
	return n
}

func (m *UpdateUserExRequest) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Online {
		n += 2
	}
	if m.Updated != 0 {
		n += 1 + sovRoute(uint64(m.Updated))
	}
	if m.TopicId != 0 {
		n += 1 + sovRoute(uint64(m.TopicId))
	}
	if m.DelayDeath {
		n += 2
	}
	if m.Layer != 0 {
		n += 1 + sovRoute(uint64(m.Layer))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ApiId != 0 {
		n += 1 + sovRoute(uint64(m.ApiId))
	}
	return n
}

func (m *UpdateUserExReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UpdateUserExV2Request) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Online {
		n += 2
	}
	if m.Delay != 0 {
		n += 1 + sovRoute(uint64(m.Delay))
	}
	if m.TopicId != 0 {
		n += 1 + sovRoute(uint64(m.TopicId))
	}
	if m.DelayDeath {
		n += 2
	}
	if m.Layer != 0 {
		n += 1 + sovRoute(uint64(m.Layer))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.ApiId != 0 {
		n += 1 + sovRoute(uint64(m.ApiId))
	}
	return n
}

func (m *UpdateUserExV2Reply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *FindUsersRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *FindUsersReply) Size() (n int) {
	var l int
	_ = l
	if len(m.UserKeys) > 0 {
		for k, v := range m.UserKeys {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoute(uint64(l))
			}
			mapEntrySize := 1 + sovRoute(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoute(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UpdateUsersRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRoute(uint64(l))
		}
	}
	return n
}

func (m *UpdateUsersReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Replies) > 0 {
		for k, v := range m.Replies {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovRoute(uint64(l))
			}
			mapEntrySize := 1 + sovRoute(uint64(k)) + l
			n += mapEntrySize + 1 + sovRoute(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RegisterClient) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func (m *PeerUser) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovRoute(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovRoute(uint64(m.KeyId))
	}
	return n
}

func (m *RegisterUser) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovRoute(uint64(m.SessionId))
	}
	return n
}

func (m *UnregisterUser) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovRoute(uint64(m.SessionId))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovRoute(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovRoute(uint64(m.Kind))
	}
	return n
}

func (m *MessageContent) Size() (n int) {
	var l int
	_ = l
	if m.ShootTime != 0 {
		n += 1 + sovRoute(uint64(m.ShootTime))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovRoute(uint64(l))
	}
	return n
}

func sovRoute(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRoute(x uint64) (n int) {
	return sovRoute(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DelUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &PeerUser{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field How", wireType)
			}
			m.How = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.How |= (DelUserRequest_OpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &PeerUser{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field How", wireType)
			}
			m.How = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.How |= (FindUserRequest_OpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TopicIdentifiers = append(m.TopicIdentifiers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRoute
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TopicIdentifiers = append(m.TopicIdentifiers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicIdentifiers", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &PeerUser{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			m.Updated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Updated |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayDeath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayDeath = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindUserExRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindUserExRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindUserExRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &PeerUser{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field How", wireType)
			}
			m.How = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.How |= (FindUserExRequest_OpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindUserExReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindUserExReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindUserExReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, &KeyInfo{})
			if err := m.Keys[len(m.Keys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicIdentifier", wireType)
			}
			m.TopicIdentifier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicIdentifier |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserExRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserExRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserExRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &PeerUser{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			m.Updated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Updated |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayDeath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayDeath = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserExReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserExReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserExReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserExV2Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserExV2Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserExV2Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &PeerUser{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Online", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Online = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delay", wireType)
			}
			m.Delay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Delay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicId", wireType)
			}
			m.TopicId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayDeath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DelayDeath = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUserExV2Reply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUserExV2Reply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUserExV2Reply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindUsersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindUsersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindUsersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &PeerUser{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindUsersReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindUsersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindUsersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserKeys == nil {
				m.UserKeys = make(map[int32]*FindUserExReply)
			}
			var mapkey int32
			var mapvalue *FindUserExReply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoute
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRoute
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FindUserExReply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoute(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoute
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UserKeys[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUsersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUsersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUsersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &UpdateUserExV2Request{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateUsersReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateUsersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateUsersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replies == nil {
				m.Replies = make(map[int32]*UpdateUserExV2Reply)
			}
			var mapkey int32
			var mapvalue *UpdateUserExV2Reply
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRoute
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthRoute
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthRoute
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &UpdateUserExV2Reply{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRoute(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRoute
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Replies[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &PeerUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &PeerUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &PeerUser{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= (Message_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShootTime", wireType)
			}
			m.ShootTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShootTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRoute
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRoute(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRoute
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRoute(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRoute
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRoute
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRoute
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRoute
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRoute(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRoute = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRoute   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("route/route.proto", fileDescriptorRoute) }

var fileDescriptorRoute = []byte{
	// 1050 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x5f, 0x6f, 0x1b, 0x45,
	0x10, 0xcf, 0xda, 0x3e, 0xff, 0x19, 0xff, 0xc9, 0x79, 0xf3, 0xcf, 0x35, 0x34, 0x8d, 0xb6, 0x20,
	0x82, 0x00, 0x97, 0x1a, 0x90, 0x42, 0x40, 0x88, 0xd2, 0xa4, 0x92, 0x89, 0x68, 0xd1, 0x26, 0xe9,
	0xab, 0x75, 0xed, 0x4d, 0xeb, 0x53, 0x2e, 0x77, 0xc7, 0xdd, 0xb9, 0xf4, 0x3e, 0x02, 0x5f, 0x01,
	0x24, 0x1e, 0x41, 0x82, 0x2f, 0xc2, 0x23, 0x1f, 0x01, 0xe5, 0x1d, 0xf1, 0xcc, 0x1b, 0x9a, 0xdd,
	0x3b, 0xfb, 0xec, 0xd8, 0x15, 0x01, 0x84, 0xfa, 0x62, 0x79, 0x66, 0x67, 0x7f, 0x3b, 0xbf, 0xfd,
	0xcd, 0xcc, 0x1e, 0xb4, 0x43, 0x7f, 0x1c, 0xe3, 0x2d, 0xf5, 0xdb, 0x0b, 0x42, 0x3f, 0xf6, 0xb9,
	0xa1, 0x0c, 0xf1, 0x0d, 0x83, 0xd6, 0x01, 0xba, 0xa7, 0x11, 0x86, 0x12, 0xbf, 0x1a, 0x63, 0x14,
	0xf3, 0x9b, 0x50, 0x0a, 0x10, 0xc3, 0x0e, 0xdb, 0x61, 0xbb, 0xf5, 0xfe, 0x6a, 0x4f, 0xef, 0xfa,
	0x12, 0x31, 0x54, 0x51, 0x6a, 0x91, 0xf7, 0xa0, 0x38, 0xf2, 0xbf, 0xee, 0x14, 0x76, 0xd8, 0x6e,
	0xab, 0xff, 0x6a, 0x1a, 0x33, 0x0b, 0xd4, 0x7b, 0x10, 0x9c, 0x24, 0x01, 0x4a, 0x0a, 0x14, 0x02,
	0xca, 0xda, 0xe4, 0x00, 0xe5, 0x03, 0x74, 0x1f, 0x78, 0x68, 0xae, 0xf0, 0x06, 0x54, 0xe9, 0x7f,
	0x3c, 0xc2, 0xd0, 0x64, 0xa2, 0x05, 0x8d, 0x09, 0x42, 0xe0, 0x26, 0xe2, 0x5b, 0x06, 0xab, 0xf7,
	0x1c, 0xcf, 0xbe, 0x72, 0x72, 0xb7, 0xf2, 0xc9, 0x5d, 0x4f, 0x63, 0xe6, 0x90, 0x66, 0xb2, 0xbb,
	0x3d, 0xc9, 0xae, 0x0e, 0x15, 0x0a, 0xbc, 0xe3, 0xba, 0xe6, 0x4a, 0x66, 0x50, 0xae, 0x8c, 0x37,
	0xa1, 0xa6, 0x0c, 0x95, 0x6c, 0x41, 0x7c, 0x0c, 0xcd, 0x29, 0x62, 0xe0, 0x26, 0xfc, 0x2d, 0x68,
	0xc7, 0x7e, 0xe0, 0x3c, 0x1e, 0x3a, 0x36, 0x7a, 0xb1, 0xf3, 0xc4, 0xc1, 0x30, 0xea, 0xb0, 0x9d,
	0xe2, 0x6e, 0x53, 0x9a, 0x6a, 0x61, 0x30, 0xf5, 0x8b, 0x1f, 0x18, 0xb4, 0x4f, 0x03, 0xdb, 0x8a,
	0xf1, 0xca, 0xe4, 0x36, 0xa1, 0xec, 0x7b, 0xae, 0xe3, 0xa1, 0xe2, 0x57, 0x95, 0xa9, 0xc5, 0x3b,
	0x50, 0x19, 0x2b, 0x44, 0xbb, 0x53, 0xdc, 0x61, 0xbb, 0x45, 0x99, 0x99, 0xfc, 0x1a, 0x54, 0xb3,
	0xcc, 0x3a, 0xa5, 0x1d, 0xb6, 0xdb, 0x94, 0x95, 0x34, 0x21, 0x7e, 0x03, 0xea, 0x36, 0xba, 0x56,
	0x32, 0xb4, 0xd1, 0x8a, 0x47, 0x1d, 0x43, 0x21, 0x82, 0x72, 0x1d, 0x90, 0x47, 0xb4, 0x61, 0x35,
	0x9f, 0x27, 0xc9, 0xf2, 0x3d, 0x83, 0x76, 0x46, 0xfd, 0xf0, 0xf9, 0x95, 0x72, 0xbf, 0x9d, 0x17,
	0xe6, 0xc6, 0x9c, 0x30, 0x13, 0xac, 0x7f, 0x2b, 0xcd, 0x07, 0xd3, 0xb2, 0x21, 0x4c, 0x12, 0x47,
	0x40, 0xe9, 0x0c, 0x13, 0xad, 0x47, 0xbd, 0xdf, 0x4a, 0x4f, 0x3e, 0xc2, 0x64, 0xe0, 0x3d, 0xf1,
	0xa5, 0x5a, 0x13, 0xdf, 0x31, 0xa8, 0xa4, 0x1e, 0xbe, 0x0d, 0x75, 0x6b, 0x1c, 0x8f, 0x86, 0x67,
	0x98, 0xd0, 0xad, 0x11, 0xa9, 0x92, 0xac, 0x91, 0x8b, 0x22, 0x6c, 0xfe, 0x26, 0x98, 0xf3, 0x62,
	0x2b, 0x56, 0x4d, 0xb9, 0x3a, 0xa7, 0x35, 0x5f, 0x07, 0xc3, 0xb5, 0x12, 0x0c, 0x95, 0x2a, 0x4d,
	0xa9, 0x0d, 0x52, 0xeb, 0x19, 0x86, 0x91, 0xe3, 0x7b, 0x4a, 0x92, 0x9a, 0xcc, 0x4c, 0xbe, 0x01,
	0x65, 0x2b, 0x70, 0xe8, 0x54, 0x52, 0xc3, 0x90, 0x86, 0x15, 0x38, 0x03, 0x5b, 0xfc, 0xc1, 0x60,
	0x6d, 0xaa, 0xc4, 0x15, 0xef, 0xfd, 0x7f, 0xad, 0x99, 0x29, 0xe3, 0xf2, 0x12, 0xc6, 0x95, 0x65,
	0x8c, 0xab, 0x79, 0xc6, 0x6b, 0xf9, 0x16, 0x49, 0x85, 0x14, 0xbf, 0x33, 0xd8, 0xc8, 0x7b, 0x1f,
	0xf6, 0xff, 0x93, 0x8b, 0x58, 0x07, 0x43, 0x11, 0x48, 0xaf, 0x41, 0x1b, 0x2f, 0xc3, 0x25, 0x6c,
	0xcc, 0xaa, 0x4e, 0x74, 0xe9, 0x1a, 0x3e, 0x04, 0x33, 0x2b, 0xf1, 0x28, 0xbb, 0x80, 0xd7, 0xc1,
	0x20, 0x8e, 0x59, 0x91, 0x5f, 0xba, 0x01, 0xbd, 0x2a, 0x7e, 0x64, 0xd0, 0xca, 0xed, 0xa5, 0xee,
	0xf8, 0x14, 0x6a, 0xe3, 0x08, 0xc3, 0x61, 0xae, 0x45, 0x6e, 0xce, 0x35, 0xa7, 0x8e, 0xec, 0xd1,
	0xdf, 0x23, 0x4c, 0xa2, 0x43, 0x2f, 0x0e, 0x13, 0x59, 0x1d, 0xa7, 0x66, 0xf7, 0x18, 0x9a, 0x33,
	0x4b, 0xdc, 0x84, 0xe2, 0x19, 0x26, 0x4a, 0x0c, 0x43, 0xd2, 0x5f, 0xfe, 0x36, 0x18, 0xcf, 0x2c,
	0x77, 0xac, 0x6f, 0xbe, 0xde, 0xdf, 0x5c, 0xd0, 0xfd, 0x81, 0x9b, 0x48, 0x1d, 0xb4, 0x5f, 0xd8,
	0x63, 0xe2, 0x3e, 0xf0, 0x29, 0xf7, 0x09, 0xcd, 0x3d, 0xa8, 0x86, 0xfa, 0x6f, 0x96, 0x6b, 0xf6,
	0xfc, 0x2c, 0xac, 0x0b, 0x39, 0x89, 0x16, 0x3f, 0x31, 0x30, 0x67, 0x00, 0x89, 0xfb, 0x27, 0x50,
	0x09, 0x31, 0x70, 0x1d, 0xcc, 0xd0, 0x5e, 0xbb, 0x84, 0x96, 0x72, 0x97, 0x3a, 0x4c, 0x53, 0xcf,
	0x36, 0x75, 0x1f, 0x42, 0x23, 0xbf, 0xb0, 0x80, 0xf8, 0xbb, 0xb3, 0xc4, 0xbb, 0x4b, 0xb2, 0x9d,
	0x23, 0x7f, 0x0c, 0x86, 0x54, 0x2f, 0xf4, 0xe7, 0x50, 0x3a, 0x72, 0x3c, 0x9b, 0x9b, 0x74, 0xd0,
	0x53, 0x27, 0x8a, 0xb5, 0x9c, 0xe6, 0x0a, 0xe7, 0xd0, 0x3a, 0xf5, 0xc2, 0xbc, 0x8f, 0xf1, 0x2a,
	0x94, 0x0e, 0xac, 0xd8, 0x32, 0x0b, 0xb4, 0x9a, 0xc5, 0xdf, 0x75, 0x1d, 0xf4, 0x62, 0xb3, 0x28,
	0xde, 0x99, 0xf7, 0xf1, 0x57, 0xa0, 0x36, 0xf2, 0xa3, 0x78, 0xe8, 0x59, 0xe7, 0xa8, 0x92, 0xae,
	0xc9, 0x2a, 0x39, 0xee, 0x5b, 0xe7, 0x28, 0xf6, 0xa1, 0x9a, 0x55, 0x0f, 0xdf, 0x82, 0x8a, 0xaa,
	0x91, 0x74, 0x1a, 0x1a, 0xb2, 0x4c, 0xe6, 0xc0, 0xa6, 0xc2, 0x4d, 0xa7, 0x64, 0x41, 0x4d, 0x49,
	0xe3, 0x8c, 0x26, 0xa4, 0x90, 0xb3, 0xe9, 0x52, 0x7b, 0xd2, 0x86, 0xa5, 0xed, 0x49, 0x8b, 0xfc,
	0x3a, 0x40, 0x84, 0x11, 0xf5, 0xc3, 0x14, 0xaf, 0x96, 0x7a, 0x06, 0xb6, 0x38, 0x99, 0x27, 0xfc,
	0x4f, 0x50, 0x8b, 0xf3, 0xa8, 0x3f, 0x33, 0xa8, 0x7c, 0x81, 0x51, 0x64, 0x3d, 0xc5, 0xbf, 0x87,
	0xd7, 0x81, 0xca, 0x63, 0xdf, 0x8b, 0xd1, 0x8b, 0x55, 0x8a, 0x0d, 0x99, 0x99, 0xfc, 0x0d, 0x28,
	0x9d, 0x39, 0x9e, 0x3e, 0xa3, 0xd5, 0x5f, 0x4b, 0xb7, 0xa7, 0xe0, 0x3d, 0x92, 0x51, 0xaa, 0x00,
	0xb1, 0x97, 0x8a, 0xda, 0x80, 0xea, 0x31, 0xea, 0x06, 0x30, 0x57, 0xf8, 0x2a, 0xd4, 0x33, 0x4b,
	0x3f, 0x6c, 0x6d, 0x68, 0x4e, 0x1c, 0xea, 0x71, 0x2b, 0x8a, 0x01, 0xb4, 0x52, 0xbc, 0xbb, 0xe9,
	0xa1, 0x44, 0x6f, 0xe4, 0xfb, 0xf1, 0x30, 0x76, 0x52, 0x0d, 0x8b, 0xb2, 0xa6, 0x3c, 0x27, 0xce,
	0x39, 0x2e, 0xcf, 0xb6, 0xff, 0x67, 0x01, 0x40, 0xd5, 0xd8, 0x89, 0xf5, 0xc8, 0x45, 0x7a, 0x9c,
	0x0f, 0xd0, 0xe5, 0x1b, 0x0b, 0x3f, 0xe6, 0xba, 0x6b, 0xf3, 0x6e, 0x6a, 0x9e, 0xf7, 0xa1, 0x44,
	0xfd, 0xcb, 0x37, 0x17, 0x7f, 0x63, 0x75, 0xd7, 0x2f, 0xf9, 0x69, 0xd7, 0x3e, 0x94, 0xc9, 0x71,
	0xf8, 0x9c, 0x77, 0x96, 0x7d, 0x02, 0x74, 0x97, 0x8c, 0x07, 0xfe, 0x91, 0x7e, 0xea, 0x55, 0x5b,
	0xf2, 0xad, 0xcb, 0x43, 0x4a, 0xef, 0xde, 0x58, 0x38, 0xbd, 0xf8, 0x3d, 0x00, 0xdd, 0x75, 0xd4,
	0x71, 0xfc, 0x85, 0x63, 0xa3, 0xfb, 0x82, 0x36, 0xe5, 0x77, 0xa0, 0x9e, 0x9b, 0x0e, 0xfc, 0xda,
	0xa2, 0x89, 0xa1, 0x51, 0xb6, 0x96, 0x0c, 0x93, 0xcf, 0x1a, 0xbf, 0x5c, 0x6c, 0xb3, 0x5f, 0x2f,
	0xb6, 0xd9, 0x6f, 0x17, 0xdb, 0xec, 0x51, 0x59, 0x7d, 0x93, 0xbf, 0xf7, 0x57, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x02, 0xb2, 0x7b, 0x81, 0xa8, 0x0b, 0x00, 0x00,
}
