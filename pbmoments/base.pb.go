// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/pbmoments/base.proto

/*
Package moment is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/pbmoments/base.proto

It has these top-level messages:

	UserIgnoresAllResp
	UserIgnoreMeGetResp
	UserContactsSyncReq
	UserContactsSyncRep
	UserAlbumsReq
	UserAlbumsRep
	UserVersionGetRep
	UserVersionUpdateReq
	UserVersionUpdateRep
	UserAllIDReq
	UserAllIDRep
	UserRecommendCheckRep
	UserIgnoreCheckRep
	IgnoreSlice
	IgnoreNone
	UserAlbumReq
	UserAlbumRep
	UserStatisticsReq
	UserStatisticsRep
	UserIgnore
	UserStatus
	UserRecommendVersion
	TagAddReq
	TagAddRep
	UserTags
	TagGetReq
	TagGetRep
	Tag
	UserTag
	UserRecommend
	Page
*/
package moment

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import moment1 "gitlab.chatserver.im/interfaceprobuf/pbmoments/media"
import imapigateway "gitlab.chatserver.im/interfaceprobuf/imapigateway"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type UserIgnoresAllResp struct {
	UserIDs []int32 `protobuf:"varint,1,rep,packed,name=UserIDs" json:"UserIDs,omitempty"`
}

func (m *UserIgnoresAllResp) Reset()                    { *m = UserIgnoresAllResp{} }
func (m *UserIgnoresAllResp) String() string            { return proto.CompactTextString(m) }
func (*UserIgnoresAllResp) ProtoMessage()               {}
func (*UserIgnoresAllResp) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{0} }

func (m *UserIgnoresAllResp) GetUserIDs() []int32 {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

type UserIgnoreMeGetResp struct {
	UserIDs []int32 `protobuf:"varint,1,rep,packed,name=UserIDs" json:"UserIDs,omitempty"`
}

func (m *UserIgnoreMeGetResp) Reset()                    { *m = UserIgnoreMeGetResp{} }
func (m *UserIgnoreMeGetResp) String() string            { return proto.CompactTextString(m) }
func (*UserIgnoreMeGetResp) ProtoMessage()               {}
func (*UserIgnoreMeGetResp) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{1} }

func (m *UserIgnoreMeGetResp) GetUserIDs() []int32 {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

type UserContactsSyncReq struct {
	Action    int32   `protobuf:"varint,1,opt,name=Action,proto3" json:"Action,omitempty"`
	UserID    int32   `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	ContactID []int32 `protobuf:"varint,3,rep,packed,name=ContactID" json:"ContactID,omitempty"`
}

func (m *UserContactsSyncReq) Reset()                    { *m = UserContactsSyncReq{} }
func (m *UserContactsSyncReq) String() string            { return proto.CompactTextString(m) }
func (*UserContactsSyncReq) ProtoMessage()               {}
func (*UserContactsSyncReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{2} }

func (m *UserContactsSyncReq) GetAction() int32 {
	if m != nil {
		return m.Action
	}
	return 0
}

func (m *UserContactsSyncReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserContactsSyncReq) GetContactID() []int32 {
	if m != nil {
		return m.ContactID
	}
	return nil
}

type UserContactsSyncRep struct {
	Code int32  `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Msg  string `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
}

func (m *UserContactsSyncRep) Reset()                    { *m = UserContactsSyncRep{} }
func (m *UserContactsSyncRep) String() string            { return proto.CompactTextString(m) }
func (*UserContactsSyncRep) ProtoMessage()               {}
func (*UserContactsSyncRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{3} }

func (m *UserContactsSyncRep) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UserContactsSyncRep) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type UserAlbumsReq struct {
	UserID   int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	FriendID int32 `protobuf:"varint,2,opt,name=FriendID,proto3" json:"FriendID,omitempty"`
}

func (m *UserAlbumsReq) Reset()                    { *m = UserAlbumsReq{} }
func (m *UserAlbumsReq) String() string            { return proto.CompactTextString(m) }
func (*UserAlbumsReq) ProtoMessage()               {}
func (*UserAlbumsReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{4} }

func (m *UserAlbumsReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserAlbumsReq) GetFriendID() int32 {
	if m != nil {
		return m.FriendID
	}
	return 0
}

type UserAlbumsRep struct {
	Code   int32            `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Msg    string           `protobuf:"bytes,2,opt,name=Msg,proto3" json:"Msg,omitempty"`
	Medias []*moment1.Media `protobuf:"bytes,3,rep,name=Medias" json:"Medias,omitempty"`
}

func (m *UserAlbumsRep) Reset()                    { *m = UserAlbumsRep{} }
func (m *UserAlbumsRep) String() string            { return proto.CompactTextString(m) }
func (*UserAlbumsRep) ProtoMessage()               {}
func (*UserAlbumsRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{5} }

func (m *UserAlbumsRep) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *UserAlbumsRep) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UserAlbumsRep) GetMedias() []*moment1.Media {
	if m != nil {
		return m.Medias
	}
	return nil
}

type UserVersionGetRep struct {
	RecommendState bool  `protobuf:"varint,1,opt,name=RecommendState,proto3" json:"RecommendState,omitempty"`
	RecommendUID   int32 `protobuf:"varint,2,opt,name=RecommendUID,proto3" json:"RecommendUID,omitempty"`
	FriendState    bool  `protobuf:"varint,3,opt,name=FriendState,proto3" json:"FriendState,omitempty"`
	FriendUID      int32 `protobuf:"varint,4,opt,name=FriendUID,proto3" json:"FriendUID,omitempty"`
	FollowState    bool  `protobuf:"varint,5,opt,name=FollowState,proto3" json:"FollowState,omitempty"`
	FollowUID      int32 `protobuf:"varint,6,opt,name=FollowUID,proto3" json:"FollowUID,omitempty"`
}

func (m *UserVersionGetRep) Reset()                    { *m = UserVersionGetRep{} }
func (m *UserVersionGetRep) String() string            { return proto.CompactTextString(m) }
func (*UserVersionGetRep) ProtoMessage()               {}
func (*UserVersionGetRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{6} }

func (m *UserVersionGetRep) GetRecommendState() bool {
	if m != nil {
		return m.RecommendState
	}
	return false
}

func (m *UserVersionGetRep) GetRecommendUID() int32 {
	if m != nil {
		return m.RecommendUID
	}
	return 0
}

func (m *UserVersionGetRep) GetFriendState() bool {
	if m != nil {
		return m.FriendState
	}
	return false
}

func (m *UserVersionGetRep) GetFriendUID() int32 {
	if m != nil {
		return m.FriendUID
	}
	return 0
}

func (m *UserVersionGetRep) GetFollowState() bool {
	if m != nil {
		return m.FollowState
	}
	return false
}

func (m *UserVersionGetRep) GetFollowUID() int32 {
	if m != nil {
		return m.FollowUID
	}
	return 0
}

type UserVersionUpdateReq struct {
	UserID         int32   `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	IsRecommedUser bool    `protobuf:"varint,2,opt,name=IsRecommedUser,proto3" json:"IsRecommedUser,omitempty"`
	Version        int64   `protobuf:"varint,3,opt,name=Version,proto3" json:"Version,omitempty"`
	Friend         []int32 `protobuf:"varint,4,rep,packed,name=Friend" json:"Friend,omitempty"`
	Fans           []int32 `protobuf:"varint,5,rep,packed,name=Fans" json:"Fans,omitempty"`
}

func (m *UserVersionUpdateReq) Reset()                    { *m = UserVersionUpdateReq{} }
func (m *UserVersionUpdateReq) String() string            { return proto.CompactTextString(m) }
func (*UserVersionUpdateReq) ProtoMessage()               {}
func (*UserVersionUpdateReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{7} }

func (m *UserVersionUpdateReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserVersionUpdateReq) GetIsRecommedUser() bool {
	if m != nil {
		return m.IsRecommedUser
	}
	return false
}

func (m *UserVersionUpdateReq) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *UserVersionUpdateReq) GetFriend() []int32 {
	if m != nil {
		return m.Friend
	}
	return nil
}

func (m *UserVersionUpdateReq) GetFans() []int32 {
	if m != nil {
		return m.Fans
	}
	return nil
}

type UserVersionUpdateRep struct {
}

func (m *UserVersionUpdateRep) Reset()                    { *m = UserVersionUpdateRep{} }
func (m *UserVersionUpdateRep) String() string            { return proto.CompactTextString(m) }
func (*UserVersionUpdateRep) ProtoMessage()               {}
func (*UserVersionUpdateRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{8} }

type UserAllIDReq struct {
	ExcludeUID []int32 `protobuf:"varint,1,rep,packed,name=ExcludeUID" json:"ExcludeUID,omitempty"`
}

func (m *UserAllIDReq) Reset()                    { *m = UserAllIDReq{} }
func (m *UserAllIDReq) String() string            { return proto.CompactTextString(m) }
func (*UserAllIDReq) ProtoMessage()               {}
func (*UserAllIDReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{9} }

func (m *UserAllIDReq) GetExcludeUID() []int32 {
	if m != nil {
		return m.ExcludeUID
	}
	return nil
}

type UserAllIDRep struct {
	UserIDs []int32 `protobuf:"varint,1,rep,packed,name=UserIDs" json:"UserIDs,omitempty"`
}

func (m *UserAllIDRep) Reset()                    { *m = UserAllIDRep{} }
func (m *UserAllIDRep) String() string            { return proto.CompactTextString(m) }
func (*UserAllIDRep) ProtoMessage()               {}
func (*UserAllIDRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{10} }

func (m *UserAllIDRep) GetUserIDs() []int32 {
	if m != nil {
		return m.UserIDs
	}
	return nil
}

type UserRecommendCheckRep struct {
	Status   bool  `protobuf:"varint,1,opt,name=Status,proto3" json:"Status,omitempty"`
	LimitVIP int32 `protobuf:"varint,2,opt,name=LimitVIP,proto3" json:"LimitVIP,omitempty"`
}

func (m *UserRecommendCheckRep) Reset()                    { *m = UserRecommendCheckRep{} }
func (m *UserRecommendCheckRep) String() string            { return proto.CompactTextString(m) }
func (*UserRecommendCheckRep) ProtoMessage()               {}
func (*UserRecommendCheckRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{11} }

func (m *UserRecommendCheckRep) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func (m *UserRecommendCheckRep) GetLimitVIP() int32 {
	if m != nil {
		return m.LimitVIP
	}
	return 0
}

type UserIgnoreCheckRep struct {
	Status bool `protobuf:"varint,1,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *UserIgnoreCheckRep) Reset()                    { *m = UserIgnoreCheckRep{} }
func (m *UserIgnoreCheckRep) String() string            { return proto.CompactTextString(m) }
func (*UserIgnoreCheckRep) ProtoMessage()               {}
func (*UserIgnoreCheckRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{12} }

func (m *UserIgnoreCheckRep) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

type IgnoreSlice struct {
	Ignores []*UserIgnore `protobuf:"bytes,1,rep,name=Ignores" json:"Ignores,omitempty"`
}

func (m *IgnoreSlice) Reset()                    { *m = IgnoreSlice{} }
func (m *IgnoreSlice) String() string            { return proto.CompactTextString(m) }
func (*IgnoreSlice) ProtoMessage()               {}
func (*IgnoreSlice) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{13} }

func (m *IgnoreSlice) GetIgnores() []*UserIgnore {
	if m != nil {
		return m.Ignores
	}
	return nil
}

type IgnoreNone struct {
}

func (m *IgnoreNone) Reset()                    { *m = IgnoreNone{} }
func (m *IgnoreNone) String() string            { return proto.CompactTextString(m) }
func (*IgnoreNone) ProtoMessage()               {}
func (*IgnoreNone) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{14} }

type UserAlbumReq struct {
	UserID   int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	ForumID  int32 `protobuf:"varint,2,opt,name=ForumID,proto3" json:"ForumID,omitempty"`
	FriendID int32 `protobuf:"varint,3,opt,name=FriendID,proto3" json:"FriendID,omitempty"`
	Limit    int64 `protobuf:"varint,4,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *UserAlbumReq) Reset()                    { *m = UserAlbumReq{} }
func (m *UserAlbumReq) String() string            { return proto.CompactTextString(m) }
func (*UserAlbumReq) ProtoMessage()               {}
func (*UserAlbumReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{15} }

func (m *UserAlbumReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserAlbumReq) GetForumID() int32 {
	if m != nil {
		return m.ForumID
	}
	return 0
}

func (m *UserAlbumReq) GetFriendID() int32 {
	if m != nil {
		return m.FriendID
	}
	return 0
}

func (m *UserAlbumReq) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type UserAlbumRep struct {
	Medias []*moment1.Media `protobuf:"bytes,1,rep,name=Medias" json:"Medias,omitempty"`
}

func (m *UserAlbumRep) Reset()                    { *m = UserAlbumRep{} }
func (m *UserAlbumRep) String() string            { return proto.CompactTextString(m) }
func (*UserAlbumRep) ProtoMessage()               {}
func (*UserAlbumRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{16} }

func (m *UserAlbumRep) GetMedias() []*moment1.Media {
	if m != nil {
		return m.Medias
	}
	return nil
}

type UserStatisticsReq struct {
	Vistor   int32 `protobuf:"varint,1,opt,name=Vistor,proto3" json:"Vistor,omitempty"`
	CreateBy int32 `protobuf:"varint,2,opt,name=CreateBy,proto3" json:"CreateBy,omitempty"`
}

func (m *UserStatisticsReq) Reset()                    { *m = UserStatisticsReq{} }
func (m *UserStatisticsReq) String() string            { return proto.CompactTextString(m) }
func (*UserStatisticsReq) ProtoMessage()               {}
func (*UserStatisticsReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{17} }

func (m *UserStatisticsReq) GetVistor() int32 {
	if m != nil {
		return m.Vistor
	}
	return 0
}

func (m *UserStatisticsReq) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

type UserStatisticsRep struct {
	Forum  int64 `protobuf:"varint,1,opt,name=Forum,proto3" json:"Forum,omitempty"`
	Follow int64 `protobuf:"varint,2,opt,name=Follow,proto3" json:"Follow,omitempty"`
	Thumb  int64 `protobuf:"varint,3,opt,name=Thumb,proto3" json:"Thumb,omitempty"`
	Fans   int64 `protobuf:"varint,4,opt,name=Fans,proto3" json:"Fans,omitempty"`
}

func (m *UserStatisticsRep) Reset()                    { *m = UserStatisticsRep{} }
func (m *UserStatisticsRep) String() string            { return proto.CompactTextString(m) }
func (*UserStatisticsRep) ProtoMessage()               {}
func (*UserStatisticsRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{18} }

func (m *UserStatisticsRep) GetForum() int64 {
	if m != nil {
		return m.Forum
	}
	return 0
}

func (m *UserStatisticsRep) GetFollow() int64 {
	if m != nil {
		return m.Follow
	}
	return 0
}

func (m *UserStatisticsRep) GetThumb() int64 {
	if m != nil {
		return m.Thumb
	}
	return 0
}

func (m *UserStatisticsRep) GetFans() int64 {
	if m != nil {
		return m.Fans
	}
	return 0
}

type UserIgnore struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// UserIgnoreID id
	// @inject_tag: db:"ignore_id"
	IgnoreID int64 `protobuf:"varint,2,opt,name=IgnoreID,proto3" json:"IgnoreID,omitempty"`
	// @inject_tag: db:"look"
	Look int32 `protobuf:"varint,3,opt,name=Look,proto3" json:"Look,omitempty"`
	// UserID 朋友
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID,omitempty"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,5,opt,name=CreateBy,proto3" json:"CreateBy,omitempty"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,6,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
}

func (m *UserIgnore) Reset()                    { *m = UserIgnore{} }
func (m *UserIgnore) String() string            { return proto.CompactTextString(m) }
func (*UserIgnore) ProtoMessage()               {}
func (*UserIgnore) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{19} }

func (m *UserIgnore) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserIgnore) GetIgnoreID() int64 {
	if m != nil {
		return m.IgnoreID
	}
	return 0
}

func (m *UserIgnore) GetLook() int32 {
	if m != nil {
		return m.Look
	}
	return 0
}

func (m *UserIgnore) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserIgnore) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *UserIgnore) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

type UserStatus struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// UserID 用户
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,2,opt,name=UserID,proto3" json:"UserID,omitempty"`
	// ForumCount 发帖数
	// @inject_tag: db:"forum_count"
	ForumCount int64 `protobuf:"varint,3,opt,name=ForumCount,proto3" json:"ForumCount,omitempty"`
	// FollowCount 关注数
	// @inject_tag: db:"follow_count"
	FollowCount int64 `protobuf:"varint,4,opt,name=FollowCount,proto3" json:"FollowCount,omitempty"`
	// ThumbCount 点赞数
	// @inject_tag: db:"thumb_count"
	ThumbCount int64 `protobuf:"varint,5,opt,name=ThumbCount,proto3" json:"ThumbCount,omitempty"`
	// FansCount 粉丝数
	// @inject_tag: db:"fans_count"
	FansCount int64 `protobuf:"varint,6,opt,name=FansCount,proto3" json:"FansCount,omitempty"`
	// Version 版本号
	// @inject_tag: db:"friend_version"
	FriendVersion int64 `protobuf:"varint,7,opt,name=FriendVersion,proto3" json:"FriendVersion,omitempty"`
	// Version 版本号
	// @inject_tag: db:"follow_version"
	FollowVersion int64 `protobuf:"varint,8,opt,name=FollowVersion,proto3" json:"FollowVersion,omitempty"`
	// Version 版本号
	// @inject_tag: db:"recommend_version_read"
	RecommendVersionRead int64 `protobuf:"varint,9,opt,name=RecommendVersionRead,proto3" json:"RecommendVersionRead,omitempty"`
	// Version 版本号
	// @inject_tag: db:"friend_version_read"
	FriendVersionRead int64 `protobuf:"varint,10,opt,name=FriendVersionRead,proto3" json:"FriendVersionRead,omitempty"`
	// Version 版本号
	// @inject_tag: db:"follow_version_read"
	FollowVersionRead int64 `protobuf:"varint,11,opt,name=FollowVersionRead,proto3" json:"FollowVersionRead,omitempty"`
	// Version 背景图
	// @inject_tag: db:"home_background"
	HomeBackground string `protobuf:"bytes,12,opt,name=HomeBackground,proto3" json:"HomeBackground,omitempty"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,13,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
	// CreateAt 创建时间
	// @inject_tag: db:"update_at"
	UpdateAt int64 `protobuf:"varint,14,opt,name=UpdateAt,proto3" json:"UpdateAt,omitempty"`
	// RecommendVersion 推荐版本号
	RecommendVersion int64                  `protobuf:"varint,15,opt,name=RecommendVersion,proto3" json:"RecommendVersion,omitempty"`
	User             *imapigateway.UserInfo `protobuf:"bytes,16,opt,name=User" json:"User,omitempty"`
	IsFriend         bool                   `protobuf:"varint,17,opt,name=IsFriend,proto3" json:"IsFriend,omitempty"`
	RecommendUID     int32                  `protobuf:"varint,18,opt,name=RecommendUID,proto3" json:"RecommendUID,omitempty"`
	FriendUID        int32                  `protobuf:"varint,19,opt,name=FriendUID,proto3" json:"FriendUID,omitempty"`
	FollowUID        int32                  `protobuf:"varint,20,opt,name=FollowUID,proto3" json:"FollowUID,omitempty"`
}

func (m *UserStatus) Reset()                    { *m = UserStatus{} }
func (m *UserStatus) String() string            { return proto.CompactTextString(m) }
func (*UserStatus) ProtoMessage()               {}
func (*UserStatus) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{20} }

func (m *UserStatus) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserStatus) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserStatus) GetForumCount() int64 {
	if m != nil {
		return m.ForumCount
	}
	return 0
}

func (m *UserStatus) GetFollowCount() int64 {
	if m != nil {
		return m.FollowCount
	}
	return 0
}

func (m *UserStatus) GetThumbCount() int64 {
	if m != nil {
		return m.ThumbCount
	}
	return 0
}

func (m *UserStatus) GetFansCount() int64 {
	if m != nil {
		return m.FansCount
	}
	return 0
}

func (m *UserStatus) GetFriendVersion() int64 {
	if m != nil {
		return m.FriendVersion
	}
	return 0
}

func (m *UserStatus) GetFollowVersion() int64 {
	if m != nil {
		return m.FollowVersion
	}
	return 0
}

func (m *UserStatus) GetRecommendVersionRead() int64 {
	if m != nil {
		return m.RecommendVersionRead
	}
	return 0
}

func (m *UserStatus) GetFriendVersionRead() int64 {
	if m != nil {
		return m.FriendVersionRead
	}
	return 0
}

func (m *UserStatus) GetFollowVersionRead() int64 {
	if m != nil {
		return m.FollowVersionRead
	}
	return 0
}

func (m *UserStatus) GetHomeBackground() string {
	if m != nil {
		return m.HomeBackground
	}
	return ""
}

func (m *UserStatus) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserStatus) GetUpdateAt() int64 {
	if m != nil {
		return m.UpdateAt
	}
	return 0
}

func (m *UserStatus) GetRecommendVersion() int64 {
	if m != nil {
		return m.RecommendVersion
	}
	return 0
}

func (m *UserStatus) GetUser() *imapigateway.UserInfo {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *UserStatus) GetIsFriend() bool {
	if m != nil {
		return m.IsFriend
	}
	return false
}

func (m *UserStatus) GetRecommendUID() int32 {
	if m != nil {
		return m.RecommendUID
	}
	return 0
}

func (m *UserStatus) GetFriendUID() int32 {
	if m != nil {
		return m.FriendUID
	}
	return 0
}

func (m *UserStatus) GetFollowUID() int32 {
	if m != nil {
		return m.FollowUID
	}
	return 0
}

// UserRecommendVersion ...
type UserRecommendVersion struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Version 推荐版本号
	// @inject_tag: db:"version"
	Version string `protobuf:"bytes,2,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *UserRecommendVersion) Reset()                    { *m = UserRecommendVersion{} }
func (m *UserRecommendVersion) String() string            { return proto.CompactTextString(m) }
func (*UserRecommendVersion) ProtoMessage()               {}
func (*UserRecommendVersion) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{21} }

func (m *UserRecommendVersion) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserRecommendVersion) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type TagAddReq struct {
	Tag      *Tag       `protobuf:"bytes,1,opt,name=Tag" json:"Tag,omitempty"`
	UserTags []*UserTag `protobuf:"bytes,2,rep,name=UserTags" json:"UserTags,omitempty"`
}

func (m *TagAddReq) Reset()                    { *m = TagAddReq{} }
func (m *TagAddReq) String() string            { return proto.CompactTextString(m) }
func (*TagAddReq) ProtoMessage()               {}
func (*TagAddReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{22} }

func (m *TagAddReq) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *TagAddReq) GetUserTags() []*UserTag {
	if m != nil {
		return m.UserTags
	}
	return nil
}

type TagAddRep struct {
	Tag *Tag `protobuf:"bytes,1,opt,name=Tag" json:"Tag,omitempty"`
}

func (m *TagAddRep) Reset()                    { *m = TagAddRep{} }
func (m *TagAddRep) String() string            { return proto.CompactTextString(m) }
func (*TagAddRep) ProtoMessage()               {}
func (*TagAddRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{23} }

func (m *TagAddRep) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

type UserTags struct {
	Tag      *Tag       `protobuf:"bytes,1,opt,name=Tag" json:"Tag,omitempty"`
	TagUsers []*UserTag `protobuf:"bytes,2,rep,name=TagUsers" json:"TagUsers,omitempty"`
}

func (m *UserTags) Reset()                    { *m = UserTags{} }
func (m *UserTags) String() string            { return proto.CompactTextString(m) }
func (*UserTags) ProtoMessage()               {}
func (*UserTags) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{24} }

func (m *UserTags) GetTag() *Tag {
	if m != nil {
		return m.Tag
	}
	return nil
}

func (m *UserTags) GetTagUsers() []*UserTag {
	if m != nil {
		return m.TagUsers
	}
	return nil
}

type TagGetReq struct {
	UserID int32 `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
}

func (m *TagGetReq) Reset()                    { *m = TagGetReq{} }
func (m *TagGetReq) String() string            { return proto.CompactTextString(m) }
func (*TagGetReq) ProtoMessage()               {}
func (*TagGetReq) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{25} }

func (m *TagGetReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

type TagGetRep struct {
	UserTags []*UserTags `protobuf:"bytes,1,rep,name=UserTags" json:"UserTags,omitempty"`
}

func (m *TagGetRep) Reset()                    { *m = TagGetRep{} }
func (m *TagGetRep) String() string            { return proto.CompactTextString(m) }
func (*TagGetRep) ProtoMessage()               {}
func (*TagGetRep) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{26} }

func (m *TagGetRep) GetUserTags() []*UserTags {
	if m != nil {
		return m.UserTags
	}
	return nil
}

type Tag struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// TagID 标签ID
	// @inject_tag: db:"tag_id"
	TagID int64 `protobuf:"varint,2,opt,name=TagID,proto3" json:"TagID,omitempty"`
	// TagName 标签名称(*此字段必传)
	// @inject_tag: db:"tag_name"
	TagName string `protobuf:"bytes,3,opt,name=TagName,proto3" json:"TagName,omitempty"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,4,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,5,opt,name=CreateBy,proto3" json:"CreateBy,omitempty"`
}

func (m *Tag) Reset()                    { *m = Tag{} }
func (m *Tag) String() string            { return proto.CompactTextString(m) }
func (*Tag) ProtoMessage()               {}
func (*Tag) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{27} }

func (m *Tag) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Tag) GetTagID() int64 {
	if m != nil {
		return m.TagID
	}
	return 0
}

func (m *Tag) GetTagName() string {
	if m != nil {
		return m.TagName
	}
	return ""
}

func (m *Tag) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *Tag) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

type UserTag struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// UserTagID 用户标签ID
	// @inject_tag: db:"user_tag_id"
	UserTagID int64 `protobuf:"varint,2,opt,name=UserTagID,proto3" json:"UserTagID,omitempty"`
	// ForumID 帖子ID
	// @inject_tag: db:"forum_id"
	// int32 ForumID  =3;
	// TagID 标签ID
	// @inject_tag: db:"tag_id"
	TagID int64 `protobuf:"varint,3,opt,name=TagID,proto3" json:"TagID,omitempty"`
	// UserID 用户(*此字段必传)
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID,omitempty"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,5,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,6,opt,name=CreateBy,proto3" json:"CreateBy,omitempty"`
}

func (m *UserTag) Reset()                    { *m = UserTag{} }
func (m *UserTag) String() string            { return proto.CompactTextString(m) }
func (*UserTag) ProtoMessage()               {}
func (*UserTag) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{28} }

func (m *UserTag) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserTag) GetUserTagID() int64 {
	if m != nil {
		return m.UserTagID
	}
	return 0
}

func (m *UserTag) GetTagID() int64 {
	if m != nil {
		return m.TagID
	}
	return 0
}

func (m *UserTag) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserTag) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserTag) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

type UserRecommend struct {
	// ID 主键
	// @inject_tag: db:"id"
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// ForumType 帖子类型
	// @inject_tag: db:"forum_type"
	ForumType int64 `protobuf:"varint,2,opt,name=ForumType,proto3" json:"ForumType,omitempty"`
	// UserID 用户(*此字段必传)
	// @inject_tag: db:"user_id"
	UserID int32 `protobuf:"varint,4,opt,name=UserID,proto3" json:"UserID,omitempty"`
	// CreateAt 创建时间
	// @inject_tag: db:"create_at"
	CreateAt int64 `protobuf:"varint,5,opt,name=CreateAt,proto3" json:"CreateAt,omitempty"`
	// CreateBy 创建人
	// @inject_tag: db:"create_by"
	CreateBy int32 `protobuf:"varint,6,opt,name=CreateBy,proto3" json:"CreateBy,omitempty"`
	// Mark 备注
	// @inject_tag: db:"mark"
	Mark string `protobuf:"bytes,7,opt,name=Mark,proto3" json:"Mark,omitempty"`
	// Mark 最低评论等级
	// @inject_tag: db:"limit_vip"
	LimitVIP int32 `protobuf:"varint,8,opt,name=LimitVIP,proto3" json:"LimitVIP,omitempty"`
}

func (m *UserRecommend) Reset()                    { *m = UserRecommend{} }
func (m *UserRecommend) String() string            { return proto.CompactTextString(m) }
func (*UserRecommend) ProtoMessage()               {}
func (*UserRecommend) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{29} }

func (m *UserRecommend) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UserRecommend) GetForumType() int64 {
	if m != nil {
		return m.ForumType
	}
	return 0
}

func (m *UserRecommend) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserRecommend) GetCreateAt() int64 {
	if m != nil {
		return m.CreateAt
	}
	return 0
}

func (m *UserRecommend) GetCreateBy() int32 {
	if m != nil {
		return m.CreateBy
	}
	return 0
}

func (m *UserRecommend) GetMark() string {
	if m != nil {
		return m.Mark
	}
	return ""
}

func (m *UserRecommend) GetLimitVIP() int32 {
	if m != nil {
		return m.LimitVIP
	}
	return 0
}

type Page struct {
	// 总条数
	TotalRows int64 `protobuf:"varint,1,opt,name=TotalRows,proto3" json:"TotalRows,omitempty"`
	// 总页数
	PageCount int64 `protobuf:"varint,2,opt,name=PageCount,proto3" json:"PageCount,omitempty"`
	// 页数大小
	PageSize int64 `protobuf:"varint,3,opt,name=PageSize,proto3" json:"PageSize,omitempty"`
	// 当前页
	CurrentPage int64 `protobuf:"varint,4,opt,name=CurrentPage,proto3" json:"CurrentPage,omitempty"`
	// 偏移量
	Offset int64 `protobuf:"varint,5,opt,name=Offset,proto3" json:"Offset,omitempty"`
	// 长度
	Limit int64 `protobuf:"varint,6,opt,name=Limit,proto3" json:"Limit,omitempty"`
	// 排序字段
	Order string `protobuf:"bytes,7,opt,name=Order,proto3" json:"Order,omitempty"`
	// 排序方法 (AES,DESC)
	Sort string `protobuf:"bytes,8,opt,name=Sort,proto3" json:"Sort,omitempty"`
}

func (m *Page) Reset()                    { *m = Page{} }
func (m *Page) String() string            { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()               {}
func (*Page) Descriptor() ([]byte, []int) { return fileDescriptorBase, []int{30} }

func (m *Page) GetTotalRows() int64 {
	if m != nil {
		return m.TotalRows
	}
	return 0
}

func (m *Page) GetPageCount() int64 {
	if m != nil {
		return m.PageCount
	}
	return 0
}

func (m *Page) GetPageSize() int64 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *Page) GetCurrentPage() int64 {
	if m != nil {
		return m.CurrentPage
	}
	return 0
}

func (m *Page) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Page) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *Page) GetOrder() string {
	if m != nil {
		return m.Order
	}
	return ""
}

func (m *Page) GetSort() string {
	if m != nil {
		return m.Sort
	}
	return ""
}

func init() {
	proto.RegisterType((*UserIgnoresAllResp)(nil), "moment.UserIgnoresAllResp")
	proto.RegisterType((*UserIgnoreMeGetResp)(nil), "moment.UserIgnoreMeGetResp")
	proto.RegisterType((*UserContactsSyncReq)(nil), "moment.UserContactsSyncReq")
	proto.RegisterType((*UserContactsSyncRep)(nil), "moment.UserContactsSyncRep")
	proto.RegisterType((*UserAlbumsReq)(nil), "moment.UserAlbumsReq")
	proto.RegisterType((*UserAlbumsRep)(nil), "moment.UserAlbumsRep")
	proto.RegisterType((*UserVersionGetRep)(nil), "moment.UserVersionGetRep")
	proto.RegisterType((*UserVersionUpdateReq)(nil), "moment.UserVersionUpdateReq")
	proto.RegisterType((*UserVersionUpdateRep)(nil), "moment.UserVersionUpdateRep")
	proto.RegisterType((*UserAllIDReq)(nil), "moment.UserAllIDReq")
	proto.RegisterType((*UserAllIDRep)(nil), "moment.UserAllIDRep")
	proto.RegisterType((*UserRecommendCheckRep)(nil), "moment.UserRecommendCheckRep")
	proto.RegisterType((*UserIgnoreCheckRep)(nil), "moment.UserIgnoreCheckRep")
	proto.RegisterType((*IgnoreSlice)(nil), "moment.IgnoreSlice")
	proto.RegisterType((*IgnoreNone)(nil), "moment.IgnoreNone")
	proto.RegisterType((*UserAlbumReq)(nil), "moment.UserAlbumReq")
	proto.RegisterType((*UserAlbumRep)(nil), "moment.UserAlbumRep")
	proto.RegisterType((*UserStatisticsReq)(nil), "moment.UserStatisticsReq")
	proto.RegisterType((*UserStatisticsRep)(nil), "moment.UserStatisticsRep")
	proto.RegisterType((*UserIgnore)(nil), "moment.UserIgnore")
	proto.RegisterType((*UserStatus)(nil), "moment.UserStatus")
	proto.RegisterType((*UserRecommendVersion)(nil), "moment.UserRecommendVersion")
	proto.RegisterType((*TagAddReq)(nil), "moment.TagAddReq")
	proto.RegisterType((*TagAddRep)(nil), "moment.TagAddRep")
	proto.RegisterType((*UserTags)(nil), "moment.UserTags")
	proto.RegisterType((*TagGetReq)(nil), "moment.TagGetReq")
	proto.RegisterType((*TagGetRep)(nil), "moment.TagGetRep")
	proto.RegisterType((*Tag)(nil), "moment.Tag")
	proto.RegisterType((*UserTag)(nil), "moment.UserTag")
	proto.RegisterType((*UserRecommend)(nil), "moment.UserRecommend")
	proto.RegisterType((*Page)(nil), "moment.Page")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BaseDBService service

type BaseDBServiceClient interface {
	TagAdd(ctx context.Context, in *TagAddReq, opts ...grpc.CallOption) (*TagAddRep, error)
	TagGet(ctx context.Context, in *TagGetReq, opts ...grpc.CallOption) (*TagGetRep, error)
	UserIgnoreAdd(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error)
	UserIgnoreGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*IgnoreSlice, error)
	UserIgnoreCheck(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreCheckRep, error)
	UserIgnoreDelete(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error)
	UserIgnoreMeGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreMeGetResp, error)
	UserVersionGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserVersionGetRep, error)
	UserVersionReadUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserVersionUpdate(ctx context.Context, in *UserVersionUpdateReq, opts ...grpc.CallOption) (*UserVersionUpdateRep, error)
	UserAlbumFromCache(ctx context.Context, in *UserAlbumReq, opts ...grpc.CallOption) (*UserAlbumRep, error)
	UserStatusUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserStatisticsGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserHomeBackgroudGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error)
	UserRecommendGet(ctx context.Context, in *UserRecommend, opts ...grpc.CallOption) (*UserRecommend, error)
	UserAllID(ctx context.Context, in *UserAllIDReq, opts ...grpc.CallOption) (*UserAllIDRep, error)
	UserIgnoresAll(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoresAllResp, error)
}

type baseDBServiceClient struct {
	cc *grpc.ClientConn
}

func NewBaseDBServiceClient(cc *grpc.ClientConn) BaseDBServiceClient {
	return &baseDBServiceClient{cc}
}

func (c *baseDBServiceClient) TagAdd(ctx context.Context, in *TagAddReq, opts ...grpc.CallOption) (*TagAddRep, error) {
	out := new(TagAddRep)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/TagAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) TagGet(ctx context.Context, in *TagGetReq, opts ...grpc.CallOption) (*TagGetRep, error) {
	out := new(TagGetRep)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/TagGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreAdd(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error) {
	out := new(IgnoreNone)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*IgnoreSlice, error) {
	out := new(IgnoreSlice)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreCheck(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreCheckRep, error) {
	out := new(UserIgnoreCheckRep)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreCheck", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreDelete(ctx context.Context, in *IgnoreSlice, opts ...grpc.CallOption) (*IgnoreNone, error) {
	out := new(IgnoreNone)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreDelete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoreMeGet(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoreMeGetResp, error) {
	out := new(UserIgnoreMeGetResp)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserIgnoreMeGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserVersionGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserVersionGetRep, error) {
	out := new(UserVersionGetRep)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserVersionGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserVersionReadUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserVersionReadUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserVersionUpdate(ctx context.Context, in *UserVersionUpdateReq, opts ...grpc.CallOption) (*UserVersionUpdateRep, error) {
	out := new(UserVersionUpdateRep)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserVersionUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserAlbumFromCache(ctx context.Context, in *UserAlbumReq, opts ...grpc.CallOption) (*UserAlbumRep, error) {
	out := new(UserAlbumRep)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserAlbumFromCache", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserStatusUpdate(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserStatusUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserStatisticsGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserStatisticsGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserHomeBackgroudGet(ctx context.Context, in *UserStatus, opts ...grpc.CallOption) (*UserStatus, error) {
	out := new(UserStatus)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserHomeBackgroudGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserRecommendGet(ctx context.Context, in *UserRecommend, opts ...grpc.CallOption) (*UserRecommend, error) {
	out := new(UserRecommend)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserRecommendGet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserAllID(ctx context.Context, in *UserAllIDReq, opts ...grpc.CallOption) (*UserAllIDRep, error) {
	out := new(UserAllIDRep)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserAllID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseDBServiceClient) UserIgnoresAll(ctx context.Context, in *UserIgnore, opts ...grpc.CallOption) (*UserIgnoresAllResp, error) {
	out := new(UserIgnoresAllResp)
	err := grpc.Invoke(ctx, "/moment.BaseDBService/UserIgnoresAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BaseDBService service

type BaseDBServiceServer interface {
	TagAdd(context.Context, *TagAddReq) (*TagAddRep, error)
	TagGet(context.Context, *TagGetReq) (*TagGetRep, error)
	UserIgnoreAdd(context.Context, *IgnoreSlice) (*IgnoreNone, error)
	UserIgnoreGet(context.Context, *UserIgnore) (*IgnoreSlice, error)
	UserIgnoreCheck(context.Context, *UserIgnore) (*UserIgnoreCheckRep, error)
	UserIgnoreDelete(context.Context, *IgnoreSlice) (*IgnoreNone, error)
	UserIgnoreMeGet(context.Context, *UserIgnore) (*UserIgnoreMeGetResp, error)
	UserVersionGet(context.Context, *UserStatus) (*UserVersionGetRep, error)
	UserVersionReadUpdate(context.Context, *UserStatus) (*UserStatus, error)
	UserVersionUpdate(context.Context, *UserVersionUpdateReq) (*UserVersionUpdateRep, error)
	UserAlbumFromCache(context.Context, *UserAlbumReq) (*UserAlbumRep, error)
	UserStatusUpdate(context.Context, *UserStatus) (*UserStatus, error)
	UserStatisticsGet(context.Context, *UserStatus) (*UserStatus, error)
	UserHomeBackgroudGet(context.Context, *UserStatus) (*UserStatus, error)
	UserRecommendGet(context.Context, *UserRecommend) (*UserRecommend, error)
	UserAllID(context.Context, *UserAllIDReq) (*UserAllIDRep, error)
	UserIgnoresAll(context.Context, *UserIgnore) (*UserIgnoresAllResp, error)
}

func RegisterBaseDBServiceServer(s *grpc.Server, srv BaseDBServiceServer) {
	s.RegisterService(&_BaseDBService_serviceDesc, srv)
}

func _BaseDBService_TagAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagAddReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).TagAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/TagAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).TagAdd(ctx, req.(*TagAddReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_TagGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TagGetReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).TagGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/TagGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).TagGet(ctx, req.(*TagGetReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgnoreSlice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreAdd(ctx, req.(*IgnoreSlice))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreGet(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreCheck(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IgnoreSlice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreDelete(ctx, req.(*IgnoreSlice))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoreMeGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoreMeGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoreMeGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoreMeGet(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserVersionGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserVersionGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserVersionGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserVersionGet(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserVersionReadUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserVersionReadUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserVersionReadUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserVersionReadUpdate(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserVersionUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserVersionUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserVersionUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserVersionUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserVersionUpdate(ctx, req.(*UserVersionUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserAlbumFromCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAlbumReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserAlbumFromCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserAlbumFromCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserAlbumFromCache(ctx, req.(*UserAlbumReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserStatusUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserStatusUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserStatusUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserStatusUpdate(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserStatisticsGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserStatisticsGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserStatisticsGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserStatisticsGet(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserHomeBackgroudGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserHomeBackgroudGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserHomeBackgroudGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserHomeBackgroudGet(ctx, req.(*UserStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserRecommendGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRecommend)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserRecommendGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserRecommendGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserRecommendGet(ctx, req.(*UserRecommend))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserAllID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAllIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserAllID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserAllID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserAllID(ctx, req.(*UserAllIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseDBService_UserIgnoresAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIgnore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseDBServiceServer).UserIgnoresAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseDBService/UserIgnoresAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseDBServiceServer).UserIgnoresAll(ctx, req.(*UserIgnore))
	}
	return interceptor(ctx, in, info, handler)
}

var _BaseDBService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.BaseDBService",
	HandlerType: (*BaseDBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "TagAdd",
			Handler:    _BaseDBService_TagAdd_Handler,
		},
		{
			MethodName: "TagGet",
			Handler:    _BaseDBService_TagGet_Handler,
		},
		{
			MethodName: "UserIgnoreAdd",
			Handler:    _BaseDBService_UserIgnoreAdd_Handler,
		},
		{
			MethodName: "UserIgnoreGet",
			Handler:    _BaseDBService_UserIgnoreGet_Handler,
		},
		{
			MethodName: "UserIgnoreCheck",
			Handler:    _BaseDBService_UserIgnoreCheck_Handler,
		},
		{
			MethodName: "UserIgnoreDelete",
			Handler:    _BaseDBService_UserIgnoreDelete_Handler,
		},
		{
			MethodName: "UserIgnoreMeGet",
			Handler:    _BaseDBService_UserIgnoreMeGet_Handler,
		},
		{
			MethodName: "UserVersionGet",
			Handler:    _BaseDBService_UserVersionGet_Handler,
		},
		{
			MethodName: "UserVersionReadUpdate",
			Handler:    _BaseDBService_UserVersionReadUpdate_Handler,
		},
		{
			MethodName: "UserVersionUpdate",
			Handler:    _BaseDBService_UserVersionUpdate_Handler,
		},
		{
			MethodName: "UserAlbumFromCache",
			Handler:    _BaseDBService_UserAlbumFromCache_Handler,
		},
		{
			MethodName: "UserStatusUpdate",
			Handler:    _BaseDBService_UserStatusUpdate_Handler,
		},
		{
			MethodName: "UserStatisticsGet",
			Handler:    _BaseDBService_UserStatisticsGet_Handler,
		},
		{
			MethodName: "UserHomeBackgroudGet",
			Handler:    _BaseDBService_UserHomeBackgroudGet_Handler,
		},
		{
			MethodName: "UserRecommendGet",
			Handler:    _BaseDBService_UserRecommendGet_Handler,
		},
		{
			MethodName: "UserAllID",
			Handler:    _BaseDBService_UserAllID_Handler,
		},
		{
			MethodName: "UserIgnoresAll",
			Handler:    _BaseDBService_UserIgnoresAll_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/pbmoments/base.proto",
}

// Client API for BaseService service

type BaseServiceClient interface {
	UserAlbums(ctx context.Context, in *UserAlbumsReq, opts ...grpc.CallOption) (*UserAlbumsRep, error)
	UserContactsSync(ctx context.Context, in *UserContactsSyncReq, opts ...grpc.CallOption) (*UserContactsSyncRep, error)
}

type baseServiceClient struct {
	cc *grpc.ClientConn
}

func NewBaseServiceClient(cc *grpc.ClientConn) BaseServiceClient {
	return &baseServiceClient{cc}
}

func (c *baseServiceClient) UserAlbums(ctx context.Context, in *UserAlbumsReq, opts ...grpc.CallOption) (*UserAlbumsRep, error) {
	out := new(UserAlbumsRep)
	err := grpc.Invoke(ctx, "/moment.BaseService/UserAlbums", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *baseServiceClient) UserContactsSync(ctx context.Context, in *UserContactsSyncReq, opts ...grpc.CallOption) (*UserContactsSyncRep, error) {
	out := new(UserContactsSyncRep)
	err := grpc.Invoke(ctx, "/moment.BaseService/UserContactsSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BaseService service

type BaseServiceServer interface {
	UserAlbums(context.Context, *UserAlbumsReq) (*UserAlbumsRep, error)
	UserContactsSync(context.Context, *UserContactsSyncReq) (*UserContactsSyncRep, error)
}

func RegisterBaseServiceServer(s *grpc.Server, srv BaseServiceServer) {
	s.RegisterService(&_BaseService_serviceDesc, srv)
}

func _BaseService_UserAlbums_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAlbumsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServiceServer).UserAlbums(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseService/UserAlbums",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServiceServer).UserAlbums(ctx, req.(*UserAlbumsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _BaseService_UserContactsSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserContactsSyncReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseServiceServer).UserContactsSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moment.BaseService/UserContactsSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseServiceServer).UserContactsSync(ctx, req.(*UserContactsSyncReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _BaseService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "moment.BaseService",
	HandlerType: (*BaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UserAlbums",
			Handler:    _BaseService_UserAlbums_Handler,
		},
		{
			MethodName: "UserContactsSync",
			Handler:    _BaseService_UserContactsSync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/pbmoments/base.proto",
}

func (m *UserIgnoresAllResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnoresAllResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		dAtA2 := make([]byte, len(m.UserIDs)*10)
		var j1 int
		for _, num1 := range m.UserIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *UserIgnoreMeGetResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnoreMeGetResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		dAtA4 := make([]byte, len(m.UserIDs)*10)
		var j3 int
		for _, num1 := range m.UserIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *UserContactsSyncReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserContactsSyncReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Action))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if len(m.ContactID) > 0 {
		dAtA6 := make([]byte, len(m.ContactID)*10)
		var j5 int
		for _, num1 := range m.ContactID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *UserContactsSyncRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserContactsSyncRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *UserAlbumsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if m.FriendID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FriendID))
	}
	return i, nil
}

func (m *UserAlbumsRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumsRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Medias) > 0 {
		for _, msg := range m.Medias {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserVersionGetRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserVersionGetRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RecommendState {
		dAtA[i] = 0x8
		i++
		if m.RecommendState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecommendUID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendUID))
	}
	if m.FriendState {
		dAtA[i] = 0x18
		i++
		if m.FriendState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FriendUID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FriendUID))
	}
	if m.FollowState {
		dAtA[i] = 0x28
		i++
		if m.FollowState {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FollowUID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FollowUID))
	}
	return i, nil
}

func (m *UserVersionUpdateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserVersionUpdateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if m.IsRecommedUser {
		dAtA[i] = 0x10
		i++
		if m.IsRecommedUser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Version != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Version))
	}
	if len(m.Friend) > 0 {
		dAtA8 := make([]byte, len(m.Friend)*10)
		var j7 int
		for _, num1 := range m.Friend {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintBase(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Fans) > 0 {
		dAtA10 := make([]byte, len(m.Fans)*10)
		var j9 int
		for _, num1 := range m.Fans {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBase(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *UserVersionUpdateRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserVersionUpdateRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UserAllIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAllIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExcludeUID) > 0 {
		dAtA12 := make([]byte, len(m.ExcludeUID)*10)
		var j11 int
		for _, num1 := range m.ExcludeUID {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	return i, nil
}

func (m *UserAllIDRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAllIDRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		dAtA14 := make([]byte, len(m.UserIDs)*10)
		var j13 int
		for _, num1 := range m.UserIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	return i, nil
}

func (m *UserRecommendCheckRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecommendCheckRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status {
		dAtA[i] = 0x8
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LimitVIP != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.LimitVIP))
	}
	return i, nil
}

func (m *UserIgnoreCheckRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnoreCheckRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status {
		dAtA[i] = 0x8
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *IgnoreSlice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IgnoreSlice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ignores) > 0 {
		for _, msg := range m.Ignores {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IgnoreNone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IgnoreNone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *UserAlbumReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if m.ForumID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ForumID))
	}
	if m.FriendID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FriendID))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *UserAlbumRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAlbumRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Medias) > 0 {
		for _, msg := range m.Medias {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UserStatisticsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatisticsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Vistor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Vistor))
	}
	if m.CreateBy != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
	}
	return i, nil
}

func (m *UserStatisticsRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatisticsRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Forum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Forum))
	}
	if m.Follow != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Follow))
	}
	if m.Thumb != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Thumb))
	}
	if m.Fans != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Fans))
	}
	return i, nil
}

func (m *UserIgnore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIgnore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
	}
	if m.IgnoreID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.IgnoreID))
	}
	if m.Look != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Look))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if m.CreateBy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
	}
	if m.CreateAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
	}
	return i, nil
}

func (m *UserStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if m.ForumCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ForumCount))
	}
	if m.FollowCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FollowCount))
	}
	if m.ThumbCount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ThumbCount))
	}
	if m.FansCount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FansCount))
	}
	if m.FriendVersion != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FriendVersion))
	}
	if m.FollowVersion != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FollowVersion))
	}
	if m.RecommendVersionRead != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendVersionRead))
	}
	if m.FriendVersionRead != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FriendVersionRead))
	}
	if m.FollowVersionRead != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FollowVersionRead))
	}
	if len(m.HomeBackground) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.HomeBackground)))
		i += copy(dAtA[i:], m.HomeBackground)
	}
	if m.CreateAt != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UpdateAt))
	}
	if m.RecommendVersion != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendVersion))
	}
	if m.User != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.User.Size()))
		n15, err := m.User.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.IsFriend {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IsFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RecommendUID != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.RecommendUID))
	}
	if m.FriendUID != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FriendUID))
	}
	if m.FollowUID != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.FollowUID))
	}
	return i, nil
}

func (m *UserRecommendVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecommendVersion) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *TagAddReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagAddReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Tag.Size()))
		n16, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.UserTags) > 0 {
		for _, msg := range m.UserTags {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TagAddRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagAddRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Tag.Size()))
		n17, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *UserTags) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTags) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Tag != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Tag.Size()))
		n18, err := m.Tag.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if len(m.TagUsers) > 0 {
		for _, msg := range m.TagUsers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TagGetReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagGetReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	return i, nil
}

func (m *TagGetRep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TagGetRep) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserTags) > 0 {
		for _, msg := range m.UserTags {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
	}
	if m.TagID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.TagID))
	}
	if len(m.TagName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.TagName)))
		i += copy(dAtA[i:], m.TagName)
	}
	if m.CreateAt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
	}
	return i, nil
}

func (m *UserTag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserTag) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
	}
	if m.UserTagID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserTagID))
	}
	if m.TagID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.TagID))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if m.CreateAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
	}
	return i, nil
}

func (m *UserRecommend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserRecommend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ID))
	}
	if m.ForumType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.ForumType))
	}
	if m.UserID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.UserID))
	}
	if m.CreateAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CreateBy))
	}
	if len(m.Mark) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Mark)))
		i += copy(dAtA[i:], m.Mark)
	}
	if m.LimitVIP != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.LimitVIP))
	}
	return i, nil
}

func (m *Page) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Page) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TotalRows != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.TotalRows))
	}
	if m.PageCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.PageCount))
	}
	if m.PageSize != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.PageSize))
	}
	if m.CurrentPage != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.CurrentPage))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Offset))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBase(dAtA, i, uint64(m.Limit))
	}
	if len(m.Order) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Order)))
		i += copy(dAtA[i:], m.Order)
	}
	if len(m.Sort) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBase(dAtA, i, uint64(len(m.Sort)))
		i += copy(dAtA[i:], m.Sort)
	}
	return i, nil
}

func encodeVarintBase(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserIgnoresAllResp) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		l = 0
		for _, e := range m.UserIDs {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	return n
}

func (m *UserIgnoreMeGetResp) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		l = 0
		for _, e := range m.UserIDs {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	return n
}

func (m *UserContactsSyncReq) Size() (n int) {
	var l int
	_ = l
	if m.Action != 0 {
		n += 1 + sovBase(uint64(m.Action))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if len(m.ContactID) > 0 {
		l = 0
		for _, e := range m.ContactID {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	return n
}

func (m *UserContactsSyncRep) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBase(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *UserAlbumsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.FriendID != 0 {
		n += 1 + sovBase(uint64(m.FriendID))
	}
	return n
}

func (m *UserAlbumsRep) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovBase(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if len(m.Medias) > 0 {
		for _, e := range m.Medias {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *UserVersionGetRep) Size() (n int) {
	var l int
	_ = l
	if m.RecommendState {
		n += 2
	}
	if m.RecommendUID != 0 {
		n += 1 + sovBase(uint64(m.RecommendUID))
	}
	if m.FriendState {
		n += 2
	}
	if m.FriendUID != 0 {
		n += 1 + sovBase(uint64(m.FriendUID))
	}
	if m.FollowState {
		n += 2
	}
	if m.FollowUID != 0 {
		n += 1 + sovBase(uint64(m.FollowUID))
	}
	return n
}

func (m *UserVersionUpdateReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.IsRecommedUser {
		n += 2
	}
	if m.Version != 0 {
		n += 1 + sovBase(uint64(m.Version))
	}
	if len(m.Friend) > 0 {
		l = 0
		for _, e := range m.Friend {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	if len(m.Fans) > 0 {
		l = 0
		for _, e := range m.Fans {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	return n
}

func (m *UserVersionUpdateRep) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UserAllIDReq) Size() (n int) {
	var l int
	_ = l
	if len(m.ExcludeUID) > 0 {
		l = 0
		for _, e := range m.ExcludeUID {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	return n
}

func (m *UserAllIDRep) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIDs) > 0 {
		l = 0
		for _, e := range m.UserIDs {
			l += sovBase(uint64(e))
		}
		n += 1 + sovBase(uint64(l)) + l
	}
	return n
}

func (m *UserRecommendCheckRep) Size() (n int) {
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	if m.LimitVIP != 0 {
		n += 1 + sovBase(uint64(m.LimitVIP))
	}
	return n
}

func (m *UserIgnoreCheckRep) Size() (n int) {
	var l int
	_ = l
	if m.Status {
		n += 2
	}
	return n
}

func (m *IgnoreSlice) Size() (n int) {
	var l int
	_ = l
	if len(m.Ignores) > 0 {
		for _, e := range m.Ignores {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *IgnoreNone) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *UserAlbumReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.ForumID != 0 {
		n += 1 + sovBase(uint64(m.ForumID))
	}
	if m.FriendID != 0 {
		n += 1 + sovBase(uint64(m.FriendID))
	}
	if m.Limit != 0 {
		n += 1 + sovBase(uint64(m.Limit))
	}
	return n
}

func (m *UserAlbumRep) Size() (n int) {
	var l int
	_ = l
	if len(m.Medias) > 0 {
		for _, e := range m.Medias {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *UserStatisticsReq) Size() (n int) {
	var l int
	_ = l
	if m.Vistor != 0 {
		n += 1 + sovBase(uint64(m.Vistor))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	return n
}

func (m *UserStatisticsRep) Size() (n int) {
	var l int
	_ = l
	if m.Forum != 0 {
		n += 1 + sovBase(uint64(m.Forum))
	}
	if m.Follow != 0 {
		n += 1 + sovBase(uint64(m.Follow))
	}
	if m.Thumb != 0 {
		n += 1 + sovBase(uint64(m.Thumb))
	}
	if m.Fans != 0 {
		n += 1 + sovBase(uint64(m.Fans))
	}
	return n
}

func (m *UserIgnore) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.IgnoreID != 0 {
		n += 1 + sovBase(uint64(m.IgnoreID))
	}
	if m.Look != 0 {
		n += 1 + sovBase(uint64(m.Look))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	return n
}

func (m *UserStatus) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.ForumCount != 0 {
		n += 1 + sovBase(uint64(m.ForumCount))
	}
	if m.FollowCount != 0 {
		n += 1 + sovBase(uint64(m.FollowCount))
	}
	if m.ThumbCount != 0 {
		n += 1 + sovBase(uint64(m.ThumbCount))
	}
	if m.FansCount != 0 {
		n += 1 + sovBase(uint64(m.FansCount))
	}
	if m.FriendVersion != 0 {
		n += 1 + sovBase(uint64(m.FriendVersion))
	}
	if m.FollowVersion != 0 {
		n += 1 + sovBase(uint64(m.FollowVersion))
	}
	if m.RecommendVersionRead != 0 {
		n += 1 + sovBase(uint64(m.RecommendVersionRead))
	}
	if m.FriendVersionRead != 0 {
		n += 1 + sovBase(uint64(m.FriendVersionRead))
	}
	if m.FollowVersionRead != 0 {
		n += 1 + sovBase(uint64(m.FollowVersionRead))
	}
	l = len(m.HomeBackground)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovBase(uint64(m.UpdateAt))
	}
	if m.RecommendVersion != 0 {
		n += 1 + sovBase(uint64(m.RecommendVersion))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 2 + l + sovBase(uint64(l))
	}
	if m.IsFriend {
		n += 3
	}
	if m.RecommendUID != 0 {
		n += 2 + sovBase(uint64(m.RecommendUID))
	}
	if m.FriendUID != 0 {
		n += 2 + sovBase(uint64(m.FriendUID))
	}
	if m.FollowUID != 0 {
		n += 2 + sovBase(uint64(m.FollowUID))
	}
	return n
}

func (m *UserRecommendVersion) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *TagAddReq) Size() (n int) {
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	if len(m.UserTags) > 0 {
		for _, e := range m.UserTags {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *TagAddRep) Size() (n int) {
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func (m *UserTags) Size() (n int) {
	var l int
	_ = l
	if m.Tag != nil {
		l = m.Tag.Size()
		n += 1 + l + sovBase(uint64(l))
	}
	if len(m.TagUsers) > 0 {
		for _, e := range m.TagUsers {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *TagGetReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	return n
}

func (m *TagGetRep) Size() (n int) {
	var l int
	_ = l
	if len(m.UserTags) > 0 {
		for _, e := range m.UserTags {
			l = e.Size()
			n += 1 + l + sovBase(uint64(l))
		}
	}
	return n
}

func (m *Tag) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.TagID != 0 {
		n += 1 + sovBase(uint64(m.TagID))
	}
	l = len(m.TagName)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	return n
}

func (m *UserTag) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.UserTagID != 0 {
		n += 1 + sovBase(uint64(m.UserTagID))
	}
	if m.TagID != 0 {
		n += 1 + sovBase(uint64(m.TagID))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	return n
}

func (m *UserRecommend) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBase(uint64(m.ID))
	}
	if m.ForumType != 0 {
		n += 1 + sovBase(uint64(m.ForumType))
	}
	if m.UserID != 0 {
		n += 1 + sovBase(uint64(m.UserID))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBase(uint64(m.CreateAt))
	}
	if m.CreateBy != 0 {
		n += 1 + sovBase(uint64(m.CreateBy))
	}
	l = len(m.Mark)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	if m.LimitVIP != 0 {
		n += 1 + sovBase(uint64(m.LimitVIP))
	}
	return n
}

func (m *Page) Size() (n int) {
	var l int
	_ = l
	if m.TotalRows != 0 {
		n += 1 + sovBase(uint64(m.TotalRows))
	}
	if m.PageCount != 0 {
		n += 1 + sovBase(uint64(m.PageCount))
	}
	if m.PageSize != 0 {
		n += 1 + sovBase(uint64(m.PageSize))
	}
	if m.CurrentPage != 0 {
		n += 1 + sovBase(uint64(m.CurrentPage))
	}
	if m.Offset != 0 {
		n += 1 + sovBase(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovBase(uint64(m.Limit))
	}
	l = len(m.Order)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	l = len(m.Sort)
	if l > 0 {
		n += 1 + l + sovBase(uint64(l))
	}
	return n
}

func sovBase(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBase(x uint64) (n int) {
	return sovBase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserIgnoresAllResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnoresAllResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnoresAllResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIDs = append(m.UserIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIDs = append(m.UserIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIgnoreMeGetResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnoreMeGetResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnoreMeGetResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIDs = append(m.UserIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIDs = append(m.UserIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserContactsSyncReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserContactsSyncReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserContactsSyncReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ContactID = append(m.ContactID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ContactID = append(m.ContactID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserContactsSyncRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserContactsSyncRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserContactsSyncRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendID", wireType)
			}
			m.FriendID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumsRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumsRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumsRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Medias = append(m.Medias, &moment1.Media{})
			if err := m.Medias[len(m.Medias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserVersionGetRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserVersionGetRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserVersionGetRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RecommendState = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendUID", wireType)
			}
			m.RecommendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendUID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FriendState = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendUID", wireType)
			}
			m.FriendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendUID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowState", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FollowState = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowUID", wireType)
			}
			m.FollowUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowUID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserVersionUpdateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserVersionUpdateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserVersionUpdateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRecommedUser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRecommedUser = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Friend = append(m.Friend, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Friend = append(m.Friend, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Friend", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Fans = append(m.Fans, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Fans = append(m.Fans, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Fans", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserVersionUpdateRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserVersionUpdateRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserVersionUpdateRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAllIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAllIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAllIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExcludeUID = append(m.ExcludeUID, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExcludeUID = append(m.ExcludeUID, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeUID", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAllIDRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAllIDRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAllIDRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIDs = append(m.UserIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIDs = append(m.UserIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecommendCheckRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecommendCheckRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecommendCheckRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVIP", wireType)
			}
			m.LimitVIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitVIP |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIgnoreCheckRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnoreCheckRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnoreCheckRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IgnoreSlice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IgnoreSlice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IgnoreSlice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignores", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ignores = append(m.Ignores, &UserIgnore{})
			if err := m.Ignores[len(m.Ignores)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IgnoreNone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IgnoreNone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IgnoreNone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumID", wireType)
			}
			m.ForumID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendID", wireType)
			}
			m.FriendID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAlbumRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAlbumRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAlbumRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Medias = append(m.Medias, &moment1.Media{})
			if err := m.Medias[len(m.Medias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatisticsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatisticsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatisticsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vistor", wireType)
			}
			m.Vistor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vistor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatisticsRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatisticsRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatisticsRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Forum", wireType)
			}
			m.Forum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Forum |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			m.Follow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Follow |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			m.Thumb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Thumb |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fans", wireType)
			}
			m.Fans = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fans |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIgnore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIgnore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIgnore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreID", wireType)
			}
			m.IgnoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IgnoreID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Look", wireType)
			}
			m.Look = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Look |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumCount", wireType)
			}
			m.ForumCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowCount", wireType)
			}
			m.FollowCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThumbCount", wireType)
			}
			m.ThumbCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThumbCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FansCount", wireType)
			}
			m.FansCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FansCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendVersion", wireType)
			}
			m.FriendVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendVersion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowVersion", wireType)
			}
			m.FollowVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowVersion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendVersionRead", wireType)
			}
			m.RecommendVersionRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendVersionRead |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendVersionRead", wireType)
			}
			m.FriendVersionRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendVersionRead |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowVersionRead", wireType)
			}
			m.FollowVersionRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowVersionRead |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HomeBackground", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HomeBackground = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendVersion", wireType)
			}
			m.RecommendVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendVersion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &imapigateway.UserInfo{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFriend = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendUID", wireType)
			}
			m.RecommendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecommendUID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendUID", wireType)
			}
			m.FriendUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FriendUID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FollowUID", wireType)
			}
			m.FollowUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FollowUID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecommendVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecommendVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecommendVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagAddReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagAddReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagAddReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserTags = append(m.UserTags, &UserTag{})
			if err := m.UserTags[len(m.UserTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagAddRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagAddRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagAddRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTags) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTags: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTags: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tag == nil {
				m.Tag = &Tag{}
			}
			if err := m.Tag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagUsers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagUsers = append(m.TagUsers, &UserTag{})
			if err := m.TagUsers[len(m.TagUsers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagGetReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagGetReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagGetReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TagGetRep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TagGetRep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TagGetRep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserTags = append(m.UserTags, &UserTags{})
			if err := m.UserTags[len(m.UserTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagID", wireType)
			}
			m.TagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserTag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserTag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserTag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTagID", wireType)
			}
			m.UserTagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserTagID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagID", wireType)
			}
			m.TagID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagID |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserRecommend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserRecommend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserRecommend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForumType", wireType)
			}
			m.ForumType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForumType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateBy", wireType)
			}
			m.CreateBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateBy |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitVIP", wireType)
			}
			m.LimitVIP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitVIP |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Page) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRows", wireType)
			}
			m.TotalRows = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRows |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageCount", wireType)
			}
			m.PageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PageSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentPage", wireType)
			}
			m.CurrentPage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentPage |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBase
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBase
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBase(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBase = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBase   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/pbmoments/base.proto", fileDescriptorBase)
}

var fileDescriptorBase = []byte{
	// 1575 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4d, 0x6f, 0x1b, 0x37,
	0x13, 0xd6, 0x5a, 0x1f, 0x96, 0x28, 0xdb, 0xb1, 0x19, 0xc7, 0xd0, 0xbb, 0x6f, 0x5e, 0xc3, 0xe0,
	0xdb, 0x06, 0x46, 0x6a, 0xc8, 0x85, 0x8a, 0x1e, 0xd2, 0x24, 0x45, 0x24, 0xb9, 0x4e, 0x8d, 0xc6,
	0x49, 0xba, 0x96, 0xdd, 0x4b, 0x2f, 0x94, 0x44, 0xcb, 0x0b, 0x6b, 0x3f, 0xba, 0xbb, 0x4a, 0xea,
	0x02, 0xfd, 0x25, 0x4d, 0x7f, 0x4a, 0x6f, 0x3d, 0xf4, 0x58, 0xf4, 0xd4, 0x5b, 0x8b, 0xfc, 0x92,
	0x82, 0x33, 0xe4, 0x7e, 0x69, 0xfd, 0x05, 0xf4, 0x22, 0xec, 0x3c, 0x9c, 0x19, 0x3e, 0x43, 0x0e,
	0x87, 0x43, 0x91, 0x47, 0x13, 0x3b, 0x9a, 0xf2, 0x61, 0x7b, 0x74, 0xc6, 0xa3, 0x50, 0x04, 0x6f,
	0x44, 0xd0, 0xb6, 0x9d, 0x5d, 0xdb, 0x8d, 0x44, 0x70, 0xca, 0x47, 0xc2, 0x0f, 0xbc, 0xe1, 0xec,
	0x74, 0xd7, 0x1f, 0x3a, 0x9e, 0x23, 0xdc, 0x28, 0xdc, 0x1d, 0xf2, 0x50, 0xb4, 0xfd, 0xc0, 0x8b,
	0x3c, 0x5a, 0x43, 0xcc, 0x7c, 0x76, 0x4b, 0x17, 0x8e, 0x18, 0xdb, 0x1c, 0x7f, 0xd1, 0x93, 0xf9,
	0xf9, 0x8d, 0x3c, 0xd8, 0x0e, 0xf7, 0xed, 0x09, 0x8f, 0xc4, 0x5b, 0x7e, 0xb1, 0x3b, 0xf2, 0x1c,
	0xc7, 0x73, 0xd1, 0x9e, 0xb5, 0x09, 0x3d, 0x0e, 0x45, 0x70, 0x30, 0x71, 0xbd, 0x40, 0x84, 0xdd,
	0xe9, 0xd4, 0x12, 0xa1, 0x4f, 0x5b, 0x64, 0x11, 0xd0, 0xbd, 0xb0, 0x65, 0x6c, 0x95, 0xb7, 0xab,
	0x96, 0x16, 0xd9, 0x2e, 0xb9, 0x9b, 0xe8, 0x1f, 0x8a, 0xe7, 0x22, 0xba, 0xc6, 0x60, 0x84, 0x06,
	0x7d, 0xcf, 0x8d, 0xf8, 0x28, 0x0a, 0x8f, 0x2e, 0xdc, 0x91, 0x25, 0xbe, 0xa3, 0x1b, 0xa4, 0xd6,
	0x1d, 0x45, 0xb6, 0xe7, 0xb6, 0x8c, 0x2d, 0x63, 0xbb, 0x6a, 0x29, 0x49, 0xe2, 0x68, 0xd9, 0x5a,
	0x40, 0x1c, 0x25, 0x7a, 0x9f, 0x34, 0x94, 0x8b, 0x83, 0xbd, 0x56, 0x19, 0xa6, 0x48, 0x00, 0xf6,
	0xb8, 0x68, 0x12, 0x9f, 0x52, 0x52, 0xe9, 0x7b, 0x63, 0xa1, 0xa6, 0x80, 0x6f, 0xba, 0x4a, 0xca,
	0x87, 0xe1, 0x04, 0xbc, 0x37, 0x2c, 0xf9, 0xc9, 0xfa, 0x64, 0x59, 0x1a, 0x77, 0xa7, 0xc3, 0x99,
	0x13, 0x2a, 0x6e, 0x8a, 0x83, 0x91, 0xe1, 0x60, 0x92, 0xfa, 0x7e, 0x60, 0x0b, 0x77, 0x1c, 0xb3,
	0x8b, 0x65, 0xf6, 0x6d, 0xd6, 0xc9, 0x0d, 0xe7, 0xa6, 0x1f, 0x92, 0xda, 0xa1, 0xdc, 0xcd, 0x10,
	0x62, 0x6a, 0x76, 0x96, 0xdb, 0xb8, 0xd5, 0x6d, 0x40, 0x2d, 0x35, 0xc8, 0xfe, 0x32, 0xc8, 0x9a,
	0x74, 0x7f, 0x22, 0x82, 0xd0, 0xf6, 0x5c, 0x58, 0x75, 0x9f, 0x3e, 0x20, 0x2b, 0x96, 0x90, 0xbb,
	0x29, 0xdc, 0xf1, 0x51, 0xc4, 0x23, 0x9c, 0xac, 0x6e, 0xe5, 0x50, 0xca, 0xc8, 0x52, 0x8c, 0x1c,
	0xc7, 0xdc, 0x33, 0x18, 0xdd, 0x22, 0x4d, 0x8c, 0x05, 0x1d, 0x95, 0xc1, 0x51, 0x1a, 0x92, 0x3b,
	0x80, 0xa2, 0x74, 0x51, 0x01, 0x17, 0x09, 0x00, 0xf6, 0xde, 0x74, 0xea, 0xbd, 0x45, 0xfb, 0xaa,
	0xb2, 0x4f, 0x20, 0xb0, 0x07, 0x51, 0xda, 0xd7, 0x94, 0xbd, 0x06, 0xd8, 0x3b, 0x83, 0xac, 0xa7,
	0x22, 0x3c, 0xf6, 0xc7, 0x3c, 0x12, 0x57, 0x6d, 0xc6, 0x03, 0xb2, 0x72, 0x10, 0xaa, 0x10, 0xc6,
	0x12, 0x83, 0xb0, 0xea, 0x56, 0x0e, 0x95, 0x99, 0xa9, 0x7c, 0x42, 0x50, 0x65, 0x4b, 0x8b, 0xd2,
	0x33, 0xf2, 0x6f, 0x55, 0x20, 0x9f, 0x94, 0x24, 0x77, 0x6e, 0x9f, 0xbb, 0x61, 0xab, 0x0a, 0x28,
	0x7c, 0xb3, 0x8d, 0x42, 0x76, 0x3e, 0x6b, 0x93, 0x25, 0xdc, 0xf6, 0xe9, 0xc1, 0x9e, 0x64, 0xbb,
	0x49, 0xc8, 0x17, 0xdf, 0x8f, 0xa6, 0xb3, 0xb1, 0x38, 0x06, 0xc6, 0xd2, 0x43, 0x0a, 0x61, 0xdb,
	0x19, 0xfd, 0xab, 0xce, 0xcd, 0x57, 0xe4, 0x9e, 0xfc, 0x8c, 0x37, 0xa9, 0x7f, 0x26, 0x46, 0xe7,
	0xd2, 0x64, 0x83, 0xd4, 0xe4, 0x82, 0xce, 0x42, 0xb5, 0xdb, 0x4a, 0x92, 0xd9, 0xf9, 0xc2, 0x76,
	0xec, 0xe8, 0xe4, 0xe0, 0xb5, 0xce, 0x4e, 0x2d, 0xb3, 0x9d, 0xf4, 0x29, 0xbf, 0xce, 0x13, 0x7b,
	0x4c, 0x9a, 0xa8, 0x79, 0x34, 0xb5, 0x47, 0x82, 0xee, 0x90, 0x45, 0x55, 0x1e, 0x80, 0x63, 0xb3,
	0x43, 0x75, 0x92, 0x26, 0x3e, 0x2d, 0xad, 0xc2, 0x96, 0x08, 0xc1, 0xcf, 0x97, 0x9e, 0x2b, 0x58,
	0xa0, 0xe3, 0x1d, 0xce, 0x9c, 0xab, 0x76, 0xb3, 0x45, 0x16, 0xf7, 0xbd, 0x60, 0xe6, 0xc4, 0xd9,
	0xa9, 0xc5, 0xcc, 0xa1, 0x2b, 0x67, 0x0f, 0x1d, 0x5d, 0x27, 0x55, 0x08, 0x11, 0xd2, 0xb1, 0x6c,
	0xa1, 0xc0, 0x3e, 0xcd, 0xcc, 0xe9, 0xa7, 0xce, 0x98, 0x71, 0xd5, 0x19, 0x7b, 0x8e, 0x47, 0x4c,
	0xae, 0x81, 0x1d, 0x46, 0xf6, 0x48, 0x97, 0x82, 0x13, 0x3b, 0x8c, 0xbc, 0x40, 0xf3, 0x45, 0x49,
	0xb2, 0xea, 0x07, 0x82, 0x47, 0xa2, 0x77, 0xa1, 0x17, 0x5b, 0xcb, 0xec, 0x7c, 0xde, 0x91, 0x2f,
	0xa9, 0x42, 0x44, 0xe0, 0xa7, 0x6c, 0xa1, 0x00, 0x29, 0x08, 0x47, 0x00, 0x9c, 0x94, 0x2d, 0x25,
	0x49, 0xed, 0xc1, 0xd9, 0xcc, 0x19, 0xaa, 0x94, 0x45, 0x21, 0x4e, 0x4c, 0x8c, 0x16, 0x13, 0xf3,
	0x9d, 0x41, 0x48, 0xb2, 0x0d, 0x74, 0x85, 0x2c, 0xc4, 0x6b, 0xbb, 0x80, 0xab, 0x87, 0x23, 0x6a,
	0x61, 0xcb, 0x56, 0x2c, 0x4b, 0x77, 0x2f, 0x3c, 0xef, 0x5c, 0xad, 0x2a, 0x7c, 0xa7, 0xf6, 0xa7,
	0x92, 0x2f, 0x7d, 0x71, 0xbc, 0xd5, 0x6c, 0xbc, 0xc9, 0x58, 0x37, 0x82, 0x73, 0x5d, 0xb6, 0x62,
	0x99, 0xfd, 0x5a, 0x45, 0x7a, 0x2a, 0x47, 0xf3, 0xf4, 0x2e, 0xab, 0xf6, 0x9b, 0x84, 0xc0, 0x02,
	0xf5, 0xbd, 0x99, 0x1b, 0xa9, 0x45, 0x48, 0x21, 0x49, 0xb5, 0x41, 0x05, 0x5c, 0x90, 0x34, 0x24,
	0x3d, 0xc0, 0xa2, 0xa1, 0x42, 0x15, 0x3d, 0x24, 0x08, 0x54, 0x23, 0xee, 0x86, 0x38, 0x8c, 0xac,
	0x13, 0x80, 0x7e, 0x40, 0x96, 0x31, 0xc9, 0x74, 0xe9, 0x58, 0x04, 0x8d, 0x2c, 0x08, 0x5a, 0x30,
	0xa5, 0xd6, 0xaa, 0x2b, 0xad, 0x34, 0x48, 0x3b, 0x64, 0x3d, 0x3e, 0xc4, 0x0a, 0xb3, 0x04, 0x1f,
	0xb7, 0x1a, 0xa0, 0x5c, 0x38, 0x46, 0x77, 0xc8, 0x5a, 0x66, 0x2a, 0x30, 0x20, 0x60, 0x30, 0x3f,
	0x00, 0xda, 0xe9, 0x29, 0x41, 0xbb, 0xa9, 0xb4, 0xf3, 0x03, 0xb2, 0x70, 0x7e, 0xe9, 0x39, 0xa2,
	0xc7, 0x47, 0xe7, 0x93, 0xc0, 0x9b, 0xb9, 0xe3, 0xd6, 0x12, 0xdc, 0x47, 0x39, 0x34, 0xb3, 0xad,
	0xcb, 0xd9, 0x6d, 0x95, 0x63, 0x58, 0x03, 0xbb, 0x51, 0x6b, 0x05, 0xc7, 0xb4, 0x4c, 0x1f, 0x92,
	0xd5, 0x7c, 0x4c, 0xad, 0x3b, 0xa0, 0x33, 0x87, 0xd3, 0x87, 0xa4, 0x02, 0xa5, 0x7b, 0x75, 0xcb,
	0xd8, 0x6e, 0x76, 0x36, 0xda, 0xe9, 0x3e, 0xa5, 0x3d, 0x93, 0xb9, 0xe0, 0x9e, 0x7a, 0x16, 0xe8,
	0x40, 0x2a, 0x87, 0xaa, 0x60, 0xaf, 0x41, 0xbd, 0x8a, 0xe5, 0xb9, 0x1b, 0x8e, 0x16, 0xdc, 0x70,
	0x99, 0xfb, 0xeb, 0x6e, 0xfe, 0xfe, 0xca, 0xdc, 0x4e, 0xeb, 0xf9, 0xdb, 0xe9, 0x19, 0x96, 0xff,
	0x39, 0xfe, 0xf9, 0x7c, 0x4e, 0x5d, 0x36, 0x78, 0xc9, 0x6b, 0x91, 0x7d, 0x43, 0x1a, 0x03, 0x3e,
	0xe9, 0x8e, 0xc7, 0xb2, 0xaa, 0xfc, 0x8f, 0x94, 0x07, 0x7c, 0x02, 0x76, 0xcd, 0x4e, 0x53, 0x97,
	0xa3, 0x01, 0x9f, 0x58, 0x12, 0xa7, 0x1f, 0x91, 0xba, 0x9c, 0x6d, 0xc0, 0x27, 0x61, 0x6b, 0x01,
	0x4a, 0xd6, 0x9d, 0x74, 0xc5, 0x95, 0x7a, 0xb1, 0x02, 0x7b, 0x98, 0x38, 0xf6, 0xaf, 0x71, 0xcc,
	0x4e, 0x12, 0xc7, 0x37, 0xe0, 0x30, 0xe0, 0x13, 0xa9, 0x7d, 0x39, 0x07, 0xad, 0xc0, 0xfe, 0x0f,
	0x1c, 0xa0, 0x2b, 0xb9, 0xb4, 0xc4, 0xb3, 0x47, 0x89, 0x92, 0x4f, 0x77, 0x52, 0x21, 0x62, 0x55,
	0x5e, 0xcd, 0xb9, 0x0f, 0x53, 0x31, 0xfe, 0x08, 0x5c, 0xe7, 0x56, 0x5b, 0x56, 0x49, 0x3e, 0x89,
	0x2b, 0x1b, 0x0a, 0x72, 0x0f, 0x06, 0x7c, 0xf2, 0x92, 0x3b, 0xd8, 0xc5, 0x34, 0x2c, 0x2d, 0x66,
	0x32, 0xba, 0x32, 0x9f, 0xd1, 0x97, 0x15, 0x38, 0xf6, 0xb3, 0x81, 0xb7, 0x74, 0x11, 0x87, 0xfb,
	0xa4, 0xa1, 0x86, 0x62, 0x1e, 0x09, 0x90, 0x30, 0x2c, 0xa7, 0x19, 0x5e, 0x5b, 0x64, 0xbb, 0xba,
	0x62, 0x15, 0xf3, 0xab, 0xe5, 0xf8, 0xfd, 0x62, 0x60, 0xf3, 0x19, 0xa7, 0x67, 0x11, 0x4b, 0xa8,
	0x9e, 0x83, 0x0b, 0x5f, 0x68, 0x96, 0x31, 0xf0, 0x6f, 0xf3, 0x91, 0x17, 0xcb, 0x21, 0x0f, 0xce,
	0xa1, 0x68, 0x36, 0x2c, 0xf8, 0xce, 0x74, 0x27, 0xf5, 0x5c, 0x77, 0xf2, 0xa7, 0x41, 0x2a, 0xaf,
	0xf9, 0x04, 0x5a, 0xc4, 0x81, 0x17, 0xf1, 0xa9, 0xe5, 0xbd, 0x0d, 0xd5, 0x45, 0x99, 0x00, 0x72,
	0x54, 0x6a, 0x61, 0xc9, 0x56, 0x41, 0xc4, 0x80, 0x9c, 0x40, 0x0a, 0x47, 0xf6, 0x0f, 0x42, 0xad,
	0x76, 0x2c, 0xcb, 0xeb, 0xa2, 0x3f, 0x0b, 0x02, 0xe1, 0x46, 0x12, 0xd2, 0xd7, 0x45, 0x0a, 0x92,
	0x4b, 0xf0, 0xea, 0xf4, 0x34, 0x14, 0x3a, 0x50, 0x25, 0x25, 0x1d, 0x46, 0x2d, 0xd5, 0x61, 0x48,
	0xf4, 0x55, 0x30, 0x16, 0x81, 0x8a, 0x10, 0x05, 0x19, 0xf6, 0x91, 0x17, 0x44, 0x10, 0x5e, 0xc3,
	0x82, 0xef, 0xce, 0x1f, 0x75, 0xb2, 0xdc, 0xe3, 0xa1, 0xd8, 0xeb, 0x1d, 0x89, 0xe0, 0x8d, 0xec,
	0xa6, 0x3e, 0x26, 0x35, 0x3c, 0xaf, 0x74, 0x2d, 0x75, 0xe8, 0xb0, 0x30, 0x98, 0x73, 0x90, 0xcf,
	0x4a, 0xca, 0xe2, 0xb9, 0x88, 0x32, 0x16, 0x78, 0xda, 0xcc, 0x39, 0x48, 0x5a, 0x7c, 0x86, 0xf9,
	0x80, 0x37, 0xbd, 0x9c, 0xea, 0xae, 0xd6, 0x4a, 0xf5, 0x75, 0x26, 0xcd, 0x82, 0xd0, 0xaf, 0xe5,
	0x6c, 0xe5, 0xa4, 0x05, 0xdd, 0x9e, 0x59, 0xe4, 0x8f, 0x95, 0x68, 0x9f, 0xdc, 0xc9, 0xb5, 0x99,
	0x85, 0xd6, 0xe6, 0x3c, 0xa6, 0x7b, 0x52, 0x56, 0xa2, 0x4f, 0xc9, 0x6a, 0x82, 0xef, 0x89, 0xa9,
	0x88, 0xc4, 0x6d, 0xf8, 0xef, 0xa5, 0x39, 0x1c, 0x5e, 0x1a, 0xc1, 0x7f, 0xe7, 0xb1, 0xf8, 0x35,
	0xcb, 0x4a, 0xb4, 0x4b, 0x56, 0xb2, 0xef, 0xad, 0xac, 0x13, 0x6c, 0x67, 0xcc, 0xff, 0xa4, 0xb1,
	0xcc, 0xdb, 0x0c, 0x5c, 0xdc, 0x4b, 0xc1, 0xf2, 0xea, 0xc5, 0x2b, 0xb2, 0xd0, 0x53, 0x01, 0xc6,
	0x4a, 0xf4, 0xeb, 0xcc, 0xab, 0x4f, 0x99, 0xdf, 0x2f, 0x98, 0x34, 0x7e, 0x2e, 0x99, 0x57, 0x8d,
	0x4a, 0x56, 0x3d, 0x7c, 0x09, 0x40, 0x73, 0xbc, 0x1f, 0x78, 0x4e, 0x9f, 0x8f, 0xce, 0x04, 0x5d,
	0x4f, 0x5b, 0xe9, 0x66, 0xdd, 0x2c, 0x42, 0xa5, 0x8f, 0x27, 0xb8, 0x43, 0x48, 0xf3, 0xd6, 0x41,
	0x3d, 0xcd, 0xb7, 0xc7, 0x97, 0xad, 0x6e, 0xb1, 0xb9, 0xba, 0x8a, 0xd3, 0xcd, 0xca, 0xf8, 0x76,
	0x1e, 0x7a, 0x48, 0x3f, 0xae, 0x96, 0xd2, 0xfa, 0x5e, 0x5a, 0x33, 0x1e, 0x31, 0x8b, 0x61, 0x56,
	0xa2, 0x8f, 0xb0, 0xec, 0xc3, 0x3b, 0x2e, 0xbf, 0x7a, 0xf8, 0x14, 0x34, 0x8b, 0x50, 0x1f, 0x02,
	0x58, 0xc9, 0xfe, 0xe3, 0x72, 0xd3, 0x33, 0xa2, 0xff, 0x9d, 0xe9, 0xfc, 0x64, 0x90, 0xa6, 0x2c,
	0x2a, 0xba, 0xa4, 0x3c, 0xc1, 0x1e, 0x1b, 0xff, 0x7b, 0xc8, 0x86, 0x12, 0xff, 0xa9, 0x61, 0x16,
	0xc2, 0x92, 0xcf, 0x4b, 0x5c, 0x8e, 0xf4, 0x7f, 0x27, 0x34, 0x73, 0x3a, 0x72, 0x7f, 0xdd, 0x98,
	0x57, 0x0c, 0xfa, 0xac, 0xd4, 0x5b, 0xfa, 0xed, 0xfd, 0xa6, 0xf1, 0xfb, 0xfb, 0x4d, 0xe3, 0xef,
	0xf7, 0x9b, 0xc6, 0xb0, 0x06, 0x7f, 0x33, 0x7d, 0xf2, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x3f,
	0x43, 0xbc, 0x81, 0x2d, 0x13, 0x00, 0x00,
}
