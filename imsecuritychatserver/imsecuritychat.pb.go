// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imsecuritychatserver/imsecuritychat.proto

/*
Package imsecuritychatserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/imsecuritychatserver/imsecuritychat.proto

It has these top-level messages:

	GetChatInfoByChatIdResult
	ChatInfo
	GetChatInfoByChatIdReq
	GetAllChatIdByUserIdKeyIdResult
	GetAllChatIdByUserIdKeyIdReq
	GetHandshakeUpdatesResult
	GetHandshakeUpdatesReq
	SecurityResult
	GetSecurityDiffByQtsReq
	GetSecurityDiffByQtsResult
	CheckSecurityChatExistReq
	CheckSecurityChatExistResult
	CheckEncryChatAcceptReq
	CheckEncryChatAcceptResult
	GetSecurityRandomIdsReq
	GetSecurityRandomIdsResult
	LogoutDisCardAllSecurityReq
	LogoutDisCardAllSecurityResult
	SetEncryptedTypingReq
	SetEncryptedTypingResult
	ReadEncryptedHistoryReq
	ReadEncryptedHistoryResult
	DiscardEncryptionReq
	DiscardEncryptionResult
	SendEncryptedServiceReq
	SendEncryptedServiceResult
	SendEncryptedFileReq
	SendEncryptedFileResult
	SendEncryptedReq
	SendEncryptedResult
	AcceptEncryptionReq
	AcceptEncryptionResult
	RequestEncryptionReq
	RequestEncryptionResult
*/
package imsecuritychatserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GetChatInfoByChatIdResult_ResultCode int32

const (
	GetChatInfoByChatIdResult_Success       GetChatInfoByChatIdResult_ResultCode = 0
	GetChatInfoByChatIdResult_InternalError GetChatInfoByChatIdResult_ResultCode = 1
)

var GetChatInfoByChatIdResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var GetChatInfoByChatIdResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x GetChatInfoByChatIdResult_ResultCode) String() string {
	return proto.EnumName(GetChatInfoByChatIdResult_ResultCode_name, int32(x))
}
func (GetChatInfoByChatIdResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{0, 0}
}

type GetAllChatIdByUserIdKeyIdResult_ErrorCode int32

const (
	GetAllChatIdByUserIdKeyIdResult_Success GetAllChatIdByUserIdKeyIdResult_ErrorCode = 0
	GetAllChatIdByUserIdKeyIdResult_Failed  GetAllChatIdByUserIdKeyIdResult_ErrorCode = 1
)

var GetAllChatIdByUserIdKeyIdResult_ErrorCode_name = map[int32]string{
	0: "Success",
	1: "Failed",
}
var GetAllChatIdByUserIdKeyIdResult_ErrorCode_value = map[string]int32{
	"Success": 0,
	"Failed":  1,
}

func (x GetAllChatIdByUserIdKeyIdResult_ErrorCode) String() string {
	return proto.EnumName(GetAllChatIdByUserIdKeyIdResult_ErrorCode_name, int32(x))
}
func (GetAllChatIdByUserIdKeyIdResult_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{3, 0}
}

type GetHandshakeUpdatesResult_ErrorCode int32

const (
	GetHandshakeUpdatesResult_Success GetHandshakeUpdatesResult_ErrorCode = 0
	GetHandshakeUpdatesResult_Failed  GetHandshakeUpdatesResult_ErrorCode = 1
)

var GetHandshakeUpdatesResult_ErrorCode_name = map[int32]string{
	0: "Success",
	1: "Failed",
}
var GetHandshakeUpdatesResult_ErrorCode_value = map[string]int32{
	"Success": 0,
	"Failed":  1,
}

func (x GetHandshakeUpdatesResult_ErrorCode) String() string {
	return proto.EnumName(GetHandshakeUpdatesResult_ErrorCode_name, int32(x))
}
func (GetHandshakeUpdatesResult_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{5, 0}
}

type GetSecurityDiffByQtsResult_ErrorCode int32

const (
	GetSecurityDiffByQtsResult_Success GetSecurityDiffByQtsResult_ErrorCode = 0
	GetSecurityDiffByQtsResult_Failed  GetSecurityDiffByQtsResult_ErrorCode = 1
)

var GetSecurityDiffByQtsResult_ErrorCode_name = map[int32]string{
	0: "Success",
	1: "Failed",
}
var GetSecurityDiffByQtsResult_ErrorCode_value = map[string]int32{
	"Success": 0,
	"Failed":  1,
}

func (x GetSecurityDiffByQtsResult_ErrorCode) String() string {
	return proto.EnumName(GetSecurityDiffByQtsResult_ErrorCode_name, int32(x))
}
func (GetSecurityDiffByQtsResult_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{9, 0}
}

type GetSecurityRandomIdsResult_ErrorCode int32

const (
	GetSecurityRandomIdsResult_Success GetSecurityRandomIdsResult_ErrorCode = 0
	GetSecurityRandomIdsResult_Failed  GetSecurityRandomIdsResult_ErrorCode = 1
)

var GetSecurityRandomIdsResult_ErrorCode_name = map[int32]string{
	0: "Success",
	1: "Failed",
}
var GetSecurityRandomIdsResult_ErrorCode_value = map[string]int32{
	"Success": 0,
	"Failed":  1,
}

func (x GetSecurityRandomIdsResult_ErrorCode) String() string {
	return proto.EnumName(GetSecurityRandomIdsResult_ErrorCode_name, int32(x))
}
func (GetSecurityRandomIdsResult_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{15, 0}
}

type LogoutDisCardAllSecurityResult_ErrorCode int32

const (
	LogoutDisCardAllSecurityResult_Success LogoutDisCardAllSecurityResult_ErrorCode = 0
	LogoutDisCardAllSecurityResult_Failed  LogoutDisCardAllSecurityResult_ErrorCode = 1
)

var LogoutDisCardAllSecurityResult_ErrorCode_name = map[int32]string{
	0: "Success",
	1: "Failed",
}
var LogoutDisCardAllSecurityResult_ErrorCode_value = map[string]int32{
	"Success": 0,
	"Failed":  1,
}

func (x LogoutDisCardAllSecurityResult_ErrorCode) String() string {
	return proto.EnumName(LogoutDisCardAllSecurityResult_ErrorCode_name, int32(x))
}
func (LogoutDisCardAllSecurityResult_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{17, 0}
}

type SetEncryptedTypingResult_Errcode int32

const (
	SetEncryptedTypingResult_Success       SetEncryptedTypingResult_Errcode = 0
	SetEncryptedTypingResult_failed        SetEncryptedTypingResult_Errcode = 1
	SetEncryptedTypingResult_AccessHashErr SetEncryptedTypingResult_Errcode = 2
)

var SetEncryptedTypingResult_Errcode_name = map[int32]string{
	0: "Success",
	1: "failed",
	2: "AccessHashErr",
}
var SetEncryptedTypingResult_Errcode_value = map[string]int32{
	"Success":       0,
	"failed":        1,
	"AccessHashErr": 2,
}

func (x SetEncryptedTypingResult_Errcode) String() string {
	return proto.EnumName(SetEncryptedTypingResult_Errcode_name, int32(x))
}
func (SetEncryptedTypingResult_Errcode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{19, 0}
}

type ReadEncryptedHistoryResult_Errcode int32

const (
	ReadEncryptedHistoryResult_Success       ReadEncryptedHistoryResult_Errcode = 0
	ReadEncryptedHistoryResult_failed        ReadEncryptedHistoryResult_Errcode = 1
	ReadEncryptedHistoryResult_AccessHashErr ReadEncryptedHistoryResult_Errcode = 2
)

var ReadEncryptedHistoryResult_Errcode_name = map[int32]string{
	0: "Success",
	1: "failed",
	2: "AccessHashErr",
}
var ReadEncryptedHistoryResult_Errcode_value = map[string]int32{
	"Success":       0,
	"failed":        1,
	"AccessHashErr": 2,
}

func (x ReadEncryptedHistoryResult_Errcode) String() string {
	return proto.EnumName(ReadEncryptedHistoryResult_Errcode_name, int32(x))
}
func (ReadEncryptedHistoryResult_Errcode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{21, 0}
}

type DiscardEncryptionResult_Errcode int32

const (
	DiscardEncryptionResult_Success       DiscardEncryptionResult_Errcode = 0
	DiscardEncryptionResult_failed        DiscardEncryptionResult_Errcode = 2
	DiscardEncryptionResult_AccessHashErr DiscardEncryptionResult_Errcode = 3
)

var DiscardEncryptionResult_Errcode_name = map[int32]string{
	0: "Success",
	2: "failed",
	3: "AccessHashErr",
}
var DiscardEncryptionResult_Errcode_value = map[string]int32{
	"Success":       0,
	"failed":        2,
	"AccessHashErr": 3,
}

func (x DiscardEncryptionResult_Errcode) String() string {
	return proto.EnumName(DiscardEncryptionResult_Errcode_name, int32(x))
}
func (DiscardEncryptionResult_Errcode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{23, 0}
}

type SendEncryptedServiceResult_Errcode int32

const (
	SendEncryptedServiceResult_Success        SendEncryptedServiceResult_Errcode = 0
	SendEncryptedServiceResult_Repeatedhandle SendEncryptedServiceResult_Errcode = 1
	SendEncryptedServiceResult_ChatNotExist   SendEncryptedServiceResult_Errcode = 2
	SendEncryptedServiceResult_DbError        SendEncryptedServiceResult_Errcode = 3
	SendEncryptedServiceResult_AccessHashErr  SendEncryptedServiceResult_Errcode = 4
)

var SendEncryptedServiceResult_Errcode_name = map[int32]string{
	0: "Success",
	1: "Repeatedhandle",
	2: "ChatNotExist",
	3: "DbError",
	4: "AccessHashErr",
}
var SendEncryptedServiceResult_Errcode_value = map[string]int32{
	"Success":        0,
	"Repeatedhandle": 1,
	"ChatNotExist":   2,
	"DbError":        3,
	"AccessHashErr":  4,
}

func (x SendEncryptedServiceResult_Errcode) String() string {
	return proto.EnumName(SendEncryptedServiceResult_Errcode_name, int32(x))
}
func (SendEncryptedServiceResult_Errcode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{25, 0}
}

type SendEncryptedFileResult_Errcode int32

const (
	SendEncryptedFileResult_Success        SendEncryptedFileResult_Errcode = 0
	SendEncryptedFileResult_Repeatedhandle SendEncryptedFileResult_Errcode = 1
	SendEncryptedFileResult_ChatNotExist   SendEncryptedFileResult_Errcode = 2
	SendEncryptedFileResult_DbError        SendEncryptedFileResult_Errcode = 3
	SendEncryptedFileResult_AccessHashErr  SendEncryptedFileResult_Errcode = 4
)

var SendEncryptedFileResult_Errcode_name = map[int32]string{
	0: "Success",
	1: "Repeatedhandle",
	2: "ChatNotExist",
	3: "DbError",
	4: "AccessHashErr",
}
var SendEncryptedFileResult_Errcode_value = map[string]int32{
	"Success":        0,
	"Repeatedhandle": 1,
	"ChatNotExist":   2,
	"DbError":        3,
	"AccessHashErr":  4,
}

func (x SendEncryptedFileResult_Errcode) String() string {
	return proto.EnumName(SendEncryptedFileResult_Errcode_name, int32(x))
}
func (SendEncryptedFileResult_Errcode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{27, 0}
}

type SendEncryptedResult_Errcode int32

const (
	SendEncryptedResult_Success        SendEncryptedResult_Errcode = 0
	SendEncryptedResult_Repeatedhandle SendEncryptedResult_Errcode = 1
	SendEncryptedResult_ChatNotExist   SendEncryptedResult_Errcode = 2
	SendEncryptedResult_DbError        SendEncryptedResult_Errcode = 3
	SendEncryptedResult_AccessHashErr  SendEncryptedResult_Errcode = 4
)

var SendEncryptedResult_Errcode_name = map[int32]string{
	0: "Success",
	1: "Repeatedhandle",
	2: "ChatNotExist",
	3: "DbError",
	4: "AccessHashErr",
}
var SendEncryptedResult_Errcode_value = map[string]int32{
	"Success":        0,
	"Repeatedhandle": 1,
	"ChatNotExist":   2,
	"DbError":        3,
	"AccessHashErr":  4,
}

func (x SendEncryptedResult_Errcode) String() string {
	return proto.EnumName(SendEncryptedResult_Errcode_name, int32(x))
}
func (SendEncryptedResult_Errcode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{29, 0}
}

type AcceptEncryptionResult_Errcode int32

const (
	AcceptEncryptionResult_Success        AcceptEncryptionResult_Errcode = 0
	AcceptEncryptionResult_AlreadyAccept  AcceptEncryptionResult_Errcode = 1
	AcceptEncryptionResult_Repeatedhandle AcceptEncryptionResult_Errcode = 2
	AcceptEncryptionResult_DbError        AcceptEncryptionResult_Errcode = 3
	AcceptEncryptionResult_AccessHashErr  AcceptEncryptionResult_Errcode = 4
)

var AcceptEncryptionResult_Errcode_name = map[int32]string{
	0: "Success",
	1: "AlreadyAccept",
	2: "Repeatedhandle",
	3: "DbError",
	4: "AccessHashErr",
}
var AcceptEncryptionResult_Errcode_value = map[string]int32{
	"Success":        0,
	"AlreadyAccept":  1,
	"Repeatedhandle": 2,
	"DbError":        3,
	"AccessHashErr":  4,
}

func (x AcceptEncryptionResult_Errcode) String() string {
	return proto.EnumName(AcceptEncryptionResult_Errcode_name, int32(x))
}
func (AcceptEncryptionResult_Errcode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{31, 0}
}

type RequestEncryptionResult_ErroCode int32

const (
	RequestEncryptionResult_SusscessFull       RequestEncryptionResult_ErroCode = 0
	RequestEncryptionResult_GenIdFailed        RequestEncryptionResult_ErroCode = 1
	RequestEncryptionResult_DbError            RequestEncryptionResult_ErroCode = 2
	RequestEncryptionResult_Restricted         RequestEncryptionResult_ErroCode = 3
	RequestEncryptionResult_ParticipantBlocked RequestEncryptionResult_ErroCode = 4
)

var RequestEncryptionResult_ErroCode_name = map[int32]string{
	0: "SusscessFull",
	1: "GenIdFailed",
	2: "DbError",
	3: "Restricted",
	4: "ParticipantBlocked",
}
var RequestEncryptionResult_ErroCode_value = map[string]int32{
	"SusscessFull":       0,
	"GenIdFailed":        1,
	"DbError":            2,
	"Restricted":         3,
	"ParticipantBlocked": 4,
}

func (x RequestEncryptionResult_ErroCode) String() string {
	return proto.EnumName(RequestEncryptionResult_ErroCode_name, int32(x))
}
func (RequestEncryptionResult_ErroCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{33, 0}
}

type GetChatInfoByChatIdResult struct {
	Code     GetChatInfoByChatIdResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=imsecuritychatserver.GetChatInfoByChatIdResult_ResultCode" json:"code,omitempty"`
	ChatInfo *ChatInfo                            `protobuf:"bytes,2,opt,name=chat_info,json=chatInfo" json:"chat_info,omitempty"`
}

func (m *GetChatInfoByChatIdResult) Reset()         { *m = GetChatInfoByChatIdResult{} }
func (m *GetChatInfoByChatIdResult) String() string { return proto.CompactTextString(m) }
func (*GetChatInfoByChatIdResult) ProtoMessage()    {}
func (*GetChatInfoByChatIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{0}
}

func (m *GetChatInfoByChatIdResult) GetCode() GetChatInfoByChatIdResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return GetChatInfoByChatIdResult_Success
}

func (m *GetChatInfoByChatIdResult) GetChatInfo() *ChatInfo {
	if m != nil {
		return m.ChatInfo
	}
	return nil
}

// 加密聊天chat信息
type ChatInfo struct {
	ChatId       int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	ChatCreator  int32 `protobuf:"varint,2,opt,name=chat_creator,json=chatCreator,proto3" json:"chat_creator,omitempty"`
	AccessHash   int64 `protobuf:"varint,3,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	ChatMember   int32 `protobuf:"varint,4,opt,name=chat_member,json=chatMember,proto3" json:"chat_member,omitempty"`
	CreatorKeyId int64 `protobuf:"varint,5,opt,name=creator_key_id,json=creatorKeyId,proto3" json:"creator_key_id,omitempty"`
	MemberKeyId  int64 `protobuf:"varint,6,opt,name=member_key_id,json=memberKeyId,proto3" json:"member_key_id,omitempty"`
	Date         int32 `protobuf:"varint,7,opt,name=date,proto3" json:"date,omitempty"`
	AlreadAccept bool  `protobuf:"varint,8,opt,name=alread_accept,json=alreadAccept,proto3" json:"alread_accept,omitempty"`
	IsNormal     bool  `protobuf:"varint,9,opt,name=is_normal,json=isNormal,proto3" json:"is_normal,omitempty"`
}

func (m *ChatInfo) Reset()                    { *m = ChatInfo{} }
func (m *ChatInfo) String() string            { return proto.CompactTextString(m) }
func (*ChatInfo) ProtoMessage()               {}
func (*ChatInfo) Descriptor() ([]byte, []int) { return fileDescriptorImsecuritychat, []int{1} }

func (m *ChatInfo) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ChatInfo) GetChatCreator() int32 {
	if m != nil {
		return m.ChatCreator
	}
	return 0
}

func (m *ChatInfo) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ChatInfo) GetChatMember() int32 {
	if m != nil {
		return m.ChatMember
	}
	return 0
}

func (m *ChatInfo) GetCreatorKeyId() int64 {
	if m != nil {
		return m.CreatorKeyId
	}
	return 0
}

func (m *ChatInfo) GetMemberKeyId() int64 {
	if m != nil {
		return m.MemberKeyId
	}
	return 0
}

func (m *ChatInfo) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ChatInfo) GetAlreadAccept() bool {
	if m != nil {
		return m.AlreadAccept
	}
	return false
}

func (m *ChatInfo) GetIsNormal() bool {
	if m != nil {
		return m.IsNormal
	}
	return false
}

type GetChatInfoByChatIdReq struct {
	ChatId int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *GetChatInfoByChatIdReq) Reset()         { *m = GetChatInfoByChatIdReq{} }
func (m *GetChatInfoByChatIdReq) String() string { return proto.CompactTextString(m) }
func (*GetChatInfoByChatIdReq) ProtoMessage()    {}
func (*GetChatInfoByChatIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{2}
}

func (m *GetChatInfoByChatIdReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

type GetAllChatIdByUserIdKeyIdResult struct {
	ErrCode GetAllChatIdByUserIdKeyIdResult_ErrorCode `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3,enum=imsecuritychatserver.GetAllChatIdByUserIdKeyIdResult_ErrorCode" json:"err_code,omitempty"`
	ChatId  []int32                                   `protobuf:"varint,2,rep,packed,name=chat_id,json=chatId" json:"chat_id,omitempty"`
}

func (m *GetAllChatIdByUserIdKeyIdResult) Reset()         { *m = GetAllChatIdByUserIdKeyIdResult{} }
func (m *GetAllChatIdByUserIdKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*GetAllChatIdByUserIdKeyIdResult) ProtoMessage()    {}
func (*GetAllChatIdByUserIdKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{3}
}

func (m *GetAllChatIdByUserIdKeyIdResult) GetErrCode() GetAllChatIdByUserIdKeyIdResult_ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return GetAllChatIdByUserIdKeyIdResult_Success
}

func (m *GetAllChatIdByUserIdKeyIdResult) GetChatId() []int32 {
	if m != nil {
		return m.ChatId
	}
	return nil
}

type GetAllChatIdByUserIdKeyIdReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId  int64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *GetAllChatIdByUserIdKeyIdReq) Reset()         { *m = GetAllChatIdByUserIdKeyIdReq{} }
func (m *GetAllChatIdByUserIdKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*GetAllChatIdByUserIdKeyIdReq) ProtoMessage()    {}
func (*GetAllChatIdByUserIdKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{4}
}

func (m *GetAllChatIdByUserIdKeyIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetAllChatIdByUserIdKeyIdReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type GetHandshakeUpdatesResult struct {
	ErrCode GetHandshakeUpdatesResult_ErrorCode `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3,enum=imsecuritychatserver.GetHandshakeUpdatesResult_ErrorCode" json:"err_code,omitempty"`
	Update  [][]byte                            `protobuf:"bytes,2,rep,name=update" json:"update,omitempty"`
}

func (m *GetHandshakeUpdatesResult) Reset()         { *m = GetHandshakeUpdatesResult{} }
func (m *GetHandshakeUpdatesResult) String() string { return proto.CompactTextString(m) }
func (*GetHandshakeUpdatesResult) ProtoMessage()    {}
func (*GetHandshakeUpdatesResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{5}
}

func (m *GetHandshakeUpdatesResult) GetErrCode() GetHandshakeUpdatesResult_ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return GetHandshakeUpdatesResult_Success
}

func (m *GetHandshakeUpdatesResult) GetUpdate() [][]byte {
	if m != nil {
		return m.Update
	}
	return nil
}

type GetHandshakeUpdatesReq struct {
	UserId    int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId int64 `protobuf:"varint,2,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Date      int64 `protobuf:"varint,3,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *GetHandshakeUpdatesReq) Reset()         { *m = GetHandshakeUpdatesReq{} }
func (m *GetHandshakeUpdatesReq) String() string { return proto.CompactTextString(m) }
func (*GetHandshakeUpdatesReq) ProtoMessage()    {}
func (*GetHandshakeUpdatesReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{6}
}

func (m *GetHandshakeUpdatesReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetHandshakeUpdatesReq) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *GetHandshakeUpdatesReq) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

type SecurityResult struct {
	Result    []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
}

func (m *SecurityResult) Reset()                    { *m = SecurityResult{} }
func (m *SecurityResult) String() string            { return proto.CompactTextString(m) }
func (*SecurityResult) ProtoMessage()               {}
func (*SecurityResult) Descriptor() ([]byte, []int) { return fileDescriptorImsecuritychat, []int{7} }

func (m *SecurityResult) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SecurityResult) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type GetSecurityDiffByQtsReq struct {
	FromId int32         `protobuf:"varint,1,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	KeyId  uint64        `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Qts    int32         `protobuf:"varint,3,opt,name=qts,proto3" json:"qts,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *GetSecurityDiffByQtsReq) Reset()         { *m = GetSecurityDiffByQtsReq{} }
func (m *GetSecurityDiffByQtsReq) String() string { return proto.CompactTextString(m) }
func (*GetSecurityDiffByQtsReq) ProtoMessage()    {}
func (*GetSecurityDiffByQtsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{8}
}

func (m *GetSecurityDiffByQtsReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *GetSecurityDiffByQtsReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *GetSecurityDiffByQtsReq) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

func (m *GetSecurityDiffByQtsReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type GetSecurityDiffByQtsResult struct {
	ErrCode GetSecurityDiffByQtsResult_ErrorCode `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3,enum=imsecuritychatserver.GetSecurityDiffByQtsResult_ErrorCode" json:"err_code,omitempty"`
	Update  [][]byte                             `protobuf:"bytes,2,rep,name=update" json:"update,omitempty"`
}

func (m *GetSecurityDiffByQtsResult) Reset()         { *m = GetSecurityDiffByQtsResult{} }
func (m *GetSecurityDiffByQtsResult) String() string { return proto.CompactTextString(m) }
func (*GetSecurityDiffByQtsResult) ProtoMessage()    {}
func (*GetSecurityDiffByQtsResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{9}
}

func (m *GetSecurityDiffByQtsResult) GetErrCode() GetSecurityDiffByQtsResult_ErrorCode {
	if m != nil {
		return m.ErrCode
	}
	return GetSecurityDiffByQtsResult_Success
}

func (m *GetSecurityDiffByQtsResult) GetUpdate() [][]byte {
	if m != nil {
		return m.Update
	}
	return nil
}

type CheckSecurityChatExistReq struct {
	ChatId int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *CheckSecurityChatExistReq) Reset()         { *m = CheckSecurityChatExistReq{} }
func (m *CheckSecurityChatExistReq) String() string { return proto.CompactTextString(m) }
func (*CheckSecurityChatExistReq) ProtoMessage()    {}
func (*CheckSecurityChatExistReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{10}
}

func (m *CheckSecurityChatExistReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

type CheckSecurityChatExistResult struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *CheckSecurityChatExistResult) Reset()         { *m = CheckSecurityChatExistResult{} }
func (m *CheckSecurityChatExistResult) String() string { return proto.CompactTextString(m) }
func (*CheckSecurityChatExistResult) ProtoMessage()    {}
func (*CheckSecurityChatExistResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{11}
}

func (m *CheckSecurityChatExistResult) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

type CheckEncryChatAcceptReq struct {
	ChatId int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
}

func (m *CheckEncryChatAcceptReq) Reset()         { *m = CheckEncryChatAcceptReq{} }
func (m *CheckEncryChatAcceptReq) String() string { return proto.CompactTextString(m) }
func (*CheckEncryChatAcceptReq) ProtoMessage()    {}
func (*CheckEncryChatAcceptReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{12}
}

func (m *CheckEncryChatAcceptReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

type CheckEncryChatAcceptResult struct {
	Result bool `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *CheckEncryChatAcceptResult) Reset()         { *m = CheckEncryChatAcceptResult{} }
func (m *CheckEncryChatAcceptResult) String() string { return proto.CompactTextString(m) }
func (*CheckEncryChatAcceptResult) ProtoMessage()    {}
func (*CheckEncryChatAcceptResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{13}
}

func (m *CheckEncryChatAcceptResult) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

// 获取加密聊天的randomId的请求
type GetSecurityRandomIdsReq struct {
	KeyId     int64         `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	MaxQts    int32         `protobuf:"varint,2,opt,name=max_qts,json=maxQts,proto3" json:"max_qts,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
	ObjBin    []byte        `protobuf:"bytes,4,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId     uint32        `protobuf:"varint,5,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId int64         `protobuf:"varint,6,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *GetSecurityRandomIdsReq) Reset()         { *m = GetSecurityRandomIdsReq{} }
func (m *GetSecurityRandomIdsReq) String() string { return proto.CompactTextString(m) }
func (*GetSecurityRandomIdsReq) ProtoMessage()    {}
func (*GetSecurityRandomIdsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{14}
}

func (m *GetSecurityRandomIdsReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *GetSecurityRandomIdsReq) GetMaxQts() int32 {
	if m != nil {
		return m.MaxQts
	}
	return 0
}

func (m *GetSecurityRandomIdsReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *GetSecurityRandomIdsReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *GetSecurityRandomIdsReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *GetSecurityRandomIdsReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 获取加密聊天的randomId 们的返回值
type GetSecurityRandomIdsResult struct {
	Errcode   GetSecurityRandomIdsResult_ErrorCode `protobuf:"varint,1,opt,name=errcode,proto3,enum=imsecuritychatserver.GetSecurityRandomIdsResult_ErrorCode" json:"errcode,omitempty"`
	RandomIds []int64                              `protobuf:"varint,2,rep,packed,name=random_ids,json=randomIds" json:"random_ids,omitempty"`
}

func (m *GetSecurityRandomIdsResult) Reset()         { *m = GetSecurityRandomIdsResult{} }
func (m *GetSecurityRandomIdsResult) String() string { return proto.CompactTextString(m) }
func (*GetSecurityRandomIdsResult) ProtoMessage()    {}
func (*GetSecurityRandomIdsResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{15}
}

func (m *GetSecurityRandomIdsResult) GetErrcode() GetSecurityRandomIdsResult_ErrorCode {
	if m != nil {
		return m.Errcode
	}
	return GetSecurityRandomIdsResult_Success
}

func (m *GetSecurityRandomIdsResult) GetRandomIds() []int64 {
	if m != nil {
		return m.RandomIds
	}
	return nil
}

// LogOut后删除所有的加密聊天的请求
type LogoutDisCardAllSecurityReq struct {
	UserId    int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId     int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
	ObjBin    []byte        `protobuf:"bytes,4,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId     uint32        `protobuf:"varint,5,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId int64         `protobuf:"varint,6,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *LogoutDisCardAllSecurityReq) Reset()         { *m = LogoutDisCardAllSecurityReq{} }
func (m *LogoutDisCardAllSecurityReq) String() string { return proto.CompactTextString(m) }
func (*LogoutDisCardAllSecurityReq) ProtoMessage()    {}
func (*LogoutDisCardAllSecurityReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{16}
}

func (m *LogoutDisCardAllSecurityReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *LogoutDisCardAllSecurityReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *LogoutDisCardAllSecurityReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *LogoutDisCardAllSecurityReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *LogoutDisCardAllSecurityReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *LogoutDisCardAllSecurityReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// LogOut后删除所有的加密聊天的返回
type LogoutDisCardAllSecurityResult struct {
	Errcode LogoutDisCardAllSecurityResult_ErrorCode `protobuf:"varint,1,opt,name=errcode,proto3,enum=imsecuritychatserver.LogoutDisCardAllSecurityResult_ErrorCode" json:"errcode,omitempty"`
}

func (m *LogoutDisCardAllSecurityResult) Reset()         { *m = LogoutDisCardAllSecurityResult{} }
func (m *LogoutDisCardAllSecurityResult) String() string { return proto.CompactTextString(m) }
func (*LogoutDisCardAllSecurityResult) ProtoMessage()    {}
func (*LogoutDisCardAllSecurityResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{17}
}

func (m *LogoutDisCardAllSecurityResult) GetErrcode() LogoutDisCardAllSecurityResult_ErrorCode {
	if m != nil {
		return m.Errcode
	}
	return LogoutDisCardAllSecurityResult_Success
}

// 加密聊天settyping状态
type SetEncryptedTypingReq struct {
	UserId     int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId      int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	ChatId     int32         `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
	ObjBin     []byte        `protobuf:"bytes,6,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId      uint32        `protobuf:"varint,7,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId  int64         `protobuf:"varint,8,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *SetEncryptedTypingReq) Reset()         { *m = SetEncryptedTypingReq{} }
func (m *SetEncryptedTypingReq) String() string { return proto.CompactTextString(m) }
func (*SetEncryptedTypingReq) ProtoMessage()    {}
func (*SetEncryptedTypingReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{18}
}

func (m *SetEncryptedTypingReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetEncryptedTypingReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SetEncryptedTypingReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *SetEncryptedTypingReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *SetEncryptedTypingReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SetEncryptedTypingReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *SetEncryptedTypingReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *SetEncryptedTypingReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 加密聊天settyping返回
type SetEncryptedTypingResult struct {
	ErrorCode SetEncryptedTypingResult_Errcode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=imsecuritychatserver.SetEncryptedTypingResult_Errcode" json:"error_code,omitempty"`
}

func (m *SetEncryptedTypingResult) Reset()         { *m = SetEncryptedTypingResult{} }
func (m *SetEncryptedTypingResult) String() string { return proto.CompactTextString(m) }
func (*SetEncryptedTypingResult) ProtoMessage()    {}
func (*SetEncryptedTypingResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{19}
}

func (m *SetEncryptedTypingResult) GetErrorCode() SetEncryptedTypingResult_Errcode {
	if m != nil {
		return m.ErrorCode
	}
	return SetEncryptedTypingResult_Success
}

// 加密聊天双钩的请求
type ReadEncryptedHistoryReq struct {
	UserId     int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId      int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	ChatId     int32         `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	MaxDate    int32         `protobuf:"varint,5,opt,name=max_date,json=maxDate,proto3" json:"max_date,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,6,opt,name=debug" json:"debug,omitempty"`
	ObjBin     []byte        `protobuf:"bytes,7,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId      uint32        `protobuf:"varint,8,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId  int64         `protobuf:"varint,9,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *ReadEncryptedHistoryReq) Reset()         { *m = ReadEncryptedHistoryReq{} }
func (m *ReadEncryptedHistoryReq) String() string { return proto.CompactTextString(m) }
func (*ReadEncryptedHistoryReq) ProtoMessage()    {}
func (*ReadEncryptedHistoryReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{20}
}

func (m *ReadEncryptedHistoryReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReadEncryptedHistoryReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *ReadEncryptedHistoryReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ReadEncryptedHistoryReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReadEncryptedHistoryReq) GetMaxDate() int32 {
	if m != nil {
		return m.MaxDate
	}
	return 0
}

func (m *ReadEncryptedHistoryReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *ReadEncryptedHistoryReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *ReadEncryptedHistoryReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *ReadEncryptedHistoryReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 加密聊天双钩的返回
type ReadEncryptedHistoryResult struct {
	ErrorCode ReadEncryptedHistoryResult_Errcode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=imsecuritychatserver.ReadEncryptedHistoryResult_Errcode" json:"error_code,omitempty"`
}

func (m *ReadEncryptedHistoryResult) Reset()         { *m = ReadEncryptedHistoryResult{} }
func (m *ReadEncryptedHistoryResult) String() string { return proto.CompactTextString(m) }
func (*ReadEncryptedHistoryResult) ProtoMessage()    {}
func (*ReadEncryptedHistoryResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{21}
}

func (m *ReadEncryptedHistoryResult) GetErrorCode() ReadEncryptedHistoryResult_Errcode {
	if m != nil {
		return m.ErrorCode
	}
	return ReadEncryptedHistoryResult_Success
}

// 加密聊天取消请求
type DiscardEncryptionReq struct {
	UserId    int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId     int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	ChatId    int32         `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
	ObjBin    []byte        `protobuf:"bytes,5,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId     uint32        `protobuf:"varint,6,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId int64         `protobuf:"varint,7,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *DiscardEncryptionReq) Reset()         { *m = DiscardEncryptionReq{} }
func (m *DiscardEncryptionReq) String() string { return proto.CompactTextString(m) }
func (*DiscardEncryptionReq) ProtoMessage()    {}
func (*DiscardEncryptionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{22}
}

func (m *DiscardEncryptionReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DiscardEncryptionReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *DiscardEncryptionReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *DiscardEncryptionReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *DiscardEncryptionReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *DiscardEncryptionReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *DiscardEncryptionReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 加密聊天取消返回
type DiscardEncryptionResult struct {
	ErrorCode DiscardEncryptionResult_Errcode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=imsecuritychatserver.DiscardEncryptionResult_Errcode" json:"error_code,omitempty"`
}

func (m *DiscardEncryptionResult) Reset()         { *m = DiscardEncryptionResult{} }
func (m *DiscardEncryptionResult) String() string { return proto.CompactTextString(m) }
func (*DiscardEncryptionResult) ProtoMessage()    {}
func (*DiscardEncryptionResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{23}
}

func (m *DiscardEncryptionResult) GetErrorCode() DiscardEncryptionResult_Errcode {
	if m != nil {
		return m.ErrorCode
	}
	return DiscardEncryptionResult_Success
}

// 发送加密聊天发送service请求
type SendEncryptedServiceReq struct {
	SendId     int32         `protobuf:"varint,1,opt,name=send_id,json=sendId,proto3" json:"send_id,omitempty"`
	KeyId      int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	ChatId     int32         `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	RandomId   int64         `protobuf:"varint,5,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	Data       []byte        `protobuf:"bytes,6,opt,name=Data,proto3" json:"Data,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,7,opt,name=debug" json:"debug,omitempty"`
	ObjBin     []byte        `protobuf:"bytes,8,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId      uint32        `protobuf:"varint,9,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId  int64         `protobuf:"varint,10,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *SendEncryptedServiceReq) Reset()         { *m = SendEncryptedServiceReq{} }
func (m *SendEncryptedServiceReq) String() string { return proto.CompactTextString(m) }
func (*SendEncryptedServiceReq) ProtoMessage()    {}
func (*SendEncryptedServiceReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{24}
}

func (m *SendEncryptedServiceReq) GetSendId() int32 {
	if m != nil {
		return m.SendId
	}
	return 0
}

func (m *SendEncryptedServiceReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SendEncryptedServiceReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *SendEncryptedServiceReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *SendEncryptedServiceReq) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *SendEncryptedServiceReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SendEncryptedServiceReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SendEncryptedServiceReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *SendEncryptedServiceReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *SendEncryptedServiceReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 发送加密聊天发送service的返回
type SendEncryptedServiceResult struct {
	ErrorCode SendEncryptedServiceResult_Errcode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=imsecuritychatserver.SendEncryptedServiceResult_Errcode" json:"error_code,omitempty"`
}

func (m *SendEncryptedServiceResult) Reset()         { *m = SendEncryptedServiceResult{} }
func (m *SendEncryptedServiceResult) String() string { return proto.CompactTextString(m) }
func (*SendEncryptedServiceResult) ProtoMessage()    {}
func (*SendEncryptedServiceResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{25}
}

func (m *SendEncryptedServiceResult) GetErrorCode() SendEncryptedServiceResult_Errcode {
	if m != nil {
		return m.ErrorCode
	}
	return SendEncryptedServiceResult_Success
}

// 发送加密聊天媒体消息
type SendEncryptedFileReq struct {
	SendId     int32         `protobuf:"varint,1,opt,name=send_id,json=sendId,proto3" json:"send_id,omitempty"`
	KeyId      int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	ChatId     int32         `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	RandomId   int64         `protobuf:"varint,5,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	Data       []byte        `protobuf:"bytes,6,opt,name=Data,proto3" json:"Data,omitempty"`
	File       []byte        `protobuf:"bytes,7,opt,name=file,proto3" json:"file,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
	ObjBin     []byte        `protobuf:"bytes,9,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId      uint32        `protobuf:"varint,10,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId  int64         `protobuf:"varint,11,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *SendEncryptedFileReq) Reset()         { *m = SendEncryptedFileReq{} }
func (m *SendEncryptedFileReq) String() string { return proto.CompactTextString(m) }
func (*SendEncryptedFileReq) ProtoMessage()    {}
func (*SendEncryptedFileReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{26}
}

func (m *SendEncryptedFileReq) GetSendId() int32 {
	if m != nil {
		return m.SendId
	}
	return 0
}

func (m *SendEncryptedFileReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SendEncryptedFileReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *SendEncryptedFileReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *SendEncryptedFileReq) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *SendEncryptedFileReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SendEncryptedFileReq) GetFile() []byte {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *SendEncryptedFileReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SendEncryptedFileReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *SendEncryptedFileReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *SendEncryptedFileReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 发送媒体消息的返回
type SendEncryptedFileResult struct {
	ErrorCode SendEncryptedFileResult_Errcode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=imsecuritychatserver.SendEncryptedFileResult_Errcode" json:"error_code,omitempty"`
}

func (m *SendEncryptedFileResult) Reset()         { *m = SendEncryptedFileResult{} }
func (m *SendEncryptedFileResult) String() string { return proto.CompactTextString(m) }
func (*SendEncryptedFileResult) ProtoMessage()    {}
func (*SendEncryptedFileResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{27}
}

func (m *SendEncryptedFileResult) GetErrorCode() SendEncryptedFileResult_Errcode {
	if m != nil {
		return m.ErrorCode
	}
	return SendEncryptedFileResult_Success
}

// 发送加密聊天发送普通文本消息的请求
type SendEncryptedReq struct {
	SendId     int32         `protobuf:"varint,1,opt,name=send_id,json=sendId,proto3" json:"send_id,omitempty"`
	KeyId      int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	ChatId     int32         `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	RandomId   int64         `protobuf:"varint,5,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	Data       []byte        `protobuf:"bytes,6,opt,name=Data,proto3" json:"Data,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,7,opt,name=debug" json:"debug,omitempty"`
	ObjBin     []byte        `protobuf:"bytes,8,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId      uint32        `protobuf:"varint,9,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId  int64         `protobuf:"varint,10,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *SendEncryptedReq) Reset()                    { *m = SendEncryptedReq{} }
func (m *SendEncryptedReq) String() string            { return proto.CompactTextString(m) }
func (*SendEncryptedReq) ProtoMessage()               {}
func (*SendEncryptedReq) Descriptor() ([]byte, []int) { return fileDescriptorImsecuritychat, []int{28} }

func (m *SendEncryptedReq) GetSendId() int32 {
	if m != nil {
		return m.SendId
	}
	return 0
}

func (m *SendEncryptedReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SendEncryptedReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *SendEncryptedReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *SendEncryptedReq) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *SendEncryptedReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SendEncryptedReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SendEncryptedReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *SendEncryptedReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *SendEncryptedReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 发送加密聊天发送普通文本消息的返回
type SendEncryptedResult struct {
	ErrorCode SendEncryptedResult_Errcode `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3,enum=imsecuritychatserver.SendEncryptedResult_Errcode" json:"error_code,omitempty"`
}

func (m *SendEncryptedResult) Reset()         { *m = SendEncryptedResult{} }
func (m *SendEncryptedResult) String() string { return proto.CompactTextString(m) }
func (*SendEncryptedResult) ProtoMessage()    {}
func (*SendEncryptedResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{29}
}

func (m *SendEncryptedResult) GetErrorCode() SendEncryptedResult_Errcode {
	if m != nil {
		return m.ErrorCode
	}
	return SendEncryptedResult_Success
}

// B端接收的请求
type AcceptEncryptionReq struct {
	ParticipartId    int32         `protobuf:"varint,1,opt,name=participart_id,json=participartId,proto3" json:"participart_id,omitempty"`
	ParticipartKeyId int64         `protobuf:"varint,2,opt,name=participart_key_id,json=participartKeyId,proto3" json:"participart_key_id,omitempty"`
	ChatId           int32         `protobuf:"varint,3,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash       int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	GB               []byte        `protobuf:"bytes,5,opt,name=G_b,json=GB,proto3" json:"G_b,omitempty"`
	KeyFingerprint   int64         `protobuf:"varint,6,opt,name=Key_fingerprint,json=KeyFingerprint,proto3" json:"Key_fingerprint,omitempty"`
	Debug            *pbcomm.Debug `protobuf:"bytes,7,opt,name=debug" json:"debug,omitempty"`
	ObjBin           []byte        `protobuf:"bytes,8,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId            uint32        `protobuf:"varint,9,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId        int64         `protobuf:"varint,10,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *AcceptEncryptionReq) Reset()         { *m = AcceptEncryptionReq{} }
func (m *AcceptEncryptionReq) String() string { return proto.CompactTextString(m) }
func (*AcceptEncryptionReq) ProtoMessage()    {}
func (*AcceptEncryptionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{30}
}

func (m *AcceptEncryptionReq) GetParticipartId() int32 {
	if m != nil {
		return m.ParticipartId
	}
	return 0
}

func (m *AcceptEncryptionReq) GetParticipartKeyId() int64 {
	if m != nil {
		return m.ParticipartKeyId
	}
	return 0
}

func (m *AcceptEncryptionReq) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *AcceptEncryptionReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *AcceptEncryptionReq) GetGB() []byte {
	if m != nil {
		return m.GB
	}
	return nil
}

func (m *AcceptEncryptionReq) GetKeyFingerprint() int64 {
	if m != nil {
		return m.KeyFingerprint
	}
	return 0
}

func (m *AcceptEncryptionReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *AcceptEncryptionReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *AcceptEncryptionReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *AcceptEncryptionReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// B端接收的请求的返回
type AcceptEncryptionResult struct {
	AdminId         int32                          `protobuf:"varint,1,opt,name=admin_id,json=adminId,proto3" json:"admin_id,omitempty"`
	GAOrB           []byte                         `protobuf:"bytes,2,opt,name=G_a_or_b,json=GAOrB,proto3" json:"G_a_or_b,omitempty"`
	KeyFingerPrint2 int64                          `protobuf:"varint,3,opt,name=keyFingerPrint2,proto3" json:"keyFingerPrint2,omitempty"`
	ChatId          int32                          `protobuf:"varint,4,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash      int64                          `protobuf:"varint,5,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	ErrorCode       AcceptEncryptionResult_Errcode `protobuf:"varint,6,opt,name=error_code,json=errorCode,proto3,enum=imsecuritychatserver.AcceptEncryptionResult_Errcode" json:"error_code,omitempty"`
}

func (m *AcceptEncryptionResult) Reset()         { *m = AcceptEncryptionResult{} }
func (m *AcceptEncryptionResult) String() string { return proto.CompactTextString(m) }
func (*AcceptEncryptionResult) ProtoMessage()    {}
func (*AcceptEncryptionResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{31}
}

func (m *AcceptEncryptionResult) GetAdminId() int32 {
	if m != nil {
		return m.AdminId
	}
	return 0
}

func (m *AcceptEncryptionResult) GetGAOrB() []byte {
	if m != nil {
		return m.GAOrB
	}
	return nil
}

func (m *AcceptEncryptionResult) GetKeyFingerPrint2() int64 {
	if m != nil {
		return m.KeyFingerPrint2
	}
	return 0
}

func (m *AcceptEncryptionResult) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *AcceptEncryptionResult) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *AcceptEncryptionResult) GetErrorCode() AcceptEncryptionResult_Errcode {
	if m != nil {
		return m.ErrorCode
	}
	return AcceptEncryptionResult_Success
}

// 发起加密聊天请求
type RequestEncryptionReq struct {
	AdminId       int32         `protobuf:"varint,1,opt,name=admin_id,json=adminId,proto3" json:"admin_id,omitempty"`
	AdminKeyId    int64         `protobuf:"varint,2,opt,name=admin_key_id,json=adminKeyId,proto3" json:"admin_key_id,omitempty"`
	ParticipantId int32         `protobuf:"varint,3,opt,name=participant_id,json=participantId,proto3" json:"participant_id,omitempty"`
	AccessHash    int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	GA            []byte        `protobuf:"bytes,5,opt,name=g_a,json=gA,proto3" json:"g_a,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,6,opt,name=debug" json:"debug,omitempty"`
	ObjBin        []byte        `protobuf:"bytes,7,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	CrcId         uint32        `protobuf:"varint,8,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	MessageId     int64         `protobuf:"varint,9,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *RequestEncryptionReq) Reset()         { *m = RequestEncryptionReq{} }
func (m *RequestEncryptionReq) String() string { return proto.CompactTextString(m) }
func (*RequestEncryptionReq) ProtoMessage()    {}
func (*RequestEncryptionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{32}
}

func (m *RequestEncryptionReq) GetAdminId() int32 {
	if m != nil {
		return m.AdminId
	}
	return 0
}

func (m *RequestEncryptionReq) GetAdminKeyId() int64 {
	if m != nil {
		return m.AdminKeyId
	}
	return 0
}

func (m *RequestEncryptionReq) GetParticipantId() int32 {
	if m != nil {
		return m.ParticipantId
	}
	return 0
}

func (m *RequestEncryptionReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *RequestEncryptionReq) GetGA() []byte {
	if m != nil {
		return m.GA
	}
	return nil
}

func (m *RequestEncryptionReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *RequestEncryptionReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *RequestEncryptionReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *RequestEncryptionReq) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

// 发起加密聊天的返回结果
type RequestEncryptionResult struct {
	ChatId     int32                            `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	AccessHash int64                            `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	ErrorCode  RequestEncryptionResult_ErroCode `protobuf:"varint,3,opt,name=errorCode,proto3,enum=imsecuritychatserver.RequestEncryptionResult_ErroCode" json:"errorCode,omitempty"`
}

func (m *RequestEncryptionResult) Reset()         { *m = RequestEncryptionResult{} }
func (m *RequestEncryptionResult) String() string { return proto.CompactTextString(m) }
func (*RequestEncryptionResult) ProtoMessage()    {}
func (*RequestEncryptionResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImsecuritychat, []int{33}
}

func (m *RequestEncryptionResult) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *RequestEncryptionResult) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *RequestEncryptionResult) GetErrorCode() RequestEncryptionResult_ErroCode {
	if m != nil {
		return m.ErrorCode
	}
	return RequestEncryptionResult_SusscessFull
}

func init() {
	proto.RegisterType((*GetChatInfoByChatIdResult)(nil), "imsecuritychatserver.GetChatInfoByChatIdResult")
	proto.RegisterType((*ChatInfo)(nil), "imsecuritychatserver.ChatInfo")
	proto.RegisterType((*GetChatInfoByChatIdReq)(nil), "imsecuritychatserver.GetChatInfoByChatIdReq")
	proto.RegisterType((*GetAllChatIdByUserIdKeyIdResult)(nil), "imsecuritychatserver.GetAllChatIdByUserIdKeyIdResult")
	proto.RegisterType((*GetAllChatIdByUserIdKeyIdReq)(nil), "imsecuritychatserver.GetAllChatIdByUserIdKeyIdReq")
	proto.RegisterType((*GetHandshakeUpdatesResult)(nil), "imsecuritychatserver.GetHandshakeUpdatesResult")
	proto.RegisterType((*GetHandshakeUpdatesReq)(nil), "imsecuritychatserver.GetHandshakeUpdatesReq")
	proto.RegisterType((*SecurityResult)(nil), "imsecuritychatserver.SecurityResult")
	proto.RegisterType((*GetSecurityDiffByQtsReq)(nil), "imsecuritychatserver.GetSecurityDiffByQtsReq")
	proto.RegisterType((*GetSecurityDiffByQtsResult)(nil), "imsecuritychatserver.GetSecurityDiffByQtsResult")
	proto.RegisterType((*CheckSecurityChatExistReq)(nil), "imsecuritychatserver.CheckSecurityChatExistReq")
	proto.RegisterType((*CheckSecurityChatExistResult)(nil), "imsecuritychatserver.CheckSecurityChatExistResult")
	proto.RegisterType((*CheckEncryChatAcceptReq)(nil), "imsecuritychatserver.CheckEncryChatAcceptReq")
	proto.RegisterType((*CheckEncryChatAcceptResult)(nil), "imsecuritychatserver.CheckEncryChatAcceptResult")
	proto.RegisterType((*GetSecurityRandomIdsReq)(nil), "imsecuritychatserver.GetSecurityRandomIdsReq")
	proto.RegisterType((*GetSecurityRandomIdsResult)(nil), "imsecuritychatserver.GetSecurityRandomIdsResult")
	proto.RegisterType((*LogoutDisCardAllSecurityReq)(nil), "imsecuritychatserver.LogoutDisCardAllSecurityReq")
	proto.RegisterType((*LogoutDisCardAllSecurityResult)(nil), "imsecuritychatserver.LogoutDisCardAllSecurityResult")
	proto.RegisterType((*SetEncryptedTypingReq)(nil), "imsecuritychatserver.SetEncryptedTypingReq")
	proto.RegisterType((*SetEncryptedTypingResult)(nil), "imsecuritychatserver.SetEncryptedTypingResult")
	proto.RegisterType((*ReadEncryptedHistoryReq)(nil), "imsecuritychatserver.ReadEncryptedHistoryReq")
	proto.RegisterType((*ReadEncryptedHistoryResult)(nil), "imsecuritychatserver.ReadEncryptedHistoryResult")
	proto.RegisterType((*DiscardEncryptionReq)(nil), "imsecuritychatserver.DiscardEncryptionReq")
	proto.RegisterType((*DiscardEncryptionResult)(nil), "imsecuritychatserver.DiscardEncryptionResult")
	proto.RegisterType((*SendEncryptedServiceReq)(nil), "imsecuritychatserver.SendEncryptedServiceReq")
	proto.RegisterType((*SendEncryptedServiceResult)(nil), "imsecuritychatserver.SendEncryptedServiceResult")
	proto.RegisterType((*SendEncryptedFileReq)(nil), "imsecuritychatserver.SendEncryptedFileReq")
	proto.RegisterType((*SendEncryptedFileResult)(nil), "imsecuritychatserver.SendEncryptedFileResult")
	proto.RegisterType((*SendEncryptedReq)(nil), "imsecuritychatserver.SendEncryptedReq")
	proto.RegisterType((*SendEncryptedResult)(nil), "imsecuritychatserver.SendEncryptedResult")
	proto.RegisterType((*AcceptEncryptionReq)(nil), "imsecuritychatserver.AcceptEncryptionReq")
	proto.RegisterType((*AcceptEncryptionResult)(nil), "imsecuritychatserver.AcceptEncryptionResult")
	proto.RegisterType((*RequestEncryptionReq)(nil), "imsecuritychatserver.RequestEncryptionReq")
	proto.RegisterType((*RequestEncryptionResult)(nil), "imsecuritychatserver.RequestEncryptionResult")
	proto.RegisterEnum("imsecuritychatserver.GetChatInfoByChatIdResult_ResultCode", GetChatInfoByChatIdResult_ResultCode_name, GetChatInfoByChatIdResult_ResultCode_value)
	proto.RegisterEnum("imsecuritychatserver.GetAllChatIdByUserIdKeyIdResult_ErrorCode", GetAllChatIdByUserIdKeyIdResult_ErrorCode_name, GetAllChatIdByUserIdKeyIdResult_ErrorCode_value)
	proto.RegisterEnum("imsecuritychatserver.GetHandshakeUpdatesResult_ErrorCode", GetHandshakeUpdatesResult_ErrorCode_name, GetHandshakeUpdatesResult_ErrorCode_value)
	proto.RegisterEnum("imsecuritychatserver.GetSecurityDiffByQtsResult_ErrorCode", GetSecurityDiffByQtsResult_ErrorCode_name, GetSecurityDiffByQtsResult_ErrorCode_value)
	proto.RegisterEnum("imsecuritychatserver.GetSecurityRandomIdsResult_ErrorCode", GetSecurityRandomIdsResult_ErrorCode_name, GetSecurityRandomIdsResult_ErrorCode_value)
	proto.RegisterEnum("imsecuritychatserver.LogoutDisCardAllSecurityResult_ErrorCode", LogoutDisCardAllSecurityResult_ErrorCode_name, LogoutDisCardAllSecurityResult_ErrorCode_value)
	proto.RegisterEnum("imsecuritychatserver.SetEncryptedTypingResult_Errcode", SetEncryptedTypingResult_Errcode_name, SetEncryptedTypingResult_Errcode_value)
	proto.RegisterEnum("imsecuritychatserver.ReadEncryptedHistoryResult_Errcode", ReadEncryptedHistoryResult_Errcode_name, ReadEncryptedHistoryResult_Errcode_value)
	proto.RegisterEnum("imsecuritychatserver.DiscardEncryptionResult_Errcode", DiscardEncryptionResult_Errcode_name, DiscardEncryptionResult_Errcode_value)
	proto.RegisterEnum("imsecuritychatserver.SendEncryptedServiceResult_Errcode", SendEncryptedServiceResult_Errcode_name, SendEncryptedServiceResult_Errcode_value)
	proto.RegisterEnum("imsecuritychatserver.SendEncryptedFileResult_Errcode", SendEncryptedFileResult_Errcode_name, SendEncryptedFileResult_Errcode_value)
	proto.RegisterEnum("imsecuritychatserver.SendEncryptedResult_Errcode", SendEncryptedResult_Errcode_name, SendEncryptedResult_Errcode_value)
	proto.RegisterEnum("imsecuritychatserver.AcceptEncryptionResult_Errcode", AcceptEncryptionResult_Errcode_name, AcceptEncryptionResult_Errcode_value)
	proto.RegisterEnum("imsecuritychatserver.RequestEncryptionResult_ErroCode", RequestEncryptionResult_ErroCode_name, RequestEncryptionResult_ErroCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ImSecurityChatServer service

type ImSecurityChatServerClient interface {
	// 发送加密聊天请求
	RequestEncryption(ctx context.Context, in *RequestEncryptionReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// 接收加密聊天
	AcceptEncryption(ctx context.Context, in *AcceptEncryptionReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// 发送加密聊天普通消息
	SendEncrypted(ctx context.Context, in *SendEncryptedReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// 发送加密聊天媒体消息
	SendEncryptedFile(ctx context.Context, in *SendEncryptedFileReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// 发送加密聊天action消息
	SendEncryptedService(ctx context.Context, in *SendEncryptedServiceReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// 发送加密聊天取消
	DiscardEncryption(ctx context.Context, in *DiscardEncryptionReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// 加密聊天双钩
	ReadEncryptedHistory(ctx context.Context, in *ReadEncryptedHistoryReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// 加密聊天settyping
	SetEncryptedTyping(ctx context.Context, in *SetEncryptedTypingReq, opts ...grpc.CallOption) (*SecurityResult, error)
	// LogOut后删除所有的加密聊天
	LogoutDisCardAllSecurity(ctx context.Context, in *LogoutDisCardAllSecurityReq, opts ...grpc.CallOption) (*LogoutDisCardAllSecurityResult, error)
	// 获取加密聊天的randomId 们
	GetSecurityRandomIds(ctx context.Context, in *GetSecurityRandomIdsReq, opts ...grpc.CallOption) (*GetSecurityRandomIdsResult, error)
	// 检测加密聊天是否已经被接收
	CheckEncryChatAccept(ctx context.Context, in *CheckEncryChatAcceptReq, opts ...grpc.CallOption) (*CheckEncryChatAcceptResult, error)
	// 根据chatId判断加密聊天是否存在
	CheckSecurityChatExist(ctx context.Context, in *CheckSecurityChatExistReq, opts ...grpc.CallOption) (*CheckSecurityChatExistResult, error)
	// 根据qts查询diff
	GetSecurityDiffByQts(ctx context.Context, in *GetSecurityDiffByQtsReq, opts ...grpc.CallOption) (*GetSecurityDiffByQtsResult, error)
	// 加密聊天请求updates
	GetHandshakeUpdates(ctx context.Context, in *GetHandshakeUpdatesReq, opts ...grpc.CallOption) (*GetHandshakeUpdatesResult, error)
	// 根据userid和keyid获取所有的chatId
	GetAllChatIdByUserIdKeyId(ctx context.Context, in *GetAllChatIdByUserIdKeyIdReq, opts ...grpc.CallOption) (*GetAllChatIdByUserIdKeyIdResult, error)
	// 根据chatId获取chat的详细信息
	GetChatInfoByChatId(ctx context.Context, in *GetChatInfoByChatIdReq, opts ...grpc.CallOption) (*GetChatInfoByChatIdResult, error)
}

type imSecurityChatServerClient struct {
	cc *grpc.ClientConn
}

func NewImSecurityChatServerClient(cc *grpc.ClientConn) ImSecurityChatServerClient {
	return &imSecurityChatServerClient{cc}
}

func (c *imSecurityChatServerClient) RequestEncryption(ctx context.Context, in *RequestEncryptionReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/RequestEncryption", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) AcceptEncryption(ctx context.Context, in *AcceptEncryptionReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/AcceptEncryption", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) SendEncrypted(ctx context.Context, in *SendEncryptedReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/SendEncrypted", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) SendEncryptedFile(ctx context.Context, in *SendEncryptedFileReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/SendEncryptedFile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) SendEncryptedService(ctx context.Context, in *SendEncryptedServiceReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/SendEncryptedService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) DiscardEncryption(ctx context.Context, in *DiscardEncryptionReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/DiscardEncryption", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) ReadEncryptedHistory(ctx context.Context, in *ReadEncryptedHistoryReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/ReadEncryptedHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) SetEncryptedTyping(ctx context.Context, in *SetEncryptedTypingReq, opts ...grpc.CallOption) (*SecurityResult, error) {
	out := new(SecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/SetEncryptedTyping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) LogoutDisCardAllSecurity(ctx context.Context, in *LogoutDisCardAllSecurityReq, opts ...grpc.CallOption) (*LogoutDisCardAllSecurityResult, error) {
	out := new(LogoutDisCardAllSecurityResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/LogoutDisCardAllSecurity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) GetSecurityRandomIds(ctx context.Context, in *GetSecurityRandomIdsReq, opts ...grpc.CallOption) (*GetSecurityRandomIdsResult, error) {
	out := new(GetSecurityRandomIdsResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/GetSecurityRandomIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) CheckEncryChatAccept(ctx context.Context, in *CheckEncryChatAcceptReq, opts ...grpc.CallOption) (*CheckEncryChatAcceptResult, error) {
	out := new(CheckEncryChatAcceptResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/CheckEncryChatAccept", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) CheckSecurityChatExist(ctx context.Context, in *CheckSecurityChatExistReq, opts ...grpc.CallOption) (*CheckSecurityChatExistResult, error) {
	out := new(CheckSecurityChatExistResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/CheckSecurityChatExist", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) GetSecurityDiffByQts(ctx context.Context, in *GetSecurityDiffByQtsReq, opts ...grpc.CallOption) (*GetSecurityDiffByQtsResult, error) {
	out := new(GetSecurityDiffByQtsResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/GetSecurityDiffByQts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) GetHandshakeUpdates(ctx context.Context, in *GetHandshakeUpdatesReq, opts ...grpc.CallOption) (*GetHandshakeUpdatesResult, error) {
	out := new(GetHandshakeUpdatesResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/GetHandshakeUpdates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) GetAllChatIdByUserIdKeyId(ctx context.Context, in *GetAllChatIdByUserIdKeyIdReq, opts ...grpc.CallOption) (*GetAllChatIdByUserIdKeyIdResult, error) {
	out := new(GetAllChatIdByUserIdKeyIdResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/GetAllChatIdByUserIdKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imSecurityChatServerClient) GetChatInfoByChatId(ctx context.Context, in *GetChatInfoByChatIdReq, opts ...grpc.CallOption) (*GetChatInfoByChatIdResult, error) {
	out := new(GetChatInfoByChatIdResult)
	err := grpc.Invoke(ctx, "/imsecuritychatserver.ImSecurityChatServer/GetChatInfoByChatId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ImSecurityChatServer service

type ImSecurityChatServerServer interface {
	// 发送加密聊天请求
	RequestEncryption(context.Context, *RequestEncryptionReq) (*SecurityResult, error)
	// 接收加密聊天
	AcceptEncryption(context.Context, *AcceptEncryptionReq) (*SecurityResult, error)
	// 发送加密聊天普通消息
	SendEncrypted(context.Context, *SendEncryptedReq) (*SecurityResult, error)
	// 发送加密聊天媒体消息
	SendEncryptedFile(context.Context, *SendEncryptedFileReq) (*SecurityResult, error)
	// 发送加密聊天action消息
	SendEncryptedService(context.Context, *SendEncryptedServiceReq) (*SecurityResult, error)
	// 发送加密聊天取消
	DiscardEncryption(context.Context, *DiscardEncryptionReq) (*SecurityResult, error)
	// 加密聊天双钩
	ReadEncryptedHistory(context.Context, *ReadEncryptedHistoryReq) (*SecurityResult, error)
	// 加密聊天settyping
	SetEncryptedTyping(context.Context, *SetEncryptedTypingReq) (*SecurityResult, error)
	// LogOut后删除所有的加密聊天
	LogoutDisCardAllSecurity(context.Context, *LogoutDisCardAllSecurityReq) (*LogoutDisCardAllSecurityResult, error)
	// 获取加密聊天的randomId 们
	GetSecurityRandomIds(context.Context, *GetSecurityRandomIdsReq) (*GetSecurityRandomIdsResult, error)
	// 检测加密聊天是否已经被接收
	CheckEncryChatAccept(context.Context, *CheckEncryChatAcceptReq) (*CheckEncryChatAcceptResult, error)
	// 根据chatId判断加密聊天是否存在
	CheckSecurityChatExist(context.Context, *CheckSecurityChatExistReq) (*CheckSecurityChatExistResult, error)
	// 根据qts查询diff
	GetSecurityDiffByQts(context.Context, *GetSecurityDiffByQtsReq) (*GetSecurityDiffByQtsResult, error)
	// 加密聊天请求updates
	GetHandshakeUpdates(context.Context, *GetHandshakeUpdatesReq) (*GetHandshakeUpdatesResult, error)
	// 根据userid和keyid获取所有的chatId
	GetAllChatIdByUserIdKeyId(context.Context, *GetAllChatIdByUserIdKeyIdReq) (*GetAllChatIdByUserIdKeyIdResult, error)
	// 根据chatId获取chat的详细信息
	GetChatInfoByChatId(context.Context, *GetChatInfoByChatIdReq) (*GetChatInfoByChatIdResult, error)
}

func RegisterImSecurityChatServerServer(s *grpc.Server, srv ImSecurityChatServerServer) {
	s.RegisterService(&_ImSecurityChatServer_serviceDesc, srv)
}

func _ImSecurityChatServer_RequestEncryption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEncryptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).RequestEncryption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/RequestEncryption",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).RequestEncryption(ctx, req.(*RequestEncryptionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_AcceptEncryption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptEncryptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).AcceptEncryption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/AcceptEncryption",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).AcceptEncryption(ctx, req.(*AcceptEncryptionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_SendEncrypted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendEncryptedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).SendEncrypted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/SendEncrypted",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).SendEncrypted(ctx, req.(*SendEncryptedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_SendEncryptedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendEncryptedFileReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).SendEncryptedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/SendEncryptedFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).SendEncryptedFile(ctx, req.(*SendEncryptedFileReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_SendEncryptedService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendEncryptedServiceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).SendEncryptedService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/SendEncryptedService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).SendEncryptedService(ctx, req.(*SendEncryptedServiceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_DiscardEncryption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiscardEncryptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).DiscardEncryption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/DiscardEncryption",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).DiscardEncryption(ctx, req.(*DiscardEncryptionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_ReadEncryptedHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadEncryptedHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).ReadEncryptedHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/ReadEncryptedHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).ReadEncryptedHistory(ctx, req.(*ReadEncryptedHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_SetEncryptedTyping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEncryptedTypingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).SetEncryptedTyping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/SetEncryptedTyping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).SetEncryptedTyping(ctx, req.(*SetEncryptedTypingReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_LogoutDisCardAllSecurity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutDisCardAllSecurityReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).LogoutDisCardAllSecurity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/LogoutDisCardAllSecurity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).LogoutDisCardAllSecurity(ctx, req.(*LogoutDisCardAllSecurityReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_GetSecurityRandomIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSecurityRandomIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).GetSecurityRandomIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/GetSecurityRandomIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).GetSecurityRandomIds(ctx, req.(*GetSecurityRandomIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_CheckEncryChatAccept_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckEncryChatAcceptReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).CheckEncryChatAccept(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/CheckEncryChatAccept",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).CheckEncryChatAccept(ctx, req.(*CheckEncryChatAcceptReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_CheckSecurityChatExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckSecurityChatExistReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).CheckSecurityChatExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/CheckSecurityChatExist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).CheckSecurityChatExist(ctx, req.(*CheckSecurityChatExistReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_GetSecurityDiffByQts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSecurityDiffByQtsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).GetSecurityDiffByQts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/GetSecurityDiffByQts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).GetSecurityDiffByQts(ctx, req.(*GetSecurityDiffByQtsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_GetHandshakeUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHandshakeUpdatesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).GetHandshakeUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/GetHandshakeUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).GetHandshakeUpdates(ctx, req.(*GetHandshakeUpdatesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_GetAllChatIdByUserIdKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllChatIdByUserIdKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).GetAllChatIdByUserIdKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/GetAllChatIdByUserIdKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).GetAllChatIdByUserIdKeyId(ctx, req.(*GetAllChatIdByUserIdKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImSecurityChatServer_GetChatInfoByChatId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChatInfoByChatIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImSecurityChatServerServer).GetChatInfoByChatId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imsecuritychatserver.ImSecurityChatServer/GetChatInfoByChatId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImSecurityChatServerServer).GetChatInfoByChatId(ctx, req.(*GetChatInfoByChatIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImSecurityChatServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imsecuritychatserver.ImSecurityChatServer",
	HandlerType: (*ImSecurityChatServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RequestEncryption",
			Handler:    _ImSecurityChatServer_RequestEncryption_Handler,
		},
		{
			MethodName: "AcceptEncryption",
			Handler:    _ImSecurityChatServer_AcceptEncryption_Handler,
		},
		{
			MethodName: "SendEncrypted",
			Handler:    _ImSecurityChatServer_SendEncrypted_Handler,
		},
		{
			MethodName: "SendEncryptedFile",
			Handler:    _ImSecurityChatServer_SendEncryptedFile_Handler,
		},
		{
			MethodName: "SendEncryptedService",
			Handler:    _ImSecurityChatServer_SendEncryptedService_Handler,
		},
		{
			MethodName: "DiscardEncryption",
			Handler:    _ImSecurityChatServer_DiscardEncryption_Handler,
		},
		{
			MethodName: "ReadEncryptedHistory",
			Handler:    _ImSecurityChatServer_ReadEncryptedHistory_Handler,
		},
		{
			MethodName: "SetEncryptedTyping",
			Handler:    _ImSecurityChatServer_SetEncryptedTyping_Handler,
		},
		{
			MethodName: "LogoutDisCardAllSecurity",
			Handler:    _ImSecurityChatServer_LogoutDisCardAllSecurity_Handler,
		},
		{
			MethodName: "GetSecurityRandomIds",
			Handler:    _ImSecurityChatServer_GetSecurityRandomIds_Handler,
		},
		{
			MethodName: "CheckEncryChatAccept",
			Handler:    _ImSecurityChatServer_CheckEncryChatAccept_Handler,
		},
		{
			MethodName: "CheckSecurityChatExist",
			Handler:    _ImSecurityChatServer_CheckSecurityChatExist_Handler,
		},
		{
			MethodName: "GetSecurityDiffByQts",
			Handler:    _ImSecurityChatServer_GetSecurityDiffByQts_Handler,
		},
		{
			MethodName: "GetHandshakeUpdates",
			Handler:    _ImSecurityChatServer_GetHandshakeUpdates_Handler,
		},
		{
			MethodName: "GetAllChatIdByUserIdKeyId",
			Handler:    _ImSecurityChatServer_GetAllChatIdByUserIdKeyId_Handler,
		},
		{
			MethodName: "GetChatInfoByChatId",
			Handler:    _ImSecurityChatServer_GetChatInfoByChatId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imsecuritychatserver/imsecuritychat.proto",
}

func (m *GetChatInfoByChatIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChatInfoByChatIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Code))
	}
	if m.ChatInfo != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatInfo.Size()))
		n1, err := m.ChatInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ChatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.ChatCreator != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatCreator))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.ChatMember != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatMember))
	}
	if m.CreatorKeyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CreatorKeyId))
	}
	if m.MemberKeyId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MemberKeyId))
	}
	if m.Date != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Date))
	}
	if m.AlreadAccept {
		dAtA[i] = 0x40
		i++
		if m.AlreadAccept {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsNormal {
		dAtA[i] = 0x48
		i++
		if m.IsNormal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetChatInfoByChatIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChatInfoByChatIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	return i, nil
}

func (m *GetAllChatIdByUserIdKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAllChatIdByUserIdKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ChatId) > 0 {
		dAtA3 := make([]byte, len(m.ChatId)*10)
		var j2 int
		for _, num1 := range m.ChatId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *GetAllChatIdByUserIdKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAllChatIdByUserIdKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *GetHandshakeUpdatesResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHandshakeUpdatesResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Update) > 0 {
		for _, b := range m.Update {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImsecuritychat(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *GetHandshakeUpdatesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHandshakeUpdatesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Date))
	}
	return i, nil
}

func (m *SecurityResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecurityResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *GetSecurityDiffByQtsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSecurityDiffByQtsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.FromId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.Qts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Qts))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n4, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *GetSecurityDiffByQtsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSecurityDiffByQtsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.Update) > 0 {
		for _, b := range m.Update {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImsecuritychat(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	return i, nil
}

func (m *CheckSecurityChatExistReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckSecurityChatExistReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	return i, nil
}

func (m *CheckSecurityChatExistResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckSecurityChatExistResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CheckEncryChatAcceptReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckEncryChatAcceptReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	return i, nil
}

func (m *CheckEncryChatAcceptResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckEncryChatAcceptResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetSecurityRandomIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSecurityRandomIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.MaxQts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MaxQts))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n5, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *GetSecurityRandomIdsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSecurityRandomIdsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Errcode))
	}
	if len(m.RandomIds) > 0 {
		dAtA7 := make([]byte, len(m.RandomIds)*10)
		var j6 int
		for _, num1 := range m.RandomIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func (m *LogoutDisCardAllSecurityReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutDisCardAllSecurityReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n8, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *LogoutDisCardAllSecurityResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutDisCardAllSecurityResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Errcode))
	}
	return i, nil
}

func (m *SetEncryptedTypingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetEncryptedTypingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n9, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *SetEncryptedTypingResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetEncryptedTypingResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReadEncryptedHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadEncryptedHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.MaxDate != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MaxDate))
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n10, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *ReadEncryptedHistoryResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadEncryptedHistoryResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *DiscardEncryptionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscardEncryptionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n11, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *DiscardEncryptionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiscardEncryptionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *SendEncryptedServiceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEncryptedServiceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.SendId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.RandomId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.RandomId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Debug != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n12, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *SendEncryptedServiceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEncryptedServiceResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *SendEncryptedFileReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEncryptedFileReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.SendId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.RandomId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.RandomId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.File) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.File)))
		i += copy(dAtA[i:], m.File)
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n13, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *SendEncryptedFileResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEncryptedFileResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *SendEncryptedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEncryptedReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.SendId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.RandomId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.RandomId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Debug != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n14, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *SendEncryptedResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEncryptedResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *AcceptEncryptionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptEncryptionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ParticipartId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ParticipartId))
	}
	if m.ParticipartKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ParticipartKeyId))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if len(m.GB) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.GB)))
		i += copy(dAtA[i:], m.GB)
	}
	if m.KeyFingerprint != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyFingerprint))
	}
	if m.Debug != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n15, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *AcceptEncryptionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptEncryptionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AdminId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AdminId))
	}
	if len(m.GAOrB) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.GAOrB)))
		i += copy(dAtA[i:], m.GAOrB)
	}
	if m.KeyFingerPrint2 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.KeyFingerPrint2))
	}
	if m.ChatId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *RequestEncryptionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEncryptionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AdminId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AdminId))
	}
	if m.AdminKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AdminKeyId))
	}
	if m.ParticipantId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ParticipantId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if len(m.GA) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.GA)))
		i += copy(dAtA[i:], m.GA)
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.Debug.Size()))
		n16, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *RequestEncryptionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEncryptionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChatId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.AccessHash))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImsecuritychat(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func encodeVarintImsecuritychat(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetChatInfoByChatIdResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImsecuritychat(uint64(m.Code))
	}
	if m.ChatInfo != nil {
		l = m.ChatInfo.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	return n
}

func (m *ChatInfo) Size() (n int) {
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.ChatCreator != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatCreator))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.ChatMember != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatMember))
	}
	if m.CreatorKeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CreatorKeyId))
	}
	if m.MemberKeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MemberKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovImsecuritychat(uint64(m.Date))
	}
	if m.AlreadAccept {
		n += 2
	}
	if m.IsNormal {
		n += 2
	}
	return n
}

func (m *GetChatInfoByChatIdReq) Size() (n int) {
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	return n
}

func (m *GetAllChatIdByUserIdKeyIdResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrCode))
	}
	if len(m.ChatId) > 0 {
		l = 0
		for _, e := range m.ChatId {
			l += sovImsecuritychat(uint64(e))
		}
		n += 1 + sovImsecuritychat(uint64(l)) + l
	}
	return n
}

func (m *GetAllChatIdByUserIdKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	return n
}

func (m *GetHandshakeUpdatesResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrCode))
	}
	if len(m.Update) > 0 {
		for _, b := range m.Update {
			l = len(b)
			n += 1 + l + sovImsecuritychat(uint64(l))
		}
	}
	return n
}

func (m *GetHandshakeUpdatesReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AuthKeyId))
	}
	if m.Date != 0 {
		n += 1 + sovImsecuritychat(uint64(m.Date))
	}
	return n
}

func (m *SecurityResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *GetSecurityDiffByQtsReq) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.FromId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.Qts != 0 {
		n += 1 + sovImsecuritychat(uint64(m.Qts))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	return n
}

func (m *GetSecurityDiffByQtsResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrCode))
	}
	if len(m.Update) > 0 {
		for _, b := range m.Update {
			l = len(b)
			n += 1 + l + sovImsecuritychat(uint64(l))
		}
	}
	return n
}

func (m *CheckSecurityChatExistReq) Size() (n int) {
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	return n
}

func (m *CheckSecurityChatExistResult) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *CheckEncryChatAcceptReq) Size() (n int) {
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	return n
}

func (m *CheckEncryChatAcceptResult) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	return n
}

func (m *GetSecurityRandomIdsReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.MaxQts != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MaxQts))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *GetSecurityRandomIdsResult) Size() (n int) {
	var l int
	_ = l
	if m.Errcode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.Errcode))
	}
	if len(m.RandomIds) > 0 {
		l = 0
		for _, e := range m.RandomIds {
			l += sovImsecuritychat(uint64(e))
		}
		n += 1 + sovImsecuritychat(uint64(l)) + l
	}
	return n
}

func (m *LogoutDisCardAllSecurityReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *LogoutDisCardAllSecurityResult) Size() (n int) {
	var l int
	_ = l
	if m.Errcode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.Errcode))
	}
	return n
}

func (m *SetEncryptedTypingReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *SetEncryptedTypingResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReadEncryptedHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.MaxDate != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MaxDate))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *ReadEncryptedHistoryResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *DiscardEncryptionReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *DiscardEncryptionResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *SendEncryptedServiceReq) Size() (n int) {
	var l int
	_ = l
	if m.SendId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.SendId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.RandomId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.RandomId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *SendEncryptedServiceResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *SendEncryptedFileReq) Size() (n int) {
	var l int
	_ = l
	if m.SendId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.SendId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.RandomId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.RandomId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *SendEncryptedFileResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *SendEncryptedReq) Size() (n int) {
	var l int
	_ = l
	if m.SendId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.SendId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.RandomId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.RandomId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *SendEncryptedResult) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *AcceptEncryptionReq) Size() (n int) {
	var l int
	_ = l
	if m.ParticipartId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ParticipartId))
	}
	if m.ParticipartKeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ParticipartKeyId))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	l = len(m.GB)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.KeyFingerprint != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyFingerprint))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *AcceptEncryptionResult) Size() (n int) {
	var l int
	_ = l
	if m.AdminId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AdminId))
	}
	l = len(m.GAOrB)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.KeyFingerPrint2 != 0 {
		n += 1 + sovImsecuritychat(uint64(m.KeyFingerPrint2))
	}
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func (m *RequestEncryptionReq) Size() (n int) {
	var l int
	_ = l
	if m.AdminId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AdminId))
	}
	if m.AdminKeyId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AdminKeyId))
	}
	if m.ParticipantId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ParticipantId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	l = len(m.GA)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImsecuritychat(uint64(l))
	}
	if m.CrcId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.CrcId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.MessageId))
	}
	return n
}

func (m *RequestEncryptionResult) Size() (n int) {
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ChatId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImsecuritychat(uint64(m.AccessHash))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImsecuritychat(uint64(m.ErrorCode))
	}
	return n
}

func sovImsecuritychat(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImsecuritychat(x uint64) (n int) {
	return sovImsecuritychat(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetChatInfoByChatIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChatInfoByChatIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChatInfoByChatIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (GetChatInfoByChatIdResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChatInfo == nil {
				m.ChatInfo = &ChatInfo{}
			}
			if err := m.ChatInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatCreator", wireType)
			}
			m.ChatCreator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatCreator |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatMember", wireType)
			}
			m.ChatMember = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatMember |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorKeyId", wireType)
			}
			m.CreatorKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatorKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberKeyId", wireType)
			}
			m.MemberKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemberKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlreadAccept", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlreadAccept = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNormal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNormal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChatInfoByChatIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChatInfoByChatIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChatInfoByChatIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAllChatIdByUserIdKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAllChatIdByUserIdKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAllChatIdByUserIdKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (GetAllChatIdByUserIdKeyIdResult_ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImsecuritychat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChatId = append(m.ChatId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImsecuritychat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImsecuritychat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImsecuritychat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChatId = append(m.ChatId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAllChatIdByUserIdKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAllChatIdByUserIdKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAllChatIdByUserIdKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHandshakeUpdatesResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHandshakeUpdatesResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHandshakeUpdatesResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (GetHandshakeUpdatesResult_ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update, make([]byte, postIndex-iNdEx))
			copy(m.Update[len(m.Update)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHandshakeUpdatesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHandshakeUpdatesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHandshakeUpdatesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecurityResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecurityResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecurityResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSecurityDiffByQtsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSecurityDiffByQtsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSecurityDiffByQtsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSecurityDiffByQtsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSecurityDiffByQtsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSecurityDiffByQtsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (GetSecurityDiffByQtsResult_ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update, make([]byte, postIndex-iNdEx))
			copy(m.Update[len(m.Update)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckSecurityChatExistReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckSecurityChatExistReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckSecurityChatExistReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckSecurityChatExistResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckSecurityChatExistResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckSecurityChatExistResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckEncryChatAcceptReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckEncryChatAcceptReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckEncryChatAcceptReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckEncryChatAcceptResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckEncryChatAcceptResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckEncryChatAcceptResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSecurityRandomIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSecurityRandomIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSecurityRandomIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxQts", wireType)
			}
			m.MaxQts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxQts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSecurityRandomIdsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSecurityRandomIdsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSecurityRandomIdsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errcode", wireType)
			}
			m.Errcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errcode |= (GetSecurityRandomIdsResult_ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImsecuritychat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RandomIds = append(m.RandomIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImsecuritychat
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImsecuritychat
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImsecuritychat
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RandomIds = append(m.RandomIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutDisCardAllSecurityReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutDisCardAllSecurityReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutDisCardAllSecurityReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutDisCardAllSecurityResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutDisCardAllSecurityResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutDisCardAllSecurityResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errcode", wireType)
			}
			m.Errcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errcode |= (LogoutDisCardAllSecurityResult_ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetEncryptedTypingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetEncryptedTypingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetEncryptedTypingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetEncryptedTypingResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetEncryptedTypingResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetEncryptedTypingResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (SetEncryptedTypingResult_Errcode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadEncryptedHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadEncryptedHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadEncryptedHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDate", wireType)
			}
			m.MaxDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadEncryptedHistoryResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadEncryptedHistoryResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadEncryptedHistoryResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ReadEncryptedHistoryResult_Errcode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscardEncryptionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscardEncryptionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscardEncryptionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiscardEncryptionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiscardEncryptionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiscardEncryptionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (DiscardEncryptionResult_Errcode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEncryptedServiceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEncryptedServiceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEncryptedServiceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendId", wireType)
			}
			m.SendId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEncryptedServiceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEncryptedServiceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEncryptedServiceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (SendEncryptedServiceResult_Errcode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEncryptedFileReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEncryptedFileReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEncryptedFileReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendId", wireType)
			}
			m.SendId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File[:0], dAtA[iNdEx:postIndex]...)
			if m.File == nil {
				m.File = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEncryptedFileResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEncryptedFileResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEncryptedFileResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (SendEncryptedFileResult_Errcode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEncryptedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEncryptedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEncryptedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendId", wireType)
			}
			m.SendId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendEncryptedResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEncryptedResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEncryptedResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (SendEncryptedResult_Errcode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptEncryptionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptEncryptionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptEncryptionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipartId", wireType)
			}
			m.ParticipartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParticipartId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipartKeyId", wireType)
			}
			m.ParticipartKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParticipartKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GB = append(m.GB[:0], dAtA[iNdEx:postIndex]...)
			if m.GB == nil {
				m.GB = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyFingerprint", wireType)
			}
			m.KeyFingerprint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyFingerprint |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptEncryptionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptEncryptionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptEncryptionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			m.AdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GAOrB", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GAOrB = append(m.GAOrB[:0], dAtA[iNdEx:postIndex]...)
			if m.GAOrB == nil {
				m.GAOrB = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyFingerPrint2", wireType)
			}
			m.KeyFingerPrint2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyFingerPrint2 |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (AcceptEncryptionResult_Errcode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEncryptionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEncryptionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEncryptionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminId", wireType)
			}
			m.AdminId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminKeyId", wireType)
			}
			m.AdminKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdminKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantId", wireType)
			}
			m.ParticipantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParticipantId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GA", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GA = append(m.GA[:0], dAtA[iNdEx:postIndex]...)
			if m.GA == nil {
				m.GA = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEncryptionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEncryptionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEncryptionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (RequestEncryptionResult_ErroCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImsecuritychat(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImsecuritychat
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImsecuritychat(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImsecuritychat
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImsecuritychat
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImsecuritychat
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImsecuritychat
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImsecuritychat(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImsecuritychat = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImsecuritychat   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imsecuritychatserver/imsecuritychat.proto", fileDescriptorImsecuritychat)
}

var fileDescriptorImsecuritychat = []byte{
	// 1924 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x8f, 0xdc, 0x48,
	0x15, 0x1f, 0xbb, 0xbf, 0xdc, 0xaf, 0x7b, 0x26, 0x9d, 0xca, 0xec, 0x4c, 0xa7, 0x93, 0x9d, 0x1d,
	0xbc, 0x01, 0x06, 0x08, 0x13, 0x32, 0x24, 0xab, 0x05, 0x24, 0xd0, 0x7c, 0x64, 0x26, 0xad, 0xc0,
	0x90, 0xf5, 0x24, 0x02, 0x21, 0x90, 0x55, 0x6d, 0x57, 0x77, 0x7b, 0xc7, 0x6d, 0xf7, 0x94, 0xdd,
	0x51, 0xfa, 0x04, 0x17, 0x24, 0x2e, 0x5c, 0xf8, 0x0b, 0x96, 0x0b, 0xda, 0x03, 0x12, 0xe2, 0x84,
	0x90, 0xe0, 0xc0, 0x01, 0x89, 0x0b, 0x12, 0x62, 0x25, 0xb8, 0xa2, 0x88, 0x7f, 0x81, 0x3b, 0xaa,
	0xb2, 0x3d, 0xed, 0xb6, 0xab, 0x1a, 0x77, 0x08, 0x1b, 0x0e, 0x7b, 0x9a, 0xf2, 0xeb, 0xaa, 0xf7,
	0xea, 0xfd, 0x7e, 0xbf, 0xfa, 0x1e, 0x38, 0x1d, 0x38, 0xa1, 0x8b, 0x7b, 0xbb, 0xd6, 0x10, 0x87,
	0x01, 0xa1, 0xcf, 0x08, 0xdd, 0x75, 0x46, 0x77, 0x1c, 0x2f, 0x24, 0xb4, 0x8f, 0x2d, 0x32, 0xa6,
	0x7e, 0x6f, 0xd2, 0xbf, 0xe3, 0x8c, 0x02, 0x62, 0x4d, 0xa8, 0x13, 0x4e, 0x67, 0xf5, 0x32, 0xc6,
	0xdd, 0x31, 0xf5, 0x43, 0x1f, 0xad, 0x8b, 0xaa, 0x76, 0xde, 0x2d, 0x14, 0x65, 0xdc, 0xb3, 0xfc,
	0xd1, 0x28, 0xfe, 0x13, 0xf9, 0xd3, 0xff, 0xa6, 0xc0, 0xf5, 0x13, 0x12, 0x1e, 0x0e, 0x71, 0xd8,
	0xf5, 0xfa, 0xfe, 0xc1, 0x94, 0x97, 0x6c, 0x83, 0x04, 0x13, 0x37, 0x44, 0xa7, 0x50, 0xb6, 0x7c,
	0x9b, 0xb4, 0x95, 0x6d, 0x65, 0x67, 0x6d, 0xef, 0xab, 0xbb, 0xa2, 0xe0, 0xbb, 0xd2, 0xe6, 0xbb,
	0xd1, 0x9f, 0x43, 0xdf, 0x26, 0x06, 0xf7, 0x83, 0xbe, 0x06, 0x75, 0xd6, 0xd0, 0x74, 0xbc, 0xbe,
	0xdf, 0x56, 0xb7, 0x95, 0x9d, 0xc6, 0xde, 0x96, 0xd8, 0x69, 0xe2, 0xd1, 0xd0, 0xac, 0xb8, 0xa4,
	0xdf, 0x06, 0x98, 0x39, 0x44, 0x0d, 0xa8, 0x9d, 0x4d, 0x2c, 0x8b, 0x04, 0x41, 0x6b, 0x05, 0x5d,
	0x85, 0xd5, 0x2e, 0x4b, 0xd6, 0xc3, 0xee, 0x03, 0x4a, 0x7d, 0xda, 0x52, 0xf4, 0x0f, 0x55, 0xd0,
	0x12, 0x27, 0x68, 0x13, 0x6a, 0x51, 0x5c, 0x9b, 0xa7, 0x52, 0x31, 0xaa, 0xdc, 0xab, 0x8d, 0x3e,
	0x05, 0x4d, 0xfe, 0x83, 0x45, 0x09, 0x0e, 0x7d, 0xca, 0xfb, 0x54, 0x31, 0x1a, 0xcc, 0x76, 0x18,
	0x99, 0xd0, 0x5b, 0xd0, 0xc0, 0x3c, 0x8e, 0x39, 0xc4, 0xc1, 0xb0, 0x5d, 0xda, 0x56, 0x76, 0x4a,
	0x06, 0x44, 0xa6, 0x87, 0x38, 0x18, 0xb2, 0x0a, 0xdc, 0xc7, 0x88, 0x8c, 0x7a, 0x84, 0xb6, 0xcb,
	0xdc, 0x05, 0x30, 0xd3, 0xb7, 0xb8, 0x05, 0xdd, 0x82, 0xb5, 0xd8, 0xbf, 0x79, 0x4e, 0xa6, 0xac,
	0x13, 0x15, 0xee, 0xa4, 0x19, 0x5b, 0x1f, 0x91, 0x69, 0xd7, 0x46, 0x3a, 0xac, 0x46, 0x1e, 0x92,
	0x4a, 0x55, 0x5e, 0xa9, 0x11, 0x19, 0xa3, 0x3a, 0x08, 0xca, 0x36, 0x0e, 0x49, 0xbb, 0xc6, 0x63,
	0xf0, 0x32, 0x7a, 0x1b, 0x56, 0xb1, 0x4b, 0x09, 0xb6, 0x4d, 0xd6, 0xa7, 0x71, 0xd8, 0xd6, 0xb6,
	0x95, 0x1d, 0xcd, 0x68, 0x46, 0xc6, 0x7d, 0x6e, 0x43, 0x37, 0xa0, 0xee, 0x04, 0xa6, 0xe7, 0xd3,
	0x11, 0x76, 0xdb, 0x75, 0x5e, 0x41, 0x73, 0x82, 0x53, 0xfe, 0xad, 0xdf, 0x85, 0x0d, 0x21, 0x87,
	0x17, 0x52, 0xdc, 0xf4, 0xdf, 0x29, 0xf0, 0xd6, 0x09, 0x09, 0xf7, 0x5d, 0x37, 0xaa, 0x7c, 0x30,
	0x7d, 0x1a, 0x10, 0xda, 0xb5, 0x79, 0x37, 0x63, 0xf1, 0x7c, 0x0f, 0x34, 0x42, 0xa9, 0x99, 0x12,
	0xd0, 0x37, 0xa4, 0x02, 0x5a, 0xe4, 0x68, 0x97, 0x53, 0xca, 0x55, 0x54, 0x23, 0x94, 0x17, 0xd2,
	0x1d, 0x53, 0xb7, 0x4b, 0xa9, 0x8e, 0xdd, 0x82, 0xfa, 0x65, 0xf5, 0x79, 0x8d, 0x00, 0x54, 0x8f,
	0xb1, 0xe3, 0x12, 0xbb, 0xa5, 0xe8, 0xa7, 0x70, 0x73, 0x41, 0x50, 0x9e, 0xf7, 0x24, 0x20, 0x34,
	0x95, 0xf7, 0x84, 0x57, 0x40, 0x6f, 0x40, 0x35, 0x66, 0x47, 0xe5, 0xec, 0x54, 0xce, 0x59, 0x13,
	0xfd, 0x57, 0xd1, 0x28, 0x7a, 0x88, 0x3d, 0x3b, 0x18, 0xe2, 0x73, 0xf2, 0x74, 0xcc, 0xa8, 0x09,
	0x62, 0x20, 0x9e, 0xe4, 0x80, 0xf8, 0x8a, 0x14, 0x08, 0xb1, 0x0b, 0x11, 0x04, 0x1b, 0x50, 0x9d,
	0xf0, 0x3a, 0x1c, 0x81, 0xa6, 0x11, 0x7f, 0x15, 0x44, 0x80, 0x70, 0xce, 0xf3, 0xd1, 0x16, 0xe4,
	0xbe, 0x05, 0x0d, 0x3c, 0x09, 0x87, 0xe6, 0x1c, 0x00, 0x75, 0x66, 0x9a, 0x17, 0x67, 0x34, 0x42,
	0x78, 0x59, 0x3f, 0x86, 0xb5, 0xb3, 0x38, 0xcf, 0x18, 0x8c, 0x0d, 0xa8, 0x52, 0x5e, 0xe2, 0xde,
	0x9b, 0x46, 0xfc, 0x85, 0x6e, 0x42, 0x9d, 0x24, 0xdd, 0x8e, 0x87, 0xe1, 0xcc, 0xa0, 0xff, 0x48,
	0x81, 0xcd, 0x13, 0x12, 0x26, 0xbe, 0x8e, 0x9c, 0x7e, 0xff, 0x60, 0xfa, 0x5e, 0x98, 0x74, 0xb8,
	0x4f, 0xfd, 0x51, 0xaa, 0xc3, 0xec, 0x33, 0x47, 0x56, 0x39, 0x26, 0x0b, 0xb5, 0xa0, 0x74, 0x11,
	0x06, 0xbc, 0x9b, 0x15, 0x83, 0x15, 0xd1, 0xdb, 0x50, 0xb1, 0x49, 0x6f, 0x32, 0xe0, 0x63, 0xb7,
	0xb1, 0xb7, 0xba, 0x1b, 0x4f, 0x91, 0x47, 0xcc, 0x68, 0x44, 0xbf, 0xe9, 0xbf, 0x56, 0xa0, 0x23,
	0xee, 0x02, 0xef, 0xff, 0xd3, 0x1c, 0xc9, 0xf2, 0xe9, 0x52, 0xe2, 0xe3, 0xd5, 0xb3, 0x7c, 0x0f,
	0xae, 0x1f, 0x0e, 0x89, 0x75, 0x9e, 0x04, 0x64, 0x72, 0x7f, 0xf0, 0xdc, 0x09, 0xc2, 0x85, 0x83,
	0xfb, 0x1d, 0xb8, 0x29, 0x6b, 0x25, 0xa0, 0x50, 0x4b, 0x28, 0xd4, 0xf7, 0x60, 0x93, 0xb7, 0x7b,
	0xe0, 0x59, 0x94, 0x37, 0x8a, 0x26, 0x9f, 0x85, 0xb1, 0xee, 0x41, 0x47, 0xdc, 0x66, 0x61, 0xa4,
	0xdf, 0xcf, 0xcb, 0xc1, 0xc0, 0x9e, 0xcd, 0x18, 0xe7, 0x72, 0x98, 0xb1, 0xae, 0xa4, 0x86, 0x28,
	0xeb, 0xc1, 0x08, 0x3f, 0x37, 0x19, 0xf3, 0x91, 0xba, 0xaa, 0x23, 0xfc, 0xfc, 0xbd, 0x34, 0xf9,
	0x25, 0x39, 0xf9, 0xac, 0xb5, 0xdf, 0x7b, 0xdf, 0xec, 0x39, 0x1e, 0xd7, 0x48, 0xd3, 0xa8, 0xfa,
	0xbd, 0xf7, 0x0f, 0x1c, 0x8f, 0x45, 0xb3, 0xa8, 0x95, 0xcc, 0xe9, 0xab, 0x46, 0xc5, 0xa2, 0x56,
	0xd7, 0x46, 0x6f, 0x02, 0x8c, 0x48, 0x10, 0xe0, 0x01, 0x99, 0xcd, 0xe4, 0xf5, 0xd8, 0xd2, 0xb5,
	0xf5, 0xdf, 0xcc, 0x6b, 0x29, 0xd5, 0xff, 0x78, 0xc2, 0x60, 0xfc, 0x2f, 0x25, 0xa5, 0x8c, 0x8b,
	0x8c, 0x94, 0xf8, 0xe2, 0xfb, 0x26, 0x00, 0xe5, 0xb5, 0x4c, 0xc7, 0x0e, 0xb8, 0x9c, 0x4a, 0x46,
	0x9d, 0x26, 0xed, 0x0a, 0x2a, 0xea, 0x0f, 0x0a, 0xdc, 0xf8, 0xa6, 0x3f, 0xf0, 0x27, 0xe1, 0x91,
	0x13, 0x1c, 0x62, 0x6a, 0xef, 0xbb, 0xee, 0x6c, 0x84, 0x2f, 0x3d, 0x73, 0xbe, 0x16, 0xf4, 0x3f,
	0x50, 0x60, 0x4b, 0x9e, 0x03, 0x67, 0xe0, 0xbb, 0x59, 0x06, 0xbe, 0x2e, 0x66, 0x60, 0xb1, 0x1b,
	0x01, 0x0b, 0x05, 0x61, 0xfe, 0x97, 0x02, 0x6f, 0x9c, 0x91, 0x90, 0x8f, 0x8a, 0x71, 0x48, 0xec,
	0x27, 0xd3, 0xb1, 0xe3, 0x0d, 0x5e, 0x06, 0xe0, 0xd4, 0xc8, 0x2b, 0xcd, 0x6d, 0x7d, 0x32, 0xfb,
	0x9a, 0x72, 0x6e, 0x5f, 0x73, 0x49, 0x4d, 0xa5, 0x18, 0x35, 0x55, 0x09, 0x35, 0x35, 0x39, 0x35,
	0x5a, 0x96, 0x9a, 0x0f, 0x15, 0x68, 0x8b, 0xf2, 0x8e, 0xa7, 0x58, 0xe0, 0x2b, 0x42, 0x7a, 0x92,
	0x7d, 0x47, 0xcc, 0x8b, 0xcc, 0x07, 0x63, 0x84, 0xb5, 0x4e, 0xaf, 0x2d, 0xf7, 0xa1, 0x16, 0x5b,
	0x73, 0x7c, 0xf4, 0x63, 0x3e, 0xd8, 0x06, 0x73, 0xff, 0x12, 0x99, 0x07, 0x94, 0xb6, 0x54, 0xfd,
	0x67, 0x2a, 0x6c, 0x1a, 0x04, 0xdb, 0x97, 0x71, 0x1e, 0x3a, 0x41, 0xe8, 0xd3, 0xe9, 0xc7, 0x4b,
	0xd2, 0x75, 0xd0, 0xd8, 0xb4, 0xc6, 0x57, 0x88, 0x0a, 0x6f, 0xca, 0xa6, 0xb9, 0xa3, 0x68, 0x63,
	0x18, 0xf3, 0x57, 0x2d, 0xc6, 0x5f, 0x4d, 0xc2, 0x9f, 0x26, 0xe7, 0xaf, 0x9e, 0xe5, 0xef, 0x97,
	0x0a, 0x74, 0xc4, 0xa0, 0x70, 0x06, 0xbf, 0x23, 0x60, 0xf0, 0x5d, 0x31, 0x83, 0x72, 0x2f, 0xaf,
	0x90, 0xc3, 0x8f, 0x14, 0x58, 0x3f, 0x72, 0x02, 0x0b, 0xd3, 0x24, 0x96, 0xe3, 0x7b, 0xaf, 0x94,
	0xc0, 0x22, 0x5b, 0x8b, 0x34, 0x09, 0x15, 0x09, 0x09, 0x55, 0x39, 0x09, 0xb5, 0x2c, 0x09, 0xbf,
	0x50, 0x60, 0x53, 0x90, 0x55, 0xbc, 0xb4, 0xe4, 0x19, 0xb8, 0x2f, 0x66, 0x40, 0xe2, 0xe2, 0xe5,
	0xe0, 0x57, 0xf3, 0xf0, 0x97, 0xd8, 0x19, 0x6d, 0xf3, 0x8c, 0x78, 0x33, 0x9e, 0xcf, 0x08, 0x7d,
	0xe6, 0x58, 0x24, 0x66, 0x20, 0x20, 0x9e, 0x9d, 0x62, 0x80, 0x7d, 0xfe, 0x2f, 0x86, 0xd0, 0x0d,
	0xa8, 0x5f, 0xae, 0x8b, 0xf1, 0xc9, 0x4c, 0x4b, 0x96, 0x45, 0xb6, 0xa9, 0x3d, 0xc2, 0x21, 0x8e,
	0x27, 0x37, 0x5e, 0x9e, 0x71, 0x5a, 0x2b, 0xc6, 0xa9, 0x26, 0xe1, 0xb4, 0x2e, 0xe7, 0x14, 0xb2,
	0x9c, 0x7e, 0xa4, 0x40, 0x47, 0x0c, 0xd5, 0xb2, 0x03, 0x4b, 0xee, 0x45, 0xc4, 0xec, 0xf7, 0x25,
	0xcc, 0x22, 0x58, 0x33, 0xc8, 0x98, 0xe0, 0x90, 0xd8, 0x43, 0xec, 0xd9, 0x2e, 0x69, 0x29, 0xa8,
	0x05, 0x4d, 0xb6, 0x83, 0x3b, 0xf5, 0xa3, 0xdd, 0x62, 0x4b, 0x65, 0x4d, 0x8e, 0x7a, 0xd1, 0x89,
	0xbc, 0x94, 0x17, 0x40, 0x59, 0xff, 0xad, 0x0a, 0xeb, 0x73, 0xfd, 0x39, 0x76, 0xdc, 0xff, 0x77,
	0xf6, 0x11, 0x94, 0xfb, 0x8e, 0x4b, 0xe2, 0xe9, 0x92, 0x97, 0x67, 0x8a, 0xd0, 0x8a, 0x29, 0xa2,
	0x2e, 0x51, 0x04, 0xc8, 0x15, 0xd1, 0xc8, 0x2a, 0xe2, 0xcf, 0x4a, 0x66, 0xf0, 0x44, 0xd8, 0x2d,
	0x3b, 0xca, 0x25, 0x2e, 0x3e, 0x7e, 0x2d, 0xfc, 0x5c, 0x85, 0xd6, 0x5c, 0x67, 0x3e, 0x99, 0x05,
	0x72, 0xb3, 0xc0, 0x1f, 0x15, 0xb8, 0x96, 0xc1, 0x88, 0xf3, 0xfd, 0x58, 0xc0, 0xf7, 0xdd, 0x02,
	0x7c, 0xbf, 0x2e, 0xae, 0xff, 0xaa, 0xc2, 0xb5, 0xe8, 0xa0, 0x37, 0xbf, 0xec, 0x7e, 0x1a, 0xd6,
	0xc6, 0x98, 0x86, 0x8e, 0xe5, 0xb0, 0x3f, 0x33, 0xd6, 0x57, 0x53, 0xd6, 0xae, 0x8d, 0x6e, 0x03,
	0x4a, 0x57, 0x9b, 0x13, 0x42, 0x2b, 0xf5, 0xcb, 0xa3, 0xff, 0x52, 0x13, 0x57, 0xa0, 0x74, 0x62,
	0xf6, 0xe2, 0x35, 0x59, 0x3d, 0x39, 0x40, 0x9f, 0x85, 0x2b, 0x8f, 0xc8, 0xd4, 0xec, 0x3b, 0xde,
	0x80, 0xd0, 0x31, 0x75, 0xbc, 0x30, 0x3e, 0x5d, 0xac, 0x3d, 0x22, 0xd3, 0xe3, 0x99, 0xf5, 0xb5,
	0x88, 0xe3, 0x9f, 0x2a, 0x6c, 0xe4, 0x41, 0xe5, 0xfa, 0xb8, 0x0e, 0x1a, 0xb6, 0x47, 0x8e, 0x37,
	0x43, 0xb4, 0xc6, 0xbf, 0x39, 0x3a, 0xda, 0x89, 0x89, 0x4d, 0x9f, 0x9a, 0x3d, 0x8e, 0x60, 0xd3,
	0xa8, 0x9c, 0xec, 0x7f, 0x9b, 0x1e, 0xa0, 0x1d, 0xb8, 0x72, 0x9e, 0x24, 0xf5, 0x98, 0x25, 0xb5,
	0x17, 0xdf, 0xec, 0x64, 0xcd, 0x69, 0x80, 0xcb, 0x8b, 0x00, 0xae, 0xe4, 0x00, 0x3e, 0x9b, 0xd3,
	0x6d, 0x95, 0xeb, 0xf6, 0x9e, 0x58, 0xb7, 0xe2, 0xcc, 0x44, 0xd2, 0xfd, 0x81, 0x44, 0xba, 0x4c,
	0x87, 0xfc, 0x4e, 0x74, 0x1a, 0xf9, 0x6a, 0x29, 0x02, 0x35, 0xff, 0x67, 0xed, 0x7e, 0xa0, 0xc2,
	0xba, 0x41, 0x2e, 0x26, 0x24, 0xc8, 0x88, 0x77, 0x01, 0xc8, 0xdb, 0xd0, 0x8c, 0x7e, 0x9a, 0x93,
	0x2a, 0x70, 0x5b, 0x24, 0xd2, 0xb4, 0xf2, 0xbd, 0x94, 0x56, 0x57, 0x53, 0xd6, 0x82, 0x92, 0x1d,
	0x98, 0x38, 0x91, 0xec, 0x60, 0xff, 0xb5, 0x9c, 0x02, 0x7e, 0xca, 0x8f, 0x46, 0x39, 0x88, 0xb8,
	0x14, 0xa5, 0x57, 0xf1, 0x99, 0xd4, 0xd4, 0x5c, 0x6a, 0x4f, 0xd2, 0x37, 0x84, 0xa5, 0x45, 0xa7,
	0x3f, 0x49, 0x6c, 0x7e, 0x1c, 0x3f, 0xcc, 0xa8, 0xa5, 0x07, 0x5a, 0x62, 0x66, 0x13, 0xd9, 0xd9,
	0x24, 0x08, 0x58, 0xc4, 0xe3, 0x89, 0xeb, 0xb6, 0x56, 0xd0, 0x15, 0x68, 0x9c, 0x10, 0xaf, 0x6b,
	0x27, 0x07, 0xf3, 0xb4, 0x3a, 0x54, 0xb4, 0xc6, 0x5f, 0x24, 0x42, 0xea, 0x58, 0x21, 0xb1, 0x5b,
	0x25, 0xb4, 0x01, 0xe8, 0xf1, 0x8c, 0xae, 0x03, 0xd7, 0xb7, 0xce, 0x89, 0xdd, 0x2a, 0xef, 0xfd,
	0x7d, 0x0d, 0xd6, 0xbb, 0xa3, 0xf4, 0x75, 0xda, 0x19, 0xef, 0x28, 0x1a, 0xc0, 0xd5, 0x5c, 0x5f,
	0xd1, 0xe7, 0x0b, 0x27, 0x75, 0xd1, 0xb9, 0x25, 0x9b, 0xe4, 0xd3, 0xd7, 0x10, 0xfa, 0x0a, 0x22,
	0xd0, 0xca, 0x0e, 0x20, 0xf4, 0xb9, 0xa2, 0x03, 0xad, 0x78, 0x18, 0x13, 0x56, 0xe7, 0xd6, 0x17,
	0xf4, 0x99, 0x42, 0x8b, 0x50, 0xf1, 0x00, 0x03, 0xb8, 0x9a, 0xdb, 0xb0, 0xc8, 0x00, 0x13, 0x6d,
	0x2c, 0x0b, 0x07, 0x1a, 0x65, 0x36, 0xa6, 0xf1, 0x46, 0x19, 0x7d, 0x71, 0x99, 0x4d, 0xf5, 0x52,
	0x79, 0xe5, 0x8e, 0x5b, 0xb2, 0xbc, 0x44, 0x07, 0xd6, 0x65, 0xf2, 0x12, 0x9d, 0xac, 0x65, 0x79,
	0x49, 0x2e, 0x38, 0x0a, 0x87, 0x73, 0x00, 0xe5, 0xaf, 0x62, 0xd0, 0x17, 0x8a, 0x5f, 0xda, 0x14,
	0x0f, 0xf5, 0x63, 0x05, 0xda, 0xb2, 0xeb, 0x38, 0x74, 0x77, 0xd9, 0xeb, 0xbb, 0x8b, 0xce, 0xbd,
	0x97, 0xb9, 0xf1, 0xd3, 0x57, 0xd0, 0x14, 0xd6, 0x45, 0xf7, 0xb2, 0x32, 0x84, 0x25, 0xd7, 0xd8,
	0x9d, 0x2f, 0x2d, 0x7b, 0xe5, 0x1b, 0x85, 0x16, 0x5d, 0xa6, 0xcb, 0x42, 0x4b, 0x2e, 0xeb, 0x65,
	0xa1, 0xe5, 0xf7, 0xf4, 0xfa, 0x0a, 0xfa, 0x21, 0x6c, 0x88, 0xdf, 0x0c, 0xd0, 0x9d, 0x05, 0xde,
	0x44, 0xef, 0x12, 0x9d, 0xbd, 0xe5, 0x1a, 0x08, 0x61, 0xbf, 0x7c, 0x59, 0x29, 0x00, 0x7b, 0xfa,
	0x31, 0xa9, 0x00, 0xec, 0x99, 0x47, 0x1b, 0x7d, 0x05, 0x3d, 0x83, 0x6b, 0x82, 0xb7, 0x34, 0x74,
	0x7b, 0x89, 0x47, 0xbe, 0x8b, 0xce, 0x9d, 0x25, 0x9f, 0x04, 0xf5, 0x15, 0xf4, 0x93, 0xe8, 0xd5,
	0x51, 0xfc, 0x8c, 0x89, 0xf6, 0x96, 0x7e, 0x6c, 0xbd, 0xe8, 0xdc, 0x7f, 0xa9, 0x07, 0xda, 0x4b,
	0x08, 0xb2, 0x4f, 0xc8, 0x0b, 0x20, 0x10, 0xbc, 0x36, 0x2f, 0x80, 0x40, 0xfc, 0xff, 0x05, 0xfa,
	0xca, 0x41, 0xf3, 0x4f, 0x2f, 0xb6, 0x94, 0xbf, 0xbc, 0xd8, 0x52, 0xfe, 0xf1, 0x62, 0x4b, 0xe9,
	0x55, 0xf9, 0xff, 0x34, 0x7c, 0xf9, 0xdf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xfd, 0xb1, 0x20, 0x98,
	0x75, 0x21, 0x00, 0x00,
}
