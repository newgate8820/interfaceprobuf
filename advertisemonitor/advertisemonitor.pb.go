// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/advertisemonitor/advertisemonitor.proto

/*
Package pbadvertisemonitor is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/advertisemonitor/advertisemonitor.proto

It has these top-level messages:

	ReqDelManualBlockList
	ReqSetManualBlockList
	ReqGetBlockList
	ReplyGetBlockList
	ReqUnBlockBannedUser
	ReqUnBlockAllUser
	MessageSendingLimit
	MessageMaskWord
	ReqGetSendMessageRuleSettings
	SendMessageRuleSettings
	ReplyGetSendMessageRuleSettings
	ReqUpdateMessageSendingLimit
	ReqUpdateMessageMaskWord
	ReplyData
	ReqNatsData
	ReplyNatsData
	BlockUser
	BlockUserList
	UnBlockUserList
	MsgInfo
	MsgInfoList
*/
package pbadvertisemonitor

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ProtocolType int32

const (
	// 一般禁言
	ProtocolType_BlockUserList_TYPE   ProtocolType = 0
	ProtocolType_UnBlockUserList_TYPE ProtocolType = 1
	ProtocolType_MsgInfo_TYPE         ProtocolType = 2
	ProtocolType_MsgInfoList_TYPE     ProtocolType = 3
	ProtocolType_UnBlockAllUser_TYPE  ProtocolType = 4
	// 各別群設定(消息限制)
	ProtocolType_UnBlockGroupUser_TYPE ProtocolType = 5
	// 回覆確認
	ProtocolType_BlockUserList_CONFIRM_TYPE   ProtocolType = 6
	ProtocolType_UnBlockUserList_CONFIRM_TYPE ProtocolType = 7
	ProtocolType_MsgInfo_CONFIRM_TYPE         ProtocolType = 8
	ProtocolType_UnBlockAllUser_CONFIRM_TYPE  ProtocolType = 9
)

var ProtocolType_name = map[int32]string{
	0: "BlockUserList_TYPE",
	1: "UnBlockUserList_TYPE",
	2: "MsgInfo_TYPE",
	3: "MsgInfoList_TYPE",
	4: "UnBlockAllUser_TYPE",
	5: "UnBlockGroupUser_TYPE",
	6: "BlockUserList_CONFIRM_TYPE",
	7: "UnBlockUserList_CONFIRM_TYPE",
	8: "MsgInfo_CONFIRM_TYPE",
	9: "UnBlockAllUser_CONFIRM_TYPE",
}
var ProtocolType_value = map[string]int32{
	"BlockUserList_TYPE":           0,
	"UnBlockUserList_TYPE":         1,
	"MsgInfo_TYPE":                 2,
	"MsgInfoList_TYPE":             3,
	"UnBlockAllUser_TYPE":          4,
	"UnBlockGroupUser_TYPE":        5,
	"BlockUserList_CONFIRM_TYPE":   6,
	"UnBlockUserList_CONFIRM_TYPE": 7,
	"MsgInfo_CONFIRM_TYPE":         8,
	"UnBlockAllUser_CONFIRM_TYPE":  9,
}

func (x ProtocolType) String() string {
	return proto.EnumName(ProtocolType_name, int32(x))
}
func (ProtocolType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{0} }

type BlockListType int32

const (
	// 禁言名單類型
	BlockListType_NormalBlockList_TYPE BlockListType = 0
	BlockListType_ManualBlockList_TYPE BlockListType = 1
	BlockListType_GroupBlockList_TYPE  BlockListType = 2
)

var BlockListType_name = map[int32]string{
	0: "NormalBlockList_TYPE",
	1: "ManualBlockList_TYPE",
	2: "GroupBlockList_TYPE",
}
var BlockListType_value = map[string]int32{
	"NormalBlockList_TYPE": 0,
	"ManualBlockList_TYPE": 1,
	"GroupBlockList_TYPE":  2,
}

func (x BlockListType) String() string {
	return proto.EnumName(BlockListType_name, int32(x))
}
func (BlockListType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{1}
}

type ReqDelManualBlockList struct {
	UnBlockUser *BlockUser    `protobuf:"bytes,1,opt,name=UnBlockUser" json:"UnBlockUser,omitempty"`
	BotId       int32         `protobuf:"varint,2,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqDelManualBlockList) Reset()         { *m = ReqDelManualBlockList{} }
func (m *ReqDelManualBlockList) String() string { return proto.CompactTextString(m) }
func (*ReqDelManualBlockList) ProtoMessage()    {}
func (*ReqDelManualBlockList) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{0}
}

func (m *ReqDelManualBlockList) GetUnBlockUser() *BlockUser {
	if m != nil {
		return m.UnBlockUser
	}
	return nil
}

func (m *ReqDelManualBlockList) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

func (m *ReqDelManualBlockList) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqSetManualBlockList struct {
	BlockUser *BlockUser    `protobuf:"bytes,1,opt,name=BlockUser" json:"BlockUser,omitempty"`
	BotId     int32         `protobuf:"varint,2,opt,name=bot_id,json=botId,proto3" json:"bot_id,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqSetManualBlockList) Reset()         { *m = ReqSetManualBlockList{} }
func (m *ReqSetManualBlockList) String() string { return proto.CompactTextString(m) }
func (*ReqSetManualBlockList) ProtoMessage()    {}
func (*ReqSetManualBlockList) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{1}
}

func (m *ReqSetManualBlockList) GetBlockUser() *BlockUser {
	if m != nil {
		return m.BlockUser
	}
	return nil
}

func (m *ReqSetManualBlockList) GetBotId() int32 {
	if m != nil {
		return m.BotId
	}
	return 0
}

func (m *ReqSetManualBlockList) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 獲取所有禁言用戶
type ReqGetBlockList struct {
}

func (m *ReqGetBlockList) Reset()                    { *m = ReqGetBlockList{} }
func (m *ReqGetBlockList) String() string            { return proto.CompactTextString(m) }
func (*ReqGetBlockList) ProtoMessage()               {}
func (*ReqGetBlockList) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{2} }

type ReplyGetBlockList struct {
	BlockUserList []*BlockUser `protobuf:"bytes,1,rep,name=BlockUserList" json:"BlockUserList,omitempty"`
	ErrorCode     int32        `protobuf:"varint,2,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
}

func (m *ReplyGetBlockList) Reset()         { *m = ReplyGetBlockList{} }
func (m *ReplyGetBlockList) String() string { return proto.CompactTextString(m) }
func (*ReplyGetBlockList) ProtoMessage()    {}
func (*ReplyGetBlockList) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{3}
}

func (m *ReplyGetBlockList) GetBlockUserList() []*BlockUser {
	if m != nil {
		return m.BlockUserList
	}
	return nil
}

func (m *ReplyGetBlockList) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 取消單個用戶
type ReqUnBlockBannedUser struct {
	UserId []int32 `protobuf:"varint,1,rep,packed,name=userId" json:"userId,omitempty"`
}

func (m *ReqUnBlockBannedUser) Reset()         { *m = ReqUnBlockBannedUser{} }
func (m *ReqUnBlockBannedUser) String() string { return proto.CompactTextString(m) }
func (*ReqUnBlockBannedUser) ProtoMessage()    {}
func (*ReqUnBlockBannedUser) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{4}
}

func (m *ReqUnBlockBannedUser) GetUserId() []int32 {
	if m != nil {
		return m.UserId
	}
	return nil
}

// 解除所有用户限制
type ReqUnBlockAllUser struct {
}

func (m *ReqUnBlockAllUser) Reset()         { *m = ReqUnBlockAllUser{} }
func (m *ReqUnBlockAllUser) String() string { return proto.CompactTextString(m) }
func (*ReqUnBlockAllUser) ProtoMessage()    {}
func (*ReqUnBlockAllUser) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{5}
}

// 管理員DuringTime秒內 , 同一用戶只允許發送MaxMsgCount條消息，超過群內禁言BlockTime小時
// ex.管理員1秒內 , 同一用戶只允許發送2條消息，超過群內禁言１小時
type MessageSendingLimit struct {
	DuringTime  int64 `protobuf:"varint,3,opt,name=DuringTime,proto3" json:"DuringTime,omitempty"`
	MaxMsgCount int32 `protobuf:"varint,4,opt,name=MaxMsgCount,proto3" json:"MaxMsgCount,omitempty"`
	BlockTime   int64 `protobuf:"varint,5,opt,name=BlockTime,proto3" json:"BlockTime,omitempty"`
}

func (m *MessageSendingLimit) Reset()         { *m = MessageSendingLimit{} }
func (m *MessageSendingLimit) String() string { return proto.CompactTextString(m) }
func (*MessageSendingLimit) ProtoMessage()    {}
func (*MessageSendingLimit) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{6}
}

func (m *MessageSendingLimit) GetDuringTime() int64 {
	if m != nil {
		return m.DuringTime
	}
	return 0
}

func (m *MessageSendingLimit) GetMaxMsgCount() int32 {
	if m != nil {
		return m.MaxMsgCount
	}
	return 0
}

func (m *MessageSendingLimit) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

type MessageMaskWord struct {
	MaskWord []string `protobuf:"bytes,1,rep,name=MaskWord" json:"MaskWord,omitempty"`
}

func (m *MessageMaskWord) Reset()                    { *m = MessageMaskWord{} }
func (m *MessageMaskWord) String() string            { return proto.CompactTextString(m) }
func (*MessageMaskWord) ProtoMessage()               {}
func (*MessageMaskWord) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{7} }

func (m *MessageMaskWord) GetMaskWord() []string {
	if m != nil {
		return m.MaskWord
	}
	return nil
}

type ReqGetSendMessageRuleSettings struct {
	GroupId int64 `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
}

func (m *ReqGetSendMessageRuleSettings) Reset()         { *m = ReqGetSendMessageRuleSettings{} }
func (m *ReqGetSendMessageRuleSettings) String() string { return proto.CompactTextString(m) }
func (*ReqGetSendMessageRuleSettings) ProtoMessage()    {}
func (*ReqGetSendMessageRuleSettings) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{8}
}

func (m *ReqGetSendMessageRuleSettings) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type SendMessageRuleSettings struct {
	GroupId             int64                `protobuf:"varint,1,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	MessageSendingLimit *MessageSendingLimit `protobuf:"bytes,2,opt,name=MessageSendingLimit" json:"MessageSendingLimit,omitempty"`
	MessageMaskWord     *MessageMaskWord     `protobuf:"bytes,3,opt,name=MessageMaskWord" json:"MessageMaskWord,omitempty"`
}

func (m *SendMessageRuleSettings) Reset()         { *m = SendMessageRuleSettings{} }
func (m *SendMessageRuleSettings) String() string { return proto.CompactTextString(m) }
func (*SendMessageRuleSettings) ProtoMessage()    {}
func (*SendMessageRuleSettings) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{9}
}

func (m *SendMessageRuleSettings) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *SendMessageRuleSettings) GetMessageSendingLimit() *MessageSendingLimit {
	if m != nil {
		return m.MessageSendingLimit
	}
	return nil
}

func (m *SendMessageRuleSettings) GetMessageMaskWord() *MessageMaskWord {
	if m != nil {
		return m.MessageMaskWord
	}
	return nil
}

type ReplyGetSendMessageRuleSettings struct {
	SendMessageRuleSettings *SendMessageRuleSettings `protobuf:"bytes,1,opt,name=SendMessageRuleSettings" json:"SendMessageRuleSettings,omitempty"`
}

func (m *ReplyGetSendMessageRuleSettings) Reset()         { *m = ReplyGetSendMessageRuleSettings{} }
func (m *ReplyGetSendMessageRuleSettings) String() string { return proto.CompactTextString(m) }
func (*ReplyGetSendMessageRuleSettings) ProtoMessage()    {}
func (*ReplyGetSendMessageRuleSettings) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{10}
}

func (m *ReplyGetSendMessageRuleSettings) GetSendMessageRuleSettings() *SendMessageRuleSettings {
	if m != nil {
		return m.SendMessageRuleSettings
	}
	return nil
}

type ReqUpdateMessageSendingLimit struct {
	UserId              int32                `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	GroupId             int64                `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	MessageSendingLimit *MessageSendingLimit `protobuf:"bytes,3,opt,name=MessageSendingLimit" json:"MessageSendingLimit,omitempty"`
}

func (m *ReqUpdateMessageSendingLimit) Reset()         { *m = ReqUpdateMessageSendingLimit{} }
func (m *ReqUpdateMessageSendingLimit) String() string { return proto.CompactTextString(m) }
func (*ReqUpdateMessageSendingLimit) ProtoMessage()    {}
func (*ReqUpdateMessageSendingLimit) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{11}
}

func (m *ReqUpdateMessageSendingLimit) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUpdateMessageSendingLimit) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ReqUpdateMessageSendingLimit) GetMessageSendingLimit() *MessageSendingLimit {
	if m != nil {
		return m.MessageSendingLimit
	}
	return nil
}

type ReqUpdateMessageMaskWord struct {
	UserId          int32            `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	GroupId         int64            `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	MessageMaskWord *MessageMaskWord `protobuf:"bytes,3,opt,name=MessageMaskWord" json:"MessageMaskWord,omitempty"`
}

func (m *ReqUpdateMessageMaskWord) Reset()         { *m = ReqUpdateMessageMaskWord{} }
func (m *ReqUpdateMessageMaskWord) String() string { return proto.CompactTextString(m) }
func (*ReqUpdateMessageMaskWord) ProtoMessage()    {}
func (*ReqUpdateMessageMaskWord) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{12}
}

func (m *ReqUpdateMessageMaskWord) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqUpdateMessageMaskWord) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *ReqUpdateMessageMaskWord) GetMessageMaskWord() *MessageMaskWord {
	if m != nil {
		return m.MessageMaskWord
	}
	return nil
}

type ReplyData struct {
	ReplyData []byte `protobuf:"bytes,1,opt,name=replyData,proto3" json:"replyData,omitempty"`
	Reply     bool   `protobuf:"varint,2,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,3,opt,name=errorCode,proto3" json:"errorCode,omitempty"`
}

func (m *ReplyData) Reset()                    { *m = ReplyData{} }
func (m *ReplyData) String() string            { return proto.CompactTextString(m) }
func (*ReplyData) ProtoMessage()               {}
func (*ReplyData) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{13} }

func (m *ReplyData) GetReplyData() []byte {
	if m != nil {
		return m.ReplyData
	}
	return nil
}

func (m *ReplyData) GetReply() bool {
	if m != nil {
		return m.Reply
	}
	return false
}

func (m *ReplyData) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 發送請求
type ReqNatsData struct {
	Type          ProtocolType  `protobuf:"varint,1,opt,name=Type,proto3,enum=pbadvertisemonitor.ProtocolType" json:"Type,omitempty"`
	Data          []byte        `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	MessageId     int64         `protobuf:"varint,3,opt,name=MessageId,proto3" json:"MessageId,omitempty"`
	Hostname      string        `protobuf:"bytes,4,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
	BlockListType BlockListType `protobuf:"varint,5,opt,name=BlockListType,proto3,enum=pbadvertisemonitor.BlockListType" json:"BlockListType,omitempty"`
}

func (m *ReqNatsData) Reset()                    { *m = ReqNatsData{} }
func (m *ReqNatsData) String() string            { return proto.CompactTextString(m) }
func (*ReqNatsData) ProtoMessage()               {}
func (*ReqNatsData) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{14} }

func (m *ReqNatsData) GetType() ProtocolType {
	if m != nil {
		return m.Type
	}
	return ProtocolType_BlockUserList_TYPE
}

func (m *ReqNatsData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ReqNatsData) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *ReqNatsData) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *ReqNatsData) GetBlockListType() BlockListType {
	if m != nil {
		return m.BlockListType
	}
	return BlockListType_NormalBlockList_TYPE
}

// 確認請求的回覆
type ReplyNatsData struct {
	Enable    bool   `protobuf:"varint,1,opt,name=Enable,proto3" json:"Enable,omitempty"`
	MessageId int64  `protobuf:"varint,2,opt,name=MessageId,proto3" json:"MessageId,omitempty"`
	Hostname  string `protobuf:"bytes,3,opt,name=Hostname,proto3" json:"Hostname,omitempty"`
}

func (m *ReplyNatsData) Reset()                    { *m = ReplyNatsData{} }
func (m *ReplyNatsData) String() string            { return proto.CompactTextString(m) }
func (*ReplyNatsData) ProtoMessage()               {}
func (*ReplyNatsData) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{15} }

func (m *ReplyNatsData) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

func (m *ReplyNatsData) GetMessageId() int64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *ReplyNatsData) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

// 禁言某用戶
type BlockUser struct {
	UserId    int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	BlockTime int64 `protobuf:"varint,2,opt,name=blockTime,proto3" json:"blockTime,omitempty"`
	GroupId   int64 `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	Terminate bool  `protobuf:"varint,4,opt,name=terminate,proto3" json:"terminate,omitempty"`
}

func (m *BlockUser) Reset()                    { *m = BlockUser{} }
func (m *BlockUser) String() string            { return proto.CompactTextString(m) }
func (*BlockUser) ProtoMessage()               {}
func (*BlockUser) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{16} }

func (m *BlockUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BlockUser) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *BlockUser) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *BlockUser) GetTerminate() bool {
	if m != nil {
		return m.Terminate
	}
	return false
}

// 禁言多个用户
type BlockUserList struct {
	UserList []*BlockUser `protobuf:"bytes,1,rep,name=UserList" json:"UserList,omitempty"`
}

func (m *BlockUserList) Reset()                    { *m = BlockUserList{} }
func (m *BlockUserList) String() string            { return proto.CompactTextString(m) }
func (*BlockUserList) ProtoMessage()               {}
func (*BlockUserList) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{17} }

func (m *BlockUserList) GetUserList() []*BlockUser {
	if m != nil {
		return m.UserList
	}
	return nil
}

// 解禁某用戶
type UnBlockUserList struct {
	UserId   []int32      `protobuf:"varint,2,rep,packed,name=userId" json:"userId,omitempty"`
	UserList []*BlockUser `protobuf:"bytes,1,rep,name=UserList" json:"UserList,omitempty"`
	GroupId  int64        `protobuf:"varint,3,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
}

func (m *UnBlockUserList) Reset()         { *m = UnBlockUserList{} }
func (m *UnBlockUserList) String() string { return proto.CompactTextString(m) }
func (*UnBlockUserList) ProtoMessage()    {}
func (*UnBlockUserList) Descriptor() ([]byte, []int) {
	return fileDescriptorAdvertisemonitor, []int{18}
}

func (m *UnBlockUserList) GetUserId() []int32 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *UnBlockUserList) GetUserList() []*BlockUser {
	if m != nil {
		return m.UserList
	}
	return nil
}

func (m *UnBlockUserList) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

// IM向AdvertiseMonitor發送msg的結構體
type MsgInfo struct {
	UserID         int32  `protobuf:"varint,1,opt,name=UserID,proto3" json:"UserID,omitempty"`
	GroupId        int64  `protobuf:"varint,2,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	MessageContent string `protobuf:"bytes,3,opt,name=MessageContent,proto3" json:"MessageContent,omitempty"`
	Phone          string `protobuf:"bytes,4,opt,name=phone,proto3" json:"phone,omitempty"`
	ContentType    int32  `protobuf:"varint,5,opt,name=ContentType,proto3" json:"ContentType,omitempty"`
	ClientIp       string `protobuf:"bytes,6,opt,name=ClientIp,proto3" json:"ClientIp,omitempty"`
}

func (m *MsgInfo) Reset()                    { *m = MsgInfo{} }
func (m *MsgInfo) String() string            { return proto.CompactTextString(m) }
func (*MsgInfo) ProtoMessage()               {}
func (*MsgInfo) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{19} }

func (m *MsgInfo) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *MsgInfo) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *MsgInfo) GetMessageContent() string {
	if m != nil {
		return m.MessageContent
	}
	return ""
}

func (m *MsgInfo) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *MsgInfo) GetContentType() int32 {
	if m != nil {
		return m.ContentType
	}
	return 0
}

func (m *MsgInfo) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

// IM向AdvertiseMonitor發送msg list的結構體
type MsgInfoList struct {
	MsgInfoList []*MsgInfo `protobuf:"bytes,2,rep,name=MsgInfoList" json:"MsgInfoList,omitempty"`
}

func (m *MsgInfoList) Reset()                    { *m = MsgInfoList{} }
func (m *MsgInfoList) String() string            { return proto.CompactTextString(m) }
func (*MsgInfoList) ProtoMessage()               {}
func (*MsgInfoList) Descriptor() ([]byte, []int) { return fileDescriptorAdvertisemonitor, []int{20} }

func (m *MsgInfoList) GetMsgInfoList() []*MsgInfo {
	if m != nil {
		return m.MsgInfoList
	}
	return nil
}

func init() {
	proto.RegisterType((*ReqDelManualBlockList)(nil), "pbadvertisemonitor.ReqDelManualBlockList")
	proto.RegisterType((*ReqSetManualBlockList)(nil), "pbadvertisemonitor.ReqSetManualBlockList")
	proto.RegisterType((*ReqGetBlockList)(nil), "pbadvertisemonitor.ReqGetBlockList")
	proto.RegisterType((*ReplyGetBlockList)(nil), "pbadvertisemonitor.ReplyGetBlockList")
	proto.RegisterType((*ReqUnBlockBannedUser)(nil), "pbadvertisemonitor.ReqUnBlockBannedUser")
	proto.RegisterType((*ReqUnBlockAllUser)(nil), "pbadvertisemonitor.ReqUnBlockAllUser")
	proto.RegisterType((*MessageSendingLimit)(nil), "pbadvertisemonitor.MessageSendingLimit")
	proto.RegisterType((*MessageMaskWord)(nil), "pbadvertisemonitor.MessageMaskWord")
	proto.RegisterType((*ReqGetSendMessageRuleSettings)(nil), "pbadvertisemonitor.ReqGetSendMessageRuleSettings")
	proto.RegisterType((*SendMessageRuleSettings)(nil), "pbadvertisemonitor.SendMessageRuleSettings")
	proto.RegisterType((*ReplyGetSendMessageRuleSettings)(nil), "pbadvertisemonitor.ReplyGetSendMessageRuleSettings")
	proto.RegisterType((*ReqUpdateMessageSendingLimit)(nil), "pbadvertisemonitor.ReqUpdateMessageSendingLimit")
	proto.RegisterType((*ReqUpdateMessageMaskWord)(nil), "pbadvertisemonitor.ReqUpdateMessageMaskWord")
	proto.RegisterType((*ReplyData)(nil), "pbadvertisemonitor.ReplyData")
	proto.RegisterType((*ReqNatsData)(nil), "pbadvertisemonitor.ReqNatsData")
	proto.RegisterType((*ReplyNatsData)(nil), "pbadvertisemonitor.ReplyNatsData")
	proto.RegisterType((*BlockUser)(nil), "pbadvertisemonitor.BlockUser")
	proto.RegisterType((*BlockUserList)(nil), "pbadvertisemonitor.BlockUserList")
	proto.RegisterType((*UnBlockUserList)(nil), "pbadvertisemonitor.UnBlockUserList")
	proto.RegisterType((*MsgInfo)(nil), "pbadvertisemonitor.MsgInfo")
	proto.RegisterType((*MsgInfoList)(nil), "pbadvertisemonitor.MsgInfoList")
	proto.RegisterEnum("pbadvertisemonitor.ProtocolType", ProtocolType_name, ProtocolType_value)
	proto.RegisterEnum("pbadvertisemonitor.BlockListType", BlockListType_name, BlockListType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AdvertiseMonitor service

type AdvertiseMonitorClient interface {
	// 獲取所有禁言用戶
	GetBlockList(ctx context.Context, in *ReqGetBlockList, opts ...grpc.CallOption) (*ReplyGetBlockList, error)
	// 解除單個用户限制
	UnBlockSingleUser(ctx context.Context, in *ReqUnBlockBannedUser, opts ...grpc.CallOption) (*ReplyData, error)
	// 解除所有用户限制
	UnBlockAllUser(ctx context.Context, in *ReqUnBlockAllUser, opts ...grpc.CallOption) (*ReplyData, error)
	// 獲取群成員消息發送條件限制
	GetSendMessageRuleSettings(ctx context.Context, in *ReqGetSendMessageRuleSettings, opts ...grpc.CallOption) (*ReplyGetSendMessageRuleSettings, error)
	// 設定某個群的發消息規則
	UpdateMessageSendingLimit(ctx context.Context, in *ReqUpdateMessageSendingLimit, opts ...grpc.CallOption) (*ReplyData, error)
	// 設定某個群的發消息規則
	UpdateMessageMaskWord(ctx context.Context, in *ReqUpdateMessageMaskWord, opts ...grpc.CallOption) (*ReplyData, error)
	// 新增手動禁言名單
	SetManualBlockList(ctx context.Context, in *ReqSetManualBlockList, opts ...grpc.CallOption) (*ReplyData, error)
	// 刪除手動禁言名單
	DelManualBlockList(ctx context.Context, in *ReqDelManualBlockList, opts ...grpc.CallOption) (*ReplyData, error)
}

type advertiseMonitorClient struct {
	cc *grpc.ClientConn
}

func NewAdvertiseMonitorClient(cc *grpc.ClientConn) AdvertiseMonitorClient {
	return &advertiseMonitorClient{cc}
}

func (c *advertiseMonitorClient) GetBlockList(ctx context.Context, in *ReqGetBlockList, opts ...grpc.CallOption) (*ReplyGetBlockList, error) {
	out := new(ReplyGetBlockList)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/GetBlockList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advertiseMonitorClient) UnBlockSingleUser(ctx context.Context, in *ReqUnBlockBannedUser, opts ...grpc.CallOption) (*ReplyData, error) {
	out := new(ReplyData)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/UnBlockSingleUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advertiseMonitorClient) UnBlockAllUser(ctx context.Context, in *ReqUnBlockAllUser, opts ...grpc.CallOption) (*ReplyData, error) {
	out := new(ReplyData)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/UnBlockAllUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advertiseMonitorClient) GetSendMessageRuleSettings(ctx context.Context, in *ReqGetSendMessageRuleSettings, opts ...grpc.CallOption) (*ReplyGetSendMessageRuleSettings, error) {
	out := new(ReplyGetSendMessageRuleSettings)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/GetSendMessageRuleSettings", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advertiseMonitorClient) UpdateMessageSendingLimit(ctx context.Context, in *ReqUpdateMessageSendingLimit, opts ...grpc.CallOption) (*ReplyData, error) {
	out := new(ReplyData)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/UpdateMessageSendingLimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advertiseMonitorClient) UpdateMessageMaskWord(ctx context.Context, in *ReqUpdateMessageMaskWord, opts ...grpc.CallOption) (*ReplyData, error) {
	out := new(ReplyData)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/UpdateMessageMaskWord", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advertiseMonitorClient) SetManualBlockList(ctx context.Context, in *ReqSetManualBlockList, opts ...grpc.CallOption) (*ReplyData, error) {
	out := new(ReplyData)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/SetManualBlockList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *advertiseMonitorClient) DelManualBlockList(ctx context.Context, in *ReqDelManualBlockList, opts ...grpc.CallOption) (*ReplyData, error) {
	out := new(ReplyData)
	err := grpc.Invoke(ctx, "/pbadvertisemonitor.AdvertiseMonitor/DelManualBlockList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AdvertiseMonitor service

type AdvertiseMonitorServer interface {
	// 獲取所有禁言用戶
	GetBlockList(context.Context, *ReqGetBlockList) (*ReplyGetBlockList, error)
	// 解除單個用户限制
	UnBlockSingleUser(context.Context, *ReqUnBlockBannedUser) (*ReplyData, error)
	// 解除所有用户限制
	UnBlockAllUser(context.Context, *ReqUnBlockAllUser) (*ReplyData, error)
	// 獲取群成員消息發送條件限制
	GetSendMessageRuleSettings(context.Context, *ReqGetSendMessageRuleSettings) (*ReplyGetSendMessageRuleSettings, error)
	// 設定某個群的發消息規則
	UpdateMessageSendingLimit(context.Context, *ReqUpdateMessageSendingLimit) (*ReplyData, error)
	// 設定某個群的發消息規則
	UpdateMessageMaskWord(context.Context, *ReqUpdateMessageMaskWord) (*ReplyData, error)
	// 新增手動禁言名單
	SetManualBlockList(context.Context, *ReqSetManualBlockList) (*ReplyData, error)
	// 刪除手動禁言名單
	DelManualBlockList(context.Context, *ReqDelManualBlockList) (*ReplyData, error)
}

func RegisterAdvertiseMonitorServer(s *grpc.Server, srv AdvertiseMonitorServer) {
	s.RegisterService(&_AdvertiseMonitor_serviceDesc, srv)
}

func _AdvertiseMonitor_GetBlockList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetBlockList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).GetBlockList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/GetBlockList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).GetBlockList(ctx, req.(*ReqGetBlockList))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvertiseMonitor_UnBlockSingleUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUnBlockBannedUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).UnBlockSingleUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/UnBlockSingleUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).UnBlockSingleUser(ctx, req.(*ReqUnBlockBannedUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvertiseMonitor_UnBlockAllUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUnBlockAllUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).UnBlockAllUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/UnBlockAllUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).UnBlockAllUser(ctx, req.(*ReqUnBlockAllUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvertiseMonitor_GetSendMessageRuleSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetSendMessageRuleSettings)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).GetSendMessageRuleSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/GetSendMessageRuleSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).GetSendMessageRuleSettings(ctx, req.(*ReqGetSendMessageRuleSettings))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvertiseMonitor_UpdateMessageSendingLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUpdateMessageSendingLimit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).UpdateMessageSendingLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/UpdateMessageSendingLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).UpdateMessageSendingLimit(ctx, req.(*ReqUpdateMessageSendingLimit))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvertiseMonitor_UpdateMessageMaskWord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqUpdateMessageMaskWord)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).UpdateMessageMaskWord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/UpdateMessageMaskWord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).UpdateMessageMaskWord(ctx, req.(*ReqUpdateMessageMaskWord))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvertiseMonitor_SetManualBlockList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqSetManualBlockList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).SetManualBlockList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/SetManualBlockList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).SetManualBlockList(ctx, req.(*ReqSetManualBlockList))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdvertiseMonitor_DelManualBlockList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqDelManualBlockList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdvertiseMonitorServer).DelManualBlockList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pbadvertisemonitor.AdvertiseMonitor/DelManualBlockList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdvertiseMonitorServer).DelManualBlockList(ctx, req.(*ReqDelManualBlockList))
	}
	return interceptor(ctx, in, info, handler)
}

var _AdvertiseMonitor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pbadvertisemonitor.AdvertiseMonitor",
	HandlerType: (*AdvertiseMonitorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlockList",
			Handler:    _AdvertiseMonitor_GetBlockList_Handler,
		},
		{
			MethodName: "UnBlockSingleUser",
			Handler:    _AdvertiseMonitor_UnBlockSingleUser_Handler,
		},
		{
			MethodName: "UnBlockAllUser",
			Handler:    _AdvertiseMonitor_UnBlockAllUser_Handler,
		},
		{
			MethodName: "GetSendMessageRuleSettings",
			Handler:    _AdvertiseMonitor_GetSendMessageRuleSettings_Handler,
		},
		{
			MethodName: "UpdateMessageSendingLimit",
			Handler:    _AdvertiseMonitor_UpdateMessageSendingLimit_Handler,
		},
		{
			MethodName: "UpdateMessageMaskWord",
			Handler:    _AdvertiseMonitor_UpdateMessageMaskWord_Handler,
		},
		{
			MethodName: "SetManualBlockList",
			Handler:    _AdvertiseMonitor_SetManualBlockList_Handler,
		},
		{
			MethodName: "DelManualBlockList",
			Handler:    _AdvertiseMonitor_DelManualBlockList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/advertisemonitor/advertisemonitor.proto",
}

func (m *ReqDelManualBlockList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDelManualBlockList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UnBlockUser != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.UnBlockUser.Size()))
		n1, err := m.UnBlockUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.BotId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.BotId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.Debug.Size()))
		n2, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ReqSetManualBlockList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqSetManualBlockList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockUser != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.BlockUser.Size()))
		n3, err := m.BlockUser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.BotId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.BotId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.Debug.Size()))
		n4, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ReqGetBlockList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetBlockList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReplyGetBlockList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetBlockList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BlockUserList) > 0 {
		for _, msg := range m.BlockUserList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvertisemonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqUnBlockBannedUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUnBlockBannedUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA6 := make([]byte, len(m.UserId)*10)
		var j5 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *ReqUnBlockAllUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUnBlockAllUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MessageSendingLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageSendingLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DuringTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.DuringTime))
	}
	if m.MaxMsgCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.MaxMsgCount))
	}
	if m.BlockTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.BlockTime))
	}
	return i, nil
}

func (m *MessageMaskWord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageMaskWord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MaskWord) > 0 {
		for _, s := range m.MaskWord {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ReqGetSendMessageRuleSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetSendMessageRuleSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.GroupId))
	}
	return i, nil
}

func (m *SendMessageRuleSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMessageRuleSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.GroupId))
	}
	if m.MessageSendingLimit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.MessageSendingLimit.Size()))
		n7, err := m.MessageSendingLimit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.MessageMaskWord != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.MessageMaskWord.Size()))
		n8, err := m.MessageMaskWord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *ReplyGetSendMessageRuleSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetSendMessageRuleSettings) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendMessageRuleSettings != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.SendMessageRuleSettings.Size()))
		n9, err := m.SendMessageRuleSettings.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *ReqUpdateMessageSendingLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateMessageSendingLimit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.UserId))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.GroupId))
	}
	if m.MessageSendingLimit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.MessageSendingLimit.Size()))
		n10, err := m.MessageSendingLimit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *ReqUpdateMessageMaskWord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqUpdateMessageMaskWord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.UserId))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.GroupId))
	}
	if m.MessageMaskWord != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.MessageMaskWord.Size()))
		n11, err := m.MessageMaskWord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *ReplyData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReplyData) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(len(m.ReplyData)))
		i += copy(dAtA[i:], m.ReplyData)
	}
	if m.Reply {
		dAtA[i] = 0x10
		i++
		if m.Reply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqNatsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqNatsData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.Type))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.MessageId))
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.BlockListType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.BlockListType))
	}
	return i, nil
}

func (m *ReplyNatsData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyNatsData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Enable {
		dAtA[i] = 0x8
		i++
		if m.Enable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.MessageId))
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	return i, nil
}

func (m *BlockUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.UserId))
	}
	if m.BlockTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.BlockTime))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.GroupId))
	}
	if m.Terminate {
		dAtA[i] = 0x20
		i++
		if m.Terminate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BlockUserList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockUserList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserList) > 0 {
		for _, msg := range m.UserList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvertisemonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UnBlockUserList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnBlockUserList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserList) > 0 {
		for _, msg := range m.UserList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAdvertisemonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UserId) > 0 {
		dAtA13 := make([]byte, len(m.UserId)*10)
		var j12 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.GroupId))
	}
	return i, nil
}

func (m *MsgInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.UserID))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.GroupId))
	}
	if len(m.MessageContent) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(len(m.MessageContent)))
		i += copy(dAtA[i:], m.MessageContent)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.ContentType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(m.ContentType))
	}
	if len(m.ClientIp) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAdvertisemonitor(dAtA, i, uint64(len(m.ClientIp)))
		i += copy(dAtA[i:], m.ClientIp)
	}
	return i, nil
}

func (m *MsgInfoList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInfoList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MsgInfoList) > 0 {
		for _, msg := range m.MsgInfoList {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAdvertisemonitor(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintAdvertisemonitor(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ReqDelManualBlockList) Size() (n int) {
	var l int
	_ = l
	if m.UnBlockUser != nil {
		l = m.UnBlockUser.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	if m.BotId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.BotId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *ReqSetManualBlockList) Size() (n int) {
	var l int
	_ = l
	if m.BlockUser != nil {
		l = m.BlockUser.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	if m.BotId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.BotId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *ReqGetBlockList) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReplyGetBlockList) Size() (n int) {
	var l int
	_ = l
	if len(m.BlockUserList) > 0 {
		for _, e := range m.BlockUserList {
			l = e.Size()
			n += 1 + l + sovAdvertisemonitor(uint64(l))
		}
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqUnBlockBannedUser) Size() (n int) {
	var l int
	_ = l
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovAdvertisemonitor(uint64(e))
		}
		n += 1 + sovAdvertisemonitor(uint64(l)) + l
	}
	return n
}

func (m *ReqUnBlockAllUser) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *MessageSendingLimit) Size() (n int) {
	var l int
	_ = l
	if m.DuringTime != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.DuringTime))
	}
	if m.MaxMsgCount != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.MaxMsgCount))
	}
	if m.BlockTime != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.BlockTime))
	}
	return n
}

func (m *MessageMaskWord) Size() (n int) {
	var l int
	_ = l
	if len(m.MaskWord) > 0 {
		for _, s := range m.MaskWord {
			l = len(s)
			n += 1 + l + sovAdvertisemonitor(uint64(l))
		}
	}
	return n
}

func (m *ReqGetSendMessageRuleSettings) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.GroupId))
	}
	return n
}

func (m *SendMessageRuleSettings) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.GroupId))
	}
	if m.MessageSendingLimit != nil {
		l = m.MessageSendingLimit.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	if m.MessageMaskWord != nil {
		l = m.MessageMaskWord.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *ReplyGetSendMessageRuleSettings) Size() (n int) {
	var l int
	_ = l
	if m.SendMessageRuleSettings != nil {
		l = m.SendMessageRuleSettings.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *ReqUpdateMessageSendingLimit) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.UserId))
	}
	if m.GroupId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.GroupId))
	}
	if m.MessageSendingLimit != nil {
		l = m.MessageSendingLimit.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *ReqUpdateMessageMaskWord) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.UserId))
	}
	if m.GroupId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.GroupId))
	}
	if m.MessageMaskWord != nil {
		l = m.MessageMaskWord.Size()
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *ReplyData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReplyData)
	if l > 0 {
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	if m.Reply {
		n += 2
	}
	if m.ErrorCode != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqNatsData) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.MessageId))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	if m.BlockListType != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.BlockListType))
	}
	return n
}

func (m *ReplyNatsData) Size() (n int) {
	var l int
	_ = l
	if m.Enable {
		n += 2
	}
	if m.MessageId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.MessageId))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *BlockUser) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.UserId))
	}
	if m.BlockTime != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.BlockTime))
	}
	if m.GroupId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.GroupId))
	}
	if m.Terminate {
		n += 2
	}
	return n
}

func (m *BlockUserList) Size() (n int) {
	var l int
	_ = l
	if len(m.UserList) > 0 {
		for _, e := range m.UserList {
			l = e.Size()
			n += 1 + l + sovAdvertisemonitor(uint64(l))
		}
	}
	return n
}

func (m *UnBlockUserList) Size() (n int) {
	var l int
	_ = l
	if len(m.UserList) > 0 {
		for _, e := range m.UserList {
			l = e.Size()
			n += 1 + l + sovAdvertisemonitor(uint64(l))
		}
	}
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovAdvertisemonitor(uint64(e))
		}
		n += 1 + sovAdvertisemonitor(uint64(l)) + l
	}
	if m.GroupId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.GroupId))
	}
	return n
}

func (m *MsgInfo) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.UserID))
	}
	if m.GroupId != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.GroupId))
	}
	l = len(m.MessageContent)
	if l > 0 {
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	if m.ContentType != 0 {
		n += 1 + sovAdvertisemonitor(uint64(m.ContentType))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovAdvertisemonitor(uint64(l))
	}
	return n
}

func (m *MsgInfoList) Size() (n int) {
	var l int
	_ = l
	if len(m.MsgInfoList) > 0 {
		for _, e := range m.MsgInfoList {
			l = e.Size()
			n += 1 + l + sovAdvertisemonitor(uint64(l))
		}
	}
	return n
}

func sovAdvertisemonitor(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAdvertisemonitor(x uint64) (n int) {
	return sovAdvertisemonitor(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReqDelManualBlockList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDelManualBlockList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDelManualBlockList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnBlockUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnBlockUser == nil {
				m.UnBlockUser = &BlockUser{}
			}
			if err := m.UnBlockUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqSetManualBlockList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqSetManualBlockList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqSetManualBlockList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockUser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockUser == nil {
				m.BlockUser = &BlockUser{}
			}
			if err := m.BlockUser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BotId", wireType)
			}
			m.BotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetBlockList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetBlockList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetBlockList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetBlockList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetBlockList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetBlockList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockUserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockUserList = append(m.BlockUserList, &BlockUser{})
			if err := m.BlockUserList[len(m.BlockUserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUnBlockBannedUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUnBlockBannedUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUnBlockBannedUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvertisemonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvertisemonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdvertisemonitor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvertisemonitor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUnBlockAllUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUnBlockAllUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUnBlockAllUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageSendingLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageSendingLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageSendingLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DuringTime", wireType)
			}
			m.DuringTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DuringTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgCount", wireType)
			}
			m.MaxMsgCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageMaskWord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageMaskWord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageMaskWord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaskWord", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaskWord = append(m.MaskWord, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetSendMessageRuleSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetSendMessageRuleSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetSendMessageRuleSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMessageRuleSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMessageRuleSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMessageRuleSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageSendingLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageSendingLimit == nil {
				m.MessageSendingLimit = &MessageSendingLimit{}
			}
			if err := m.MessageSendingLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageMaskWord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageMaskWord == nil {
				m.MessageMaskWord = &MessageMaskWord{}
			}
			if err := m.MessageMaskWord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetSendMessageRuleSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetSendMessageRuleSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetSendMessageRuleSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMessageRuleSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SendMessageRuleSettings == nil {
				m.SendMessageRuleSettings = &SendMessageRuleSettings{}
			}
			if err := m.SendMessageRuleSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateMessageSendingLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateMessageSendingLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateMessageSendingLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageSendingLimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageSendingLimit == nil {
				m.MessageSendingLimit = &MessageSendingLimit{}
			}
			if err := m.MessageSendingLimit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqUpdateMessageMaskWord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqUpdateMessageMaskWord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqUpdateMessageMaskWord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageMaskWord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageMaskWord == nil {
				m.MessageMaskWord = &MessageMaskWord{}
			}
			if err := m.MessageMaskWord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyData = append(m.ReplyData[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyData == nil {
				m.ReplyData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reply = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqNatsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqNatsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqNatsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (ProtocolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockListType", wireType)
			}
			m.BlockListType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockListType |= (BlockListType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyNatsData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyNatsData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyNatsData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockTime", wireType)
			}
			m.BlockTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockUserList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockUserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockUserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserList = append(m.UserList, &BlockUser{})
			if err := m.UserList[len(m.UserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnBlockUserList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnBlockUserList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnBlockUserList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserList = append(m.UserList, &BlockUser{})
			if err := m.UserList[len(m.UserList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvertisemonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdvertisemonitor
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAdvertisemonitor
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdvertisemonitor
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			m.ContentType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInfoList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInfoList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInfoList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgInfoList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgInfoList = append(m.MsgInfoList, &MsgInfo{})
			if err := m.MsgInfoList[len(m.MsgInfoList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdvertisemonitor(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAdvertisemonitor
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdvertisemonitor(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdvertisemonitor
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdvertisemonitor
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAdvertisemonitor
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAdvertisemonitor
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAdvertisemonitor(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAdvertisemonitor = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdvertisemonitor   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/advertisemonitor/advertisemonitor.proto", fileDescriptorAdvertisemonitor)
}

var fileDescriptorAdvertisemonitor = []byte{
	// 1165 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4f, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0xda, 0xb1, 0x6b, 0x3f, 0xe7, 0xef, 0xe4, 0x9f, 0xeb, 0x26, 0xa9, 0xd9, 0xaa, 0x10,
	0x0a, 0x38, 0x90, 0x72, 0xa9, 0x2a, 0x84, 0x1a, 0xa7, 0x04, 0xa3, 0x38, 0x54, 0x93, 0x54, 0x50,
	0xa9, 0x50, 0x76, 0xb3, 0x13, 0x77, 0xd5, 0xf5, 0xcc, 0x66, 0x77, 0x1c, 0x91, 0x0b, 0x47, 0xc4,
	0x91, 0x03, 0x17, 0xc4, 0x47, 0xe0, 0x03, 0xf0, 0x15, 0xb8, 0xc1, 0x19, 0x09, 0x09, 0xe5, 0x93,
	0xa0, 0x99, 0x9d, 0x5d, 0xef, 0xae, 0x77, 0xed, 0x44, 0xed, 0xc9, 0x7e, 0x6f, 0xde, 0x9f, 0xdf,
	0xfb, 0x33, 0x6f, 0xde, 0xc2, 0x41, 0xcf, 0xe6, 0x8e, 0x61, 0xb6, 0x4e, 0x5e, 0x1a, 0xdc, 0x27,
	0xde, 0x39, 0xf1, 0x5a, 0x76, 0x7f, 0xdb, 0xa6, 0x9c, 0x78, 0xa7, 0xc6, 0x09, 0x71, 0x3d, 0x66,
	0x0e, 0x4e, 0xb7, 0x0d, 0xeb, 0x9c, 0x78, 0xdc, 0xf6, 0x49, 0x9f, 0x51, 0x9b, 0x33, 0x6f, 0x84,
	0xd1, 0x72, 0x3d, 0xc6, 0x19, 0x42, 0xae, 0x99, 0x3e, 0x69, 0x3c, 0xcc, 0xf6, 0xd0, 0xdf, 0x76,
	0x19, 0x37, 0x38, 0x93, 0x8a, 0xe6, 0xe0, 0xd4, 0xdf, 0x76, 0xcd, 0x13, 0xd6, 0xef, 0xab, 0x9f,
	0xc0, 0xa0, 0xfe, 0x8b, 0x06, 0x2b, 0x98, 0x9c, 0xed, 0x11, 0xa7, 0x6b, 0xd0, 0x81, 0xe1, 0xec,
	0x3a, 0xec, 0xe4, 0xd5, 0x81, 0xed, 0x73, 0xf4, 0x29, 0xd4, 0x9e, 0x52, 0x49, 0x3e, 0xf5, 0x89,
	0x57, 0xd7, 0x9a, 0xda, 0x56, 0x6d, 0x67, 0xa3, 0x35, 0x0a, 0xa0, 0x15, 0x09, 0xe1, 0xb8, 0x06,
	0x5a, 0x81, 0xb2, 0xc9, 0xf8, 0x0b, 0xdb, 0xaa, 0x17, 0x9a, 0xda, 0x56, 0x09, 0x97, 0x4c, 0xc6,
	0x3b, 0x16, 0xba, 0x03, 0x25, 0x8b, 0x98, 0x83, 0x5e, 0xbd, 0x28, 0x2d, 0xce, 0xb6, 0x14, 0x9e,
	0x3d, 0xc1, 0xc4, 0xc1, 0x99, 0xfe, 0x73, 0x00, 0xeb, 0x88, 0xf0, 0x34, 0xac, 0x87, 0x50, 0xbd,
	0x26, 0xa8, 0xea, 0x9b, 0x81, 0xb4, 0x08, 0xf3, 0x98, 0x9c, 0xed, 0x13, 0x1e, 0x61, 0xd1, 0xcf,
	0x61, 0x11, 0x13, 0xd7, 0xb9, 0x88, 0x33, 0x51, 0x1b, 0x66, 0x23, 0x87, 0x82, 0x51, 0xd7, 0x9a,
	0xc5, 0xc9, 0x20, 0x93, 0x3a, 0x68, 0x1d, 0xaa, 0xc4, 0xf3, 0x98, 0xd7, 0x66, 0x16, 0x51, 0x58,
	0x87, 0x0c, 0xbd, 0x05, 0xcb, 0x98, 0x9c, 0xa9, 0x5c, 0xef, 0x1a, 0x94, 0x12, 0x4b, 0x86, 0xb7,
	0x0a, 0xe5, 0x81, 0x4f, 0xbc, 0x8e, 0x25, 0x7d, 0x96, 0xb0, 0xa2, 0xf4, 0x25, 0x81, 0x33, 0x94,
	0x7f, 0xe4, 0x38, 0x42, 0x58, 0x1f, 0xc0, 0x52, 0x97, 0xf8, 0xbe, 0xd1, 0x23, 0x47, 0x84, 0x5a,
	0x36, 0xed, 0x1d, 0xd8, 0x7d, 0x9b, 0xa3, 0x4d, 0x80, 0xbd, 0x81, 0x67, 0xd3, 0xde, 0xb1, 0xdd,
	0x27, 0x32, 0x21, 0x45, 0x1c, 0xe3, 0xa0, 0x26, 0xd4, 0xba, 0xc6, 0xf7, 0x5d, 0xbf, 0xd7, 0x66,
	0x03, 0xca, 0xeb, 0xd3, 0x12, 0x5b, 0x9c, 0x25, 0xb0, 0x4b, 0x47, 0xd2, 0x40, 0x49, 0x1a, 0x18,
	0x32, 0xf4, 0x0f, 0x60, 0x5e, 0xb9, 0xed, 0x1a, 0xfe, 0xab, 0xaf, 0x98, 0x67, 0xa1, 0x06, 0x54,
	0xc2, 0xff, 0x12, 0x78, 0x15, 0x47, 0xb4, 0xfe, 0x00, 0x36, 0x82, 0xac, 0x0b, 0x90, 0x4a, 0x11,
	0x0f, 0x1c, 0x72, 0x44, 0x38, 0xb7, 0x69, 0xcf, 0x47, 0x75, 0xb8, 0xb1, 0xef, 0xb1, 0x81, 0x2b,
	0x83, 0x16, 0xbe, 0x42, 0x52, 0xff, 0x57, 0x83, 0xb5, 0x6b, 0x6b, 0xa1, 0x67, 0x99, 0x69, 0x91,
	0x35, 0xa8, 0xed, 0xbc, 0x93, 0x55, 0xc4, 0x0c, 0x71, 0x9c, 0x99, 0xda, 0xee, 0x48, 0xe8, 0xaa,
	0xe1, 0xee, 0x8c, 0x31, 0x1b, 0x8a, 0xe2, 0xb4, 0xae, 0xfe, 0x93, 0x06, 0xb7, 0xc3, 0xf6, 0xcb,
	0x8b, 0x93, 0xe4, 0xa6, 0x40, 0xdd, 0x9d, 0xf7, 0xb2, 0x5c, 0xe7, 0xa8, 0xe0, 0x3c, 0x5b, 0xfa,
	0xef, 0x1a, 0xac, 0x8b, 0x0e, 0x73, 0x2d, 0x83, 0x93, 0xac, 0xd0, 0xe3, 0x9d, 0xa9, 0x0d, 0x3b,
	0x33, 0x5e, 0x87, 0xc2, 0x95, 0xea, 0x50, 0x7c, 0xfd, 0x3a, 0xe8, 0xbf, 0x69, 0x50, 0x4f, 0xa3,
	0x8d, 0x9a, 0xf1, 0xfa, 0x48, 0xdf, 0x70, 0x59, 0xbf, 0x81, 0xaa, 0xac, 0xea, 0x9e, 0xc1, 0x0d,
	0x71, 0x97, 0xbc, 0x90, 0x90, 0x80, 0x66, 0xf0, 0x90, 0x81, 0x96, 0xa1, 0x24, 0x09, 0x89, 0xa8,
	0x82, 0x03, 0x22, 0x39, 0x3b, 0x8a, 0xe9, 0xd9, 0xf1, 0x8f, 0x06, 0x35, 0x4c, 0xce, 0x0e, 0x0d,
	0xee, 0x4b, 0x1b, 0x1f, 0xc3, 0xf4, 0xf1, 0x85, 0x4b, 0xa4, 0xf1, 0xb9, 0x9d, 0x66, 0x16, 0xe4,
	0x27, 0xe2, 0xa5, 0x38, 0x61, 0x8e, 0x90, 0xc3, 0x52, 0x1a, 0x21, 0x98, 0xb6, 0x04, 0xa4, 0x82,
	0x84, 0x24, 0xff, 0x0b, 0xbf, 0x2a, 0x96, 0x8e, 0xa5, 0x06, 0xc7, 0x90, 0x21, 0x2e, 0xf9, 0xe7,
	0xcc, 0xe7, 0xd4, 0xe8, 0x13, 0x39, 0x34, 0xaa, 0x38, 0xa2, 0xd1, 0xbe, 0x1a, 0x99, 0x62, 0xf4,
	0x49, 0x30, 0x25, 0x09, 0xe6, 0xad, 0xdc, 0x91, 0x19, 0x0a, 0xe2, 0xa4, 0x9e, 0x6e, 0xc0, 0xac,
	0xcc, 0x5d, 0x14, 0xdd, 0x2a, 0x94, 0x1f, 0x53, 0xc3, 0x74, 0x82, 0xf8, 0x2a, 0x58, 0x51, 0x49,
	0xac, 0x85, 0x71, 0x58, 0x8b, 0x49, 0xac, 0xfa, 0x45, 0xec, 0xfd, 0xc9, 0x6d, 0x96, 0x75, 0xa8,
	0x9a, 0xd1, 0x08, 0x54, 0xe6, 0x23, 0x86, 0x68, 0xa5, 0x9e, 0x6a, 0xa5, 0x20, 0x4d, 0x21, 0x29,
	0xf4, 0x38, 0xf1, 0xfa, 0x36, 0x35, 0x78, 0x90, 0xa5, 0x0a, 0x1e, 0x32, 0xf4, 0x2f, 0x52, 0x2f,
	0x0b, 0x7a, 0x00, 0x95, 0xeb, 0xbd, 0x32, 0x91, 0xb8, 0xfe, 0x03, 0xcc, 0xc7, 0xde, 0xea, 0xd7,
	0xb4, 0x16, 0xcb, 0x43, 0x21, 0xfe, 0xf0, 0xc4, 0x2f, 0x4d, 0x31, 0x39, 0x9c, 0xff, 0xd0, 0xe0,
	0x46, 0xd7, 0xef, 0x75, 0xe8, 0x29, 0x13, 0xda, 0xc2, 0x52, 0x67, 0x2f, 0xcc, 0x62, 0x40, 0x8d,
	0xb9, 0x72, 0x6f, 0xc3, 0x9c, 0xaa, 0x56, 0x9b, 0x51, 0x4e, 0x28, 0x57, 0x65, 0x4a, 0x71, 0xc5,
	0x05, 0x71, 0x5f, 0x32, 0x1a, 0x76, 0x5c, 0x40, 0x88, 0x27, 0x4c, 0x09, 0x44, 0xcd, 0x56, 0xc2,
	0x71, 0x96, 0x68, 0x80, 0xb6, 0x63, 0x13, 0xca, 0x3b, 0x6e, 0xbd, 0x1c, 0x34, 0x40, 0x48, 0xeb,
	0x07, 0x50, 0x53, 0xc0, 0x65, 0xe8, 0x9f, 0x24, 0x48, 0x19, 0x7f, 0x6d, 0xe7, 0x56, 0xe6, 0xcd,
	0x0f, 0xc4, 0x70, 0x5c, 0xfe, 0xde, 0xaf, 0x05, 0x98, 0x89, 0xdf, 0x2f, 0xb4, 0x0a, 0x28, 0x51,
	0x96, 0x17, 0xc7, 0xcf, 0x9e, 0x3c, 0x5e, 0x98, 0x42, 0x75, 0x58, 0x4e, 0x15, 0x2c, 0x38, 0xd1,
	0xd0, 0x02, 0xcc, 0x28, 0x8b, 0x01, 0xa7, 0x80, 0x96, 0x61, 0x21, 0xe6, 0x23, 0xe0, 0x16, 0xd1,
	0x1a, 0x2c, 0x25, 0x57, 0x80, 0xe0, 0x60, 0x1a, 0xdd, 0x84, 0x15, 0x75, 0x20, 0xf3, 0x3b, 0x3c,
	0x2a, 0xa1, 0x4d, 0x68, 0x24, 0x7d, 0xb6, 0xbf, 0x3c, 0xfc, 0xac, 0x83, 0xbb, 0xc1, 0x79, 0x19,
	0x35, 0x61, 0x3d, 0x8d, 0x2a, 0x21, 0x71, 0x43, 0xe0, 0x0e, 0xd1, 0x25, 0x4e, 0x2a, 0xe8, 0x36,
	0xdc, 0x4a, 0xe1, 0x49, 0x08, 0x54, 0xef, 0x3d, 0x4f, 0x8d, 0x05, 0x61, 0xeb, 0x90, 0x79, 0xfd,
	0xd8, 0x3a, 0x18, 0xcb, 0x4e, 0x6a, 0x51, 0x0c, 0xb3, 0xb3, 0x06, 0x4b, 0x32, 0xaa, 0xd4, 0x41,
	0x61, 0xe7, 0xaf, 0x32, 0x2c, 0x3c, 0x0a, 0x6b, 0xd4, 0x0d, 0x6a, 0x84, 0x9e, 0xc3, 0x4c, 0x62,
	0x99, 0xcb, 0x1c, 0xe1, 0xa9, 0x35, 0xb0, 0x71, 0x37, 0x5b, 0x28, 0xb5, 0x18, 0xea, 0x53, 0xe8,
	0x5b, 0x58, 0x54, 0x11, 0x1f, 0xd9, 0xb4, 0xe7, 0x10, 0x39, 0x43, 0xb6, 0x72, 0x5c, 0x8c, 0xac,
	0x77, 0x8d, 0x8d, 0x5c, 0x3f, 0x62, 0xd6, 0xe9, 0x53, 0xe8, 0x6b, 0x98, 0x4b, 0x66, 0x14, 0xdd,
	0x1d, 0x6f, 0x5c, 0x89, 0x4d, 0xb6, 0xfc, 0xa3, 0x06, 0x8d, 0x31, 0x6b, 0xc6, 0x47, 0xf9, 0x69,
	0xca, 0x51, 0x69, 0xdc, 0x1f, 0x97, 0xb4, 0xbc, 0x3d, 0x63, 0x0a, 0x51, 0xb8, 0x99, 0xbf, 0x65,
	0x7c, 0x98, 0x17, 0x6d, 0x9e, 0xc6, 0xe4, 0xc0, 0x4f, 0x61, 0x25, 0x7b, 0x4f, 0x78, 0xff, 0x2a,
	0xbe, 0x42, 0xe9, 0xc9, 0x7e, 0xbe, 0x03, 0x94, 0xf1, 0xb1, 0xf3, 0x6e, 0x8e, 0x93, 0x51, 0xd1,
	0x2b, 0x79, 0xc8, 0xf8, 0xca, 0xcb, 0xf3, 0x30, 0x2a, 0x3a, 0xd1, 0xc3, 0xee, 0xcc, 0x9f, 0x97,
	0x9b, 0xda, 0xdf, 0x97, 0x9b, 0xda, 0x7f, 0x97, 0x9b, 0x9a, 0x59, 0x96, 0x1f, 0x98, 0xf7, 0xff,
	0x0f, 0x00, 0x00, 0xff, 0xff, 0x81, 0x77, 0xa2, 0xa5, 0x01, 0x0f, 0x00, 0x00,
}
