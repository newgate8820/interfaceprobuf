// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hbase.proto

/*
Package channeldbold is a generated protocol buffer package.

It is generated from these files:

	hbase.proto

It has these top-level messages:

	ChannelMsgId
	MsgsAndMaxId
	ReplyErr
	UserMsg
	Combination
	MentionStatus
	UserMsgListAndPts
	GetChannelMediaMessageHistoryByMediaConfig
	GetChannelMsgIdReq
	GetChannelMsgIdResp
	DeleteChannelMessageReq
	DeleteChannelMessageResp
	DeleteMsgsReq
	DeleteMsgsResp
	DeleteUserHistoryReq
	DeleteUserHistoryResp
	DeleteChannelMsgReq
	GetChannelMessageReq
	GetChannelMessageResp
	GetChannelMsgsByMsgIdsReq
	GetChannelMsgsByMsgIdsResp
	GetChannelMsgHistoryReq
	GetChannelMsgHistoryResp
	GetChannelTopMsgReq
	GetChannelTopMsgResp
	GetMessageHistoryPageByMediaConfig
	GetChannelMediaMessageHistoryByMediaReq
	GetChannelMediaMessageHistoryByMediaResp
	SearchChannelMsgReq
	SearchChannelMsgResp
*/
package channeldbold

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 数据库类型
type DATABASETYPE int32

const (
	DATABASETYPE__        DATABASETYPE = 0
	DATABASETYPE_UN_ENCRY DATABASETYPE = 1
	DATABASETYPE_ENCRY    DATABASETYPE = 2
	DATABASETYPE_VIP      DATABASETYPE = 4
)

var DATABASETYPE_name = map[int32]string{
	0: "_",
	1: "UN_ENCRY",
	2: "ENCRY",
	4: "VIP",
}
var DATABASETYPE_value = map[string]int32{
	"_":        0,
	"UN_ENCRY": 1,
	"ENCRY":    2,
	"VIP":      4,
}

func (x DATABASETYPE) String() string {
	return proto.EnumName(DATABASETYPE_name, int32(x))
}
func (DATABASETYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorHbase, []int{0} }

type ChannelMsgId struct {
	Id        int32 `protobuf:"varint,1,opt,name=Id,json=id,proto3" json:"Id,omitempty"`
	ChannelId int32 `protobuf:"varint,2,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	MsgId     int32 `protobuf:"varint,3,opt,name=MsgId,json=msgId,proto3" json:"MsgId,omitempty"`
	Pts       int32 `protobuf:"varint,4,opt,name=Pts,json=pts,proto3" json:"Pts,omitempty"`
	LastDate  int32 `protobuf:"varint,5,opt,name=LastDate,json=lastDate,proto3" json:"LastDate,omitempty"`
}

func (m *ChannelMsgId) Reset()                    { *m = ChannelMsgId{} }
func (m *ChannelMsgId) String() string            { return proto.CompactTextString(m) }
func (*ChannelMsgId) ProtoMessage()               {}
func (*ChannelMsgId) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{0} }

func (m *ChannelMsgId) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChannelMsgId) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ChannelMsgId) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *ChannelMsgId) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *ChannelMsgId) GetLastDate() int32 {
	if m != nil {
		return m.LastDate
	}
	return 0
}

type MsgsAndMaxId struct {
	MaxMsgId int32   `protobuf:"varint,1,opt,name=MaxMsgId,json=maxMsgId,proto3" json:"MaxMsgId,omitempty"`
	Msgs     []int32 `protobuf:"varint,2,rep,packed,name=Msgs,json=msgs" json:"Msgs,omitempty"`
}

func (m *MsgsAndMaxId) Reset()                    { *m = MsgsAndMaxId{} }
func (m *MsgsAndMaxId) String() string            { return proto.CompactTextString(m) }
func (*MsgsAndMaxId) ProtoMessage()               {}
func (*MsgsAndMaxId) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{1} }

func (m *MsgsAndMaxId) GetMaxMsgId() int32 {
	if m != nil {
		return m.MaxMsgId
	}
	return 0
}

func (m *MsgsAndMaxId) GetMsgs() []int32 {
	if m != nil {
		return m.Msgs
	}
	return nil
}

type ReplyErr struct {
	ErrCode uint32 `protobuf:"varint,1,opt,name=ErrCode,json=errCode,proto3" json:"ErrCode,omitempty"`
	ErrMsg  string `protobuf:"bytes,2,opt,name=ErrMsg,json=errMsg,proto3" json:"ErrMsg,omitempty"`
}

func (m *ReplyErr) Reset()                    { *m = ReplyErr{} }
func (m *ReplyErr) String() string            { return proto.CompactTextString(m) }
func (*ReplyErr) ProtoMessage()               {}
func (*ReplyErr) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{2} }

func (m *ReplyErr) GetErrCode() uint32 {
	if m != nil {
		return m.ErrCode
	}
	return 0
}

func (m *ReplyErr) GetErrMsg() string {
	if m != nil {
		return m.ErrMsg
	}
	return ""
}

type UserMsg struct {
	Id           int64        `protobuf:"varint,1,opt,name=Id,json=id,proto3" json:"Id,omitempty"`
	UserId       int32        `protobuf:"varint,2,opt,name=UserId,json=userId,proto3" json:"UserId,omitempty"`
	WithId       int32        `protobuf:"varint,3,opt,name=WithId,json=withId,proto3" json:"WithId,omitempty"`
	WithIdType   int32        `protobuf:"varint,4,opt,name=WithIdType,json=withIdType,proto3" json:"WithIdType,omitempty"`
	MessageType  int32        `protobuf:"varint,5,opt,name=MessageType,json=messageType,proto3" json:"MessageType,omitempty"`
	Flags        int32        `protobuf:"varint,6,opt,name=Flags,json=flags,proto3" json:"Flags,omitempty"`
	Out          bool         `protobuf:"varint,7,opt,name=Out,json=out,proto3" json:"Out,omitempty"`
	Mentioned    bool         `protobuf:"varint,8,opt,name=Mentioned,json=mentioned,proto3" json:"Mentioned,omitempty"`
	MediaUnread  bool         `protobuf:"varint,9,opt,name=MediaUnread,json=mediaUnread,proto3" json:"MediaUnread,omitempty"`
	Silent       bool         `protobuf:"varint,10,opt,name=Silent,json=silent,proto3" json:"Silent,omitempty"`
	Post         bool         `protobuf:"varint,11,opt,name=Post,json=post,proto3" json:"Post,omitempty"`
	GroupId      int64        `protobuf:"varint,12,opt,name=GroupId,json=groupId,proto3" json:"GroupId,omitempty"`
	MsgId        int32        `protobuf:"varint,13,opt,name=MsgId,json=msgId,proto3" json:"MsgId,omitempty"`
	ToId         int32        `protobuf:"varint,14,opt,name=ToId,json=toId,proto3" json:"ToId,omitempty"`
	Pts          int32        `protobuf:"varint,15,opt,name=Pts,json=pts,proto3" json:"Pts,omitempty"`
	FwdFrom      []byte       `protobuf:"bytes,16,opt,name=FwdFrom,json=fwdFrom,proto3" json:"FwdFrom,omitempty"`
	ViaBotId     int32        `protobuf:"varint,17,opt,name=ViaBotId,json=viaBotId,proto3" json:"ViaBotId,omitempty"`
	ReplyToMsgId int32        `protobuf:"varint,18,opt,name=ReplyToMsgId,json=replyToMsgId,proto3" json:"ReplyToMsgId,omitempty"`
	Date         int32        `protobuf:"varint,19,opt,name=Date,json=date,proto3" json:"Date,omitempty"`
	Message      string       `protobuf:"bytes,20,opt,name=Message,json=message,proto3" json:"Message,omitempty"`
	Media        int64        `protobuf:"varint,21,opt,name=Media,json=media,proto3" json:"Media,omitempty"`
	MediaData    []byte       `protobuf:"bytes,22,opt,name=MediaData,json=mediaData,proto3" json:"MediaData,omitempty"`
	ReplyMarkup  []byte       `protobuf:"bytes,23,opt,name=ReplyMarkup,json=replyMarkup,proto3" json:"ReplyMarkup,omitempty"`
	Entities     [][]byte     `protobuf:"bytes,24,rep,name=Entities,json=entities" json:"Entities,omitempty"`
	FromId       int32        `protobuf:"varint,25,opt,name=FromId,json=fromId,proto3" json:"FromId,omitempty"`
	Views        int32        `protobuf:"varint,26,opt,name=Views,json=views,proto3" json:"Views,omitempty"`
	EditDate     int32        `protobuf:"varint,27,opt,name=EditDate,json=editDate,proto3" json:"EditDate,omitempty"`
	Action       []byte       `protobuf:"bytes,28,opt,name=Action,json=action,proto3" json:"Action,omitempty"`
	RandomId     int64        `protobuf:"varint,29,opt,name=RandomId,json=randomId,proto3" json:"RandomId,omitempty"`
	Uuid         int64        `protobuf:"varint,30,opt,name=Uuid,json=uuid,proto3" json:"Uuid,omitempty"`
	InsertDate   int32        `protobuf:"varint,31,opt,name=InsertDate,json=insertDate,proto3" json:"InsertDate,omitempty"`
	UpdateDate   int32        `protobuf:"varint,32,opt,name=UpdateDate,json=updateDate,proto3" json:"UpdateDate,omitempty"`
	Encry        int32        `protobuf:"varint,33,opt,name=Encry,json=encry,proto3" json:"Encry,omitempty"`
	Combination  *Combination `protobuf:"bytes,34,opt,name=Combination,json=combination" json:"Combination,omitempty"`
}

func (m *UserMsg) Reset()                    { *m = UserMsg{} }
func (m *UserMsg) String() string            { return proto.CompactTextString(m) }
func (*UserMsg) ProtoMessage()               {}
func (*UserMsg) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{3} }

func (m *UserMsg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserMsg) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *UserMsg) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *UserMsg) GetMessageType() int32 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMsg) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UserMsg) GetOut() bool {
	if m != nil {
		return m.Out
	}
	return false
}

func (m *UserMsg) GetMentioned() bool {
	if m != nil {
		return m.Mentioned
	}
	return false
}

func (m *UserMsg) GetMediaUnread() bool {
	if m != nil {
		return m.MediaUnread
	}
	return false
}

func (m *UserMsg) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *UserMsg) GetPost() bool {
	if m != nil {
		return m.Post
	}
	return false
}

func (m *UserMsg) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UserMsg) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *UserMsg) GetToId() int32 {
	if m != nil {
		return m.ToId
	}
	return 0
}

func (m *UserMsg) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *UserMsg) GetFwdFrom() []byte {
	if m != nil {
		return m.FwdFrom
	}
	return nil
}

func (m *UserMsg) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

func (m *UserMsg) GetReplyToMsgId() int32 {
	if m != nil {
		return m.ReplyToMsgId
	}
	return 0
}

func (m *UserMsg) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *UserMsg) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *UserMsg) GetMedia() int64 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *UserMsg) GetMediaData() []byte {
	if m != nil {
		return m.MediaData
	}
	return nil
}

func (m *UserMsg) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *UserMsg) GetEntities() [][]byte {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *UserMsg) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *UserMsg) GetViews() int32 {
	if m != nil {
		return m.Views
	}
	return 0
}

func (m *UserMsg) GetEditDate() int32 {
	if m != nil {
		return m.EditDate
	}
	return 0
}

func (m *UserMsg) GetAction() []byte {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *UserMsg) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *UserMsg) GetUuid() int64 {
	if m != nil {
		return m.Uuid
	}
	return 0
}

func (m *UserMsg) GetInsertDate() int32 {
	if m != nil {
		return m.InsertDate
	}
	return 0
}

func (m *UserMsg) GetUpdateDate() int32 {
	if m != nil {
		return m.UpdateDate
	}
	return 0
}

func (m *UserMsg) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *UserMsg) GetCombination() *Combination {
	if m != nil {
		return m.Combination
	}
	return nil
}

type Combination struct {
	MentionedSlice []*MentionStatus `protobuf:"bytes,1,rep,name=MentionedSlice,json=mentionedSlice" json:"MentionedSlice,omitempty"`
	KeyId          []int64          `protobuf:"varint,2,rep,packed,name=KeyId,json=keyId" json:"KeyId,omitempty"`
}

func (m *Combination) Reset()                    { *m = Combination{} }
func (m *Combination) String() string            { return proto.CompactTextString(m) }
func (*Combination) ProtoMessage()               {}
func (*Combination) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{4} }

func (m *Combination) GetMentionedSlice() []*MentionStatus {
	if m != nil {
		return m.MentionedSlice
	}
	return nil
}

func (m *Combination) GetKeyId() []int64 {
	if m != nil {
		return m.KeyId
	}
	return nil
}

type MentionStatus struct {
	UserId int32 `protobuf:"varint,1,opt,name=UserId,json=userId,proto3" json:"UserId,omitempty"`
	Status int32 `protobuf:"varint,2,opt,name=Status,json=status,proto3" json:"Status,omitempty"`
}

func (m *MentionStatus) Reset()                    { *m = MentionStatus{} }
func (m *MentionStatus) String() string            { return proto.CompactTextString(m) }
func (*MentionStatus) ProtoMessage()               {}
func (*MentionStatus) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{5} }

func (m *MentionStatus) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MentionStatus) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type UserMsgListAndPts struct {
	UserMsgs []*UserMsg `protobuf:"bytes,1,rep,name=UserMsgs,json=userMsgs" json:"UserMsgs,omitempty"`
	Pts      int32      `protobuf:"varint,2,opt,name=Pts,json=pts,proto3" json:"Pts,omitempty"`
	Count    int32      `protobuf:"varint,3,opt,name=Count,json=count,proto3" json:"Count,omitempty"`
}

func (m *UserMsgListAndPts) Reset()                    { *m = UserMsgListAndPts{} }
func (m *UserMsgListAndPts) String() string            { return proto.CompactTextString(m) }
func (*UserMsgListAndPts) ProtoMessage()               {}
func (*UserMsgListAndPts) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{6} }

func (m *UserMsgListAndPts) GetUserMsgs() []*UserMsg {
	if m != nil {
		return m.UserMsgs
	}
	return nil
}

func (m *UserMsgListAndPts) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *UserMsgListAndPts) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type GetChannelMediaMessageHistoryByMediaConfig struct {
	ChannelId int32   `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	UserId    int32   `protobuf:"varint,2,opt,name=UserId,json=userId,proto3" json:"UserId,omitempty"`
	Medias    []int32 `protobuf:"varint,3,rep,packed,name=Medias,json=medias" json:"Medias,omitempty"`
	MaxId     int32   `protobuf:"varint,4,opt,name=MaxId,json=maxId,proto3" json:"MaxId,omitempty"`
	Limit     int32   `protobuf:"varint,5,opt,name=Limit,json=limit,proto3" json:"Limit,omitempty"`
	Encry     int32   `protobuf:"varint,6,opt,name=encry,proto3" json:"encry,omitempty"`
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) Reset() {
	*m = GetChannelMediaMessageHistoryByMediaConfig{}
}
func (m *GetChannelMediaMessageHistoryByMediaConfig) String() string {
	return proto.CompactTextString(m)
}
func (*GetChannelMediaMessageHistoryByMediaConfig) ProtoMessage() {}
func (*GetChannelMediaMessageHistoryByMediaConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{7}
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) GetMedias() []int32 {
	if m != nil {
		return m.Medias
	}
	return nil
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

type GetChannelMsgIdReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,2,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetChannelMsgIdReq) Reset()                    { *m = GetChannelMsgIdReq{} }
func (m *GetChannelMsgIdReq) String() string            { return proto.CompactTextString(m) }
func (*GetChannelMsgIdReq) ProtoMessage()               {}
func (*GetChannelMsgIdReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{8} }

func (m *GetChannelMsgIdReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelMsgIdReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetChannelMsgIdResp struct {
	ChannelMsgId *ChannelMsgId `protobuf:"bytes,1,opt,name=ChannelMsgId,json=channelMsgId" json:"ChannelMsgId,omitempty"`
	ReplyErr     *ReplyErr     `protobuf:"bytes,2,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *GetChannelMsgIdResp) Reset()                    { *m = GetChannelMsgIdResp{} }
func (m *GetChannelMsgIdResp) String() string            { return proto.CompactTextString(m) }
func (*GetChannelMsgIdResp) ProtoMessage()               {}
func (*GetChannelMsgIdResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{9} }

func (m *GetChannelMsgIdResp) GetChannelMsgId() *ChannelMsgId {
	if m != nil {
		return m.ChannelMsgId
	}
	return nil
}

func (m *GetChannelMsgIdResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type DeleteChannelMessageReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	MsgId     int32        `protobuf:"varint,2,opt,name=MsgId,json=msgId,proto3" json:"MsgId,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,3,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *DeleteChannelMessageReq) Reset()                    { *m = DeleteChannelMessageReq{} }
func (m *DeleteChannelMessageReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteChannelMessageReq) ProtoMessage()               {}
func (*DeleteChannelMessageReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{10} }

func (m *DeleteChannelMessageReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *DeleteChannelMessageReq) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *DeleteChannelMessageReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type DeleteChannelMessageResp struct {
	UserId       int32     `protobuf:"varint,1,opt,name=UserId,json=userId,proto3" json:"UserId,omitempty"`
	CurrentMsgId int32     `protobuf:"varint,2,opt,name=CurrentMsgId,json=currentMsgId,proto3" json:"CurrentMsgId,omitempty"`
	UpdateDate   int32     `protobuf:"varint,3,opt,name=UpdateDate,json=updateDate,proto3" json:"UpdateDate,omitempty"`
	ReplyErr     *ReplyErr `protobuf:"bytes,4,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *DeleteChannelMessageResp) Reset()                    { *m = DeleteChannelMessageResp{} }
func (m *DeleteChannelMessageResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteChannelMessageResp) ProtoMessage()               {}
func (*DeleteChannelMessageResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{11} }

func (m *DeleteChannelMessageResp) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteChannelMessageResp) GetCurrentMsgId() int32 {
	if m != nil {
		return m.CurrentMsgId
	}
	return 0
}

func (m *DeleteChannelMessageResp) GetUpdateDate() int32 {
	if m != nil {
		return m.UpdateDate
	}
	return 0
}

func (m *DeleteChannelMessageResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type DeleteMsgsReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	MsgIds    []int32      `protobuf:"varint,2,rep,packed,name=MsgIds,json=msgIds" json:"MsgIds,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,3,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *DeleteMsgsReq) Reset()                    { *m = DeleteMsgsReq{} }
func (m *DeleteMsgsReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteMsgsReq) ProtoMessage()               {}
func (*DeleteMsgsReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{12} }

func (m *DeleteMsgsReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *DeleteMsgsReq) GetMsgIds() []int32 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

func (m *DeleteMsgsReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type DeleteMsgsResp struct {
	CurrentMsgId int32     `protobuf:"varint,1,opt,name=CurrentMsgId,json=currentMsgId,proto3" json:"CurrentMsgId,omitempty"`
	UpdateDate   int32     `protobuf:"varint,2,opt,name=UpdateDate,json=updateDate,proto3" json:"UpdateDate,omitempty"`
	ReplyErr     *ReplyErr `protobuf:"bytes,3,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *DeleteMsgsResp) Reset()                    { *m = DeleteMsgsResp{} }
func (m *DeleteMsgsResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteMsgsResp) ProtoMessage()               {}
func (*DeleteMsgsResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{13} }

func (m *DeleteMsgsResp) GetCurrentMsgId() int32 {
	if m != nil {
		return m.CurrentMsgId
	}
	return 0
}

func (m *DeleteMsgsResp) GetUpdateDate() int32 {
	if m != nil {
		return m.UpdateDate
	}
	return 0
}

func (m *DeleteMsgsResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type DeleteUserHistoryReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	UserId    int32        `protobuf:"varint,2,opt,name=UserId,json=userId,proto3" json:"UserId,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,3,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *DeleteUserHistoryReq) Reset()                    { *m = DeleteUserHistoryReq{} }
func (m *DeleteUserHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteUserHistoryReq) ProtoMessage()               {}
func (*DeleteUserHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{14} }

func (m *DeleteUserHistoryReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *DeleteUserHistoryReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DeleteUserHistoryReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type DeleteUserHistoryResp struct {
	MsgsAndMaxId *MsgsAndMaxId `protobuf:"bytes,1,opt,name=MsgsAndMaxId,json=msgsAndMaxId" json:"MsgsAndMaxId,omitempty"`
	Ptss         []int32       `protobuf:"varint,2,rep,packed,name=Ptss,json=ptss" json:"Ptss,omitempty"`
	UpdateDate   int32         `protobuf:"varint,3,opt,name=UpdateDate,json=updateDate,proto3" json:"UpdateDate,omitempty"`
	ReplyErr     *ReplyErr     `protobuf:"bytes,4,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *DeleteUserHistoryResp) Reset()                    { *m = DeleteUserHistoryResp{} }
func (m *DeleteUserHistoryResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteUserHistoryResp) ProtoMessage()               {}
func (*DeleteUserHistoryResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{15} }

func (m *DeleteUserHistoryResp) GetMsgsAndMaxId() *MsgsAndMaxId {
	if m != nil {
		return m.MsgsAndMaxId
	}
	return nil
}

func (m *DeleteUserHistoryResp) GetPtss() []int32 {
	if m != nil {
		return m.Ptss
	}
	return nil
}

func (m *DeleteUserHistoryResp) GetUpdateDate() int32 {
	if m != nil {
		return m.UpdateDate
	}
	return 0
}

func (m *DeleteUserHistoryResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type DeleteChannelMsgReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,2,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *DeleteChannelMsgReq) Reset()                    { *m = DeleteChannelMsgReq{} }
func (m *DeleteChannelMsgReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteChannelMsgReq) ProtoMessage()               {}
func (*DeleteChannelMsgReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{16} }

func (m *DeleteChannelMsgReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *DeleteChannelMsgReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetChannelMessageReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	MsgId     int32        `protobuf:"varint,2,opt,name=MsgId,json=msgId,proto3" json:"MsgId,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,3,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetChannelMessageReq) Reset()                    { *m = GetChannelMessageReq{} }
func (m *GetChannelMessageReq) String() string            { return proto.CompactTextString(m) }
func (*GetChannelMessageReq) ProtoMessage()               {}
func (*GetChannelMessageReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{17} }

func (m *GetChannelMessageReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelMessageReq) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *GetChannelMessageReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetChannelMessageResp struct {
	UserMsg  *UserMsg  `protobuf:"bytes,1,opt,name=UserMsg,json=userMsg" json:"UserMsg,omitempty"`
	ReplyErr *ReplyErr `protobuf:"bytes,2,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *GetChannelMessageResp) Reset()                    { *m = GetChannelMessageResp{} }
func (m *GetChannelMessageResp) String() string            { return proto.CompactTextString(m) }
func (*GetChannelMessageResp) ProtoMessage()               {}
func (*GetChannelMessageResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{18} }

func (m *GetChannelMessageResp) GetUserMsg() *UserMsg {
	if m != nil {
		return m.UserMsg
	}
	return nil
}

func (m *GetChannelMessageResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type GetChannelMsgsByMsgIdsReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	MsgIds    []int32      `protobuf:"varint,2,rep,packed,name=MsgIds,json=msgIds" json:"MsgIds,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,3,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetChannelMsgsByMsgIdsReq) Reset()                    { *m = GetChannelMsgsByMsgIdsReq{} }
func (m *GetChannelMsgsByMsgIdsReq) String() string            { return proto.CompactTextString(m) }
func (*GetChannelMsgsByMsgIdsReq) ProtoMessage()               {}
func (*GetChannelMsgsByMsgIdsReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{19} }

func (m *GetChannelMsgsByMsgIdsReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelMsgsByMsgIdsReq) GetMsgIds() []int32 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

func (m *GetChannelMsgsByMsgIdsReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetChannelMsgsByMsgIdsResp struct {
	UserMsgListAndPts *UserMsgListAndPts `protobuf:"bytes,1,opt,name=UserMsgListAndPts,json=userMsgListAndPts" json:"UserMsgListAndPts,omitempty"`
	ReplyErr          *ReplyErr          `protobuf:"bytes,2,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *GetChannelMsgsByMsgIdsResp) Reset()         { *m = GetChannelMsgsByMsgIdsResp{} }
func (m *GetChannelMsgsByMsgIdsResp) String() string { return proto.CompactTextString(m) }
func (*GetChannelMsgsByMsgIdsResp) ProtoMessage()    {}
func (*GetChannelMsgsByMsgIdsResp) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{20}
}

func (m *GetChannelMsgsByMsgIdsResp) GetUserMsgListAndPts() *UserMsgListAndPts {
	if m != nil {
		return m.UserMsgListAndPts
	}
	return nil
}

func (m *GetChannelMsgsByMsgIdsResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type GetChannelMsgHistoryReq struct {
	ChannelId  int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	OffsetId   int32        `protobuf:"varint,2,opt,name=OffsetId,json=offsetId,proto3" json:"OffsetId,omitempty"`
	OffsetDate int32        `protobuf:"varint,3,opt,name=OffsetDate,json=offsetDate,proto3" json:"OffsetDate,omitempty"`
	AddOffset  int32        `protobuf:"varint,4,opt,name=AddOffset,json=addOffset,proto3" json:"AddOffset,omitempty"`
	MinId      int32        `protobuf:"varint,5,opt,name=MinId,json=minId,proto3" json:"MinId,omitempty"`
	MaxId      int32        `protobuf:"varint,6,opt,name=MaxId,json=maxId,proto3" json:"MaxId,omitempty"`
	Limit      int32        `protobuf:"varint,7,opt,name=Limit,json=limit,proto3" json:"Limit,omitempty"`
	Encry      int32        `protobuf:"varint,8,opt,name=Encry,json=encry,proto3" json:"Encry,omitempty"`
	DType      DATABASETYPE `protobuf:"varint,9,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetChannelMsgHistoryReq) Reset()                    { *m = GetChannelMsgHistoryReq{} }
func (m *GetChannelMsgHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*GetChannelMsgHistoryReq) ProtoMessage()               {}
func (*GetChannelMsgHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{21} }

func (m *GetChannelMsgHistoryReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetOffsetId() int32 {
	if m != nil {
		return m.OffsetId
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetOffsetDate() int32 {
	if m != nil {
		return m.OffsetDate
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetAddOffset() int32 {
	if m != nil {
		return m.AddOffset
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetMinId() int32 {
	if m != nil {
		return m.MinId
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *GetChannelMsgHistoryReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetChannelMsgHistoryResp struct {
	UserMsgListAndPts *UserMsgListAndPts `protobuf:"bytes,1,opt,name=UserMsgListAndPts,json=userMsgListAndPts" json:"UserMsgListAndPts,omitempty"`
	ReplyErr          *ReplyErr          `protobuf:"bytes,2,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *GetChannelMsgHistoryResp) Reset()                    { *m = GetChannelMsgHistoryResp{} }
func (m *GetChannelMsgHistoryResp) String() string            { return proto.CompactTextString(m) }
func (*GetChannelMsgHistoryResp) ProtoMessage()               {}
func (*GetChannelMsgHistoryResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{22} }

func (m *GetChannelMsgHistoryResp) GetUserMsgListAndPts() *UserMsgListAndPts {
	if m != nil {
		return m.UserMsgListAndPts
	}
	return nil
}

func (m *GetChannelMsgHistoryResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type GetChannelTopMsgReq struct {
	ChannelId int32        `protobuf:"varint,1,opt,name=ChannelId,json=channelId,proto3" json:"ChannelId,omitempty"`
	DType     DATABASETYPE `protobuf:"varint,2,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetChannelTopMsgReq) Reset()                    { *m = GetChannelTopMsgReq{} }
func (m *GetChannelTopMsgReq) String() string            { return proto.CompactTextString(m) }
func (*GetChannelTopMsgReq) ProtoMessage()               {}
func (*GetChannelTopMsgReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{23} }

func (m *GetChannelTopMsgReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelTopMsgReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetChannelTopMsgResp struct {
	UserMsg  *UserMsg  `protobuf:"bytes,1,opt,name=UserMsg,json=userMsg" json:"UserMsg,omitempty"`
	ReplyErr *ReplyErr `protobuf:"bytes,2,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *GetChannelTopMsgResp) Reset()                    { *m = GetChannelTopMsgResp{} }
func (m *GetChannelTopMsgResp) String() string            { return proto.CompactTextString(m) }
func (*GetChannelTopMsgResp) ProtoMessage()               {}
func (*GetChannelTopMsgResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{24} }

func (m *GetChannelTopMsgResp) GetUserMsg() *UserMsg {
	if m != nil {
		return m.UserMsg
	}
	return nil
}

func (m *GetChannelTopMsgResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

// 查询打电话历史消息记录config 当 withid == withtype == 0 时 只搜索userid
type GetMessageHistoryPageByMediaConfig struct {
	UserId   int32   `protobuf:"varint,1,opt,name=UserId,json=userId,proto3" json:"UserId,omitempty"`
	WithId   int32   `protobuf:"varint,2,opt,name=WithId,json=withId,proto3" json:"WithId,omitempty"`
	WithType int32   `protobuf:"varint,3,opt,name=WithType,json=withType,proto3" json:"WithType,omitempty"`
	MaxId    int32   `protobuf:"varint,4,opt,name=MaxId,json=maxId,proto3" json:"MaxId,omitempty"`
	Encry    int32   `protobuf:"varint,5,opt,name=Encry,json=encry,proto3" json:"Encry,omitempty"`
	Medias   []int32 `protobuf:"varint,6,rep,packed,name=Medias,json=medias" json:"Medias,omitempty"`
	Limit    int32   `protobuf:"varint,7,opt,name=Limit,json=limit,proto3" json:"Limit,omitempty"`
}

func (m *GetMessageHistoryPageByMediaConfig) Reset()         { *m = GetMessageHistoryPageByMediaConfig{} }
func (m *GetMessageHistoryPageByMediaConfig) String() string { return proto.CompactTextString(m) }
func (*GetMessageHistoryPageByMediaConfig) ProtoMessage()    {}
func (*GetMessageHistoryPageByMediaConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{25}
}

func (m *GetMessageHistoryPageByMediaConfig) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetWithType() int32 {
	if m != nil {
		return m.WithType
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *GetMessageHistoryPageByMediaConfig) GetMedias() []int32 {
	if m != nil {
		return m.Medias
	}
	return nil
}

func (m *GetMessageHistoryPageByMediaConfig) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type GetChannelMediaMessageHistoryByMediaReq struct {
	GetChannelMediaMessageHistoryByMediaConfig *GetChannelMediaMessageHistoryByMediaConfig `protobuf:"bytes,1,opt,name=GetChannelMediaMessageHistoryByMediaConfig,json=getChannelMediaMessageHistoryByMediaConfig" json:"GetChannelMediaMessageHistoryByMediaConfig,omitempty"`
	DType                                      DATABASETYPE                                `protobuf:"varint,2,opt,name=DType,json=dType,proto3,enum=channeldbold.DATABASETYPE" json:"DType,omitempty"`
}

func (m *GetChannelMediaMessageHistoryByMediaReq) Reset() {
	*m = GetChannelMediaMessageHistoryByMediaReq{}
}
func (m *GetChannelMediaMessageHistoryByMediaReq) String() string { return proto.CompactTextString(m) }
func (*GetChannelMediaMessageHistoryByMediaReq) ProtoMessage()    {}
func (*GetChannelMediaMessageHistoryByMediaReq) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{26}
}

func (m *GetChannelMediaMessageHistoryByMediaReq) GetGetChannelMediaMessageHistoryByMediaConfig() *GetChannelMediaMessageHistoryByMediaConfig {
	if m != nil {
		return m.GetChannelMediaMessageHistoryByMediaConfig
	}
	return nil
}

func (m *GetChannelMediaMessageHistoryByMediaReq) GetDType() DATABASETYPE {
	if m != nil {
		return m.DType
	}
	return DATABASETYPE__
}

type GetChannelMediaMessageHistoryByMediaResp struct {
	ChannelMsgs []*UserMsg `protobuf:"bytes,1,rep,name=ChannelMsgs,json=channelMsgs" json:"ChannelMsgs,omitempty"`
	ReplyErr    *ReplyErr  `protobuf:"bytes,2,opt,name=ReplyErr,json=replyErr" json:"ReplyErr,omitempty"`
}

func (m *GetChannelMediaMessageHistoryByMediaResp) Reset() {
	*m = GetChannelMediaMessageHistoryByMediaResp{}
}
func (m *GetChannelMediaMessageHistoryByMediaResp) String() string { return proto.CompactTextString(m) }
func (*GetChannelMediaMessageHistoryByMediaResp) ProtoMessage()    {}
func (*GetChannelMediaMessageHistoryByMediaResp) Descriptor() ([]byte, []int) {
	return fileDescriptorHbase, []int{27}
}

func (m *GetChannelMediaMessageHistoryByMediaResp) GetChannelMsgs() []*UserMsg {
	if m != nil {
		return m.ChannelMsgs
	}
	return nil
}

func (m *GetChannelMediaMessageHistoryByMediaResp) GetReplyErr() *ReplyErr {
	if m != nil {
		return m.ReplyErr
	}
	return nil
}

type SearchChannelMsgReq struct {
	UserID    int32   `protobuf:"varint,1,opt,name=UserID,json=userID,proto3" json:"UserID,omitempty"`
	ChannelID int32   `protobuf:"varint,2,opt,name=ChannelID,json=channelID,proto3" json:"ChannelID,omitempty"`
	FromID    int32   `protobuf:"varint,3,opt,name=FromID,json=fromID,proto3" json:"FromID,omitempty"`
	Medias    []int32 `protobuf:"varint,4,rep,packed,name=Medias,json=medias" json:"Medias,omitempty"`
	OffsetID  int32   `protobuf:"varint,5,opt,name=OffsetID,json=offsetID,proto3" json:"OffsetID,omitempty"`
	AddOffset int32   `protobuf:"varint,6,opt,name=AddOffset,json=addOffset,proto3" json:"AddOffset,omitempty"`
	Encry     int32   `protobuf:"varint,7,opt,name=Encry,json=encry,proto3" json:"Encry,omitempty"`
	Limit     int32   `protobuf:"varint,8,opt,name=Limit,json=limit,proto3" json:"Limit,omitempty"`
	MinDate   int32   `protobuf:"varint,9,opt,name=MinDate,json=minDate,proto3" json:"MinDate,omitempty"`
	MaxDate   int32   `protobuf:"varint,10,opt,name=MaxDate,json=maxDate,proto3" json:"MaxDate,omitempty"`
	MinID     int32   `protobuf:"varint,11,opt,name=MinID,json=minID,proto3" json:"MinID,omitempty"`
	MaxID     int32   `protobuf:"varint,12,opt,name=MaxID,json=maxID,proto3" json:"MaxID,omitempty"`
}

func (m *SearchChannelMsgReq) Reset()                    { *m = SearchChannelMsgReq{} }
func (m *SearchChannelMsgReq) String() string            { return proto.CompactTextString(m) }
func (*SearchChannelMsgReq) ProtoMessage()               {}
func (*SearchChannelMsgReq) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{28} }

func (m *SearchChannelMsgReq) GetUserID() int32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *SearchChannelMsgReq) GetChannelID() int32 {
	if m != nil {
		return m.ChannelID
	}
	return 0
}

func (m *SearchChannelMsgReq) GetFromID() int32 {
	if m != nil {
		return m.FromID
	}
	return 0
}

func (m *SearchChannelMsgReq) GetMedias() []int32 {
	if m != nil {
		return m.Medias
	}
	return nil
}

func (m *SearchChannelMsgReq) GetOffsetID() int32 {
	if m != nil {
		return m.OffsetID
	}
	return 0
}

func (m *SearchChannelMsgReq) GetAddOffset() int32 {
	if m != nil {
		return m.AddOffset
	}
	return 0
}

func (m *SearchChannelMsgReq) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *SearchChannelMsgReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *SearchChannelMsgReq) GetMinDate() int32 {
	if m != nil {
		return m.MinDate
	}
	return 0
}

func (m *SearchChannelMsgReq) GetMaxDate() int32 {
	if m != nil {
		return m.MaxDate
	}
	return 0
}

func (m *SearchChannelMsgReq) GetMinID() int32 {
	if m != nil {
		return m.MinID
	}
	return 0
}

func (m *SearchChannelMsgReq) GetMaxID() int32 {
	if m != nil {
		return m.MaxID
	}
	return 0
}

type SearchChannelMsgResp struct {
	Messages []*UserMsg `protobuf:"bytes,1,rep,name=Messages,json=messages" json:"Messages,omitempty"`
}

func (m *SearchChannelMsgResp) Reset()                    { *m = SearchChannelMsgResp{} }
func (m *SearchChannelMsgResp) String() string            { return proto.CompactTextString(m) }
func (*SearchChannelMsgResp) ProtoMessage()               {}
func (*SearchChannelMsgResp) Descriptor() ([]byte, []int) { return fileDescriptorHbase, []int{29} }

func (m *SearchChannelMsgResp) GetMessages() []*UserMsg {
	if m != nil {
		return m.Messages
	}
	return nil
}

func init() {
	proto.RegisterType((*ChannelMsgId)(nil), "channeldbold.ChannelMsgId")
	proto.RegisterType((*MsgsAndMaxId)(nil), "channeldbold.MsgsAndMaxId")
	proto.RegisterType((*ReplyErr)(nil), "channeldbold.ReplyErr")
	proto.RegisterType((*UserMsg)(nil), "channeldbold.UserMsg")
	proto.RegisterType((*Combination)(nil), "channeldbold.Combination")
	proto.RegisterType((*MentionStatus)(nil), "channeldbold.MentionStatus")
	proto.RegisterType((*UserMsgListAndPts)(nil), "channeldbold.UserMsgListAndPts")
	proto.RegisterType((*GetChannelMediaMessageHistoryByMediaConfig)(nil), "channeldbold.GetChannelMediaMessageHistoryByMediaConfig")
	proto.RegisterType((*GetChannelMsgIdReq)(nil), "channeldbold.GetChannelMsgIdReq")
	proto.RegisterType((*GetChannelMsgIdResp)(nil), "channeldbold.GetChannelMsgIdResp")
	proto.RegisterType((*DeleteChannelMessageReq)(nil), "channeldbold.DeleteChannelMessageReq")
	proto.RegisterType((*DeleteChannelMessageResp)(nil), "channeldbold.DeleteChannelMessageResp")
	proto.RegisterType((*DeleteMsgsReq)(nil), "channeldbold.DeleteMsgsReq")
	proto.RegisterType((*DeleteMsgsResp)(nil), "channeldbold.DeleteMsgsResp")
	proto.RegisterType((*DeleteUserHistoryReq)(nil), "channeldbold.DeleteUserHistoryReq")
	proto.RegisterType((*DeleteUserHistoryResp)(nil), "channeldbold.DeleteUserHistoryResp")
	proto.RegisterType((*DeleteChannelMsgReq)(nil), "channeldbold.DeleteChannelMsgReq")
	proto.RegisterType((*GetChannelMessageReq)(nil), "channeldbold.GetChannelMessageReq")
	proto.RegisterType((*GetChannelMessageResp)(nil), "channeldbold.GetChannelMessageResp")
	proto.RegisterType((*GetChannelMsgsByMsgIdsReq)(nil), "channeldbold.GetChannelMsgsByMsgIdsReq")
	proto.RegisterType((*GetChannelMsgsByMsgIdsResp)(nil), "channeldbold.GetChannelMsgsByMsgIdsResp")
	proto.RegisterType((*GetChannelMsgHistoryReq)(nil), "channeldbold.GetChannelMsgHistoryReq")
	proto.RegisterType((*GetChannelMsgHistoryResp)(nil), "channeldbold.GetChannelMsgHistoryResp")
	proto.RegisterType((*GetChannelTopMsgReq)(nil), "channeldbold.GetChannelTopMsgReq")
	proto.RegisterType((*GetChannelTopMsgResp)(nil), "channeldbold.GetChannelTopMsgResp")
	proto.RegisterType((*GetMessageHistoryPageByMediaConfig)(nil), "channeldbold.GetMessageHistoryPageByMediaConfig")
	proto.RegisterType((*GetChannelMediaMessageHistoryByMediaReq)(nil), "channeldbold.GetChannelMediaMessageHistoryByMediaReq")
	proto.RegisterType((*GetChannelMediaMessageHistoryByMediaResp)(nil), "channeldbold.GetChannelMediaMessageHistoryByMediaResp")
	proto.RegisterType((*SearchChannelMsgReq)(nil), "channeldbold.SearchChannelMsgReq")
	proto.RegisterType((*SearchChannelMsgResp)(nil), "channeldbold.SearchChannelMsgResp")
	proto.RegisterEnum("channeldbold.DATABASETYPE", DATABASETYPE_name, DATABASETYPE_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ChanneldbOldService service

type ChanneldbOldServiceClient interface {
	// 查询单条ChannelMsgId， 返回最新的ChannelMsgId
	GetChannelMsgId(ctx context.Context, in *GetChannelMsgIdReq, opts ...grpc.CallOption) (*GetChannelMsgIdResp, error)
	// 删除单条信息
	DeleteChannelMessage(ctx context.Context, in *DeleteChannelMessageReq, opts ...grpc.CallOption) (*DeleteChannelMessageResp, error)
	// 批量删除信息
	DeleteMsgs(ctx context.Context, in *DeleteMsgsReq, opts ...grpc.CallOption) (*DeleteMsgsResp, error)
	// 超级群中删除指定用户信息
	DeleteUserHistory(ctx context.Context, in *DeleteUserHistoryReq, opts ...grpc.CallOption) (*DeleteUserHistoryResp, error)
	// 删除超级群所有消息
	DeleteChannelMsg(ctx context.Context, in *DeleteChannelMsgReq, opts ...grpc.CallOption) (*ReplyErr, error)
	// 获取指定msgid信息
	GetChannelMessage(ctx context.Context, in *GetChannelMessageReq, opts ...grpc.CallOption) (*GetChannelMessageResp, error)
	// 获取批量msgids信息集合
	GetChannelMsgsByMsgIds(ctx context.Context, in *GetChannelMsgsByMsgIdsReq, opts ...grpc.CallOption) (*GetChannelMsgsByMsgIdsResp, error)
	// 获取历史
	GetChannelMsgHistory(ctx context.Context, in *GetChannelMsgHistoryReq, opts ...grpc.CallOption) (*GetChannelMsgHistoryResp, error)
	// 分页查询媒体消息
	GetChannelMediaMessageHistoryByMedia(ctx context.Context, in *GetChannelMediaMessageHistoryByMediaReq, opts ...grpc.CallOption) (*GetChannelMediaMessageHistoryByMediaResp, error)
	// 搜索
	SearchMessage(ctx context.Context, in *SearchChannelMsgReq, opts ...grpc.CallOption) (*SearchChannelMsgResp, error)
}

type channeldbOldServiceClient struct {
	cc *grpc.ClientConn
}

func NewChanneldbOldServiceClient(cc *grpc.ClientConn) ChanneldbOldServiceClient {
	return &channeldbOldServiceClient{cc}
}

func (c *channeldbOldServiceClient) GetChannelMsgId(ctx context.Context, in *GetChannelMsgIdReq, opts ...grpc.CallOption) (*GetChannelMsgIdResp, error) {
	out := new(GetChannelMsgIdResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/GetChannelMsgId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) DeleteChannelMessage(ctx context.Context, in *DeleteChannelMessageReq, opts ...grpc.CallOption) (*DeleteChannelMessageResp, error) {
	out := new(DeleteChannelMessageResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/DeleteChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) DeleteMsgs(ctx context.Context, in *DeleteMsgsReq, opts ...grpc.CallOption) (*DeleteMsgsResp, error) {
	out := new(DeleteMsgsResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/DeleteMsgs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) DeleteUserHistory(ctx context.Context, in *DeleteUserHistoryReq, opts ...grpc.CallOption) (*DeleteUserHistoryResp, error) {
	out := new(DeleteUserHistoryResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/DeleteUserHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) DeleteChannelMsg(ctx context.Context, in *DeleteChannelMsgReq, opts ...grpc.CallOption) (*ReplyErr, error) {
	out := new(ReplyErr)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/DeleteChannelMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) GetChannelMessage(ctx context.Context, in *GetChannelMessageReq, opts ...grpc.CallOption) (*GetChannelMessageResp, error) {
	out := new(GetChannelMessageResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/GetChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) GetChannelMsgsByMsgIds(ctx context.Context, in *GetChannelMsgsByMsgIdsReq, opts ...grpc.CallOption) (*GetChannelMsgsByMsgIdsResp, error) {
	out := new(GetChannelMsgsByMsgIdsResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/GetChannelMsgsByMsgIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) GetChannelMsgHistory(ctx context.Context, in *GetChannelMsgHistoryReq, opts ...grpc.CallOption) (*GetChannelMsgHistoryResp, error) {
	out := new(GetChannelMsgHistoryResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/GetChannelMsgHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) GetChannelMediaMessageHistoryByMedia(ctx context.Context, in *GetChannelMediaMessageHistoryByMediaReq, opts ...grpc.CallOption) (*GetChannelMediaMessageHistoryByMediaResp, error) {
	out := new(GetChannelMediaMessageHistoryByMediaResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/GetChannelMediaMessageHistoryByMedia", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *channeldbOldServiceClient) SearchMessage(ctx context.Context, in *SearchChannelMsgReq, opts ...grpc.CallOption) (*SearchChannelMsgResp, error) {
	out := new(SearchChannelMsgResp)
	err := grpc.Invoke(ctx, "/channeldbold.ChanneldbOldService/SearchMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ChanneldbOldService service

type ChanneldbOldServiceServer interface {
	// 查询单条ChannelMsgId， 返回最新的ChannelMsgId
	GetChannelMsgId(context.Context, *GetChannelMsgIdReq) (*GetChannelMsgIdResp, error)
	// 删除单条信息
	DeleteChannelMessage(context.Context, *DeleteChannelMessageReq) (*DeleteChannelMessageResp, error)
	// 批量删除信息
	DeleteMsgs(context.Context, *DeleteMsgsReq) (*DeleteMsgsResp, error)
	// 超级群中删除指定用户信息
	DeleteUserHistory(context.Context, *DeleteUserHistoryReq) (*DeleteUserHistoryResp, error)
	// 删除超级群所有消息
	DeleteChannelMsg(context.Context, *DeleteChannelMsgReq) (*ReplyErr, error)
	// 获取指定msgid信息
	GetChannelMessage(context.Context, *GetChannelMessageReq) (*GetChannelMessageResp, error)
	// 获取批量msgids信息集合
	GetChannelMsgsByMsgIds(context.Context, *GetChannelMsgsByMsgIdsReq) (*GetChannelMsgsByMsgIdsResp, error)
	// 获取历史
	GetChannelMsgHistory(context.Context, *GetChannelMsgHistoryReq) (*GetChannelMsgHistoryResp, error)
	// 分页查询媒体消息
	GetChannelMediaMessageHistoryByMedia(context.Context, *GetChannelMediaMessageHistoryByMediaReq) (*GetChannelMediaMessageHistoryByMediaResp, error)
	// 搜索
	SearchMessage(context.Context, *SearchChannelMsgReq) (*SearchChannelMsgResp, error)
}

func RegisterChanneldbOldServiceServer(s *grpc.Server, srv ChanneldbOldServiceServer) {
	s.RegisterService(&_ChanneldbOldService_serviceDesc, srv)
}

func _ChanneldbOldService_GetChannelMsgId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelMsgIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).GetChannelMsgId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/GetChannelMsgId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).GetChannelMsgId(ctx, req.(*GetChannelMsgIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_DeleteChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).DeleteChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/DeleteChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).DeleteChannelMessage(ctx, req.(*DeleteChannelMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_DeleteMsgs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMsgsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).DeleteMsgs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/DeleteMsgs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).DeleteMsgs(ctx, req.(*DeleteMsgsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_DeleteUserHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).DeleteUserHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/DeleteUserHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).DeleteUserHistory(ctx, req.(*DeleteUserHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_DeleteChannelMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).DeleteChannelMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/DeleteChannelMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).DeleteChannelMsg(ctx, req.(*DeleteChannelMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_GetChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).GetChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/GetChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).GetChannelMessage(ctx, req.(*GetChannelMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_GetChannelMsgsByMsgIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelMsgsByMsgIdsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).GetChannelMsgsByMsgIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/GetChannelMsgsByMsgIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).GetChannelMsgsByMsgIds(ctx, req.(*GetChannelMsgsByMsgIdsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_GetChannelMsgHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelMsgHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).GetChannelMsgHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/GetChannelMsgHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).GetChannelMsgHistory(ctx, req.(*GetChannelMsgHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_GetChannelMediaMessageHistoryByMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelMediaMessageHistoryByMediaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).GetChannelMediaMessageHistoryByMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/GetChannelMediaMessageHistoryByMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).GetChannelMediaMessageHistoryByMedia(ctx, req.(*GetChannelMediaMessageHistoryByMediaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChanneldbOldService_SearchMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchChannelMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChanneldbOldServiceServer).SearchMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/channeldbold.ChanneldbOldService/SearchMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChanneldbOldServiceServer).SearchMessage(ctx, req.(*SearchChannelMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChanneldbOldService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "channeldbold.ChanneldbOldService",
	HandlerType: (*ChanneldbOldServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetChannelMsgId",
			Handler:    _ChanneldbOldService_GetChannelMsgId_Handler,
		},
		{
			MethodName: "DeleteChannelMessage",
			Handler:    _ChanneldbOldService_DeleteChannelMessage_Handler,
		},
		{
			MethodName: "DeleteMsgs",
			Handler:    _ChanneldbOldService_DeleteMsgs_Handler,
		},
		{
			MethodName: "DeleteUserHistory",
			Handler:    _ChanneldbOldService_DeleteUserHistory_Handler,
		},
		{
			MethodName: "DeleteChannelMsg",
			Handler:    _ChanneldbOldService_DeleteChannelMsg_Handler,
		},
		{
			MethodName: "GetChannelMessage",
			Handler:    _ChanneldbOldService_GetChannelMessage_Handler,
		},
		{
			MethodName: "GetChannelMsgsByMsgIds",
			Handler:    _ChanneldbOldService_GetChannelMsgsByMsgIds_Handler,
		},
		{
			MethodName: "GetChannelMsgHistory",
			Handler:    _ChanneldbOldService_GetChannelMsgHistory_Handler,
		},
		{
			MethodName: "GetChannelMediaMessageHistoryByMedia",
			Handler:    _ChanneldbOldService_GetChannelMediaMessageHistoryByMedia_Handler,
		},
		{
			MethodName: "SearchMessage",
			Handler:    _ChanneldbOldService_SearchMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hbase.proto",
}

func (m *ChannelMsgId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelMsgId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Id))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgId))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Pts))
	}
	if m.LastDate != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.LastDate))
	}
	return i, nil
}

func (m *MsgsAndMaxId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsAndMaxId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MaxMsgId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxMsgId))
	}
	if len(m.Msgs) > 0 {
		dAtA2 := make([]byte, len(m.Msgs)*10)
		var j1 int
		for _, num1 := range m.Msgs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *ReplyErr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyErr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrMsg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.ErrMsg)))
		i += copy(dAtA[i:], m.ErrMsg)
	}
	return i, nil
}

func (m *UserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Id))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithIdType))
	}
	if m.MessageType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MessageType))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Flags))
	}
	if m.Out {
		dAtA[i] = 0x38
		i++
		if m.Out {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mentioned {
		dAtA[i] = 0x40
		i++
		if m.Mentioned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MediaUnread {
		dAtA[i] = 0x48
		i++
		if m.MediaUnread {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Silent {
		dAtA[i] = 0x50
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Post {
		dAtA[i] = 0x58
		i++
		if m.Post {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.GroupId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgId))
	}
	if m.ToId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ToId))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Pts))
	}
	if len(m.FwdFrom) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.FwdFrom)))
		i += copy(dAtA[i:], m.FwdFrom)
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ViaBotId))
	}
	if m.ReplyToMsgId != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyToMsgId))
	}
	if m.Date != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Date))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Media != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Media))
	}
	if len(m.MediaData) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.MediaData)))
		i += copy(dAtA[i:], m.MediaData)
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintHbase(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.FromId != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.FromId))
	}
	if m.Views != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Views))
	}
	if m.EditDate != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.EditDate))
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if m.RandomId != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.RandomId))
	}
	if m.Uuid != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Uuid))
	}
	if m.InsertDate != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UpdateDate))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Encry))
	}
	if m.Combination != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Combination.Size()))
		n3, err := m.Combination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Combination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Combination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MentionedSlice) > 0 {
		for _, msg := range m.MentionedSlice {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.KeyId) > 0 {
		dAtA5 := make([]byte, len(m.KeyId)*10)
		var j4 int
		for _, num1 := range m.KeyId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	return i, nil
}

func (m *MentionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MentionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *UserMsgListAndPts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMsgListAndPts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, msg := range m.UserMsgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Pts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Pts))
	}
	if m.Count != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserId))
	}
	if len(m.Medias) > 0 {
		dAtA7 := make([]byte, len(m.Medias)*10)
		var j6 int
		for _, num1 := range m.Medias {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.MaxId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Encry))
	}
	return i, nil
}

func (m *GetChannelMsgIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMsgIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.DType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetChannelMsgIdResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMsgIdResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelMsgId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelMsgId.Size()))
		n8, err := m.ChannelMsgId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n9, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DeleteChannelMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChannelMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgId))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *DeleteChannelMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChannelMessageResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserId))
	}
	if m.CurrentMsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.CurrentMsgId))
	}
	if m.UpdateDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UpdateDate))
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n10, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *DeleteMsgsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMsgsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.MsgIds) > 0 {
		dAtA12 := make([]byte, len(m.MsgIds)*10)
		var j11 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *DeleteMsgsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMsgsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurrentMsgId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.CurrentMsgId))
	}
	if m.UpdateDate != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UpdateDate))
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n13, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *DeleteUserHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserId))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *DeleteUserHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteUserHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsgsAndMaxId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgsAndMaxId.Size()))
		n14, err := m.MsgsAndMaxId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Ptss) > 0 {
		dAtA16 := make([]byte, len(m.Ptss)*10)
		var j15 int
		for _, num1 := range m.Ptss {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.UpdateDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UpdateDate))
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n17, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *DeleteChannelMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteChannelMsgReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.DType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetChannelMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MsgId))
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetChannelMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMessageResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMsg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserMsg.Size()))
		n18, err := m.UserMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n19, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *GetChannelMsgsByMsgIdsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMsgsByMsgIdsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.MsgIds) > 0 {
		dAtA21 := make([]byte, len(m.MsgIds)*10)
		var j20 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if m.DType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetChannelMsgsByMsgIdsResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMsgsByMsgIdsResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMsgListAndPts != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserMsgListAndPts.Size()))
		n22, err := m.UserMsgListAndPts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n23, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *GetChannelMsgHistoryReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMsgHistoryReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.OffsetId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.OffsetId))
	}
	if m.OffsetDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.OffsetDate))
	}
	if m.AddOffset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.AddOffset))
	}
	if m.MinId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MinId))
	}
	if m.MaxId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Encry))
	}
	if m.DType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetChannelMsgHistoryResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMsgHistoryResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMsgListAndPts != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserMsgListAndPts.Size()))
		n24, err := m.UserMsgListAndPts.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n25, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *GetChannelTopMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelTopMsgReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelId))
	}
	if m.DType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetChannelTopMsgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelTopMsgResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserMsg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserMsg.Size()))
		n26, err := m.UserMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n27, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *GetMessageHistoryPageByMediaConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMessageHistoryPageByMediaConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithId))
	}
	if m.WithType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.WithType))
	}
	if m.MaxId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxId))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Encry))
	}
	if len(m.Medias) > 0 {
		dAtA29 := make([]byte, len(m.Medias)*10)
		var j28 int
		for _, num1 := range m.Medias {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	if m.Limit != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *GetChannelMediaMessageHistoryByMediaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMediaMessageHistoryByMediaReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GetChannelMediaMessageHistoryByMediaConfig != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.GetChannelMediaMessageHistoryByMediaConfig.Size()))
		n30, err := m.GetChannelMediaMessageHistoryByMediaConfig.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.DType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.DType))
	}
	return i, nil
}

func (m *GetChannelMediaMessageHistoryByMediaResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelMediaMessageHistoryByMediaResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelMsgs) > 0 {
		for _, msg := range m.ChannelMsgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ReplyErr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ReplyErr.Size()))
		n31, err := m.ReplyErr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *SearchChannelMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchChannelMsgReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.UserID))
	}
	if m.ChannelID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.ChannelID))
	}
	if m.FromID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.FromID))
	}
	if len(m.Medias) > 0 {
		dAtA33 := make([]byte, len(m.Medias)*10)
		var j32 int
		for _, num1 := range m.Medias {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintHbase(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	if m.OffsetID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.OffsetID))
	}
	if m.AddOffset != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.AddOffset))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Encry))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.Limit))
	}
	if m.MinDate != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxDate))
	}
	if m.MinID != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MinID))
	}
	if m.MaxID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHbase(dAtA, i, uint64(m.MaxID))
	}
	return i, nil
}

func (m *SearchChannelMsgResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchChannelMsgResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHbase(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintHbase(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ChannelMsgId) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHbase(uint64(m.Id))
	}
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		n += 1 + sovHbase(uint64(m.MsgId))
	}
	if m.Pts != 0 {
		n += 1 + sovHbase(uint64(m.Pts))
	}
	if m.LastDate != 0 {
		n += 1 + sovHbase(uint64(m.LastDate))
	}
	return n
}

func (m *MsgsAndMaxId) Size() (n int) {
	var l int
	_ = l
	if m.MaxMsgId != 0 {
		n += 1 + sovHbase(uint64(m.MaxMsgId))
	}
	if len(m.Msgs) > 0 {
		l = 0
		for _, e := range m.Msgs {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	return n
}

func (m *ReplyErr) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovHbase(uint64(m.ErrCode))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *UserMsg) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovHbase(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovHbase(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovHbase(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovHbase(uint64(m.WithIdType))
	}
	if m.MessageType != 0 {
		n += 1 + sovHbase(uint64(m.MessageType))
	}
	if m.Flags != 0 {
		n += 1 + sovHbase(uint64(m.Flags))
	}
	if m.Out {
		n += 2
	}
	if m.Mentioned {
		n += 2
	}
	if m.MediaUnread {
		n += 2
	}
	if m.Silent {
		n += 2
	}
	if m.Post {
		n += 2
	}
	if m.GroupId != 0 {
		n += 1 + sovHbase(uint64(m.GroupId))
	}
	if m.MsgId != 0 {
		n += 1 + sovHbase(uint64(m.MsgId))
	}
	if m.ToId != 0 {
		n += 1 + sovHbase(uint64(m.ToId))
	}
	if m.Pts != 0 {
		n += 1 + sovHbase(uint64(m.Pts))
	}
	l = len(m.FwdFrom)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	if m.ViaBotId != 0 {
		n += 2 + sovHbase(uint64(m.ViaBotId))
	}
	if m.ReplyToMsgId != 0 {
		n += 2 + sovHbase(uint64(m.ReplyToMsgId))
	}
	if m.Date != 0 {
		n += 2 + sovHbase(uint64(m.Date))
	}
	l = len(m.Message)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	if m.Media != 0 {
		n += 2 + sovHbase(uint64(m.Media))
	}
	l = len(m.MediaData)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			l = len(b)
			n += 2 + l + sovHbase(uint64(l))
		}
	}
	if m.FromId != 0 {
		n += 2 + sovHbase(uint64(m.FromId))
	}
	if m.Views != 0 {
		n += 2 + sovHbase(uint64(m.Views))
	}
	if m.EditDate != 0 {
		n += 2 + sovHbase(uint64(m.EditDate))
	}
	l = len(m.Action)
	if l > 0 {
		n += 2 + l + sovHbase(uint64(l))
	}
	if m.RandomId != 0 {
		n += 2 + sovHbase(uint64(m.RandomId))
	}
	if m.Uuid != 0 {
		n += 2 + sovHbase(uint64(m.Uuid))
	}
	if m.InsertDate != 0 {
		n += 2 + sovHbase(uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		n += 2 + sovHbase(uint64(m.UpdateDate))
	}
	if m.Encry != 0 {
		n += 2 + sovHbase(uint64(m.Encry))
	}
	if m.Combination != nil {
		l = m.Combination.Size()
		n += 2 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *Combination) Size() (n int) {
	var l int
	_ = l
	if len(m.MentionedSlice) > 0 {
		for _, e := range m.MentionedSlice {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	if len(m.KeyId) > 0 {
		l = 0
		for _, e := range m.KeyId {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	return n
}

func (m *MentionStatus) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovHbase(uint64(m.UserId))
	}
	if m.Status != 0 {
		n += 1 + sovHbase(uint64(m.Status))
	}
	return n
}

func (m *UserMsgListAndPts) Size() (n int) {
	var l int
	_ = l
	if len(m.UserMsgs) > 0 {
		for _, e := range m.UserMsgs {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	if m.Pts != 0 {
		n += 1 + sovHbase(uint64(m.Pts))
	}
	if m.Count != 0 {
		n += 1 + sovHbase(uint64(m.Count))
	}
	return n
}

func (m *GetChannelMediaMessageHistoryByMediaConfig) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		n += 1 + sovHbase(uint64(m.UserId))
	}
	if len(m.Medias) > 0 {
		l = 0
		for _, e := range m.Medias {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.MaxId != 0 {
		n += 1 + sovHbase(uint64(m.MaxId))
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	if m.Encry != 0 {
		n += 1 + sovHbase(uint64(m.Encry))
	}
	return n
}

func (m *GetChannelMsgIdReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetChannelMsgIdResp) Size() (n int) {
	var l int
	_ = l
	if m.ChannelMsgId != nil {
		l = m.ChannelMsgId.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *DeleteChannelMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		n += 1 + sovHbase(uint64(m.MsgId))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *DeleteChannelMessageResp) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovHbase(uint64(m.UserId))
	}
	if m.CurrentMsgId != 0 {
		n += 1 + sovHbase(uint64(m.CurrentMsgId))
	}
	if m.UpdateDate != 0 {
		n += 1 + sovHbase(uint64(m.UpdateDate))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *DeleteMsgsReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *DeleteMsgsResp) Size() (n int) {
	var l int
	_ = l
	if m.CurrentMsgId != 0 {
		n += 1 + sovHbase(uint64(m.CurrentMsgId))
	}
	if m.UpdateDate != 0 {
		n += 1 + sovHbase(uint64(m.UpdateDate))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *DeleteUserHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		n += 1 + sovHbase(uint64(m.UserId))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *DeleteUserHistoryResp) Size() (n int) {
	var l int
	_ = l
	if m.MsgsAndMaxId != nil {
		l = m.MsgsAndMaxId.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	if len(m.Ptss) > 0 {
		l = 0
		for _, e := range m.Ptss {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.UpdateDate != 0 {
		n += 1 + sovHbase(uint64(m.UpdateDate))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *DeleteChannelMsgReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetChannelMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.MsgId != 0 {
		n += 1 + sovHbase(uint64(m.MsgId))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetChannelMessageResp) Size() (n int) {
	var l int
	_ = l
	if m.UserMsg != nil {
		l = m.UserMsg.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *GetChannelMsgsByMsgIdsReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetChannelMsgsByMsgIdsResp) Size() (n int) {
	var l int
	_ = l
	if m.UserMsgListAndPts != nil {
		l = m.UserMsgListAndPts.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *GetChannelMsgHistoryReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.OffsetId != 0 {
		n += 1 + sovHbase(uint64(m.OffsetId))
	}
	if m.OffsetDate != 0 {
		n += 1 + sovHbase(uint64(m.OffsetDate))
	}
	if m.AddOffset != 0 {
		n += 1 + sovHbase(uint64(m.AddOffset))
	}
	if m.MinId != 0 {
		n += 1 + sovHbase(uint64(m.MinId))
	}
	if m.MaxId != 0 {
		n += 1 + sovHbase(uint64(m.MaxId))
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	if m.Encry != 0 {
		n += 1 + sovHbase(uint64(m.Encry))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetChannelMsgHistoryResp) Size() (n int) {
	var l int
	_ = l
	if m.UserMsgListAndPts != nil {
		l = m.UserMsgListAndPts.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *GetChannelTopMsgReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovHbase(uint64(m.ChannelId))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetChannelTopMsgResp) Size() (n int) {
	var l int
	_ = l
	if m.UserMsg != nil {
		l = m.UserMsg.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *GetMessageHistoryPageByMediaConfig) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovHbase(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovHbase(uint64(m.WithId))
	}
	if m.WithType != 0 {
		n += 1 + sovHbase(uint64(m.WithType))
	}
	if m.MaxId != 0 {
		n += 1 + sovHbase(uint64(m.MaxId))
	}
	if m.Encry != 0 {
		n += 1 + sovHbase(uint64(m.Encry))
	}
	if len(m.Medias) > 0 {
		l = 0
		for _, e := range m.Medias {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	return n
}

func (m *GetChannelMediaMessageHistoryByMediaReq) Size() (n int) {
	var l int
	_ = l
	if m.GetChannelMediaMessageHistoryByMediaConfig != nil {
		l = m.GetChannelMediaMessageHistoryByMediaConfig.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	if m.DType != 0 {
		n += 1 + sovHbase(uint64(m.DType))
	}
	return n
}

func (m *GetChannelMediaMessageHistoryByMediaResp) Size() (n int) {
	var l int
	_ = l
	if len(m.ChannelMsgs) > 0 {
		for _, e := range m.ChannelMsgs {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	if m.ReplyErr != nil {
		l = m.ReplyErr.Size()
		n += 1 + l + sovHbase(uint64(l))
	}
	return n
}

func (m *SearchChannelMsgReq) Size() (n int) {
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovHbase(uint64(m.UserID))
	}
	if m.ChannelID != 0 {
		n += 1 + sovHbase(uint64(m.ChannelID))
	}
	if m.FromID != 0 {
		n += 1 + sovHbase(uint64(m.FromID))
	}
	if len(m.Medias) > 0 {
		l = 0
		for _, e := range m.Medias {
			l += sovHbase(uint64(e))
		}
		n += 1 + sovHbase(uint64(l)) + l
	}
	if m.OffsetID != 0 {
		n += 1 + sovHbase(uint64(m.OffsetID))
	}
	if m.AddOffset != 0 {
		n += 1 + sovHbase(uint64(m.AddOffset))
	}
	if m.Encry != 0 {
		n += 1 + sovHbase(uint64(m.Encry))
	}
	if m.Limit != 0 {
		n += 1 + sovHbase(uint64(m.Limit))
	}
	if m.MinDate != 0 {
		n += 1 + sovHbase(uint64(m.MinDate))
	}
	if m.MaxDate != 0 {
		n += 1 + sovHbase(uint64(m.MaxDate))
	}
	if m.MinID != 0 {
		n += 1 + sovHbase(uint64(m.MinID))
	}
	if m.MaxID != 0 {
		n += 1 + sovHbase(uint64(m.MaxID))
	}
	return n
}

func (m *SearchChannelMsgResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovHbase(uint64(l))
		}
	}
	return n
}

func sovHbase(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHbase(x uint64) (n int) {
	return sovHbase(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChannelMsgId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelMsgId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelMsgId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastDate", wireType)
			}
			m.LastDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsAndMaxId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsAndMaxId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsAndMaxId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMsgId", wireType)
			}
			m.MaxMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Msgs = append(m.Msgs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Msgs = append(m.Msgs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyErr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyErr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyErr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Out = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentioned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mentioned = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaUnread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MediaUnread = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Post = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToId", wireType)
			}
			m.ToId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdFrom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwdFrom = append(m.FwdFrom[:0], dAtA[iNdEx:postIndex]...)
			if m.FwdFrom == nil {
				m.FwdFrom = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMsgId", wireType)
			}
			m.ReplyToMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaData = append(m.MediaData[:0], dAtA[iNdEx:postIndex]...)
			if m.MediaData == nil {
				m.MediaData = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, make([]byte, postIndex-iNdEx))
			copy(m.Entities[len(m.Entities)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			m.Views = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Views |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			m.EditDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = append(m.Action[:0], dAtA[iNdEx:postIndex]...)
			if m.Action == nil {
				m.Action = []byte{}
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			m.Uuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertDate", wireType)
			}
			m.InsertDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDate", wireType)
			}
			m.UpdateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Combination == nil {
				m.Combination = &Combination{}
			}
			if err := m.Combination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Combination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Combination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Combination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedSlice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MentionedSlice = append(m.MentionedSlice, &MentionStatus{})
			if err := m.MentionedSlice[len(m.MentionedSlice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyId = append(m.KeyId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyId = append(m.KeyId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MentionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MentionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MentionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserMsgListAndPts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMsgListAndPts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMsgListAndPts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserMsgs = append(m.UserMsgs, &UserMsg{})
			if err := m.UserMsgs[len(m.UserMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMediaMessageHistoryByMediaConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMediaMessageHistoryByMediaConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMediaMessageHistoryByMediaConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medias = append(m.Medias, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medias = append(m.Medias, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMsgIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMsgIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMsgIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMsgIdResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMsgIdResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMsgIdResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelMsgId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelMsgId == nil {
				m.ChannelMsgId = &ChannelMsgId{}
			}
			if err := m.ChannelMsgId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentMsgId", wireType)
			}
			m.CurrentMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDate", wireType)
			}
			m.UpdateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMsgsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMsgsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMsgsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMsgsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMsgsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMsgsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentMsgId", wireType)
			}
			m.CurrentMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDate", wireType)
			}
			m.UpdateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgsAndMaxId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsgsAndMaxId == nil {
				m.MsgsAndMaxId = &MsgsAndMaxId{}
			}
			if err := m.MsgsAndMaxId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ptss = append(m.Ptss, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ptss = append(m.Ptss, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptss", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDate", wireType)
			}
			m.UpdateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMsg == nil {
				m.UserMsg = &UserMsg{}
			}
			if err := m.UserMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMsgsByMsgIdsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMsgsByMsgIdsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMsgsByMsgIdsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMsgsByMsgIdsResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMsgsByMsgIdsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMsgsByMsgIdsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsgListAndPts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMsgListAndPts == nil {
				m.UserMsgListAndPts = &UserMsgListAndPts{}
			}
			if err := m.UserMsgListAndPts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMsgHistoryReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMsgHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMsgHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetId", wireType)
			}
			m.OffsetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetDate", wireType)
			}
			m.OffsetDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOffset", wireType)
			}
			m.AddOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinId", wireType)
			}
			m.MinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMsgHistoryResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMsgHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMsgHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsgListAndPts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMsgListAndPts == nil {
				m.UserMsgListAndPts = &UserMsgListAndPts{}
			}
			if err := m.UserMsgListAndPts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelTopMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelTopMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelTopMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelTopMsgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelTopMsgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelTopMsgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserMsg == nil {
				m.UserMsg = &UserMsg{}
			}
			if err := m.UserMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMessageHistoryPageByMediaConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMessageHistoryPageByMediaConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMessageHistoryPageByMediaConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithType", wireType)
			}
			m.WithType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medias = append(m.Medias, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medias = append(m.Medias, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMediaMessageHistoryByMediaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMediaMessageHistoryByMediaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMediaMessageHistoryByMediaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetChannelMediaMessageHistoryByMediaConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GetChannelMediaMessageHistoryByMediaConfig == nil {
				m.GetChannelMediaMessageHistoryByMediaConfig = &GetChannelMediaMessageHistoryByMediaConfig{}
			}
			if err := m.GetChannelMediaMessageHistoryByMediaConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DType", wireType)
			}
			m.DType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DType |= (DATABASETYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelMediaMessageHistoryByMediaResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelMediaMessageHistoryByMediaResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelMediaMessageHistoryByMediaResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelMsgs = append(m.ChannelMsgs, &UserMsg{})
			if err := m.ChannelMsgs[len(m.ChannelMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyErr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplyErr == nil {
				m.ReplyErr = &ReplyErr{}
			}
			if err := m.ReplyErr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchChannelMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchChannelMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchChannelMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			m.ChannelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromID", wireType)
			}
			m.FromID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Medias = append(m.Medias, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHbase
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHbase
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Medias = append(m.Medias, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Medias", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffsetID", wireType)
			}
			m.OffsetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffsetID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddOffset", wireType)
			}
			m.AddOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDate", wireType)
			}
			m.MinDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDate", wireType)
			}
			m.MaxDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinID", wireType)
			}
			m.MinID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxID", wireType)
			}
			m.MaxID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchChannelMsgResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchChannelMsgResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchChannelMsgResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHbase
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, &UserMsg{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHbase(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHbase
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHbase(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHbase
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHbase
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHbase
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHbase
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHbase(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHbase = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHbase   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("hbase.proto", fileDescriptorHbase) }

var fileDescriptorHbase = []byte{
	// 1805 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x5f, 0x6f, 0x1c, 0x49,
	0x11, 0xcf, 0xec, 0xdf, 0xd9, 0xda, 0xb5, 0xcf, 0x69, 0x3b, 0x4e, 0x67, 0x13, 0x7c, 0x9b, 0xe1,
	0xe0, 0x56, 0x79, 0x30, 0x60, 0x04, 0x87, 0x04, 0x3a, 0x64, 0xef, 0x3a, 0x61, 0x45, 0xf6, 0x62,
	0x8d, 0xed, 0x70, 0xf7, 0xc2, 0x69, 0xb2, 0xd3, 0x5e, 0x8f, 0x6e, 0xe7, 0x0f, 0xd3, 0xbd, 0x71,
	0x2c, 0x4e, 0x70, 0x12, 0x2f, 0xf0, 0x8e, 0x14, 0x24, 0x84, 0x78, 0xe7, 0x33, 0x20, 0x21, 0xde,
	0x10, 0x4f, 0x7c, 0x04, 0x94, 0x0f, 0xc1, 0x33, 0xea, 0xea, 0x9e, 0xd9, 0x99, 0xf5, 0xac, 0xbd,
	0xb6, 0x94, 0xe8, 0xde, 0xb6, 0xaa, 0xfa, 0x4f, 0xf5, 0xaf, 0xaa, 0x7e, 0x5d, 0x3d, 0x0b, 0xcd,
	0xd3, 0x17, 0x0e, 0x67, 0xdb, 0x51, 0x1c, 0x8a, 0x90, 0xb4, 0x46, 0xa7, 0x4e, 0x10, 0xb0, 0x89,
	0xfb, 0x22, 0x9c, 0xb8, 0xd6, 0x57, 0x06, 0xb4, 0x7a, 0x4a, 0x31, 0xe4, 0xe3, 0x81, 0x4b, 0x56,
	0xa1, 0x34, 0x70, 0xa9, 0xd1, 0x31, 0xba, 0x55, 0xbb, 0xe4, 0xb9, 0xe4, 0x01, 0x34, 0xb4, 0x7d,
	0xe0, 0xd2, 0x12, 0xaa, 0x1b, 0xa3, 0x44, 0x41, 0x36, 0xa0, 0x8a, 0xd3, 0x68, 0x19, 0x2d, 0x55,
	0x1f, 0xd7, 0x58, 0x83, 0xf2, 0x81, 0xe0, 0xb4, 0x82, 0xba, 0x72, 0x24, 0x38, 0x69, 0x83, 0xf9,
	0xd4, 0xe1, 0xa2, 0xef, 0x08, 0x46, 0xab, 0xa8, 0x36, 0x27, 0x5a, 0xb6, 0x3e, 0x86, 0xd6, 0x90,
	0x8f, 0xf9, 0x6e, 0xe0, 0x0e, 0x9d, 0x57, 0x03, 0x57, 0x8e, 0x1d, 0x3a, 0xaf, 0xd4, 0xb2, 0xca,
	0x0f, 0xd3, 0xd7, 0x32, 0x21, 0x50, 0x91, 0x63, 0x69, 0xa9, 0x53, 0xee, 0x56, 0xed, 0x8a, 0xcf,
	0xc7, 0xdc, 0xfa, 0x09, 0x98, 0x36, 0x8b, 0x26, 0xe7, 0xfb, 0x71, 0x4c, 0x28, 0xd4, 0xf7, 0xe3,
	0xb8, 0x17, 0xba, 0x0c, 0xa7, 0xae, 0xd8, 0x75, 0xa6, 0x44, 0xb2, 0x09, 0xb5, 0xfd, 0x38, 0x1e,
	0xf2, 0x31, 0x1e, 0xa2, 0x61, 0xd7, 0x18, 0x4a, 0xd6, 0x1f, 0xeb, 0x50, 0x3f, 0xe6, 0x4c, 0xfe,
	0xce, 0x9c, 0xbd, 0x8c, 0x67, 0xdf, 0x84, 0x9a, 0x34, 0xa5, 0x07, 0xaf, 0x4d, 0x51, 0x92, 0xfa,
	0x5f, 0x78, 0xe2, 0x34, 0x3d, 0x76, 0xed, 0x0c, 0x25, 0xb2, 0x05, 0xa0, 0xf4, 0x47, 0xe7, 0x11,
	0xd3, 0xc7, 0x87, 0xb3, 0x54, 0x43, 0x3a, 0xd0, 0x1c, 0x32, 0xce, 0x9d, 0x31, 0xc3, 0x01, 0x0a,
	0x88, 0xa6, 0x3f, 0x53, 0x49, 0x3c, 0x1f, 0x4f, 0x9c, 0x31, 0xa7, 0x35, 0x85, 0xe7, 0x89, 0x14,
	0x24, 0x9e, 0xcf, 0xa6, 0x82, 0xd6, 0x3b, 0x46, 0xd7, 0xb4, 0xcb, 0xe1, 0x54, 0xc8, 0xa8, 0x0c,
	0x59, 0x20, 0xbc, 0x30, 0x60, 0x2e, 0x35, 0x51, 0xdf, 0xf0, 0x13, 0x85, 0xda, 0xc7, 0xf5, 0x9c,
	0xe3, 0x20, 0x66, 0x8e, 0x4b, 0x1b, 0x68, 0x6f, 0xfa, 0x33, 0x95, 0x3c, 0xc1, 0xa1, 0x37, 0x61,
	0x81, 0xa0, 0x80, 0xc6, 0x1a, 0x47, 0x49, 0xe2, 0x7b, 0x10, 0x72, 0x41, 0x9b, 0xa8, 0xad, 0x44,
	0x21, 0x17, 0x12, 0xd3, 0x27, 0x71, 0x38, 0x8d, 0x06, 0x2e, 0x6d, 0x21, 0x34, 0xf5, 0xb1, 0x12,
	0x67, 0xd1, 0x5f, 0xc9, 0x46, 0x9f, 0x40, 0xe5, 0x28, 0x1c, 0xb8, 0x74, 0x15, 0x95, 0x15, 0x11,
	0xce, 0x32, 0xe2, 0xbd, 0x59, 0x46, 0x50, 0xa8, 0x3f, 0x3e, 0x73, 0x1f, 0xc7, 0xa1, 0x4f, 0xd7,
	0x3a, 0x46, 0xb7, 0x65, 0xd7, 0x4f, 0x94, 0x28, 0xe3, 0xff, 0xdc, 0x73, 0xf6, 0x42, 0x31, 0x70,
	0xe9, 0x6d, 0x15, 0xff, 0x97, 0x5a, 0x26, 0x16, 0xb4, 0x30, 0xd6, 0x47, 0xa1, 0xda, 0x98, 0xa0,
	0xbd, 0x15, 0x67, 0x74, 0x72, 0x7f, 0xcc, 0xb3, 0x75, 0xb5, 0xbf, 0xeb, 0x08, 0x26, 0x77, 0xd3,
	0xc8, 0xd3, 0x0d, 0x0c, 0x7f, 0x5d, 0xa3, 0x8e, 0x67, 0x90, 0xc0, 0xd0, 0x3b, 0x78, 0xb6, 0x2a,
	0xa2, 0xa4, 0xf0, 0x75, 0x3d, 0xa7, 0xef, 0x08, 0x87, 0x6e, 0xa2, 0x7f, 0x0d, 0x3f, 0x51, 0x48,
	0x7c, 0xd1, 0x8b, 0xa1, 0x13, 0x7f, 0x31, 0x8d, 0xe8, 0x5d, 0xb4, 0x37, 0xe3, 0x99, 0x4a, 0x9e,
	0x61, 0x3f, 0x10, 0x9e, 0xf0, 0x18, 0xa7, 0xb4, 0x53, 0xee, 0xb6, 0x6c, 0x93, 0x69, 0x59, 0x62,
	0x2f, 0xcf, 0x39, 0x70, 0xe9, 0x3d, 0x95, 0x3d, 0x27, 0x28, 0x49, 0x4f, 0x9e, 0x7b, 0xec, 0x8c,
	0xd3, 0xb6, 0x42, 0xf3, 0xa5, 0x14, 0x70, 0x25, 0xd7, 0x53, 0x95, 0x73, 0x5f, 0xa1, 0xc1, 0xb4,
	0x2c, 0x57, 0xda, 0x1d, 0xc9, 0x98, 0xd3, 0x07, 0xe8, 0x42, 0xcd, 0x41, 0x49, 0xce, 0xb1, 0x9d,
	0xc0, 0xc5, 0x3d, 0xbe, 0x81, 0xc7, 0x32, 0x63, 0x2d, 0x4b, 0x74, 0x8e, 0xa7, 0x9e, 0x4b, 0xb7,
	0x50, 0x5f, 0x99, 0x4e, 0x3d, 0xcc, 0xdb, 0x41, 0xc0, 0x59, 0xac, 0x76, 0x79, 0x5f, 0xe5, 0xad,
	0x97, 0x6a, 0xa4, 0xfd, 0x38, 0x92, 0x38, 0xa2, 0xbd, 0xa3, 0xec, 0xd3, 0x54, 0x23, 0x3d, 0xdf,
	0x0f, 0x46, 0xf1, 0x39, 0x7d, 0xa8, 0x3c, 0x67, 0x52, 0x20, 0x3f, 0x86, 0x66, 0x2f, 0xf4, 0x5f,
	0x78, 0x81, 0x83, 0x2e, 0x5a, 0x1d, 0xa3, 0xdb, 0xdc, 0xb9, 0xb7, 0x9d, 0xa5, 0x9f, 0xed, 0xcc,
	0x00, 0xbb, 0x39, 0x9a, 0x09, 0xd6, 0x69, 0x6e, 0x32, 0xe9, 0xc1, 0x6a, 0x9a, 0xef, 0x87, 0x13,
	0x6f, 0x24, 0xcb, 0xbb, 0xdc, 0x6d, 0xee, 0xdc, 0xcf, 0x2f, 0xa7, 0xc7, 0x1c, 0x0a, 0x47, 0x4c,
	0xb9, 0xbd, 0xea, 0xe7, 0xa6, 0x48, 0x37, 0x7f, 0xce, 0xce, 0xb1, 0x9a, 0xcb, 0x32, 0xd4, 0x5f,
	0x48, 0xc1, 0xfa, 0x29, 0xac, 0xe4, 0xa6, 0x65, 0xaa, 0xde, 0x98, 0xaf, 0x7a, 0x35, 0x22, 0x61,
	0x03, 0x8e, 0x92, 0x15, 0xc0, 0x6d, 0x4d, 0x20, 0x4f, 0x3d, 0x2e, 0x76, 0x03, 0xf7, 0x40, 0x70,
	0xf2, 0x3d, 0x30, 0xb5, 0x92, 0x6b, 0x57, 0xef, 0xe4, 0x5d, 0xd5, 0x56, 0xdb, 0x9c, 0xea, 0x61,
	0x49, 0x8d, 0x94, 0x66, 0x35, 0xb2, 0x01, 0xd5, 0x5e, 0x38, 0x0d, 0x44, 0xc2, 0xae, 0x23, 0x29,
	0x58, 0x7f, 0x37, 0xe0, 0xd1, 0x13, 0x26, 0x12, 0xd6, 0x96, 0x59, 0xa9, 0x73, 0xfb, 0x67, 0x1e,
	0x17, 0x61, 0x7c, 0xbe, 0x77, 0x8e, 0xca, 0x5e, 0x18, 0x9c, 0x78, 0xe3, 0x3c, 0x81, 0x1b, 0xf3,
	0x04, 0x7e, 0x09, 0xc5, 0xe1, 0x22, 0x9c, 0x96, 0x91, 0x6a, 0x6b, 0x98, 0xfd, 0xe8, 0x12, 0xb2,
	0xb4, 0x66, 0xb7, 0xaa, 0x8f, 0x94, 0xbd, 0x01, 0xd5, 0xa7, 0x9e, 0xef, 0x09, 0x4d, 0x69, 0xd5,
	0x89, 0x14, 0xa4, 0x16, 0x33, 0x21, 0x21, 0x33, 0x14, 0x2c, 0x17, 0x48, 0xc6, 0x7b, 0x59, 0xb1,
	0x36, 0xfb, 0xd5, 0x15, 0x5e, 0x7e, 0x17, 0xaa, 0x7d, 0xa4, 0x4c, 0xe9, 0xe4, 0xea, 0x4e, 0x3b,
	0x0f, 0x65, 0x7f, 0xf7, 0x68, 0x77, 0x6f, 0xf7, 0x70, 0xff, 0xe8, 0xb3, 0x83, 0x7d, 0xbb, 0x8a,
	0x54, 0x6b, 0xfd, 0xc1, 0x80, 0xf5, 0x0b, 0xdb, 0xf0, 0x88, 0x7c, 0x9c, 0xbf, 0xee, 0x70, 0xab,
	0xe6, 0xfc, 0x82, 0xb9, 0x59, 0xc9, 0x7d, 0xa9, 0xc8, 0x65, 0x67, 0x76, 0xd9, 0xa0, 0x33, 0xcd,
	0x9d, 0xcd, 0xfc, 0xdc, 0xc4, 0x6a, 0x9b, 0xb1, 0xfe, 0x65, 0xfd, 0x16, 0xee, 0xf6, 0xd9, 0x84,
	0x09, 0x96, 0x86, 0x0c, 0xa3, 0x75, 0xf5, 0xb1, 0x53, 0x7e, 0x2d, 0x65, 0xf9, 0x35, 0x05, 0xa3,
	0xbc, 0x2c, 0x18, 0x7f, 0x33, 0x80, 0x16, 0x7b, 0xc0, 0xa3, 0x85, 0xe9, 0x6e, 0x41, 0xab, 0x37,
	0x8d, 0x63, 0x16, 0x88, 0xac, 0x0f, 0xad, 0x51, 0x46, 0x37, 0x47, 0x0c, 0xe5, 0x0b, 0xc4, 0x90,
	0x45, 0xab, 0xb2, 0x24, 0x5a, 0x67, 0xb0, 0xa2, 0x7c, 0x95, 0x45, 0x71, 0x35, 0x46, 0x32, 0x51,
	0xa5, 0x2f, 0x49, 0x4f, 0x50, 0x43, 0x90, 0xf8, 0x0d, 0x50, 0xfa, 0xbd, 0x01, 0xab, 0xd9, 0x9d,
	0x79, 0x74, 0x01, 0x03, 0xe3, 0x4a, 0x0c, 0x4a, 0x97, 0x62, 0x50, 0x5e, 0x12, 0x83, 0xdf, 0xc0,
	0x86, 0xf2, 0x44, 0x46, 0x46, 0x57, 0xf5, 0x52, 0x50, 0x14, 0xd6, 0xf2, 0xf5, 0xa1, 0xf8, 0x87,
	0x01, 0x77, 0x0a, 0x1c, 0x50, 0xf5, 0x93, 0x6d, 0xd6, 0x8a, 0xeb, 0x27, 0x3b, 0xc2, 0x6e, 0xf9,
	0xd9, 0xe6, 0x4e, 0x36, 0x18, 0x82, 0xa7, 0x0d, 0x5c, 0x24, 0x38, 0x7f, 0x2b, 0x59, 0xc4, 0x60,
	0x3d, 0x9f, 0xf1, 0x7c, 0xfc, 0x36, 0x68, 0xe6, 0x4b, 0xd8, 0xc8, 0x52, 0xf1, 0x3b, 0xae, 0xeb,
	0x2f, 0xe1, 0x4e, 0xc1, 0xee, 0x3c, 0x22, 0xdf, 0x49, 0x7b, 0x5a, 0x1d, 0xa0, 0x05, 0x97, 0x4f,
	0x5d, 0x5f, 0x3e, 0x37, 0xa2, 0xb5, 0xdf, 0x19, 0x70, 0x2f, 0x47, 0xb1, 0x7c, 0xef, 0x5c, 0x95,
	0xe2, 0xbb, 0xac, 0xda, 0xbf, 0x1a, 0xd0, 0x5e, 0xe4, 0x05, 0x8f, 0xc8, 0xb0, 0xe0, 0x72, 0xd6,
	0x98, 0xbc, 0x5f, 0x88, 0xc9, 0x6c, 0x98, 0x7d, 0x7b, 0x7a, 0xe1, 0x5a, 0xbf, 0x09, 0x4e, 0x7f,
	0x2e, 0xc1, 0xdd, 0x9c, 0x87, 0x4b, 0x17, 0x74, 0x1b, 0xcc, 0x67, 0x27, 0x27, 0x9c, 0x89, 0x34,
	0x55, 0xcc, 0x50, 0xcb, 0xb2, 0x68, 0x94, 0x2d, 0x5b, 0x34, 0x61, 0xaa, 0x91, 0x2b, 0xef, 0xba,
	0xae, 0x1a, 0xa2, 0x2f, 0xeb, 0x86, 0x93, 0x28, 0x30, 0x03, 0xbd, 0x60, 0xe0, 0x26, 0x17, 0xb6,
	0x2f, 0x85, 0xd9, 0xe5, 0x5e, 0x2b, 0xbc, 0xdc, 0xeb, 0x73, 0x97, 0xbb, 0xea, 0xf9, 0xcc, 0x6c,
	0xcf, 0x97, 0xc6, 0xaf, 0xb1, 0x6c, 0xfc, 0xfe, 0x62, 0x00, 0x2d, 0x46, 0xe7, 0xeb, 0x11, 0x3d,
	0x96, 0xed, 0x23, 0x8e, 0xc2, 0xe8, 0x2d, 0x11, 0xc9, 0xaf, 0xb3, 0x44, 0x92, 0x6c, 0xf3, 0xae,
	0x2a, 0xf9, 0xdf, 0x06, 0x58, 0x4f, 0x98, 0xc8, 0x77, 0x91, 0x07, 0xce, 0x98, 0xe5, 0x3b, 0xc9,
	0x4b, 0x1a, 0x63, 0xfd, 0x1c, 0x2e, 0xe5, 0x9e, 0xc3, 0x6d, 0x30, 0xa5, 0x3e, 0xad, 0xe7, 0xaa,
	0x6d, 0x9e, 0x69, 0x79, 0x71, 0x1f, 0xa9, 0x92, 0xaa, 0x9a, 0x4d, 0xaa, 0x59, 0x2f, 0x5a, 0x9b,
	0xef, 0x45, 0x2f, 0x26, 0xa6, 0xf5, 0x3f, 0x03, 0x3e, 0x5c, 0xa6, 0x3d, 0x96, 0x51, 0xfc, 0xd3,
	0xb5, 0x5a, 0x69, 0x1d, 0x81, 0x1f, 0xe5, 0xf1, 0x5c, 0x7e, 0xbe, 0xfd, 0x68, 0xbc, 0x7c, 0xdb,
	0x7e, 0xfd, 0x14, 0x7a, 0x6d, 0x40, 0x77, 0xb9, 0x83, 0xf3, 0x88, 0x7c, 0x04, 0xcd, 0x0c, 0x65,
	0x5e, 0xfe, 0x44, 0x69, 0xce, 0x3a, 0xe0, 0x9b, 0xd5, 0xd0, 0x3f, 0x4b, 0xb0, 0x7e, 0xc8, 0x9c,
	0x78, 0x74, 0x9a, 0xbf, 0x8d, 0x93, 0x84, 0xea, 0xe7, 0x12, 0xaa, 0x9f, 0x2d, 0xae, 0xfe, 0xfc,
	0x37, 0xa7, 0x7e, 0xfa, 0x7e, 0xee, 0x27, 0x5f, 0x5f, 0xf0, 0xfd, 0xdc, 0xcf, 0xa4, 0x49, 0x25,
	0x97, 0x26, 0x33, 0x16, 0xed, 0x27, 0xdf, 0x9e, 0x34, 0x8b, 0xf6, 0xf3, 0x2c, 0x59, 0x2b, 0x60,
	0x49, 0x95, 0x8e, 0xf5, 0x6c, 0x3a, 0xa6, 0x69, 0x67, 0x66, 0xf9, 0x90, 0x42, 0x7d, 0xe8, 0x05,
	0x48, 0xc6, 0x0d, 0xd4, 0xd7, 0x7d, 0x25, 0xa2, 0xc5, 0x79, 0x85, 0x16, 0xd0, 0x16, 0x25, 0x26,
	0x2c, 0xdc, 0xc7, 0xcf, 0x2d, 0x9a, 0x85, 0xfb, 0x49, 0x69, 0xf4, 0xf1, 0x6b, 0x8b, 0x2e, 0x8d,
	0xbe, 0x35, 0x80, 0x8d, 0x8b, 0x10, 0xf2, 0x48, 0x3e, 0x34, 0x75, 0x94, 0xaf, 0x7a, 0x68, 0xea,
	0x2f, 0x1e, 0xfc, 0xd1, 0x47, 0xd0, 0xca, 0xe6, 0x0f, 0xa9, 0x82, 0xf1, 0xf9, 0xda, 0x2d, 0xd2,
	0x02, 0xf3, 0xf8, 0x93, 0xcf, 0xf7, 0x3f, 0xe9, 0xd9, 0x9f, 0xad, 0x19, 0xa4, 0x01, 0x55, 0xf5,
	0xb3, 0x44, 0xea, 0x50, 0x7e, 0x3e, 0x38, 0x58, 0xab, 0xec, 0x7c, 0x65, 0xc2, 0x7a, 0x2f, 0x59,
	0xfb, 0xd9, 0xc4, 0x3d, 0x64, 0xf1, 0x4b, 0xf9, 0xb0, 0xfe, 0x14, 0xde, 0x9b, 0x7b, 0x6b, 0x91,
	0xce, 0xc2, 0x22, 0xd1, 0x2f, 0xbe, 0xf6, 0xc3, 0x2b, 0x46, 0xf0, 0xc8, 0xba, 0x45, 0xc6, 0x49,
	0x23, 0x9c, 0x6f, 0x72, 0xc8, 0xb7, 0xe6, 0xca, 0xa1, 0xf8, 0x79, 0xd5, 0xfe, 0xf6, 0x32, 0xc3,
	0x70, 0xa3, 0x01, 0xc0, 0xac, 0xf7, 0x27, 0xf7, 0x8b, 0xe6, 0xe9, 0xf7, 0x48, 0xfb, 0xc1, 0x62,
	0x23, 0x2e, 0xf5, 0x4b, 0xb8, 0x7d, 0xa1, 0x77, 0x26, 0x56, 0xd1, 0xa4, 0x7c, 0x77, 0xdf, 0xfe,
	0xe6, 0x95, 0x63, 0x70, 0xfd, 0x67, 0xb0, 0x36, 0xdf, 0xda, 0x92, 0x87, 0x97, 0x1d, 0x14, 0x8b,
	0xad, 0xbd, 0xa0, 0x4c, 0x95, 0xc3, 0x17, 0xda, 0xc8, 0x79, 0x87, 0x8b, 0xba, 0xdc, 0x79, 0x87,
	0x0b, 0x7b, 0x51, 0xeb, 0x16, 0xf1, 0x61, 0xb3, 0xb8, 0x43, 0x23, 0x1f, 0x5e, 0x92, 0x03, 0xd9,
	0x6e, 0xb2, 0xdd, 0x5d, 0x6e, 0x60, 0x92, 0x33, 0x45, 0x0d, 0xc5, 0x7c, 0xce, 0x2c, 0x68, 0xc9,
	0xe6, 0x73, 0x66, 0x51, 0x6f, 0x62, 0xdd, 0x22, 0xaf, 0x0d, 0xf8, 0x60, 0x19, 0xc2, 0x25, 0x3f,
	0xb8, 0xfe, 0x8d, 0x21, 0x3d, 0xf9, 0xe1, 0x4d, 0xa6, 0xa1, 0x67, 0x9f, 0xc2, 0x8a, 0x22, 0x8b,
	0x24, 0x9a, 0x73, 0xf9, 0x51, 0x40, 0xc6, 0x6d, 0xeb, 0xaa, 0x21, 0x72, 0xe5, 0xbd, 0x0f, 0xfe,
	0xf5, 0x66, 0xcb, 0xf8, 0xcf, 0x9b, 0x2d, 0xe3, 0xbf, 0x6f, 0xb6, 0x0c, 0xd8, 0xf0, 0xfc, 0xed,
	0x48, 0x6c, 0x8f, 0x34, 0xb5, 0xa8, 0x7f, 0x18, 0x0e, 0x8c, 0x17, 0x35, 0xfc, 0xf1, 0xfd, 0xff,
	0x07, 0x00, 0x00, 0xff, 0xff, 0xba, 0xe7, 0xa9, 0x67, 0x79, 0x18, 0x00, 0x00,
}
