// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/groupservice/activeuserinfoserver.proto

/*
Package groupservice is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/groupservice/activeuserinfoserver.proto
	gitlab.chatserver.im/interfaceprobuf/groupservice/groupservice.proto
	gitlab.chatserver.im/interfaceprobuf/groupservice/groupusersearch.proto
	gitlab.chatserver.im/interfaceprobuf/groupservice/kickedleftinfoserver.proto
	gitlab.chatserver.im/interfaceprobuf/groupservice/usernamesearchserver.proto

It has these top-level messages:

	ActivateUserReq
	ActivateUserReply
	SearchSelfGroupReq
	SearchSelfGroupReply
	GetTwoUserChatsCountReq
	GetTwoUserChatsCountReply
	GetTwoUserChatsReq
	GetTwoUserChatsReply
	CheckOnlineUsersReq
	CheckOnlineUsersReply
	SearchUsersByStrReq
	SearchUsersByStrReply
	UserNameBase
	ChatChannel
	ChannelParticipants
	ChannelKickedLeft
	SearchUsersByNameReq
	SearchUsersByNameReply
	SearchKickedParticipantReq
	SearchKickedParticipantReply
	GetChannelKickedByLimitReq
	GetChannelKickedByLimitReply
	GetChannelKeckedLeftReq
	GetChannelKeckedLeftReply
	AddLeftParticipantReq
	AddLeftParticipantReply
	DelLeftParticipantReq
	DelLeftParticipantReply
	DelAllLeftChatParticipantReq
	DelAllLeftChatParticipantReply
	UpdateUsernameReq
	UpdateUsernameReply
	GetUsernameReq
	GetUsernameReply
	SearchUsernameReq
	SearchUsernameReply
*/
package groupservice

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 激活用户
type ActivateUserReq struct {
	KeyId  int64 `protobuf:"varint,1,opt,name=KeyId,proto3" json:"KeyId,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=UserId,proto3" json:"UserId,omitempty"`
}

func (m *ActivateUserReq) Reset()         { *m = ActivateUserReq{} }
func (m *ActivateUserReq) String() string { return proto.CompactTextString(m) }
func (*ActivateUserReq) ProtoMessage()    {}
func (*ActivateUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{0}
}

func (m *ActivateUserReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *ActivateUserReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ActivateUserReply struct {
	ErrorCode ActiveErrorCode `protobuf:"varint,1,opt,name=ErrorCode,proto3,enum=groupservice.ActiveErrorCode" json:"ErrorCode,omitempty"`
}

func (m *ActivateUserReply) Reset()         { *m = ActivateUserReply{} }
func (m *ActivateUserReply) String() string { return proto.CompactTextString(m) }
func (*ActivateUserReply) ProtoMessage()    {}
func (*ActivateUserReply) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{1}
}

func (m *ActivateUserReply) GetErrorCode() ActiveErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ActiveErrorCode_Active_OK
}

// 根据群名称搜索自己所在的群
type SearchSelfGroupReq struct {
	Title  string `protobuf:"bytes,1,opt,name=Title,proto3" json:"Title,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=UserId,proto3" json:"UserId,omitempty"`
}

func (m *SearchSelfGroupReq) Reset()         { *m = SearchSelfGroupReq{} }
func (m *SearchSelfGroupReq) String() string { return proto.CompactTextString(m) }
func (*SearchSelfGroupReq) ProtoMessage()    {}
func (*SearchSelfGroupReq) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{2}
}

func (m *SearchSelfGroupReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SearchSelfGroupReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SearchSelfGroupReply struct {
	ChatIds    []int32         `protobuf:"varint,1,rep,packed,name=ChatIds" json:"ChatIds,omitempty"`
	ChannelIds []int32         `protobuf:"varint,2,rep,packed,name=ChannelIds" json:"ChannelIds,omitempty"`
	ErrorCode  ActiveErrorCode `protobuf:"varint,3,opt,name=ErrorCode,proto3,enum=groupservice.ActiveErrorCode" json:"ErrorCode,omitempty"`
}

func (m *SearchSelfGroupReply) Reset()         { *m = SearchSelfGroupReply{} }
func (m *SearchSelfGroupReply) String() string { return proto.CompactTextString(m) }
func (*SearchSelfGroupReply) ProtoMessage()    {}
func (*SearchSelfGroupReply) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{3}
}

func (m *SearchSelfGroupReply) GetChatIds() []int32 {
	if m != nil {
		return m.ChatIds
	}
	return nil
}

func (m *SearchSelfGroupReply) GetChannelIds() []int32 {
	if m != nil {
		return m.ChannelIds
	}
	return nil
}

func (m *SearchSelfGroupReply) GetErrorCode() ActiveErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ActiveErrorCode_Active_OK
}

// 获取两个用户相同的群数量
type GetTwoUserChatsCountReq struct {
	UserOne int32 `protobuf:"varint,1,opt,name=UserOne,proto3" json:"UserOne,omitempty"`
	UserTwo int32 `protobuf:"varint,2,opt,name=UserTwo,proto3" json:"UserTwo,omitempty"`
}

func (m *GetTwoUserChatsCountReq) Reset()         { *m = GetTwoUserChatsCountReq{} }
func (m *GetTwoUserChatsCountReq) String() string { return proto.CompactTextString(m) }
func (*GetTwoUserChatsCountReq) ProtoMessage()    {}
func (*GetTwoUserChatsCountReq) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{4}
}

func (m *GetTwoUserChatsCountReq) GetUserOne() int32 {
	if m != nil {
		return m.UserOne
	}
	return 0
}

func (m *GetTwoUserChatsCountReq) GetUserTwo() int32 {
	if m != nil {
		return m.UserTwo
	}
	return 0
}

type GetTwoUserChatsCountReply struct {
	Count     int32           `protobuf:"varint,1,opt,name=Count,proto3" json:"Count,omitempty"`
	ErrorCode ActiveErrorCode `protobuf:"varint,2,opt,name=ErrorCode,proto3,enum=groupservice.ActiveErrorCode" json:"ErrorCode,omitempty"`
}

func (m *GetTwoUserChatsCountReply) Reset()         { *m = GetTwoUserChatsCountReply{} }
func (m *GetTwoUserChatsCountReply) String() string { return proto.CompactTextString(m) }
func (*GetTwoUserChatsCountReply) ProtoMessage()    {}
func (*GetTwoUserChatsCountReply) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{5}
}

func (m *GetTwoUserChatsCountReply) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *GetTwoUserChatsCountReply) GetErrorCode() ActiveErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ActiveErrorCode_Active_OK
}

// 获取两个用户相同的群
type GetTwoUserChatsReq struct {
	UserOne int32 `protobuf:"varint,1,opt,name=UserOne,proto3" json:"UserOne,omitempty"`
	UserTwo int32 `protobuf:"varint,2,opt,name=UserTwo,proto3" json:"UserTwo,omitempty"`
}

func (m *GetTwoUserChatsReq) Reset()         { *m = GetTwoUserChatsReq{} }
func (m *GetTwoUserChatsReq) String() string { return proto.CompactTextString(m) }
func (*GetTwoUserChatsReq) ProtoMessage()    {}
func (*GetTwoUserChatsReq) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{6}
}

func (m *GetTwoUserChatsReq) GetUserOne() int32 {
	if m != nil {
		return m.UserOne
	}
	return 0
}

func (m *GetTwoUserChatsReq) GetUserTwo() int32 {
	if m != nil {
		return m.UserTwo
	}
	return 0
}

type GetTwoUserChatsReply struct {
	ChatIds    []int32         `protobuf:"varint,1,rep,packed,name=ChatIds" json:"ChatIds,omitempty"`
	ChannelIds []int32         `protobuf:"varint,2,rep,packed,name=ChannelIds" json:"ChannelIds,omitempty"`
	ErrorCode  ActiveErrorCode `protobuf:"varint,3,opt,name=ErrorCode,proto3,enum=groupservice.ActiveErrorCode" json:"ErrorCode,omitempty"`
}

func (m *GetTwoUserChatsReply) Reset()         { *m = GetTwoUserChatsReply{} }
func (m *GetTwoUserChatsReply) String() string { return proto.CompactTextString(m) }
func (*GetTwoUserChatsReply) ProtoMessage()    {}
func (*GetTwoUserChatsReply) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{7}
}

func (m *GetTwoUserChatsReply) GetChatIds() []int32 {
	if m != nil {
		return m.ChatIds
	}
	return nil
}

func (m *GetTwoUserChatsReply) GetChannelIds() []int32 {
	if m != nil {
		return m.ChannelIds
	}
	return nil
}

func (m *GetTwoUserChatsReply) GetErrorCode() ActiveErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ActiveErrorCode_Active_OK
}

// 判断哪些用户在线
type CheckOnlineUsersReq struct {
	UserIds []int32 `protobuf:"varint,1,rep,packed,name=UserIds" json:"UserIds,omitempty"`
}

func (m *CheckOnlineUsersReq) Reset()         { *m = CheckOnlineUsersReq{} }
func (m *CheckOnlineUsersReq) String() string { return proto.CompactTextString(m) }
func (*CheckOnlineUsersReq) ProtoMessage()    {}
func (*CheckOnlineUsersReq) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{8}
}

func (m *CheckOnlineUsersReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type CheckOnlineUsersReply struct {
	UserIds   []int32         `protobuf:"varint,1,rep,packed,name=UserIds" json:"UserIds,omitempty"`
	ErrorCode ActiveErrorCode `protobuf:"varint,2,opt,name=ErrorCode,proto3,enum=groupservice.ActiveErrorCode" json:"ErrorCode,omitempty"`
}

func (m *CheckOnlineUsersReply) Reset()         { *m = CheckOnlineUsersReply{} }
func (m *CheckOnlineUsersReply) String() string { return proto.CompactTextString(m) }
func (*CheckOnlineUsersReply) ProtoMessage()    {}
func (*CheckOnlineUsersReply) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{9}
}

func (m *CheckOnlineUsersReply) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *CheckOnlineUsersReply) GetErrorCode() ActiveErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ActiveErrorCode_Active_OK
}

// 根据传入ID搜索用户
type SearchUsersByStrReq struct {
	UserIds []int32 `protobuf:"varint,1,rep,packed,name=UserIds" json:"UserIds,omitempty"`
	Str     string  `protobuf:"bytes,2,opt,name=str,proto3" json:"str,omitempty"`
}

func (m *SearchUsersByStrReq) Reset()         { *m = SearchUsersByStrReq{} }
func (m *SearchUsersByStrReq) String() string { return proto.CompactTextString(m) }
func (*SearchUsersByStrReq) ProtoMessage()    {}
func (*SearchUsersByStrReq) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{10}
}

func (m *SearchUsersByStrReq) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *SearchUsersByStrReq) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

type SearchUsersByStrReply struct {
	UserIds   []int32         `protobuf:"varint,1,rep,packed,name=UserIds" json:"UserIds,omitempty"`
	ErrorCode ActiveErrorCode `protobuf:"varint,2,opt,name=ErrorCode,proto3,enum=groupservice.ActiveErrorCode" json:"ErrorCode,omitempty"`
}

func (m *SearchUsersByStrReply) Reset()         { *m = SearchUsersByStrReply{} }
func (m *SearchUsersByStrReply) String() string { return proto.CompactTextString(m) }
func (*SearchUsersByStrReply) ProtoMessage()    {}
func (*SearchUsersByStrReply) Descriptor() ([]byte, []int) {
	return fileDescriptorActiveuserinfoserver, []int{11}
}

func (m *SearchUsersByStrReply) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

func (m *SearchUsersByStrReply) GetErrorCode() ActiveErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ActiveErrorCode_Active_OK
}

func init() {
	proto.RegisterType((*ActivateUserReq)(nil), "groupservice.ActivateUserReq")
	proto.RegisterType((*ActivateUserReply)(nil), "groupservice.ActivateUserReply")
	proto.RegisterType((*SearchSelfGroupReq)(nil), "groupservice.SearchSelfGroupReq")
	proto.RegisterType((*SearchSelfGroupReply)(nil), "groupservice.SearchSelfGroupReply")
	proto.RegisterType((*GetTwoUserChatsCountReq)(nil), "groupservice.GetTwoUserChatsCountReq")
	proto.RegisterType((*GetTwoUserChatsCountReply)(nil), "groupservice.GetTwoUserChatsCountReply")
	proto.RegisterType((*GetTwoUserChatsReq)(nil), "groupservice.GetTwoUserChatsReq")
	proto.RegisterType((*GetTwoUserChatsReply)(nil), "groupservice.GetTwoUserChatsReply")
	proto.RegisterType((*CheckOnlineUsersReq)(nil), "groupservice.CheckOnlineUsersReq")
	proto.RegisterType((*CheckOnlineUsersReply)(nil), "groupservice.CheckOnlineUsersReply")
	proto.RegisterType((*SearchUsersByStrReq)(nil), "groupservice.SearchUsersByStrReq")
	proto.RegisterType((*SearchUsersByStrReply)(nil), "groupservice.SearchUsersByStrReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ActiveUserInfoService service

type ActiveUserInfoServiceClient interface {
	// 激活用户
	ActivateUser(ctx context.Context, in *ActivateUserReq, opts ...grpc.CallOption) (*ActivateUserReply, error)
	// 获取两个用户相同的群数量
	GetTwoUserChatsCount(ctx context.Context, in *GetTwoUserChatsCountReq, opts ...grpc.CallOption) (*GetTwoUserChatsCountReply, error)
	// 获取两个用户相同的群
	GetTwoUserChats(ctx context.Context, in *GetTwoUserChatsReq, opts ...grpc.CallOption) (*GetTwoUserChatsReply, error)
	// 根据群名称搜索自己所在的群
	SearchSelfGroup(ctx context.Context, in *SearchSelfGroupReq, opts ...grpc.CallOption) (*SearchSelfGroupReply, error)
	// 判断传入的哪些用户在线
	CheckOnlineUsers(ctx context.Context, in *CheckOnlineUsersReq, opts ...grpc.CallOption) (*CheckOnlineUsersReply, error)
	// 根据传入ID搜索用户
	SearchUsersByStr(ctx context.Context, in *SearchUsersByStrReq, opts ...grpc.CallOption) (*SearchUsersByStrReply, error)
}

type activeUserInfoServiceClient struct {
	cc *grpc.ClientConn
}

func NewActiveUserInfoServiceClient(cc *grpc.ClientConn) ActiveUserInfoServiceClient {
	return &activeUserInfoServiceClient{cc}
}

func (c *activeUserInfoServiceClient) ActivateUser(ctx context.Context, in *ActivateUserReq, opts ...grpc.CallOption) (*ActivateUserReply, error) {
	out := new(ActivateUserReply)
	err := grpc.Invoke(ctx, "/groupservice.ActiveUserInfoService/ActivateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activeUserInfoServiceClient) GetTwoUserChatsCount(ctx context.Context, in *GetTwoUserChatsCountReq, opts ...grpc.CallOption) (*GetTwoUserChatsCountReply, error) {
	out := new(GetTwoUserChatsCountReply)
	err := grpc.Invoke(ctx, "/groupservice.ActiveUserInfoService/GetTwoUserChatsCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activeUserInfoServiceClient) GetTwoUserChats(ctx context.Context, in *GetTwoUserChatsReq, opts ...grpc.CallOption) (*GetTwoUserChatsReply, error) {
	out := new(GetTwoUserChatsReply)
	err := grpc.Invoke(ctx, "/groupservice.ActiveUserInfoService/GetTwoUserChats", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activeUserInfoServiceClient) SearchSelfGroup(ctx context.Context, in *SearchSelfGroupReq, opts ...grpc.CallOption) (*SearchSelfGroupReply, error) {
	out := new(SearchSelfGroupReply)
	err := grpc.Invoke(ctx, "/groupservice.ActiveUserInfoService/SearchSelfGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activeUserInfoServiceClient) CheckOnlineUsers(ctx context.Context, in *CheckOnlineUsersReq, opts ...grpc.CallOption) (*CheckOnlineUsersReply, error) {
	out := new(CheckOnlineUsersReply)
	err := grpc.Invoke(ctx, "/groupservice.ActiveUserInfoService/CheckOnlineUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *activeUserInfoServiceClient) SearchUsersByStr(ctx context.Context, in *SearchUsersByStrReq, opts ...grpc.CallOption) (*SearchUsersByStrReply, error) {
	out := new(SearchUsersByStrReply)
	err := grpc.Invoke(ctx, "/groupservice.ActiveUserInfoService/SearchUsersByStr", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ActiveUserInfoService service

type ActiveUserInfoServiceServer interface {
	// 激活用户
	ActivateUser(context.Context, *ActivateUserReq) (*ActivateUserReply, error)
	// 获取两个用户相同的群数量
	GetTwoUserChatsCount(context.Context, *GetTwoUserChatsCountReq) (*GetTwoUserChatsCountReply, error)
	// 获取两个用户相同的群
	GetTwoUserChats(context.Context, *GetTwoUserChatsReq) (*GetTwoUserChatsReply, error)
	// 根据群名称搜索自己所在的群
	SearchSelfGroup(context.Context, *SearchSelfGroupReq) (*SearchSelfGroupReply, error)
	// 判断传入的哪些用户在线
	CheckOnlineUsers(context.Context, *CheckOnlineUsersReq) (*CheckOnlineUsersReply, error)
	// 根据传入ID搜索用户
	SearchUsersByStr(context.Context, *SearchUsersByStrReq) (*SearchUsersByStrReply, error)
}

func RegisterActiveUserInfoServiceServer(s *grpc.Server, srv ActiveUserInfoServiceServer) {
	s.RegisterService(&_ActiveUserInfoService_serviceDesc, srv)
}

func _ActiveUserInfoService_ActivateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveUserInfoServiceServer).ActivateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupservice.ActiveUserInfoService/ActivateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveUserInfoServiceServer).ActivateUser(ctx, req.(*ActivateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActiveUserInfoService_GetTwoUserChatsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTwoUserChatsCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveUserInfoServiceServer).GetTwoUserChatsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupservice.ActiveUserInfoService/GetTwoUserChatsCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveUserInfoServiceServer).GetTwoUserChatsCount(ctx, req.(*GetTwoUserChatsCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActiveUserInfoService_GetTwoUserChats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTwoUserChatsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveUserInfoServiceServer).GetTwoUserChats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupservice.ActiveUserInfoService/GetTwoUserChats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveUserInfoServiceServer).GetTwoUserChats(ctx, req.(*GetTwoUserChatsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActiveUserInfoService_SearchSelfGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchSelfGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveUserInfoServiceServer).SearchSelfGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupservice.ActiveUserInfoService/SearchSelfGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveUserInfoServiceServer).SearchSelfGroup(ctx, req.(*SearchSelfGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActiveUserInfoService_CheckOnlineUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckOnlineUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveUserInfoServiceServer).CheckOnlineUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupservice.ActiveUserInfoService/CheckOnlineUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveUserInfoServiceServer).CheckOnlineUsers(ctx, req.(*CheckOnlineUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ActiveUserInfoService_SearchUsersByStr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchUsersByStrReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActiveUserInfoServiceServer).SearchUsersByStr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/groupservice.ActiveUserInfoService/SearchUsersByStr",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActiveUserInfoServiceServer).SearchUsersByStr(ctx, req.(*SearchUsersByStrReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ActiveUserInfoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "groupservice.ActiveUserInfoService",
	HandlerType: (*ActiveUserInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ActivateUser",
			Handler:    _ActiveUserInfoService_ActivateUser_Handler,
		},
		{
			MethodName: "GetTwoUserChatsCount",
			Handler:    _ActiveUserInfoService_GetTwoUserChatsCount_Handler,
		},
		{
			MethodName: "GetTwoUserChats",
			Handler:    _ActiveUserInfoService_GetTwoUserChats_Handler,
		},
		{
			MethodName: "SearchSelfGroup",
			Handler:    _ActiveUserInfoService_SearchSelfGroup_Handler,
		},
		{
			MethodName: "CheckOnlineUsers",
			Handler:    _ActiveUserInfoService_CheckOnlineUsers_Handler,
		},
		{
			MethodName: "SearchUsersByStr",
			Handler:    _ActiveUserInfoService_SearchUsersByStr_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/groupservice/activeuserinfoserver.proto",
}

func (m *ActivateUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateUserReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.KeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *ActivateUserReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateUserReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrorCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *SearchSelfGroupReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchSelfGroupReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SearchSelfGroupReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchSelfGroupReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatIds) > 0 {
		dAtA2 := make([]byte, len(m.ChatIds)*10)
		var j1 int
		for _, num1 := range m.ChatIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.ChannelIds) > 0 {
		dAtA4 := make([]byte, len(m.ChannelIds)*10)
		var j3 int
		for _, num1 := range m.ChannelIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *GetTwoUserChatsCountReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTwoUserChatsCountReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserOne != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.UserOne))
	}
	if m.UserTwo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.UserTwo))
	}
	return i, nil
}

func (m *GetTwoUserChatsCountReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTwoUserChatsCountReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.Count))
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *GetTwoUserChatsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTwoUserChatsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserOne != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.UserOne))
	}
	if m.UserTwo != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.UserTwo))
	}
	return i, nil
}

func (m *GetTwoUserChatsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTwoUserChatsReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatIds) > 0 {
		dAtA6 := make([]byte, len(m.ChatIds)*10)
		var j5 int
		for _, num1 := range m.ChatIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.ChannelIds) > 0 {
		dAtA8 := make([]byte, len(m.ChannelIds)*10)
		var j7 int
		for _, num1 := range m.ChannelIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *CheckOnlineUsersReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckOnlineUsersReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA10 := make([]byte, len(m.UserIds)*10)
		var j9 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	return i, nil
}

func (m *CheckOnlineUsersReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckOnlineUsersReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA12 := make([]byte, len(m.UserIds)*10)
		var j11 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j11))
		i += copy(dAtA[i:], dAtA12[:j11])
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *SearchUsersByStrReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUsersByStrReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA14 := make([]byte, len(m.UserIds)*10)
		var j13 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.Str) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(len(m.Str)))
		i += copy(dAtA[i:], m.Str)
	}
	return i, nil
}

func (m *SearchUsersByStrReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchUsersByStrReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA16 := make([]byte, len(m.UserIds)*10)
		var j15 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActiveuserinfoserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func encodeVarintActiveuserinfoserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ActivateUserReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.KeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.UserId))
	}
	return n
}

func (m *ActivateUserReply) Size() (n int) {
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *SearchSelfGroupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovActiveuserinfoserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.UserId))
	}
	return n
}

func (m *SearchSelfGroupReply) Size() (n int) {
	var l int
	_ = l
	if len(m.ChatIds) > 0 {
		l = 0
		for _, e := range m.ChatIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	if len(m.ChannelIds) > 0 {
		l = 0
		for _, e := range m.ChannelIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	if m.ErrorCode != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *GetTwoUserChatsCountReq) Size() (n int) {
	var l int
	_ = l
	if m.UserOne != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.UserOne))
	}
	if m.UserTwo != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.UserTwo))
	}
	return n
}

func (m *GetTwoUserChatsCountReply) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.Count))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *GetTwoUserChatsReq) Size() (n int) {
	var l int
	_ = l
	if m.UserOne != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.UserOne))
	}
	if m.UserTwo != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.UserTwo))
	}
	return n
}

func (m *GetTwoUserChatsReply) Size() (n int) {
	var l int
	_ = l
	if len(m.ChatIds) > 0 {
		l = 0
		for _, e := range m.ChatIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	if len(m.ChannelIds) > 0 {
		l = 0
		for _, e := range m.ChannelIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	if m.ErrorCode != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *CheckOnlineUsersReq) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	return n
}

func (m *CheckOnlineUsersReply) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	if m.ErrorCode != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *SearchUsersByStrReq) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	l = len(m.Str)
	if l > 0 {
		n += 1 + l + sovActiveuserinfoserver(uint64(l))
	}
	return n
}

func (m *SearchUsersByStrReply) Size() (n int) {
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovActiveuserinfoserver(uint64(e))
		}
		n += 1 + sovActiveuserinfoserver(uint64(l)) + l
	}
	if m.ErrorCode != 0 {
		n += 1 + sovActiveuserinfoserver(uint64(m.ErrorCode))
	}
	return n
}

func sovActiveuserinfoserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozActiveuserinfoserver(x uint64) (n int) {
	return sovActiveuserinfoserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ActivateUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateUserReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateUserReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateUserReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ActiveErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchSelfGroupReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchSelfGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchSelfGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchSelfGroupReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchSelfGroupReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchSelfGroupReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChatIds = append(m.ChatIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChatIds = append(m.ChatIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChannelIds = append(m.ChannelIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChannelIds = append(m.ChannelIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ActiveErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTwoUserChatsCountReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTwoUserChatsCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTwoUserChatsCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserOne", wireType)
			}
			m.UserOne = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserOne |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTwo", wireType)
			}
			m.UserTwo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserTwo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTwoUserChatsCountReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTwoUserChatsCountReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTwoUserChatsCountReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ActiveErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTwoUserChatsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTwoUserChatsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTwoUserChatsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserOne", wireType)
			}
			m.UserOne = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserOne |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTwo", wireType)
			}
			m.UserTwo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserTwo |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTwoUserChatsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTwoUserChatsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTwoUserChatsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChatIds = append(m.ChatIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChatIds = append(m.ChatIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChannelIds = append(m.ChannelIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChannelIds = append(m.ChannelIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelIds", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ActiveErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckOnlineUsersReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckOnlineUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckOnlineUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckOnlineUsersReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckOnlineUsersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckOnlineUsersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ActiveErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUsersByStrReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUsersByStrReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUsersByStrReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchUsersByStrReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchUsersByStrReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchUsersByStrReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActiveuserinfoserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActiveuserinfoserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (ActiveErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActiveuserinfoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActiveuserinfoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipActiveuserinfoserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowActiveuserinfoserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActiveuserinfoserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthActiveuserinfoserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowActiveuserinfoserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipActiveuserinfoserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthActiveuserinfoserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowActiveuserinfoserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/groupservice/activeuserinfoserver.proto", fileDescriptorActiveuserinfoserver)
}

var fileDescriptorActiveuserinfoserver = []byte{
	// 550 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x95, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0xe3, 0x84, 0xb4, 0xca, 0x28, 0xa2, 0x65, 0x9b, 0x82, 0x89, 0x44, 0x08, 0x46, 0x88,
	0x9c, 0x12, 0xa9, 0x1c, 0x39, 0xa0, 0xc6, 0xa0, 0x12, 0x01, 0x6a, 0xe5, 0x84, 0x03, 0x12, 0x17,
	0xc7, 0x19, 0xd7, 0x16, 0x66, 0xd7, 0xac, 0x37, 0xad, 0xf2, 0x10, 0x3c, 0x16, 0x12, 0x47, 0x1e,
	0x01, 0xe5, 0x49, 0xd0, 0x7a, 0x9d, 0xd4, 0xff, 0x9a, 0x12, 0x10, 0xe2, 0x96, 0xcf, 0x33, 0xf3,
	0x9b, 0x6f, 0xe2, 0xc9, 0x04, 0xde, 0x9e, 0xfb, 0x22, 0xb0, 0xa7, 0x7d, 0xc7, 0xb3, 0x45, 0x84,
	0xfc, 0x02, 0x79, 0xdf, 0xff, 0x3c, 0xf0, 0xa9, 0x40, 0xee, 0xda, 0x0e, 0x86, 0x9c, 0x4d, 0xe7,
	0xee, 0xe0, 0x9c, 0xb3, 0x79, 0x28, 0xc3, 0xbe, 0x83, 0x03, 0xdb, 0x11, 0xfe, 0x05, 0xce, 0x23,
	0xe4, 0x3e, 0x75, 0x59, 0x52, 0x14, 0x72, 0x26, 0x18, 0x69, 0xa6, 0x13, 0xdb, 0x2f, 0xb7, 0x67,
	0xa7, 0x85, 0x62, 0x1a, 0x2f, 0x60, 0xef, 0x58, 0x76, 0xb4, 0x05, 0xbe, 0x8f, 0x90, 0x5b, 0xf8,
	0x85, 0xb4, 0xa0, 0xfe, 0x06, 0x17, 0xa3, 0x99, 0xae, 0x75, 0xb5, 0x5e, 0xcd, 0x52, 0x82, 0xdc,
	0x85, 0x1d, 0x99, 0x30, 0x9a, 0xe9, 0xd5, 0xae, 0xd6, 0xab, 0x5b, 0x89, 0x32, 0xce, 0xe0, 0x4e,
	0x16, 0x10, 0x06, 0x0b, 0xf2, 0x1c, 0x1a, 0xaf, 0x38, 0x67, 0xdc, 0x64, 0x33, 0x8c, 0x31, 0xb7,
	0x8f, 0x1e, 0xf4, 0x33, 0xdd, 0xe3, 0x1a, 0x5c, 0x27, 0x59, 0x57, 0xf9, 0xc6, 0x10, 0xc8, 0x18,
	0x6d, 0xee, 0x78, 0x63, 0x0c, 0xdc, 0x13, 0x59, 0x94, 0xb8, 0x9a, 0xf8, 0x22, 0x50, 0xb8, 0x86,
	0xa5, 0xc4, 0xb5, 0xae, 0xbe, 0x6a, 0xd0, 0x2a, 0x40, 0xa4, 0x33, 0x1d, 0x76, 0x4d, 0xcf, 0x16,
	0xa3, 0x59, 0xa4, 0x6b, 0xdd, 0x5a, 0xaf, 0x6e, 0xad, 0x24, 0xe9, 0x00, 0x98, 0x9e, 0x4d, 0x29,
	0x06, 0x32, 0x58, 0x8d, 0x83, 0xa9, 0x27, 0xd9, 0x99, 0x6a, 0x5b, 0xce, 0xf4, 0x0e, 0xee, 0x9d,
	0xa0, 0x98, 0x5c, 0x32, 0xe9, 0x4f, 0x76, 0x8c, 0x4c, 0x36, 0xa7, 0x42, 0x0e, 0xa6, 0xc3, 0xae,
	0x7c, 0x78, 0x4a, 0xd5, 0x68, 0x75, 0x6b, 0x25, 0x57, 0x91, 0xc9, 0x25, 0x4b, 0xa6, 0x5b, 0x49,
	0x83, 0xc2, 0xfd, 0x72, 0x9c, 0x1c, 0xb1, 0x05, 0xf5, 0x58, 0x25, 0x38, 0x25, 0xb2, 0xf6, 0xab,
	0x5b, 0xda, 0x7f, 0x0d, 0x24, 0xd7, 0xef, 0x4f, 0x9d, 0xcb, 0x17, 0x53, 0x40, 0xfd, 0xc7, 0x17,
	0x33, 0x80, 0x03, 0xd3, 0x43, 0xe7, 0xd3, 0x29, 0x0d, 0x7c, 0x1a, 0x6f, 0x70, 0x7a, 0xb4, 0x94,
	0x9b, 0x44, 0x1a, 0x14, 0x0e, 0x8b, 0x05, 0xc9, 0x00, 0xe5, 0x25, 0x7f, 0xf7, 0xd5, 0x1f, 0xc3,
	0x81, 0x5a, 0xe4, 0xb8, 0xd5, 0x70, 0x31, 0x16, 0x7c, 0xa3, 0x41, 0xb2, 0x0f, 0xb5, 0x48, 0xf0,
	0xb8, 0x4f, 0xc3, 0x92, 0x1f, 0xa5, 0xe5, 0x22, 0xe2, 0xdf, 0x59, 0x3e, 0xfa, 0x76, 0x0b, 0x0e,
	0x55, 0x38, 0xc6, 0x51, 0x97, 0x8d, 0x55, 0x11, 0x39, 0x83, 0x66, 0xfa, 0x58, 0x90, 0x32, 0xe6,
	0xd5, 0x25, 0x6a, 0x3f, 0xdc, 0x14, 0x0e, 0x83, 0x85, 0x51, 0x21, 0x5e, 0x61, 0x9d, 0xd4, 0xba,
	0x3f, 0xc9, 0x96, 0x5e, 0xf3, 0xe3, 0x6b, 0x3f, 0xfd, 0x9d, 0x34, 0xd5, 0xe9, 0x03, 0xec, 0xe5,
	0xc2, 0xa4, 0xbb, 0xb1, 0x5a, 0xf2, 0x8d, 0x1b, 0x32, 0xd6, 0xe8, 0xdc, 0xb1, 0xca, 0xa3, 0x8b,
	0x07, 0x31, 0x8f, 0x2e, 0xbb, 0x76, 0x46, 0x85, 0x7c, 0x84, 0xfd, 0xfc, 0xba, 0x92, 0x47, 0xd9,
	0xca, 0x92, 0xfd, 0x6f, 0x3f, 0xbe, 0x29, 0x65, 0x4d, 0xcf, 0x6f, 0x56, 0x9e, 0x5e, 0xb2, 0xbc,
	0x79, 0x7a, 0xe9, 0x72, 0x1a, 0x95, 0x61, 0xf3, 0xfb, 0xb2, 0xa3, 0xfd, 0x58, 0x76, 0xb4, 0x9f,
	0xcb, 0x8e, 0x36, 0xdd, 0x89, 0xff, 0xb0, 0x9e, 0xfd, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x3d, 0x62,
	0xbb, 0xc2, 0x54, 0x07, 0x00, 0x00,
}
