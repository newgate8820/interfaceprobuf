// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/storagebfss/storagebfss.proto

/*
Package storagebfss is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/storagebfss/storagebfss.proto

It has these top-level messages:

	ObjectBlockInfo
	BFSSGetFilePtReq
	BFSSGetFilePtResp
	BFSSSaveFilePartPtReq
	BFSSSaveFilePartPtResp
	BFSSSaveBigFilePartPtReq
	BFSSSaveBigFilePartPtResp
	BFSSSaveFileCompleteReq
	BFSSSaveFileCompleteResp
	BFSSResetObjectIdReq
	BFSSResetObjectIdResp
*/
package storagebfss

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 块信息
type ObjectBlockInfo struct {
	BlockSize uint32 `protobuf:"varint,1,opt,name=BlockSize,json=blockSize,proto3" json:"BlockSize,omitempty"`
	DataOff   uint32 `protobuf:"varint,2,opt,name=DataOff,json=dataOff,proto3" json:"DataOff,omitempty"`
	BlockKey  []byte `protobuf:"bytes,3,opt,name=BlockKey,json=blockKey,proto3" json:"BlockKey,omitempty"`
}

func (m *ObjectBlockInfo) Reset()                    { *m = ObjectBlockInfo{} }
func (m *ObjectBlockInfo) String() string            { return proto.CompactTextString(m) }
func (*ObjectBlockInfo) ProtoMessage()               {}
func (*ObjectBlockInfo) Descriptor() ([]byte, []int) { return fileDescriptorStoragebfss, []int{0} }

func (m *ObjectBlockInfo) GetBlockSize() uint32 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *ObjectBlockInfo) GetDataOff() uint32 {
	if m != nil {
		return m.DataOff
	}
	return 0
}

func (m *ObjectBlockInfo) GetBlockKey() []byte {
	if m != nil {
		return m.BlockKey
	}
	return nil
}

// 请求文件下载信息
type BFSSGetFilePtReq struct {
	FileId uint64 `protobuf:"varint,1,opt,name=FileId,json=fileId,proto3" json:"FileId,omitempty"`
}

func (m *BFSSGetFilePtReq) Reset()                    { *m = BFSSGetFilePtReq{} }
func (m *BFSSGetFilePtReq) String() string            { return proto.CompactTextString(m) }
func (*BFSSGetFilePtReq) ProtoMessage()               {}
func (*BFSSGetFilePtReq) Descriptor() ([]byte, []int) { return fileDescriptorStoragebfss, []int{1} }

func (m *BFSSGetFilePtReq) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

// 返回文件下载信息
type BFSSGetFilePtResp struct {
	ObjectSize       uint32             `protobuf:"varint,1,opt,name=ObjectSize,json=objectSize,proto3" json:"ObjectSize,omitempty"`
	AccessHash       string             `protobuf:"bytes,2,opt,name=AccessHash,json=accessHash,proto3" json:"AccessHash,omitempty"`
	ObjectBlockInfos []*ObjectBlockInfo `protobuf:"bytes,3,rep,name=ObjectBlockInfos,json=objectBlockInfos" json:"ObjectBlockInfos,omitempty"`
}

func (m *BFSSGetFilePtResp) Reset()                    { *m = BFSSGetFilePtResp{} }
func (m *BFSSGetFilePtResp) String() string            { return proto.CompactTextString(m) }
func (*BFSSGetFilePtResp) ProtoMessage()               {}
func (*BFSSGetFilePtResp) Descriptor() ([]byte, []int) { return fileDescriptorStoragebfss, []int{2} }

func (m *BFSSGetFilePtResp) GetObjectSize() uint32 {
	if m != nil {
		return m.ObjectSize
	}
	return 0
}

func (m *BFSSGetFilePtResp) GetAccessHash() string {
	if m != nil {
		return m.AccessHash
	}
	return ""
}

func (m *BFSSGetFilePtResp) GetObjectBlockInfos() []*ObjectBlockInfo {
	if m != nil {
		return m.ObjectBlockInfos
	}
	return nil
}

// 请求上传小文件
type BFSSSaveFilePartPtReq struct {
	FileId   uint64 `protobuf:"varint,1,opt,name=FileId,json=fileId,proto3" json:"FileId,omitempty"`
	FileSize uint32 `protobuf:"varint,2,opt,name=FileSize,json=fileSize,proto3" json:"FileSize,omitempty"`
	FilePart uint32 `protobuf:"varint,3,opt,name=FilePart,json=filePart,proto3" json:"FilePart,omitempty"`
	Offset   uint32 `protobuf:"varint,4,opt,name=Offset,json=offset,proto3" json:"Offset,omitempty"`
	Data     []byte `protobuf:"bytes,5,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *BFSSSaveFilePartPtReq) Reset()         { *m = BFSSSaveFilePartPtReq{} }
func (m *BFSSSaveFilePartPtReq) String() string { return proto.CompactTextString(m) }
func (*BFSSSaveFilePartPtReq) ProtoMessage()    {}
func (*BFSSSaveFilePartPtReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStoragebfss, []int{3}
}

func (m *BFSSSaveFilePartPtReq) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *BFSSSaveFilePartPtReq) GetFileSize() uint32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *BFSSSaveFilePartPtReq) GetFilePart() uint32 {
	if m != nil {
		return m.FilePart
	}
	return 0
}

func (m *BFSSSaveFilePartPtReq) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BFSSSaveFilePartPtReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 上传小文件返回
type BFSSSaveFilePartPtResp struct {
	Success bool `protobuf:"varint,1,opt,name=Success,json=success,proto3" json:"Success,omitempty"`
}

func (m *BFSSSaveFilePartPtResp) Reset()         { *m = BFSSSaveFilePartPtResp{} }
func (m *BFSSSaveFilePartPtResp) String() string { return proto.CompactTextString(m) }
func (*BFSSSaveFilePartPtResp) ProtoMessage()    {}
func (*BFSSSaveFilePartPtResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStoragebfss, []int{4}
}

func (m *BFSSSaveFilePartPtResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// 请求上传大文件
type BFSSSaveBigFilePartPtReq struct {
	FileId         uint64 `protobuf:"varint,1,opt,name=FileId,json=fileId,proto3" json:"FileId,omitempty"`
	FileSize       uint32 `protobuf:"varint,2,opt,name=FileSize,json=fileSize,proto3" json:"FileSize,omitempty"`
	FileTotalParts uint32 `protobuf:"varint,3,opt,name=FileTotalParts,json=fileTotalParts,proto3" json:"FileTotalParts,omitempty"`
	FilePart       uint32 `protobuf:"varint,4,opt,name=FilePart,json=filePart,proto3" json:"FilePart,omitempty"`
	Offset         uint32 `protobuf:"varint,5,opt,name=Offset,json=offset,proto3" json:"Offset,omitempty"`
	Data           []byte `protobuf:"bytes,6,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *BFSSSaveBigFilePartPtReq) Reset()         { *m = BFSSSaveBigFilePartPtReq{} }
func (m *BFSSSaveBigFilePartPtReq) String() string { return proto.CompactTextString(m) }
func (*BFSSSaveBigFilePartPtReq) ProtoMessage()    {}
func (*BFSSSaveBigFilePartPtReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStoragebfss, []int{5}
}

func (m *BFSSSaveBigFilePartPtReq) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *BFSSSaveBigFilePartPtReq) GetFileSize() uint32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *BFSSSaveBigFilePartPtReq) GetFileTotalParts() uint32 {
	if m != nil {
		return m.FileTotalParts
	}
	return 0
}

func (m *BFSSSaveBigFilePartPtReq) GetFilePart() uint32 {
	if m != nil {
		return m.FilePart
	}
	return 0
}

func (m *BFSSSaveBigFilePartPtReq) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *BFSSSaveBigFilePartPtReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 上传大文件返回
type BFSSSaveBigFilePartPtResp struct {
	Success bool `protobuf:"varint,1,opt,name=Success,json=success,proto3" json:"Success,omitempty"`
}

func (m *BFSSSaveBigFilePartPtResp) Reset()         { *m = BFSSSaveBigFilePartPtResp{} }
func (m *BFSSSaveBigFilePartPtResp) String() string { return proto.CompactTextString(m) }
func (*BFSSSaveBigFilePartPtResp) ProtoMessage()    {}
func (*BFSSSaveBigFilePartPtResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStoragebfss, []int{6}
}

func (m *BFSSSaveBigFilePartPtResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// 上传文件完成通知
type BFSSSaveFileCompleteReq struct {
	FileId   uint64 `protobuf:"varint,1,opt,name=FileId,json=fileId,proto3" json:"FileId,omitempty"`
	FileSize uint32 `protobuf:"varint,2,opt,name=FileSize,json=fileSize,proto3" json:"FileSize,omitempty"`
	Flag     uint32 `protobuf:"varint,3,opt,name=Flag,json=flag,proto3" json:"Flag,omitempty"`
}

func (m *BFSSSaveFileCompleteReq) Reset()         { *m = BFSSSaveFileCompleteReq{} }
func (m *BFSSSaveFileCompleteReq) String() string { return proto.CompactTextString(m) }
func (*BFSSSaveFileCompleteReq) ProtoMessage()    {}
func (*BFSSSaveFileCompleteReq) Descriptor() ([]byte, []int) {
	return fileDescriptorStoragebfss, []int{7}
}

func (m *BFSSSaveFileCompleteReq) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *BFSSSaveFileCompleteReq) GetFileSize() uint32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *BFSSSaveFileCompleteReq) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

// 上传文件完成返回
type BFSSSaveFileCompleteResp struct {
	Success bool `protobuf:"varint,1,opt,name=Success,json=success,proto3" json:"Success,omitempty"`
}

func (m *BFSSSaveFileCompleteResp) Reset()         { *m = BFSSSaveFileCompleteResp{} }
func (m *BFSSSaveFileCompleteResp) String() string { return proto.CompactTextString(m) }
func (*BFSSSaveFileCompleteResp) ProtoMessage()    {}
func (*BFSSSaveFileCompleteResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStoragebfss, []int{8}
}

func (m *BFSSSaveFileCompleteResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// 上传文件完成通知
type BFSSResetObjectIdReq struct {
	FileId uint64 `protobuf:"varint,1,opt,name=FileId,json=fileId,proto3" json:"FileId,omitempty"`
	NewId  uint64 `protobuf:"varint,2,opt,name=NewId,json=newId,proto3" json:"NewId,omitempty"`
	NewTag string `protobuf:"bytes,3,opt,name=NewTag,json=newTag,proto3" json:"NewTag,omitempty"`
}

func (m *BFSSResetObjectIdReq) Reset()                    { *m = BFSSResetObjectIdReq{} }
func (m *BFSSResetObjectIdReq) String() string            { return proto.CompactTextString(m) }
func (*BFSSResetObjectIdReq) ProtoMessage()               {}
func (*BFSSResetObjectIdReq) Descriptor() ([]byte, []int) { return fileDescriptorStoragebfss, []int{9} }

func (m *BFSSResetObjectIdReq) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *BFSSResetObjectIdReq) GetNewId() uint64 {
	if m != nil {
		return m.NewId
	}
	return 0
}

func (m *BFSSResetObjectIdReq) GetNewTag() string {
	if m != nil {
		return m.NewTag
	}
	return ""
}

// 上传文件完成返回
type BFSSResetObjectIdResp struct {
	Success bool `protobuf:"varint,1,opt,name=Success,json=success,proto3" json:"Success,omitempty"`
}

func (m *BFSSResetObjectIdResp) Reset()         { *m = BFSSResetObjectIdResp{} }
func (m *BFSSResetObjectIdResp) String() string { return proto.CompactTextString(m) }
func (*BFSSResetObjectIdResp) ProtoMessage()    {}
func (*BFSSResetObjectIdResp) Descriptor() ([]byte, []int) {
	return fileDescriptorStoragebfss, []int{10}
}

func (m *BFSSResetObjectIdResp) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func init() {
	proto.RegisterType((*ObjectBlockInfo)(nil), "storagebfss.ObjectBlockInfo")
	proto.RegisterType((*BFSSGetFilePtReq)(nil), "storagebfss.BFSSGetFilePtReq")
	proto.RegisterType((*BFSSGetFilePtResp)(nil), "storagebfss.BFSSGetFilePtResp")
	proto.RegisterType((*BFSSSaveFilePartPtReq)(nil), "storagebfss.BFSSSaveFilePartPtReq")
	proto.RegisterType((*BFSSSaveFilePartPtResp)(nil), "storagebfss.BFSSSaveFilePartPtResp")
	proto.RegisterType((*BFSSSaveBigFilePartPtReq)(nil), "storagebfss.BFSSSaveBigFilePartPtReq")
	proto.RegisterType((*BFSSSaveBigFilePartPtResp)(nil), "storagebfss.BFSSSaveBigFilePartPtResp")
	proto.RegisterType((*BFSSSaveFileCompleteReq)(nil), "storagebfss.BFSSSaveFileCompleteReq")
	proto.RegisterType((*BFSSSaveFileCompleteResp)(nil), "storagebfss.BFSSSaveFileCompleteResp")
	proto.RegisterType((*BFSSResetObjectIdReq)(nil), "storagebfss.BFSSResetObjectIdReq")
	proto.RegisterType((*BFSSResetObjectIdResp)(nil), "storagebfss.BFSSResetObjectIdResp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for FileStorageBFSS service

type FileStorageBFSSClient interface {
	// 获取文件下载信息
	BFSSGetFilePt(ctx context.Context, in *BFSSGetFilePtReq, opts ...grpc.CallOption) (*BFSSGetFilePtResp, error)
	// BFSS上传小文件
	BFSSSaveFilePartPt(ctx context.Context, in *BFSSSaveFilePartPtReq, opts ...grpc.CallOption) (*BFSSSaveFilePartPtResp, error)
	// BFSS上传大文件
	BFSSSaveBigFilePartPt(ctx context.Context, in *BFSSSaveBigFilePartPtReq, opts ...grpc.CallOption) (*BFSSSaveBigFilePartPtResp, error)
	// 上传BFSS文件完成通知
	BFSSSaveFileComplete(ctx context.Context, in *BFSSSaveFileCompleteReq, opts ...grpc.CallOption) (*BFSSSaveFileCompleteResp, error)
	// 上传BFSS文件完成通知
	BFSSResetObjectId(ctx context.Context, in *BFSSResetObjectIdReq, opts ...grpc.CallOption) (*BFSSResetObjectIdResp, error)
}

type fileStorageBFSSClient struct {
	cc *grpc.ClientConn
}

func NewFileStorageBFSSClient(cc *grpc.ClientConn) FileStorageBFSSClient {
	return &fileStorageBFSSClient{cc}
}

func (c *fileStorageBFSSClient) BFSSGetFilePt(ctx context.Context, in *BFSSGetFilePtReq, opts ...grpc.CallOption) (*BFSSGetFilePtResp, error) {
	out := new(BFSSGetFilePtResp)
	err := grpc.Invoke(ctx, "/storagebfss.FileStorageBFSS/BFSSGetFilePt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageBFSSClient) BFSSSaveFilePartPt(ctx context.Context, in *BFSSSaveFilePartPtReq, opts ...grpc.CallOption) (*BFSSSaveFilePartPtResp, error) {
	out := new(BFSSSaveFilePartPtResp)
	err := grpc.Invoke(ctx, "/storagebfss.FileStorageBFSS/BFSSSaveFilePartPt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageBFSSClient) BFSSSaveBigFilePartPt(ctx context.Context, in *BFSSSaveBigFilePartPtReq, opts ...grpc.CallOption) (*BFSSSaveBigFilePartPtResp, error) {
	out := new(BFSSSaveBigFilePartPtResp)
	err := grpc.Invoke(ctx, "/storagebfss.FileStorageBFSS/BFSSSaveBigFilePartPt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageBFSSClient) BFSSSaveFileComplete(ctx context.Context, in *BFSSSaveFileCompleteReq, opts ...grpc.CallOption) (*BFSSSaveFileCompleteResp, error) {
	out := new(BFSSSaveFileCompleteResp)
	err := grpc.Invoke(ctx, "/storagebfss.FileStorageBFSS/BFSSSaveFileComplete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileStorageBFSSClient) BFSSResetObjectId(ctx context.Context, in *BFSSResetObjectIdReq, opts ...grpc.CallOption) (*BFSSResetObjectIdResp, error) {
	out := new(BFSSResetObjectIdResp)
	err := grpc.Invoke(ctx, "/storagebfss.FileStorageBFSS/BFSSResetObjectId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for FileStorageBFSS service

type FileStorageBFSSServer interface {
	// 获取文件下载信息
	BFSSGetFilePt(context.Context, *BFSSGetFilePtReq) (*BFSSGetFilePtResp, error)
	// BFSS上传小文件
	BFSSSaveFilePartPt(context.Context, *BFSSSaveFilePartPtReq) (*BFSSSaveFilePartPtResp, error)
	// BFSS上传大文件
	BFSSSaveBigFilePartPt(context.Context, *BFSSSaveBigFilePartPtReq) (*BFSSSaveBigFilePartPtResp, error)
	// 上传BFSS文件完成通知
	BFSSSaveFileComplete(context.Context, *BFSSSaveFileCompleteReq) (*BFSSSaveFileCompleteResp, error)
	// 上传BFSS文件完成通知
	BFSSResetObjectId(context.Context, *BFSSResetObjectIdReq) (*BFSSResetObjectIdResp, error)
}

func RegisterFileStorageBFSSServer(s *grpc.Server, srv FileStorageBFSSServer) {
	s.RegisterService(&_FileStorageBFSS_serviceDesc, srv)
}

func _FileStorageBFSS_BFSSGetFilePt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BFSSGetFilePtReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageBFSSServer).BFSSGetFilePt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storagebfss.FileStorageBFSS/BFSSGetFilePt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageBFSSServer).BFSSGetFilePt(ctx, req.(*BFSSGetFilePtReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageBFSS_BFSSSaveFilePartPt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BFSSSaveFilePartPtReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageBFSSServer).BFSSSaveFilePartPt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storagebfss.FileStorageBFSS/BFSSSaveFilePartPt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageBFSSServer).BFSSSaveFilePartPt(ctx, req.(*BFSSSaveFilePartPtReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageBFSS_BFSSSaveBigFilePartPt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BFSSSaveBigFilePartPtReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageBFSSServer).BFSSSaveBigFilePartPt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storagebfss.FileStorageBFSS/BFSSSaveBigFilePartPt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageBFSSServer).BFSSSaveBigFilePartPt(ctx, req.(*BFSSSaveBigFilePartPtReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageBFSS_BFSSSaveFileComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BFSSSaveFileCompleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageBFSSServer).BFSSSaveFileComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storagebfss.FileStorageBFSS/BFSSSaveFileComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageBFSSServer).BFSSSaveFileComplete(ctx, req.(*BFSSSaveFileCompleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileStorageBFSS_BFSSResetObjectId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BFSSResetObjectIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileStorageBFSSServer).BFSSResetObjectId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/storagebfss.FileStorageBFSS/BFSSResetObjectId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileStorageBFSSServer).BFSSResetObjectId(ctx, req.(*BFSSResetObjectIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _FileStorageBFSS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "storagebfss.FileStorageBFSS",
	HandlerType: (*FileStorageBFSSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BFSSGetFilePt",
			Handler:    _FileStorageBFSS_BFSSGetFilePt_Handler,
		},
		{
			MethodName: "BFSSSaveFilePartPt",
			Handler:    _FileStorageBFSS_BFSSSaveFilePartPt_Handler,
		},
		{
			MethodName: "BFSSSaveBigFilePartPt",
			Handler:    _FileStorageBFSS_BFSSSaveBigFilePartPt_Handler,
		},
		{
			MethodName: "BFSSSaveFileComplete",
			Handler:    _FileStorageBFSS_BFSSSaveFileComplete_Handler,
		},
		{
			MethodName: "BFSSResetObjectId",
			Handler:    _FileStorageBFSS_BFSSResetObjectId_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/storagebfss/storagebfss.proto",
}

func (m *ObjectBlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectBlockInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.BlockSize))
	}
	if m.DataOff != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.DataOff))
	}
	if len(m.BlockKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(len(m.BlockKey)))
		i += copy(dAtA[i:], m.BlockKey)
	}
	return i, nil
}

func (m *BFSSGetFilePtReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSGetFilePtReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileId))
	}
	return i, nil
}

func (m *BFSSGetFilePtResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSGetFilePtResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjectSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.ObjectSize))
	}
	if len(m.AccessHash) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(len(m.AccessHash)))
		i += copy(dAtA[i:], m.AccessHash)
	}
	if len(m.ObjectBlockInfos) > 0 {
		for _, msg := range m.ObjectBlockInfos {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintStoragebfss(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BFSSSaveFilePartPtReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSSaveFilePartPtReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileId))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileSize))
	}
	if m.FilePart != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FilePart))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.Offset))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *BFSSSaveFilePartPtResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSSaveFilePartPtResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BFSSSaveBigFilePartPtReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSSaveBigFilePartPtReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileId))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileSize))
	}
	if m.FileTotalParts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileTotalParts))
	}
	if m.FilePart != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FilePart))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.Offset))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *BFSSSaveBigFilePartPtResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSSaveBigFilePartPtResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BFSSSaveFileCompleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSSaveFileCompleteReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileId))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileSize))
	}
	if m.Flag != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.Flag))
	}
	return i, nil
}

func (m *BFSSSaveFileCompleteResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSSaveFileCompleteResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BFSSResetObjectIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSResetObjectIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.FileId))
	}
	if m.NewId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(m.NewId))
	}
	if len(m.NewTag) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStoragebfss(dAtA, i, uint64(len(m.NewTag)))
		i += copy(dAtA[i:], m.NewTag)
	}
	return i, nil
}

func (m *BFSSResetObjectIdResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BFSSResetObjectIdResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintStoragebfss(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ObjectBlockInfo) Size() (n int) {
	var l int
	_ = l
	if m.BlockSize != 0 {
		n += 1 + sovStoragebfss(uint64(m.BlockSize))
	}
	if m.DataOff != 0 {
		n += 1 + sovStoragebfss(uint64(m.DataOff))
	}
	l = len(m.BlockKey)
	if l > 0 {
		n += 1 + l + sovStoragebfss(uint64(l))
	}
	return n
}

func (m *BFSSGetFilePtReq) Size() (n int) {
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileId))
	}
	return n
}

func (m *BFSSGetFilePtResp) Size() (n int) {
	var l int
	_ = l
	if m.ObjectSize != 0 {
		n += 1 + sovStoragebfss(uint64(m.ObjectSize))
	}
	l = len(m.AccessHash)
	if l > 0 {
		n += 1 + l + sovStoragebfss(uint64(l))
	}
	if len(m.ObjectBlockInfos) > 0 {
		for _, e := range m.ObjectBlockInfos {
			l = e.Size()
			n += 1 + l + sovStoragebfss(uint64(l))
		}
	}
	return n
}

func (m *BFSSSaveFilePartPtReq) Size() (n int) {
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileId))
	}
	if m.FileSize != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileSize))
	}
	if m.FilePart != 0 {
		n += 1 + sovStoragebfss(uint64(m.FilePart))
	}
	if m.Offset != 0 {
		n += 1 + sovStoragebfss(uint64(m.Offset))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStoragebfss(uint64(l))
	}
	return n
}

func (m *BFSSSaveFilePartPtResp) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *BFSSSaveBigFilePartPtReq) Size() (n int) {
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileId))
	}
	if m.FileSize != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileSize))
	}
	if m.FileTotalParts != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileTotalParts))
	}
	if m.FilePart != 0 {
		n += 1 + sovStoragebfss(uint64(m.FilePart))
	}
	if m.Offset != 0 {
		n += 1 + sovStoragebfss(uint64(m.Offset))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovStoragebfss(uint64(l))
	}
	return n
}

func (m *BFSSSaveBigFilePartPtResp) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *BFSSSaveFileCompleteReq) Size() (n int) {
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileId))
	}
	if m.FileSize != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileSize))
	}
	if m.Flag != 0 {
		n += 1 + sovStoragebfss(uint64(m.Flag))
	}
	return n
}

func (m *BFSSSaveFileCompleteResp) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func (m *BFSSResetObjectIdReq) Size() (n int) {
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovStoragebfss(uint64(m.FileId))
	}
	if m.NewId != 0 {
		n += 1 + sovStoragebfss(uint64(m.NewId))
	}
	l = len(m.NewTag)
	if l > 0 {
		n += 1 + l + sovStoragebfss(uint64(l))
	}
	return n
}

func (m *BFSSResetObjectIdResp) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	return n
}

func sovStoragebfss(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStoragebfss(x uint64) (n int) {
	return sovStoragebfss(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ObjectBlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectBlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectBlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			m.BlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataOff", wireType)
			}
			m.DataOff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataOff |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStoragebfss
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockKey = append(m.BlockKey[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockKey == nil {
				m.BlockKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSGetFilePtReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSGetFilePtReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSGetFilePtReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSGetFilePtResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSGetFilePtResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSGetFilePtResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectSize", wireType)
			}
			m.ObjectSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjectSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoragebfss
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectBlockInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStoragebfss
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjectBlockInfos = append(m.ObjectBlockInfos, &ObjectBlockInfo{})
			if err := m.ObjectBlockInfos[len(m.ObjectBlockInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSSaveFilePartPtReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSSaveFilePartPtReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSSaveFilePartPtReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePart", wireType)
			}
			m.FilePart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilePart |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStoragebfss
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSSaveFilePartPtResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSSaveFilePartPtResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSSaveFilePartPtResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSSaveBigFilePartPtReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSSaveBigFilePartPtReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSSaveBigFilePartPtReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTotalParts", wireType)
			}
			m.FileTotalParts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileTotalParts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePart", wireType)
			}
			m.FilePart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilePart |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStoragebfss
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSSaveBigFilePartPtResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSSaveBigFilePartPtResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSSaveBigFilePartPtResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSSaveFileCompleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSSaveFileCompleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSSaveFileCompleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSSaveFileCompleteResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSSaveFileCompleteResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSSaveFileCompleteResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSResetObjectIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSResetObjectIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSResetObjectIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewId", wireType)
			}
			m.NewId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStoragebfss
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BFSSResetObjectIdResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BFSSResetObjectIdResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BFSSResetObjectIdResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStoragebfss(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStoragebfss
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStoragebfss(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStoragebfss
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStoragebfss
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStoragebfss
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStoragebfss
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStoragebfss(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStoragebfss = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStoragebfss   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/storagebfss/storagebfss.proto", fileDescriptorStoragebfss)
}

var fileDescriptorStoragebfss = []byte{
	// 603 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x4d, 0x6e, 0xd3, 0x40,
	0x14, 0xc6, 0xc4, 0x71, 0x92, 0xd7, 0xbf, 0x30, 0x2a, 0xc5, 0x58, 0x25, 0x0a, 0x86, 0x56, 0x11,
	0x8b, 0x54, 0x04, 0x38, 0x00, 0x01, 0x85, 0x46, 0x48, 0x4d, 0xe5, 0x74, 0x59, 0x09, 0x8d, 0x9d,
	0x99, 0xc4, 0xe0, 0x66, 0x8c, 0x67, 0xda, 0x0a, 0xae, 0xc1, 0x9a, 0xab, 0xb0, 0x66, 0xc9, 0x11,
	0x50, 0xae, 0xc0, 0x05, 0xd0, 0x8c, 0x9d, 0xd6, 0x76, 0x12, 0xb7, 0x82, 0x5d, 0xbe, 0xf7, 0x33,
	0xef, 0xfb, 0xde, 0x4f, 0x0c, 0xdd, 0xb1, 0x2f, 0x02, 0xec, 0xb6, 0xbd, 0x09, 0x16, 0x9c, 0x44,
	0x17, 0x24, 0x6a, 0xfb, 0x67, 0x07, 0xfe, 0x54, 0x90, 0x88, 0x62, 0x8f, 0x84, 0x11, 0x73, 0xcf,
	0xe9, 0x01, 0x17, 0x2c, 0xc2, 0x63, 0xe2, 0x52, 0xce, 0xd3, 0xbf, 0xdb, 0x61, 0xc4, 0x04, 0x43,
	0x6b, 0x29, 0x93, 0x4d, 0x60, 0x6b, 0xe0, 0x7e, 0x24, 0x9e, 0xe8, 0x06, 0xcc, 0xfb, 0xd4, 0x9f,
	0x52, 0x86, 0x76, 0xa1, 0xa6, 0xc0, 0xd0, 0xff, 0x4a, 0x4c, 0xad, 0xa9, 0xb5, 0x36, 0x9c, 0x9a,
	0x3b, 0x37, 0x20, 0x13, 0x2a, 0x6f, 0xb1, 0xc0, 0x03, 0x4a, 0xcd, 0xbb, 0xca, 0x57, 0x19, 0xc5,
	0x10, 0x59, 0x50, 0x55, 0x79, 0xef, 0xc9, 0x17, 0xb3, 0xd4, 0xd4, 0x5a, 0xeb, 0x4e, 0xd5, 0x4d,
	0xb0, 0xfd, 0x0c, 0xea, 0xdd, 0xde, 0x70, 0xf8, 0x8e, 0x88, 0x9e, 0x1f, 0x90, 0x63, 0xe1, 0x90,
	0xcf, 0x68, 0x07, 0x0c, 0x09, 0xfa, 0x23, 0x55, 0x44, 0x77, 0x0c, 0xaa, 0x90, 0xfd, 0x5d, 0x83,
	0x7b, 0xb9, 0x60, 0x1e, 0xa2, 0x06, 0x40, 0x4c, 0x34, 0x45, 0x0b, 0xd8, 0x95, 0x45, 0xfa, 0x5f,
	0x7b, 0x1e, 0xe1, 0xfc, 0x10, 0xf3, 0x89, 0xa2, 0x56, 0x73, 0x00, 0x5f, 0x59, 0xd0, 0x21, 0xd4,
	0x73, 0x42, 0xb9, 0x59, 0x6a, 0x96, 0x5a, 0x6b, 0x9d, 0xdd, 0x76, 0xba, 0x47, 0xb9, 0x20, 0xa7,
	0xce, 0x72, 0x59, 0xf6, 0x37, 0x0d, 0xee, 0x4b, 0x7e, 0x43, 0x7c, 0x41, 0x14, 0x41, 0x1c, 0x89,
	0x42, 0x45, 0xb2, 0x33, 0xd2, 0xae, 0x98, 0xc7, 0x4d, 0xab, 0xd2, 0x04, 0xcf, 0x7d, 0xf2, 0x11,
	0xd5, 0xb5, 0xc4, 0x27, 0xb1, 0x7c, 0x6f, 0x40, 0x29, 0x27, 0xc2, 0xd4, 0x95, 0xc7, 0x60, 0x0a,
	0x21, 0x04, 0xba, 0x9c, 0x81, 0x59, 0x56, 0x5d, 0xd6, 0xe5, 0x00, 0xec, 0x0e, 0xec, 0x2c, 0x23,
	0xc5, 0x43, 0x39, 0xb1, 0xe1, 0xb9, 0x6a, 0x84, 0xa2, 0x55, 0x75, 0x2a, 0x3c, 0x86, 0xf6, 0x0f,
	0x0d, 0xcc, 0x79, 0x52, 0xd7, 0x1f, 0xff, 0xbf, 0x98, 0x7d, 0xd8, 0x94, 0xbe, 0x13, 0x26, 0x70,
	0x20, 0x5f, 0xe2, 0x89, 0xa4, 0x4d, 0x9a, 0xb1, 0x66, 0x44, 0xeb, 0x2b, 0x45, 0x97, 0x97, 0x8a,
	0x36, 0x52, 0xa2, 0x5f, 0xc1, 0xc3, 0x15, 0xfc, 0x0b, 0x75, 0x63, 0x78, 0x90, 0xee, 0xd5, 0x1b,
	0x76, 0x16, 0x06, 0x44, 0x90, 0x7f, 0x55, 0x8d, 0x40, 0xef, 0x05, 0x78, 0x9c, 0x68, 0xd5, 0x69,
	0x80, 0xc7, 0xf6, 0xcb, 0xeb, 0xce, 0x66, 0x4b, 0x14, 0x12, 0x3b, 0x85, 0x6d, 0x99, 0xe5, 0x10,
	0x4e, 0x44, 0xbc, 0x88, 0xfd, 0x51, 0x11, 0xab, 0x6d, 0x28, 0x1f, 0x91, 0xcb, 0xfe, 0x48, 0x51,
	0xd2, 0x9d, 0xf2, 0x54, 0x02, 0x19, 0x7d, 0x44, 0x2e, 0x4f, 0x12, 0x46, 0x35, 0xc7, 0x98, 0x2a,
	0x64, 0x3f, 0x8f, 0xf7, 0x36, 0xf7, 0x7a, 0x11, 0xa1, 0xce, 0x9f, 0x12, 0x6c, 0x29, 0xdd, 0xf1,
	0x85, 0xc8, 0x74, 0x74, 0x0c, 0x1b, 0x99, 0xf3, 0x44, 0x8f, 0x32, 0x07, 0x94, 0xbf, 0x73, 0xab,
	0x51, 0xe4, 0xe6, 0xa1, 0x7d, 0x07, 0x7d, 0x00, 0xb4, 0xb8, 0xbb, 0xc8, 0x5e, 0xc8, 0x5b, 0xb8,
	0x38, 0xeb, 0xc9, 0x8d, 0x31, 0xaa, 0xc0, 0xe4, 0xfa, 0x62, 0x33, 0x7b, 0x82, 0xf6, 0x96, 0xe6,
	0xe7, 0x6f, 0xc1, 0xda, 0xbf, 0x4d, 0x98, 0xaa, 0x44, 0xe2, 0x09, 0xe6, 0xe7, 0x8e, 0x9e, 0xae,
	0x24, 0x9a, 0xda, 0x3e, 0x6b, 0xef, 0x16, 0x51, 0xaa, 0xcc, 0x69, 0xfc, 0x17, 0x99, 0x19, 0x25,
	0x7a, 0xbc, 0x90, 0x9d, 0x5f, 0x24, 0xcb, 0xbe, 0x29, 0x44, 0xbe, 0xde, 0x5d, 0xff, 0x39, 0x6b,
	0x68, 0xbf, 0x66, 0x0d, 0xed, 0xf7, 0xac, 0xa1, 0xb9, 0x86, 0xfa, 0x6c, 0xbc, 0xf8, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x5a, 0xa7, 0x05, 0xd3, 0x7c, 0x06, 0x00, 0x00,
}
