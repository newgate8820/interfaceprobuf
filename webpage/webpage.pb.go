// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/webpage/webpage.proto

/*
Package webpage is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/webpage/webpage.proto

It has these top-level messages:

	ParseUrlRequest
	ParseUrlReply
	PageInfo
	VideoInfo
	PhotoInfo
	SavedWebPage
	UploadPhoto
	ParseUrlForEncodedRequest
	ParseUrlForEncodedReply
	ParseUrlAndStoreRequest
	ParseUrlAndStoreReply
*/
package webpage

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ErrCode int32

const (
	ErrCode_OK                 ErrCode = 0
	ErrCode_UnknownException   ErrCode = 1
	ErrCode_RequestUnreachable ErrCode = 2
	ErrCode_RequestTimeout     ErrCode = 3
	ErrCode_DisabledResponse   ErrCode = 4
	ErrCode_NotHtmlContent     ErrCode = 5
	ErrCode_MissingPage        ErrCode = 6
)

var ErrCode_name = map[int32]string{
	0: "OK",
	1: "UnknownException",
	2: "RequestUnreachable",
	3: "RequestTimeout",
	4: "DisabledResponse",
	5: "NotHtmlContent",
	6: "MissingPage",
}
var ErrCode_value = map[string]int32{
	"OK":                 0,
	"UnknownException":   1,
	"RequestUnreachable": 2,
	"RequestTimeout":     3,
	"DisabledResponse":   4,
	"NotHtmlContent":     5,
	"MissingPage":        6,
}

func (x ErrCode) String() string {
	return proto.EnumName(ErrCode_name, int32(x))
}
func (ErrCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{0} }

type ParseUrlRequest struct {
	Url    string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *ParseUrlRequest) Reset()                    { *m = ParseUrlRequest{} }
func (m *ParseUrlRequest) String() string            { return proto.CompactTextString(m) }
func (*ParseUrlRequest) ProtoMessage()               {}
func (*ParseUrlRequest) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{0} }

func (m *ParseUrlRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ParseUrlRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ParseUrlReply struct {
	ErrCode ErrCode    `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3,enum=webpage.ErrCode" json:"err_code,omitempty"`
	Id      int64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Page    *PageInfo  `protobuf:"bytes,3,opt,name=page" json:"page,omitempty"`
	Photo   *PhotoInfo `protobuf:"bytes,4,opt,name=photo" json:"photo,omitempty"`
}

func (m *ParseUrlReply) Reset()                    { *m = ParseUrlReply{} }
func (m *ParseUrlReply) String() string            { return proto.CompactTextString(m) }
func (*ParseUrlReply) ProtoMessage()               {}
func (*ParseUrlReply) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{1} }

func (m *ParseUrlReply) GetErrCode() ErrCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrCode_OK
}

func (m *ParseUrlReply) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ParseUrlReply) GetPage() *PageInfo {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *ParseUrlReply) GetPhoto() *PhotoInfo {
	if m != nil {
		return m.Photo
	}
	return nil
}

type PageInfo struct {
	Url         string       `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	DisplayUrl  string       `protobuf:"bytes,2,opt,name=display_url,json=displayUrl,proto3" json:"display_url,omitempty"`
	Hash        int32        `protobuf:"varint,3,opt,name=hash,proto3" json:"hash,omitempty"`
	Type        string       `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	SiteName    string       `protobuf:"bytes,5,opt,name=site_name,json=siteName,proto3" json:"site_name,omitempty"`
	Title       string       `protobuf:"bytes,6,opt,name=title,proto3" json:"title,omitempty"`
	Description string       `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	Author      string       `protobuf:"bytes,8,opt,name=author,proto3" json:"author,omitempty"`
	Photo       *UploadPhoto `protobuf:"bytes,9,opt,name=photo" json:"photo,omitempty"`
	Video       *VideoInfo   `protobuf:"bytes,10,opt,name=video" json:"video,omitempty"`
}

func (m *PageInfo) Reset()                    { *m = PageInfo{} }
func (m *PageInfo) String() string            { return proto.CompactTextString(m) }
func (*PageInfo) ProtoMessage()               {}
func (*PageInfo) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{2} }

func (m *PageInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PageInfo) GetDisplayUrl() string {
	if m != nil {
		return m.DisplayUrl
	}
	return ""
}

func (m *PageInfo) GetHash() int32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *PageInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PageInfo) GetSiteName() string {
	if m != nil {
		return m.SiteName
	}
	return ""
}

func (m *PageInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *PageInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PageInfo) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *PageInfo) GetPhoto() *UploadPhoto {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *PageInfo) GetVideo() *VideoInfo {
	if m != nil {
		return m.Video
	}
	return nil
}

type VideoInfo struct {
	PlayAddr string `protobuf:"bytes,1,opt,name=play_addr,json=playAddr,proto3" json:"play_addr,omitempty"`
	Width    int32  `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height   int32  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *VideoInfo) Reset()                    { *m = VideoInfo{} }
func (m *VideoInfo) String() string            { return proto.CompactTextString(m) }
func (*VideoInfo) ProtoMessage()               {}
func (*VideoInfo) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{3} }

func (m *VideoInfo) GetPlayAddr() string {
	if m != nil {
		return m.PlayAddr
	}
	return ""
}

func (m *VideoInfo) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *VideoInfo) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

type PhotoInfo struct {
	Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Width  int32  `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height int32  `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	Type   string `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Url    string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *PhotoInfo) Reset()                    { *m = PhotoInfo{} }
func (m *PhotoInfo) String() string            { return proto.CompactTextString(m) }
func (*PhotoInfo) ProtoMessage()               {}
func (*PhotoInfo) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{4} }

func (m *PhotoInfo) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *PhotoInfo) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *PhotoInfo) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *PhotoInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *PhotoInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// SavedWebPage redis保存的数据
type SavedWebPage struct {
	Id   int64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Page *PageInfo `protobuf:"bytes,2,opt,name=page" json:"page,omitempty"`
}

func (m *SavedWebPage) Reset()                    { *m = SavedWebPage{} }
func (m *SavedWebPage) String() string            { return proto.CompactTextString(m) }
func (*SavedWebPage) ProtoMessage()               {}
func (*SavedWebPage) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{5} }

func (m *SavedWebPage) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SavedWebPage) GetPage() *PageInfo {
	if m != nil {
		return m.Page
	}
	return nil
}

// UploadPhoto 已上传的文件id信息（注：该字段暂不可用，请忽略）
type UploadPhoto struct {
	Id         int64  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash int64  `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Width      int32  `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	Height     int32  `protobuf:"varint,4,opt,name=height,proto3" json:"height,omitempty"`
	Size_      int32  `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	Data       []byte `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *UploadPhoto) Reset()                    { *m = UploadPhoto{} }
func (m *UploadPhoto) String() string            { return proto.CompactTextString(m) }
func (*UploadPhoto) ProtoMessage()               {}
func (*UploadPhoto) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{6} }

func (m *UploadPhoto) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UploadPhoto) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *UploadPhoto) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *UploadPhoto) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *UploadPhoto) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *UploadPhoto) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ParseUrlForEncodedRequest struct {
	Url    string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	UserId int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *ParseUrlForEncodedRequest) Reset()         { *m = ParseUrlForEncodedRequest{} }
func (m *ParseUrlForEncodedRequest) String() string { return proto.CompactTextString(m) }
func (*ParseUrlForEncodedRequest) ProtoMessage()    {}
func (*ParseUrlForEncodedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorWebpage, []int{7}
}

func (m *ParseUrlForEncodedRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ParseUrlForEncodedRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ParseUrlForEncodedReply struct {
	ErrCode ErrCode `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3,enum=webpage.ErrCode" json:"err_code,omitempty"`
	Id      int64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Data    []byte  `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ParseUrlForEncodedReply) Reset()                    { *m = ParseUrlForEncodedReply{} }
func (m *ParseUrlForEncodedReply) String() string            { return proto.CompactTextString(m) }
func (*ParseUrlForEncodedReply) ProtoMessage()               {}
func (*ParseUrlForEncodedReply) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{8} }

func (m *ParseUrlForEncodedReply) GetErrCode() ErrCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrCode_OK
}

func (m *ParseUrlForEncodedReply) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ParseUrlForEncodedReply) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ParseUrlAndStoreRequest struct {
	Url     string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	UserId  int32  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Img_Url string `protobuf:"bytes,3,opt,name=img_Url,json=imgUrl,proto3" json:"img_Url,omitempty"`
}

func (m *ParseUrlAndStoreRequest) Reset()                    { *m = ParseUrlAndStoreRequest{} }
func (m *ParseUrlAndStoreRequest) String() string            { return proto.CompactTextString(m) }
func (*ParseUrlAndStoreRequest) ProtoMessage()               {}
func (*ParseUrlAndStoreRequest) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{9} }

func (m *ParseUrlAndStoreRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ParseUrlAndStoreRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ParseUrlAndStoreRequest) GetImg_Url() string {
	if m != nil {
		return m.Img_Url
	}
	return ""
}

type ParseUrlAndStoreReply struct {
	ErrCode ErrCode    `protobuf:"varint,1,opt,name=err_code,json=errCode,proto3,enum=webpage.ErrCode" json:"err_code,omitempty"`
	Id      int64      `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Page    *PageInfo  `protobuf:"bytes,3,opt,name=page" json:"page,omitempty"`
	Photo   *PhotoInfo `protobuf:"bytes,4,opt,name=photo" json:"photo,omitempty"`
	PhotoTL []byte     `protobuf:"bytes,5,opt,name=photoTL,proto3" json:"photoTL,omitempty"`
}

func (m *ParseUrlAndStoreReply) Reset()                    { *m = ParseUrlAndStoreReply{} }
func (m *ParseUrlAndStoreReply) String() string            { return proto.CompactTextString(m) }
func (*ParseUrlAndStoreReply) ProtoMessage()               {}
func (*ParseUrlAndStoreReply) Descriptor() ([]byte, []int) { return fileDescriptorWebpage, []int{10} }

func (m *ParseUrlAndStoreReply) GetErrCode() ErrCode {
	if m != nil {
		return m.ErrCode
	}
	return ErrCode_OK
}

func (m *ParseUrlAndStoreReply) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ParseUrlAndStoreReply) GetPage() *PageInfo {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *ParseUrlAndStoreReply) GetPhoto() *PhotoInfo {
	if m != nil {
		return m.Photo
	}
	return nil
}

func (m *ParseUrlAndStoreReply) GetPhotoTL() []byte {
	if m != nil {
		return m.PhotoTL
	}
	return nil
}

func init() {
	proto.RegisterType((*ParseUrlRequest)(nil), "webpage.ParseUrlRequest")
	proto.RegisterType((*ParseUrlReply)(nil), "webpage.ParseUrlReply")
	proto.RegisterType((*PageInfo)(nil), "webpage.PageInfo")
	proto.RegisterType((*VideoInfo)(nil), "webpage.VideoInfo")
	proto.RegisterType((*PhotoInfo)(nil), "webpage.PhotoInfo")
	proto.RegisterType((*SavedWebPage)(nil), "webpage.SavedWebPage")
	proto.RegisterType((*UploadPhoto)(nil), "webpage.UploadPhoto")
	proto.RegisterType((*ParseUrlForEncodedRequest)(nil), "webpage.ParseUrlForEncodedRequest")
	proto.RegisterType((*ParseUrlForEncodedReply)(nil), "webpage.ParseUrlForEncodedReply")
	proto.RegisterType((*ParseUrlAndStoreRequest)(nil), "webpage.ParseUrlAndStoreRequest")
	proto.RegisterType((*ParseUrlAndStoreReply)(nil), "webpage.ParseUrlAndStoreReply")
	proto.RegisterEnum("webpage.ErrCode", ErrCode_name, ErrCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for WebPage service

type WebPageClient interface {
	// 解析url
	ParseUrl(ctx context.Context, in *ParseUrlRequest, opts ...grpc.CallOption) (*ParseUrlReply, error)
	// 解析url
	ParseUrlForEncoded(ctx context.Context, in *ParseUrlForEncodedRequest, opts ...grpc.CallOption) (*ParseUrlForEncodedReply, error)
	ParseUrlAndStore(ctx context.Context, in *ParseUrlAndStoreRequest, opts ...grpc.CallOption) (*ParseUrlAndStoreReply, error)
}

type webPageClient struct {
	cc *grpc.ClientConn
}

func NewWebPageClient(cc *grpc.ClientConn) WebPageClient {
	return &webPageClient{cc}
}

func (c *webPageClient) ParseUrl(ctx context.Context, in *ParseUrlRequest, opts ...grpc.CallOption) (*ParseUrlReply, error) {
	out := new(ParseUrlReply)
	err := grpc.Invoke(ctx, "/webpage.WebPage/ParseUrl", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webPageClient) ParseUrlForEncoded(ctx context.Context, in *ParseUrlForEncodedRequest, opts ...grpc.CallOption) (*ParseUrlForEncodedReply, error) {
	out := new(ParseUrlForEncodedReply)
	err := grpc.Invoke(ctx, "/webpage.WebPage/ParseUrlForEncoded", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *webPageClient) ParseUrlAndStore(ctx context.Context, in *ParseUrlAndStoreRequest, opts ...grpc.CallOption) (*ParseUrlAndStoreReply, error) {
	out := new(ParseUrlAndStoreReply)
	err := grpc.Invoke(ctx, "/webpage.WebPage/ParseUrlAndStore", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for WebPage service

type WebPageServer interface {
	// 解析url
	ParseUrl(context.Context, *ParseUrlRequest) (*ParseUrlReply, error)
	// 解析url
	ParseUrlForEncoded(context.Context, *ParseUrlForEncodedRequest) (*ParseUrlForEncodedReply, error)
	ParseUrlAndStore(context.Context, *ParseUrlAndStoreRequest) (*ParseUrlAndStoreReply, error)
}

func RegisterWebPageServer(s *grpc.Server, srv WebPageServer) {
	s.RegisterService(&_WebPage_serviceDesc, srv)
}

func _WebPage_ParseUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseUrlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebPageServer).ParseUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/webpage.WebPage/ParseUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebPageServer).ParseUrl(ctx, req.(*ParseUrlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebPage_ParseUrlForEncoded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseUrlForEncodedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebPageServer).ParseUrlForEncoded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/webpage.WebPage/ParseUrlForEncoded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebPageServer).ParseUrlForEncoded(ctx, req.(*ParseUrlForEncodedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WebPage_ParseUrlAndStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseUrlAndStoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WebPageServer).ParseUrlAndStore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/webpage.WebPage/ParseUrlAndStore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WebPageServer).ParseUrlAndStore(ctx, req.(*ParseUrlAndStoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WebPage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "webpage.WebPage",
	HandlerType: (*WebPageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ParseUrl",
			Handler:    _WebPage_ParseUrl_Handler,
		},
		{
			MethodName: "ParseUrlForEncoded",
			Handler:    _WebPage_ParseUrlForEncoded_Handler,
		},
		{
			MethodName: "ParseUrlAndStore",
			Handler:    _WebPage_ParseUrlAndStore_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/webpage/webpage.proto",
}

func (m *ParseUrlRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseUrlRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *ParseUrlReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseUrlReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.ErrCode))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Id))
	}
	if m.Page != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Page.Size()))
		n1, err := m.Page.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Photo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Photo.Size()))
		n2, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.DisplayUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.DisplayUrl)))
		i += copy(dAtA[i:], m.DisplayUrl)
	}
	if m.Hash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Hash))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.SiteName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.SiteName)))
		i += copy(dAtA[i:], m.SiteName)
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Author) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Author)))
		i += copy(dAtA[i:], m.Author)
	}
	if m.Photo != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Photo.Size()))
		n3, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Video != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Video.Size()))
		n4, err := m.Video.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *VideoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayAddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.PlayAddr)))
		i += copy(dAtA[i:], m.PlayAddr)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Height))
	}
	return i, nil
}

func (m *PhotoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Width != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Height))
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *SavedWebPage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SavedWebPage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Id))
	}
	if m.Page != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Page.Size()))
		n5, err := m.Page.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *UploadPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadPhoto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Id))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.AccessHash))
	}
	if m.Width != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Width))
	}
	if m.Height != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Height))
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Size_))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ParseUrlForEncodedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseUrlForEncodedRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *ParseUrlForEncodedReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseUrlForEncodedReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.ErrCode))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Id))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *ParseUrlAndStoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseUrlAndStoreRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.UserId))
	}
	if len(m.Img_Url) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.Img_Url)))
		i += copy(dAtA[i:], m.Img_Url)
	}
	return i, nil
}

func (m *ParseUrlAndStoreReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParseUrlAndStoreReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.ErrCode))
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Id))
	}
	if m.Page != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Page.Size()))
		n6, err := m.Page.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Photo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(m.Photo.Size()))
		n7, err := m.Photo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.PhotoTL) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintWebpage(dAtA, i, uint64(len(m.PhotoTL)))
		i += copy(dAtA[i:], m.PhotoTL)
	}
	return i, nil
}

func encodeVarintWebpage(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ParseUrlRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovWebpage(uint64(m.UserId))
	}
	return n
}

func (m *ParseUrlReply) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovWebpage(uint64(m.ErrCode))
	}
	if m.Id != 0 {
		n += 1 + sovWebpage(uint64(m.Id))
	}
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func (m *PageInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	l = len(m.DisplayUrl)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.Hash != 0 {
		n += 1 + sovWebpage(uint64(m.Hash))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	l = len(m.SiteName)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func (m *VideoInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.PlayAddr)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovWebpage(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovWebpage(uint64(m.Height))
	}
	return n
}

func (m *PhotoInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovWebpage(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovWebpage(uint64(m.Height))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func (m *SavedWebPage) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovWebpage(uint64(m.Id))
	}
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func (m *UploadPhoto) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovWebpage(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovWebpage(uint64(m.AccessHash))
	}
	if m.Width != 0 {
		n += 1 + sovWebpage(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovWebpage(uint64(m.Height))
	}
	if m.Size_ != 0 {
		n += 1 + sovWebpage(uint64(m.Size_))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func (m *ParseUrlForEncodedRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovWebpage(uint64(m.UserId))
	}
	return n
}

func (m *ParseUrlForEncodedReply) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovWebpage(uint64(m.ErrCode))
	}
	if m.Id != 0 {
		n += 1 + sovWebpage(uint64(m.Id))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func (m *ParseUrlAndStoreRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovWebpage(uint64(m.UserId))
	}
	l = len(m.Img_Url)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func (m *ParseUrlAndStoreReply) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovWebpage(uint64(m.ErrCode))
	}
	if m.Id != 0 {
		n += 1 + sovWebpage(uint64(m.Id))
	}
	if m.Page != nil {
		l = m.Page.Size()
		n += 1 + l + sovWebpage(uint64(l))
	}
	if m.Photo != nil {
		l = m.Photo.Size()
		n += 1 + l + sovWebpage(uint64(l))
	}
	l = len(m.PhotoTL)
	if l > 0 {
		n += 1 + l + sovWebpage(uint64(l))
	}
	return n
}

func sovWebpage(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozWebpage(x uint64) (n int) {
	return sovWebpage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ParseUrlRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseUrlRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseUrlRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseUrlReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseUrlReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseUrlReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Page == nil {
				m.Page = &PageInfo{}
			}
			if err := m.Page.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &PhotoInfo{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SiteName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SiteName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &UploadPhoto{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &VideoInfo{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SavedWebPage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SavedWebPage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SavedWebPage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Page == nil {
				m.Page = &PageInfo{}
			}
			if err := m.Page.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseUrlForEncodedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseUrlForEncodedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseUrlForEncodedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseUrlForEncodedReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseUrlForEncodedReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseUrlForEncodedReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseUrlAndStoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseUrlAndStoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseUrlAndStoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img_Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Img_Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParseUrlAndStoreReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParseUrlAndStoreReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParseUrlAndStoreReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (ErrCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Page == nil {
				m.Page = &PageInfo{}
			}
			if err := m.Page.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Photo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Photo == nil {
				m.Photo = &PhotoInfo{}
			}
			if err := m.Photo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoTL", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWebpage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhotoTL = append(m.PhotoTL[:0], dAtA[iNdEx:postIndex]...)
			if m.PhotoTL == nil {
				m.PhotoTL = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWebpage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWebpage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWebpage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWebpage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWebpage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthWebpage
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowWebpage
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipWebpage(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthWebpage = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWebpage   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/webpage/webpage.proto", fileDescriptorWebpage)
}

var fileDescriptorWebpage = []byte{
	// 786 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0xaf, 0x9d, 0xd8, 0x49, 0x5e, 0xc2, 0xd6, 0x8c, 0x96, 0xad, 0x59, 0xa4, 0x34, 0xb2, 0x84,
	0x14, 0x15, 0x29, 0x95, 0x96, 0x1b, 0x42, 0x48, 0xa5, 0xa4, 0x6a, 0x05, 0x94, 0xca, 0xdd, 0x2c,
	0x17, 0x50, 0x34, 0xf1, 0xbc, 0x8d, 0x07, 0x1c, 0x8f, 0x99, 0x99, 0xec, 0x12, 0x3e, 0x04, 0x27,
	0xae, 0xdc, 0xf9, 0x16, 0x5c, 0x39, 0xf2, 0x11, 0xd0, 0x7e, 0x11, 0xd0, 0x8c, 0xed, 0x24, 0x24,
	0xd1, 0x4a, 0x0b, 0x97, 0x9e, 0xf2, 0xfe, 0xcd, 0xcf, 0xef, 0xfd, 0xde, 0x6f, 0x26, 0xf0, 0xd1,
	0x9c, 0xeb, 0x8c, 0xce, 0x46, 0x49, 0x4a, 0xb5, 0x42, 0x79, 0x85, 0x72, 0xc4, 0x17, 0x8f, 0x79,
	0xae, 0x51, 0x5e, 0xd2, 0x04, 0x0b, 0x29, 0x66, 0xcb, 0xcb, 0xc7, 0xd7, 0x38, 0x2b, 0xe8, 0x1c,
	0xeb, 0xdf, 0x51, 0x21, 0x85, 0x16, 0xa4, 0x55, 0xb9, 0xd1, 0xc7, 0x70, 0xff, 0x15, 0x95, 0x0a,
	0x27, 0x32, 0x8b, 0xf1, 0x87, 0x25, 0x2a, 0x4d, 0x02, 0x68, 0x2c, 0x65, 0x16, 0x3a, 0x03, 0x67,
	0xd8, 0x89, 0x8d, 0x49, 0x1e, 0x40, 0x6b, 0xa9, 0x50, 0x4e, 0x39, 0x0b, 0xdd, 0x81, 0x33, 0xf4,
	0x62, 0xdf, 0xb8, 0x2f, 0x58, 0xf4, 0xab, 0x03, 0x6f, 0x6d, 0x8e, 0x17, 0xd9, 0x8a, 0x7c, 0x00,
	0x6d, 0x94, 0x72, 0x9a, 0x08, 0x86, 0x16, 0xe1, 0xe8, 0x2c, 0x18, 0xd5, 0x9f, 0x1e, 0x4b, 0xf9,
	0x54, 0x30, 0x8c, 0x5b, 0x58, 0x1a, 0xe4, 0x08, 0xdc, 0x0a, 0xb2, 0x11, 0xbb, 0x9c, 0x91, 0xf7,
	0xa1, 0x69, 0x0a, 0xc3, 0xc6, 0xc0, 0x19, 0x76, 0xcf, 0xde, 0x5e, 0x1f, 0x7c, 0x45, 0xe7, 0xf8,
	0x22, 0xbf, 0x14, 0xb1, 0x4d, 0x93, 0x21, 0x78, 0x45, 0x2a, 0xb4, 0x08, 0x9b, 0xb6, 0x8e, 0x6c,
	0xea, 0x4c, 0xd4, 0x16, 0x96, 0x05, 0xd1, 0x6f, 0x2e, 0xb4, 0xeb, 0xc3, 0x07, 0xe6, 0x7a, 0x08,
	0x5d, 0xc6, 0x55, 0x91, 0xd1, 0xd5, 0xd4, 0x64, 0x5c, 0x9b, 0x81, 0x2a, 0x34, 0x91, 0x19, 0x21,
	0xd0, 0x4c, 0xa9, 0x4a, 0x6d, 0x43, 0x5e, 0x6c, 0x6d, 0x13, 0xd3, 0xab, 0x02, 0xed, 0xc7, 0x3b,
	0xb1, 0xb5, 0xc9, 0x7b, 0xd0, 0x51, 0x5c, 0xe3, 0x34, 0xa7, 0x0b, 0x0c, 0x3d, 0x9b, 0x68, 0x9b,
	0xc0, 0x4b, 0xba, 0x40, 0x72, 0x0c, 0x9e, 0xe6, 0x3a, 0xc3, 0xd0, 0xb7, 0x89, 0xd2, 0x21, 0x03,
	0xe8, 0x32, 0x54, 0x89, 0xe4, 0x85, 0xe6, 0x22, 0x0f, 0x5b, 0x36, 0xb7, 0x1d, 0x22, 0x27, 0xe0,
	0xd3, 0xa5, 0x4e, 0x85, 0x0c, 0xdb, 0x36, 0x59, 0x79, 0xe4, 0x51, 0x3d, 0x7e, 0xc7, 0x8e, 0x7f,
	0xbc, 0x1e, 0x7f, 0x52, 0x64, 0x82, 0x32, 0x4b, 0x42, 0x45, 0x80, 0xa1, 0xea, 0x8a, 0x33, 0x14,
	0x21, 0xec, 0x50, 0x75, 0x61, 0xa2, 0x25, 0x55, 0xb6, 0x20, 0xba, 0x80, 0xce, 0x3a, 0x66, 0xe6,
	0xb1, 0xac, 0x50, 0xc6, 0x64, 0x45, 0x58, 0xdb, 0x04, 0x9e, 0x30, 0x26, 0xcd, 0x3c, 0xd7, 0x9c,
	0xe9, 0xb4, 0xd2, 0x42, 0xe9, 0x98, 0x6e, 0x53, 0xe4, 0xf3, 0x54, 0x57, 0x64, 0x55, 0x5e, 0xa4,
	0xa0, 0xb3, 0x5e, 0x8b, 0xe1, 0x8e, 0x51, 0x4d, 0x2d, 0x64, 0x2f, 0xb6, 0xf6, 0xdd, 0xe0, 0x0e,
	0xb2, 0x5f, 0x2d, 0xd6, 0x5b, 0x2f, 0x36, 0x1a, 0x43, 0xef, 0x35, 0xbd, 0x42, 0xf6, 0x35, 0xce,
	0xcc, 0xfa, 0x2b, 0xa1, 0x39, 0x7b, 0x42, 0x73, 0x6f, 0x15, 0x5a, 0xf4, 0x8b, 0x03, 0xdd, 0x2d,
	0x52, 0xf7, 0x60, 0x1e, 0x42, 0x97, 0x26, 0x09, 0x2a, 0x35, 0xb5, 0x2a, 0x29, 0x85, 0x0c, 0x65,
	0xe8, 0xb9, 0xd1, 0xca, 0x7a, 0xb6, 0xc6, 0xe1, 0xd9, 0x9a, 0xbb, 0xb3, 0x29, 0xfe, 0x53, 0x29,
	0x20, 0x2f, 0xb6, 0xf6, 0x9a, 0x31, 0x7f, 0xc3, 0x58, 0xf4, 0x0c, 0xde, 0xad, 0x2f, 0xdd, 0x33,
	0x21, 0xc7, 0xb9, 0xb9, 0x6c, 0xec, 0x3f, 0xdc, 0xde, 0xef, 0xe0, 0xc1, 0x21, 0x9c, 0xff, 0x7d,
	0x8d, 0xeb, 0x9e, 0x1b, 0x5b, 0x3d, 0x7f, 0xbb, 0xf9, 0xd6, 0x93, 0x9c, 0xbd, 0xd6, 0x42, 0xe2,
	0xdd, 0x3b, 0x36, 0x09, 0xbe, 0x98, 0x4f, 0x27, 0x32, 0xb3, 0xe0, 0x9d, 0xd8, 0xe7, 0x8b, 0xf9,
	0x44, 0x66, 0xd1, 0xef, 0x0e, 0xbc, 0xb3, 0x8f, 0xff, 0xc6, 0x3d, 0x48, 0x24, 0x84, 0x96, 0x35,
	0xce, 0xbf, 0xb0, 0x5b, 0xee, 0xc5, 0xb5, 0xfb, 0xe8, 0x67, 0x07, 0x5a, 0x55, 0x3f, 0xc4, 0x07,
	0xf7, 0xab, 0xcf, 0x83, 0x7b, 0xe4, 0x18, 0x82, 0x49, 0xfe, 0x7d, 0x2e, 0xae, 0xf3, 0xf1, 0x8f,
	0x09, 0xda, 0x57, 0x21, 0x70, 0xc8, 0x09, 0x90, 0x8a, 0xba, 0x49, 0x2e, 0x91, 0x26, 0x29, 0x9d,
	0x65, 0x18, 0xb8, 0x84, 0xc0, 0x51, 0x15, 0x3f, 0xe7, 0x0b, 0x14, 0x4b, 0x1d, 0x34, 0x0c, 0xc2,
	0x67, 0x5c, 0x99, 0x02, 0x16, 0xa3, 0x2a, 0x44, 0xae, 0x30, 0x68, 0x9a, 0xca, 0x97, 0x42, 0x3f,
	0xd7, 0x8b, 0xec, 0xa9, 0xc8, 0x35, 0xe6, 0x3a, 0xf0, 0xc8, 0x7d, 0xe8, 0x7e, 0xc9, 0x95, 0xe2,
	0xf9, 0xdc, 0x0c, 0x17, 0xf8, 0x67, 0x7f, 0x3b, 0xd0, 0xaa, 0xef, 0xcf, 0x27, 0xe6, 0x19, 0x2d,
	0xd9, 0x25, 0xe1, 0x16, 0x0b, 0xff, 0xfa, 0xe3, 0x38, 0x3d, 0x39, 0x90, 0x29, 0xb2, 0x55, 0x74,
	0x8f, 0x7c, 0x03, 0x64, 0x5f, 0x69, 0x24, 0xda, 0xab, 0xdf, 0x93, 0xf3, 0xe9, 0xe0, 0xd6, 0x9a,
	0x12, 0xfd, 0x02, 0x82, 0xdd, 0xdd, 0x93, 0xfd, 0x73, 0x3b, 0xb2, 0x3b, 0xed, 0xdf, 0x52, 0x61,
	0x71, 0x3f, 0xed, 0xfd, 0x71, 0xd3, 0x77, 0xfe, 0xbc, 0xe9, 0x3b, 0x7f, 0xdd, 0xf4, 0x9d, 0x99,
	0x6f, 0xff, 0x39, 0x3f, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xca, 0x85, 0xb4, 0x2c, 0x77, 0x07,
	0x00, 0x00,
}
