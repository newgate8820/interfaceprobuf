// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imserver/imserver.proto

/*
Package imserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/imserver/imserver.proto

It has these top-level messages:

	HandleMTPRequest
	HandleMTPReply
	RegisterGatewayRequest
	Update
*/
package imserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type HandleMTPRequest_Flag int32

const (
	HandleMTPRequest_IsProxy       HandleMTPRequest_Flag = 0
	HandleMTPRequest_FirstLogin    HandleMTPRequest_Flag = 1
	HandleMTPRequest_IsMainSession HandleMTPRequest_Flag = 2
	HandleMTPRequest_IsHttp        HandleMTPRequest_Flag = 3
	HandleMTPRequest_IsMediaConn   HandleMTPRequest_Flag = 4
	HandleMTPRequest_UserIdChecked HandleMTPRequest_Flag = 5
	HandleMTPRequest_WithAuthKey   HandleMTPRequest_Flag = 6
)

var HandleMTPRequest_Flag_name = map[int32]string{
	0: "IsProxy",
	1: "FirstLogin",
	2: "IsMainSession",
	3: "IsHttp",
	4: "IsMediaConn",
	5: "UserIdChecked",
	6: "WithAuthKey",
}
var HandleMTPRequest_Flag_value = map[string]int32{
	"IsProxy":       0,
	"FirstLogin":    1,
	"IsMainSession": 2,
	"IsHttp":        3,
	"IsMediaConn":   4,
	"UserIdChecked": 5,
	"WithAuthKey":   6,
}

func (x HandleMTPRequest_Flag) String() string {
	return proto.EnumName(HandleMTPRequest_Flag_name, int32(x))
}
func (HandleMTPRequest_Flag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImserver, []int{0, 0}
}

type HandleMTPReply_Flag int32

const (
	HandleMTPReply_SetUserId        HandleMTPReply_Flag = 0
	HandleMTPReply_SetPhoneNumber   HandleMTPReply_Flag = 1
	HandleMTPReply_SetAuthKey       HandleMTPReply_Flag = 2
	HandleMTPReply_SetApiId         HandleMTPReply_Flag = 3
	HandleMTPReply_SetAppVersion    HandleMTPReply_Flag = 4
	HandleMTPReply_SetDeviceModel   HandleMTPReply_Flag = 5
	HandleMTPReply_SetLangCode      HandleMTPReply_Flag = 6
	HandleMTPReply_SetSystemVersion HandleMTPReply_Flag = 7
	HandleMTPReply_SetLayer         HandleMTPReply_Flag = 8
	HandleMTPReply_SetOSType        HandleMTPReply_Flag = 9
	HandleMTPReply_SetUserIdChecked HandleMTPReply_Flag = 10
	HandleMTPReply_SetQuickIsACK    HandleMTPReply_Flag = 11
	HandleMTPReply_SetGroupID       HandleMTPReply_Flag = 12
)

var HandleMTPReply_Flag_name = map[int32]string{
	0:  "SetUserId",
	1:  "SetPhoneNumber",
	2:  "SetAuthKey",
	3:  "SetApiId",
	4:  "SetAppVersion",
	5:  "SetDeviceModel",
	6:  "SetLangCode",
	7:  "SetSystemVersion",
	8:  "SetLayer",
	9:  "SetOSType",
	10: "SetUserIdChecked",
	11: "SetQuickIsACK",
	12: "SetGroupID",
}
var HandleMTPReply_Flag_value = map[string]int32{
	"SetUserId":        0,
	"SetPhoneNumber":   1,
	"SetAuthKey":       2,
	"SetApiId":         3,
	"SetAppVersion":    4,
	"SetDeviceModel":   5,
	"SetLangCode":      6,
	"SetSystemVersion": 7,
	"SetLayer":         8,
	"SetOSType":        9,
	"SetUserIdChecked": 10,
	"SetQuickIsACK":    11,
	"SetGroupID":       12,
}

func (x HandleMTPReply_Flag) String() string {
	return proto.EnumName(HandleMTPReply_Flag_name, int32(x))
}
func (HandleMTPReply_Flag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorImserver, []int{1, 0}
}

type Update_OpType int32

const (
	Update_UserAll                  Update_OpType = 0
	Update_UserOneClient            Update_OpType = 1
	Update_UserExcludeOneClient     Update_OpType = 2
	Update_InternalUserAll          Update_OpType = 3
	Update_InternalOneClient        Update_OpType = 4
	Update_InternalExcludeOneClient Update_OpType = 5
)

var Update_OpType_name = map[int32]string{
	0: "UserAll",
	1: "UserOneClient",
	2: "UserExcludeOneClient",
	3: "InternalUserAll",
	4: "InternalOneClient",
	5: "InternalExcludeOneClient",
}
var Update_OpType_value = map[string]int32{
	"UserAll":                  0,
	"UserOneClient":            1,
	"UserExcludeOneClient":     2,
	"InternalUserAll":          3,
	"InternalOneClient":        4,
	"InternalExcludeOneClient": 5,
}

func (x Update_OpType) String() string {
	return proto.EnumName(Update_OpType_name, int32(x))
}
func (Update_OpType) EnumDescriptor() ([]byte, []int) { return fileDescriptorImserver, []int{3, 0} }

type HandleMTPRequest struct {
	ClientAddr    string                `protobuf:"bytes,1,opt,name=client_addr,json=clientAddr,proto3" json:"client_addr,omitempty"`
	ApiId         int32                 `protobuf:"varint,2,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel   string                `protobuf:"bytes,3,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion string                `protobuf:"bytes,4,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion    string                `protobuf:"bytes,5,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	MtLayer       int32                 `protobuf:"varint,6,opt,name=mt_layer,json=mtLayer,proto3" json:"mt_layer,omitempty"`
	AppName       string                `protobuf:"bytes,7,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	ProxyAddr     string                `protobuf:"bytes,8,opt,name=proxy_addr,json=proxyAddr,proto3" json:"proxy_addr,omitempty"`
	LangCode      string                `protobuf:"bytes,9,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	UserId        int32                 `protobuf:"varint,10,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PhoneNumber   string                `protobuf:"bytes,11,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	AuthKeyId     uint64                `protobuf:"varint,12,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	ServerSalt    uint64                `protobuf:"varint,13,opt,name=server_salt,json=serverSalt,proto3" json:"server_salt,omitempty"`
	SessionId     uint64                `protobuf:"varint,14,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	MessageId     uint64                `protobuf:"varint,15,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	MessageSeqNo  uint32                `protobuf:"varint,16,opt,name=message_seq_no,json=messageSeqNo,proto3" json:"message_seq_no,omitempty"`
	IsAck         bool                  `protobuf:"varint,17,opt,name=is_ack,json=isAck,proto3" json:"is_ack,omitempty"`
	MessageObj    []byte                `protobuf:"bytes,18,opt,name=message_obj,json=messageObj,proto3" json:"message_obj,omitempty"`
	FlagIn        HandleMTPRequest_Flag `protobuf:"varint,19,opt,name=flag_in,json=flagIn,proto3,enum=imserver.HandleMTPRequest_Flag" json:"flag_in,omitempty"`
	Crc           uint32                `protobuf:"varint,20,opt,name=crc,proto3" json:"crc,omitempty"`
	AuthKey       []byte                `protobuf:"bytes,21,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
}

func (m *HandleMTPRequest) Reset()                    { *m = HandleMTPRequest{} }
func (m *HandleMTPRequest) String() string            { return proto.CompactTextString(m) }
func (*HandleMTPRequest) ProtoMessage()               {}
func (*HandleMTPRequest) Descriptor() ([]byte, []int) { return fileDescriptorImserver, []int{0} }

func (m *HandleMTPRequest) GetClientAddr() string {
	if m != nil {
		return m.ClientAddr
	}
	return ""
}

func (m *HandleMTPRequest) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *HandleMTPRequest) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *HandleMTPRequest) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *HandleMTPRequest) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *HandleMTPRequest) GetMtLayer() int32 {
	if m != nil {
		return m.MtLayer
	}
	return 0
}

func (m *HandleMTPRequest) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *HandleMTPRequest) GetProxyAddr() string {
	if m != nil {
		return m.ProxyAddr
	}
	return ""
}

func (m *HandleMTPRequest) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *HandleMTPRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HandleMTPRequest) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *HandleMTPRequest) GetAuthKeyId() uint64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *HandleMTPRequest) GetServerSalt() uint64 {
	if m != nil {
		return m.ServerSalt
	}
	return 0
}

func (m *HandleMTPRequest) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *HandleMTPRequest) GetMessageId() uint64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *HandleMTPRequest) GetMessageSeqNo() uint32 {
	if m != nil {
		return m.MessageSeqNo
	}
	return 0
}

func (m *HandleMTPRequest) GetIsAck() bool {
	if m != nil {
		return m.IsAck
	}
	return false
}

func (m *HandleMTPRequest) GetMessageObj() []byte {
	if m != nil {
		return m.MessageObj
	}
	return nil
}

func (m *HandleMTPRequest) GetFlagIn() HandleMTPRequest_Flag {
	if m != nil {
		return m.FlagIn
	}
	return HandleMTPRequest_IsProxy
}

func (m *HandleMTPRequest) GetCrc() uint32 {
	if m != nil {
		return m.Crc
	}
	return 0
}

func (m *HandleMTPRequest) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

type HandleMTPReply struct {
	RpcResult     []byte              `protobuf:"bytes,1,opt,name=rpc_result,json=rpcResult,proto3" json:"rpc_result,omitempty"`
	FlagOut       HandleMTPReply_Flag `protobuf:"varint,2,opt,name=flag_out,json=flagOut,proto3,enum=imserver.HandleMTPReply_Flag" json:"flag_out,omitempty"`
	UserId        int32               `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PhoneNumber   string              `protobuf:"bytes,4,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	AuthKey       []byte              `protobuf:"bytes,5,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	ApiId         int32               `protobuf:"varint,6,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	AppVersion    string              `protobuf:"bytes,7,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	DeviceModel   string              `protobuf:"bytes,8,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	LangCode      string              `protobuf:"bytes,9,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	SystemVersion string              `protobuf:"bytes,10,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	MtLayer       int32               `protobuf:"varint,11,opt,name=mt_layer,json=mtLayer,proto3" json:"mt_layer,omitempty"`
	OsType        int32               `protobuf:"varint,12,opt,name=os_type,json=osType,proto3" json:"os_type,omitempty"`
	GroupId       int32               `protobuf:"varint,13,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
}

func (m *HandleMTPReply) Reset()                    { *m = HandleMTPReply{} }
func (m *HandleMTPReply) String() string            { return proto.CompactTextString(m) }
func (*HandleMTPReply) ProtoMessage()               {}
func (*HandleMTPReply) Descriptor() ([]byte, []int) { return fileDescriptorImserver, []int{1} }

func (m *HandleMTPReply) GetRpcResult() []byte {
	if m != nil {
		return m.RpcResult
	}
	return nil
}

func (m *HandleMTPReply) GetFlagOut() HandleMTPReply_Flag {
	if m != nil {
		return m.FlagOut
	}
	return HandleMTPReply_SetUserId
}

func (m *HandleMTPReply) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HandleMTPReply) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *HandleMTPReply) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *HandleMTPReply) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *HandleMTPReply) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *HandleMTPReply) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *HandleMTPReply) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *HandleMTPReply) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *HandleMTPReply) GetMtLayer() int32 {
	if m != nil {
		return m.MtLayer
	}
	return 0
}

func (m *HandleMTPReply) GetOsType() int32 {
	if m != nil {
		return m.OsType
	}
	return 0
}

func (m *HandleMTPReply) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

type RegisterGatewayRequest struct {
	GatewayId int32 `protobuf:"varint,1,opt,name=gateway_id,json=gatewayId,proto3" json:"gateway_id,omitempty"`
}

func (m *RegisterGatewayRequest) Reset()                    { *m = RegisterGatewayRequest{} }
func (m *RegisterGatewayRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterGatewayRequest) ProtoMessage()               {}
func (*RegisterGatewayRequest) Descriptor() ([]byte, []int) { return fileDescriptorImserver, []int{2} }

func (m *RegisterGatewayRequest) GetGatewayId() int32 {
	if m != nil {
		return m.GatewayId
	}
	return 0
}

type Update struct {
	SendOp      Update_OpType `protobuf:"varint,1,opt,name=send_op,json=sendOp,proto3,enum=imserver.Update_OpType" json:"send_op,omitempty"`
	UserIdSlice []int32       `protobuf:"varint,2,rep,packed,name=user_id_slice,json=userIdSlice" json:"user_id_slice,omitempty"`
	AuthKeyId   uint64        `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptorImserver, []int{3} }

func (m *Update) GetSendOp() Update_OpType {
	if m != nil {
		return m.SendOp
	}
	return Update_UserAll
}

func (m *Update) GetUserIdSlice() []int32 {
	if m != nil {
		return m.UserIdSlice
	}
	return nil
}

func (m *Update) GetAuthKeyId() uint64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func init() {
	proto.RegisterType((*HandleMTPRequest)(nil), "imserver.HandleMTPRequest")
	proto.RegisterType((*HandleMTPReply)(nil), "imserver.HandleMTPReply")
	proto.RegisterType((*RegisterGatewayRequest)(nil), "imserver.RegisterGatewayRequest")
	proto.RegisterType((*Update)(nil), "imserver.Update")
	proto.RegisterEnum("imserver.HandleMTPRequest_Flag", HandleMTPRequest_Flag_name, HandleMTPRequest_Flag_value)
	proto.RegisterEnum("imserver.HandleMTPReply_Flag", HandleMTPReply_Flag_name, HandleMTPReply_Flag_value)
	proto.RegisterEnum("imserver.Update_OpType", Update_OpType_name, Update_OpType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MTProtoServer service

type MTProtoServerClient interface {
	HandleMTP(ctx context.Context, opts ...grpc.CallOption) (MTProtoServer_HandleMTPClient, error)
}

type mTProtoServerClient struct {
	cc *grpc.ClientConn
}

func NewMTProtoServerClient(cc *grpc.ClientConn) MTProtoServerClient {
	return &mTProtoServerClient{cc}
}

func (c *mTProtoServerClient) HandleMTP(ctx context.Context, opts ...grpc.CallOption) (MTProtoServer_HandleMTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MTProtoServer_serviceDesc.Streams[0], c.cc, "/imserver.MTProtoServer/HandleMTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &mTProtoServerHandleMTPClient{stream}
	return x, nil
}

type MTProtoServer_HandleMTPClient interface {
	Send(*HandleMTPRequest) error
	Recv() (*HandleMTPReply, error)
	grpc.ClientStream
}

type mTProtoServerHandleMTPClient struct {
	grpc.ClientStream
}

func (x *mTProtoServerHandleMTPClient) Send(m *HandleMTPRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *mTProtoServerHandleMTPClient) Recv() (*HandleMTPReply, error) {
	m := new(HandleMTPReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MTProtoServer service

type MTProtoServerServer interface {
	HandleMTP(MTProtoServer_HandleMTPServer) error
}

func RegisterMTProtoServerServer(s *grpc.Server, srv MTProtoServerServer) {
	s.RegisterService(&_MTProtoServer_serviceDesc, srv)
}

func _MTProtoServer_HandleMTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MTProtoServerServer).HandleMTP(&mTProtoServerHandleMTPServer{stream})
}

type MTProtoServer_HandleMTPServer interface {
	Send(*HandleMTPReply) error
	Recv() (*HandleMTPRequest, error)
	grpc.ServerStream
}

type mTProtoServerHandleMTPServer struct {
	grpc.ServerStream
}

func (x *mTProtoServerHandleMTPServer) Send(m *HandleMTPReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *mTProtoServerHandleMTPServer) Recv() (*HandleMTPRequest, error) {
	m := new(HandleMTPRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MTProtoServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imserver.MTProtoServer",
	HandlerType: (*MTProtoServerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HandleMTP",
			Handler:       _MTProtoServer_HandleMTP_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imserver/imserver.proto",
}

func (m *HandleMTPRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleMTPRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientAddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.ClientAddr)))
		i += copy(dAtA[i:], m.ClientAddr)
	}
	if m.ApiId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.ApiId))
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if m.MtLayer != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.MtLayer))
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.ProxyAddr) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.ProxyAddr)))
		i += copy(dAtA[i:], m.ProxyAddr)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.ServerSalt != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.ServerSalt))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.SessionId))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.MessageId))
	}
	if m.MessageSeqNo != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.MessageSeqNo))
	}
	if m.IsAck {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IsAck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.MessageObj) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.MessageObj)))
		i += copy(dAtA[i:], m.MessageObj)
	}
	if m.FlagIn != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.FlagIn))
	}
	if m.Crc != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.Crc))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	return i, nil
}

func (m *HandleMTPReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleMTPReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RpcResult) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.RpcResult)))
		i += copy(dAtA[i:], m.RpcResult)
	}
	if m.FlagOut != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.FlagOut))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if m.ApiId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.ApiId))
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImserver(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if m.MtLayer != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.MtLayer))
	}
	if m.OsType != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.OsType))
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.GroupId))
	}
	return i, nil
}

func (m *RegisterGatewayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterGatewayRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GatewayId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.GatewayId))
	}
	return i, nil
}

func (m *Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Update) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendOp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.SendOp))
	}
	if len(m.UserIdSlice) > 0 {
		dAtA2 := make([]byte, len(m.UserIdSlice)*10)
		var j1 int
		for _, num1 := range m.UserIdSlice {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintImserver(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImserver(dAtA, i, uint64(m.AuthKeyId))
	}
	return i, nil
}

func encodeVarintImserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HandleMTPRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientAddr)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	if m.ApiId != 0 {
		n += 1 + sovImserver(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	if m.MtLayer != 0 {
		n += 1 + sovImserver(uint64(m.MtLayer))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.ProxyAddr)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovImserver(uint64(m.UserId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovImserver(uint64(m.AuthKeyId))
	}
	if m.ServerSalt != 0 {
		n += 1 + sovImserver(uint64(m.ServerSalt))
	}
	if m.SessionId != 0 {
		n += 1 + sovImserver(uint64(m.SessionId))
	}
	if m.MessageId != 0 {
		n += 1 + sovImserver(uint64(m.MessageId))
	}
	if m.MessageSeqNo != 0 {
		n += 2 + sovImserver(uint64(m.MessageSeqNo))
	}
	if m.IsAck {
		n += 3
	}
	l = len(m.MessageObj)
	if l > 0 {
		n += 2 + l + sovImserver(uint64(l))
	}
	if m.FlagIn != 0 {
		n += 2 + sovImserver(uint64(m.FlagIn))
	}
	if m.Crc != 0 {
		n += 2 + sovImserver(uint64(m.Crc))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 2 + l + sovImserver(uint64(l))
	}
	return n
}

func (m *HandleMTPReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.RpcResult)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	if m.FlagOut != 0 {
		n += 1 + sovImserver(uint64(m.FlagOut))
	}
	if m.UserId != 0 {
		n += 1 + sovImserver(uint64(m.UserId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	if m.ApiId != 0 {
		n += 1 + sovImserver(uint64(m.ApiId))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovImserver(uint64(l))
	}
	if m.MtLayer != 0 {
		n += 1 + sovImserver(uint64(m.MtLayer))
	}
	if m.OsType != 0 {
		n += 1 + sovImserver(uint64(m.OsType))
	}
	if m.GroupId != 0 {
		n += 1 + sovImserver(uint64(m.GroupId))
	}
	return n
}

func (m *RegisterGatewayRequest) Size() (n int) {
	var l int
	_ = l
	if m.GatewayId != 0 {
		n += 1 + sovImserver(uint64(m.GatewayId))
	}
	return n
}

func (m *Update) Size() (n int) {
	var l int
	_ = l
	if m.SendOp != 0 {
		n += 1 + sovImserver(uint64(m.SendOp))
	}
	if len(m.UserIdSlice) > 0 {
		l = 0
		for _, e := range m.UserIdSlice {
			l += sovImserver(uint64(e))
		}
		n += 1 + sovImserver(uint64(l)) + l
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovImserver(uint64(m.AuthKeyId))
	}
	return n
}

func sovImserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImserver(x uint64) (n int) {
	return sovImserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HandleMTPRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleMTPRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleMTPRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtLayer", wireType)
			}
			m.MtLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MtLayer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSalt", wireType)
			}
			m.ServerSalt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerSalt |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageSeqNo", wireType)
			}
			m.MessageSeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageSeqNo |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAck = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageObj", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MessageObj = append(m.MessageObj[:0], dAtA[iNdEx:postIndex]...)
			if m.MessageObj == nil {
				m.MessageObj = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagIn", wireType)
			}
			m.FlagIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlagIn |= (HandleMTPRequest_Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc", wireType)
			}
			m.Crc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleMTPReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleMTPReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleMTPReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcResult", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcResult = append(m.RpcResult[:0], dAtA[iNdEx:postIndex]...)
			if m.RpcResult == nil {
				m.RpcResult = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagOut", wireType)
			}
			m.FlagOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlagOut |= (HandleMTPReply_Flag(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MtLayer", wireType)
			}
			m.MtLayer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MtLayer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsType", wireType)
			}
			m.OsType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OsType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterGatewayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterGatewayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterGatewayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayId", wireType)
			}
			m.GatewayId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GatewayId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendOp", wireType)
			}
			m.SendOp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendOp |= (Update_OpType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIdSlice = append(m.UserIdSlice, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIdSlice = append(m.UserIdSlice, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIdSlice", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imserver/imserver.proto", fileDescriptorImserver)
}

var fileDescriptorImserver = []byte{
	// 1032 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xcd, 0x72, 0xdb, 0x36,
	0x17, 0x35, 0xf5, 0x43, 0x49, 0x57, 0x3f, 0x81, 0x11, 0xfb, 0x33, 0xbf, 0xb4, 0x76, 0x54, 0x4d,
	0x3b, 0xa3, 0x95, 0x92, 0x71, 0x17, 0xcd, 0xa2, 0x1b, 0xd7, 0x69, 0x1c, 0x4e, 0x6c, 0xcb, 0x25,
	0x9d, 0xb6, 0x3b, 0x0e, 0x44, 0x5e, 0xcb, 0x8c, 0x29, 0x12, 0x26, 0x40, 0x27, 0x7a, 0x87, 0xf6,
	0x0d, 0xba, 0xe8, 0xe3, 0x74, 0xd9, 0x47, 0xe8, 0x78, 0xdb, 0x97, 0xe8, 0x00, 0x20, 0x6d, 0xd9,
	0x4e, 0xb2, 0x23, 0xce, 0xbd, 0x17, 0xbc, 0xe7, 0xe0, 0x1e, 0x00, 0xbe, 0x9f, 0xc7, 0x32, 0x61,
	0xb3, 0x49, 0x78, 0xce, 0xa4, 0xc0, 0xfc, 0x0a, 0xf3, 0x49, 0xbc, 0x78, 0x16, 0xa7, 0x12, 0xf3,
	0x33, 0x16, 0x22, 0xcf, 0xb3, 0x59, 0x71, 0xf6, 0x2c, 0x5e, 0x98, 0xd8, 0xcd, 0xc7, 0x84, 0xe7,
	0x99, 0xcc, 0x68, 0xbb, 0x5a, 0x8f, 0xfe, 0xb4, 0x81, 0xbc, 0x66, 0x69, 0x94, 0xe0, 0xd1, 0xe9,
	0x89, 0x87, 0x97, 0x05, 0x0a, 0x49, 0x9f, 0x42, 0x37, 0x4c, 0x62, 0x4c, 0x65, 0xc0, 0xa2, 0x28,
	0x77, 0xac, 0xa1, 0x35, 0xee, 0x78, 0x60, 0xa0, 0xbd, 0x28, 0xca, 0xe9, 0x26, 0xd8, 0x8c, 0xc7,
	0x41, 0x1c, 0x39, 0xb5, 0xa1, 0x35, 0x6e, 0x7a, 0x4d, 0xc6, 0x63, 0x37, 0xa2, 0x5f, 0x41, 0x2f,
	0xc2, 0xab, 0x38, 0xc4, 0x60, 0x91, 0x45, 0x98, 0x38, 0x75, 0x5d, 0xd8, 0x35, 0xd8, 0x91, 0x82,
	0xe8, 0x37, 0x30, 0x10, 0x4b, 0x21, 0x71, 0x11, 0x5c, 0x61, 0x2e, 0xe2, 0x2c, 0x75, 0x1a, 0x3a,
	0xa9, 0x6f, 0xd0, 0x9f, 0x0d, 0xa8, 0x3a, 0x60, 0x9c, 0xdf, 0xe4, 0x34, 0x4d, 0x07, 0x8c, 0xf3,
	0x2a, 0xe1, 0xff, 0xd0, 0x5e, 0xc8, 0x20, 0x61, 0x4b, 0xcc, 0x1d, 0x5b, 0xf7, 0xd0, 0x5a, 0xc8,
	0x43, 0xb5, 0x54, 0x21, 0x55, 0x9b, 0xb2, 0x05, 0x3a, 0x2d, 0x5d, 0xd8, 0x62, 0x9c, 0x1f, 0xb3,
	0x05, 0xd2, 0x6d, 0x00, 0x9e, 0x67, 0x1f, 0x96, 0x86, 0x57, 0x5b, 0x07, 0x3b, 0x1a, 0xd1, 0xb4,
	0xbe, 0x80, 0x4e, 0xc2, 0xd2, 0x79, 0x10, 0x66, 0x11, 0x3a, 0x1d, 0x1d, 0x6d, 0x2b, 0x60, 0x3f,
	0x8b, 0x90, 0x6e, 0x41, 0xab, 0x10, 0x98, 0x2b, 0xd2, 0xa0, 0x7f, 0x68, 0xab, 0xa5, 0x61, 0xcd,
	0xcf, 0xb3, 0x14, 0x83, 0xb4, 0x58, 0xcc, 0x30, 0x77, 0xba, 0x86, 0xb5, 0xc6, 0x8e, 0x35, 0x44,
	0x77, 0xa0, 0xcb, 0x0a, 0x79, 0x1e, 0x5c, 0xe0, 0x52, 0xd5, 0xf7, 0x86, 0xd6, 0xb8, 0xe1, 0x75,
	0x14, 0xf4, 0x06, 0x97, 0x6e, 0xa4, 0xe8, 0x9a, 0xf3, 0x08, 0x04, 0x4b, 0xa4, 0xd3, 0xd7, 0x71,
	0x30, 0x90, 0xcf, 0x12, 0xa9, 0x1a, 0x17, 0x28, 0x14, 0x73, 0x55, 0x3f, 0x30, 0xf5, 0x25, 0xe2,
	0x46, 0x2a, 0xbc, 0x40, 0x21, 0xd8, 0x1c, 0x55, 0xf8, 0x91, 0x09, 0x97, 0x88, 0x1b, 0xd1, 0xaf,
	0x61, 0x50, 0x85, 0x05, 0x5e, 0x06, 0x69, 0xe6, 0x90, 0xa1, 0x35, 0xee, 0x7b, 0xbd, 0x12, 0xf5,
	0xf1, 0xf2, 0x38, 0x53, 0x87, 0x1a, 0x8b, 0x80, 0x85, 0x17, 0xce, 0xfa, 0xd0, 0x1a, 0xb7, 0xbd,
	0x66, 0x2c, 0xf6, 0xc2, 0x0b, 0xd5, 0x5b, 0x55, 0x9c, 0xcd, 0xde, 0x39, 0x74, 0x68, 0x8d, 0x7b,
	0x5e, 0xf5, 0xbb, 0xe9, 0xec, 0x1d, 0x7d, 0x01, 0xad, 0xb3, 0x84, 0xcd, 0x83, 0x38, 0x75, 0x1e,
	0x0f, 0xad, 0xf1, 0x60, 0xf7, 0xe9, 0xe4, 0x66, 0xdc, 0xee, 0x8f, 0xd6, 0xe4, 0x55, 0xc2, 0xe6,
	0x9e, 0xad, 0xf2, 0xdd, 0x94, 0x12, 0xa8, 0x87, 0x79, 0xe8, 0x6c, 0xe8, 0x66, 0xd4, 0xa7, 0x3e,
	0xbb, 0x52, 0x28, 0x67, 0x53, 0xff, 0xa9, 0x55, 0xaa, 0x34, 0x7a, 0x0f, 0x0d, 0x55, 0x4c, 0xbb,
	0xd0, 0x72, 0xc5, 0x89, 0x3a, 0x33, 0xb2, 0x46, 0x07, 0x00, 0xaf, 0xe2, 0x5c, 0xc8, 0xc3, 0x6c,
	0x1e, 0xa7, 0xc4, 0xa2, 0xeb, 0xd0, 0x77, 0xc5, 0x11, 0x8b, 0x53, 0xdf, 0x68, 0x43, 0x6a, 0x14,
	0xc0, 0x76, 0xc5, 0x6b, 0x29, 0x39, 0xa9, 0xd3, 0x47, 0xd0, 0x75, 0xc5, 0x11, 0x46, 0x31, 0xdb,
	0xcf, 0xd2, 0x94, 0x34, 0x54, 0xfe, 0x5b, 0x7d, 0x8a, 0xfb, 0xe7, 0x18, 0x5e, 0x60, 0x44, 0x9a,
	0x2a, 0xe7, 0x97, 0x58, 0x9e, 0xef, 0x99, 0xdf, 0x12, 0x7b, 0xf4, 0x47, 0x13, 0x06, 0x2b, 0x3c,
	0x78, 0xb2, 0x54, 0x7a, 0xe7, 0x3c, 0x0c, 0x72, 0x14, 0x45, 0x22, 0xb5, 0x3f, 0x7a, 0x5e, 0x27,
	0xe7, 0xa1, 0xa7, 0x01, 0xfa, 0x02, 0xda, 0x5a, 0x91, 0xac, 0x90, 0xda, 0x20, 0x83, 0xdd, 0xed,
	0x8f, 0x4a, 0xc2, 0x93, 0xa5, 0x11, 0x44, 0x0b, 0x38, 0x2d, 0xe4, 0xea, 0x90, 0xd5, 0x3f, 0x3b,
	0x64, 0x8d, 0x87, 0x43, 0xb6, 0xaa, 0x5d, 0xf3, 0x8e, 0x76, 0x2b, 0x7e, 0xb5, 0x57, 0xfd, 0x7a,
	0xcf, 0x65, 0xad, 0x07, 0x2e, 0xbb, 0x6f, 0xe8, 0xf6, 0x43, 0x43, 0x7f, 0xd6, 0x33, 0x0f, 0xdd,
	0x0e, 0x1f, 0x73, 0xfb, 0xaa, 0x99, 0xbb, 0x77, 0xcd, 0xbc, 0x05, 0xad, 0x4c, 0x04, 0x72, 0xc9,
	0x51, 0xbb, 0xa6, 0xe9, 0xd9, 0x99, 0x38, 0x5d, 0x72, 0x54, 0x35, 0xf3, 0x3c, 0x2b, 0xb8, 0x22,
	0xd5, 0x37, 0x35, 0x7a, 0xed, 0x46, 0xa3, 0x7f, 0xad, 0x72, 0x54, 0xfa, 0xd0, 0xf1, 0x51, 0x9a,
	0x03, 0x26, 0x6b, 0x94, 0xc2, 0xc0, 0x47, 0x79, 0x72, 0x2b, 0x19, 0xb1, 0xd4, 0x00, 0xf9, 0x28,
	0xab, 0xc3, 0xae, 0xd1, 0x1e, 0xb4, 0xd5, 0x5a, 0xc9, 0x43, 0xea, 0x6a, 0x3c, 0xf4, 0xaa, 0x12,
	0x84, 0x34, 0xca, 0x4d, 0x5e, 0xde, 0x2a, 0x60, 0x46, 0xc6, 0x47, 0x79, 0x58, 0xb2, 0x26, 0x36,
	0xdd, 0x00, 0xe2, 0xa3, 0xf4, 0x57, 0x49, 0x92, 0x56, 0xb9, 0xb7, 0xe6, 0x45, 0xda, 0x65, 0x73,
	0x53, 0x5f, 0xb1, 0x21, 0x9d, 0xb2, 0xe4, 0xee, 0x30, 0x42, 0xd9, 0xc0, 0x4f, 0x45, 0x1c, 0x5e,
	0xb8, 0x62, 0x6f, 0xff, 0x0d, 0xe9, 0x96, 0x1d, 0x1f, 0x68, 0xae, 0x2f, 0x49, 0x6f, 0xf4, 0x1d,
	0xfc, 0xcf, 0xc3, 0x79, 0x2c, 0x24, 0xe6, 0x07, 0x4c, 0xe2, 0x7b, 0xb6, 0xac, 0xae, 0xf1, 0x6d,
	0x80, 0xb9, 0x41, 0x94, 0x48, 0x96, 0x16, 0xa9, 0x53, 0x22, 0x6e, 0x34, 0xfa, 0xbd, 0x06, 0xf6,
	0x5b, 0x1e, 0x31, 0x89, 0xf4, 0x39, 0xb4, 0x04, 0xa6, 0x51, 0x90, 0x71, 0x9d, 0x36, 0xd8, 0xdd,
	0xba, 0x9d, 0x57, 0x93, 0x32, 0x99, 0x72, 0xd5, 0xa8, 0x67, 0xab, 0xbc, 0x29, 0xa7, 0x23, 0xe8,
	0x97, 0x83, 0x1a, 0x88, 0x24, 0x0e, 0xd1, 0xa9, 0x0d, 0xeb, 0xe3, 0xa6, 0xd7, 0x35, 0xe3, 0xea,
	0x2b, 0xe8, 0xfe, 0xad, 0x57, 0xbf, 0x77, 0xeb, 0x8d, 0x7e, 0xb3, 0xc0, 0x36, 0xdb, 0x2a, 0x53,
	0x2b, 0xea, 0x7b, 0x49, 0x42, 0xd6, 0x2a, 0x53, 0x4e, 0x53, 0xdc, 0xd7, 0x4f, 0x0e, 0xb1, 0xa8,
	0x03, 0x1b, 0x0a, 0xfa, 0xf1, 0x43, 0x98, 0x14, 0x11, 0xde, 0x46, 0x6a, 0xf4, 0x31, 0x3c, 0x72,
	0xd5, 0xab, 0x97, 0xb2, 0xa4, 0xda, 0xa1, 0x4e, 0x37, 0x61, 0xbd, 0x02, 0x6f, 0x73, 0x1b, 0xf4,
	0x4b, 0x70, 0x2a, 0xf8, 0xc1, 0x4e, 0xcd, 0xdd, 0x5f, 0xa1, 0x7f, 0x74, 0x7a, 0xa2, 0xde, 0x47,
	0x5f, 0x33, 0xa7, 0x07, 0xd0, 0xb9, 0x31, 0x2b, 0x7d, 0xf2, 0xe9, 0x4b, 0xed, 0x89, 0xf3, 0x29,
	0x77, 0x8f, 0xd6, 0xc6, 0xd6, 0x73, 0xeb, 0x87, 0xde, 0x5f, 0xd7, 0x3b, 0xd6, 0xdf, 0xd7, 0x3b,
	0xd6, 0x3f, 0xd7, 0x3b, 0xd6, 0xcc, 0xd6, 0x6f, 0xf0, 0xb7, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff,
	0x7a, 0x3c, 0x8b, 0xaa, 0xc3, 0x07, 0x00, 0x00,
}
