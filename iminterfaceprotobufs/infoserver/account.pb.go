// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/account.proto

/*
Package infoserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/account.proto
	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/channelservice.proto
	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/chatcommon.proto
	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/chatservice.proto
	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/infoserver.proto
	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/phonecall.proto
	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/publiccontact.proto
	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/userserver.proto

It has these top-level messages:

	GetUniqueNumberByKeyIdReq
	GetUniqueNumberByKeyIdResult
	SessionDisconnectReq
	SessionDisconnectResult
	SessionQueryApiIDbyKeyidReq
	SessionQueryApiIDbyKeyidResult
	SessionUpdateOnHandshakeDoneReq
	SessionUpdateOnHandshakeDoneResult
	SessionQueryByUseridReq
	SessionQueryByUseridResult
	SessionQueryUseridByKeyidReq
	SessionQueryUseridByKeyidResult
	SessionInformation
	SessionQueryByKeyidReq
	SessionQueryByKeyidResult
	SessionQueryByPhoneReq
	SessionQueryByPhoneResult
	SessionIncQtsReq
	SessionIncQtsResult
	SessionUpdateInitConnectionReq
	SessionUpdateInitConnectionResult
	SessionUpdateRegisterDeviceReq
	SessionUpdateRegisterDeviceResult
	SessionUpdateSignInReq
	SessionUpdateSignInResult
	SessionUpdatePingReq
	SessionUpdatePingResult
	SessionUpdateLogoutReq
	SessionUpdateLogoutResult
	SessionTerminateByKeyidReq
	SessionTerminateByKeyidResult
	SessionTerminateExceptKeyidReq
	SessionTerminateExceptKeyidResult
	CheckUserIdAndAccessHashReq
	CheckUserIdAndAccessHashResult
	PasswordReq
	PtPasswordReq
	PasswordRsp
	BoolResult
	IntResult
	UserInfoReq
	UserInfoRsp
	GroupIdReq
	GroupIdRsp
	IdAssiginReq
	IdAssiginRsp
	Session
	SessionArray
	SessionUpdate
	SessionsReq
	SessionsStatus
	SessionsRsp
	SessionTerminateReq
	SessionTerminateRsp
	Authorization
	CheckCodeReq
	CheckCodeRsp
	SetResult
	ChannelInfoBase
	ChannelParticipant
	ChannelParticipantArr
	InvitedUsers
	AdminRights
	BannerRights
	CreateChannelReq
	ChannelupdatesResp
	GetChannelUpdatesReq
	AddChannelUserReq
	DelChannelUserReq
	UpdateChanAboutReq
	UpdateChanTitleReq
	UpdateChanPhotoReq
	UpdateChanAdminRightsReq
	UpdateChanAdminRightsResp
	UpdateChanBanRightsReq
	DismissChannelReq
	DismissChannelResp
	ParticipantLimitReq
	ParticipantLimitResp
	GetChannelOnePartReq
	GetChannelOnePartResp
	GetChannelUsersIdReq
	GetChannelUsersIdResp
	GetChannelBaseInfoReq
	GetChannelBaseInfoResp
	GetChannelInfoReq
	GetChannelInfoResp
	BatchChannelBaseInfoReq
	BatchChannelBaseInfoResp
	GetChanByLinkReq
	GetFullChannelInfoReq
	GetFullChannelInfoResp
	ToggleInviteReq
	CreateChannelLinkReq
	CreateChannelLinkResp
	CheckChannelInviteLinkReq
	CheckChannelInviteLinkResp
	UpdateChannelUserNameReq
	UpdateChannelUserNameResp
	UpdateChannelPinnedMsgIdReq
	UpdateChannelPinnedMsgIdResp
	CheckUserNameReq
	CheckUserNameResp
	CheckChannelIsEncryReq
	CheckChannelIsEncryResp
	CreateChatReq
	CreateChatResp
	GetChatUsersIdReq
	GetChatUsersIdResp
	GetChatInfoReq
	GetChatInfoResp
	AddChatMemberReq
	AddChatMemberResp
	DelChatMemberReq
	DelChatMemberResp
	EditChatPhotoReq
	EditChatPhotoResp
	EditChatTittleReq
	EditChatTittleResp
	AddChatAdminReq
	AddChatAdminResp
	DelChatAdminReq
	DelChatAdminResp
	GetChatUsersRoleReq
	ChatUserRole
	GetChatUsersRoleResp
	GetUsersChatsReq
	GetUsersChatsResult
	GetTwoUserChatsReq
	GetTwoUserChatsResp
	UpGradeChatReq
	UpGradeChatResp
	CreateChatLinkReq
	CreateChatLinkResp
	SwitchInviteRuleReq
	SwitchInviteRuleResp
	CheckChatIsEncryReq
	CheckChatIsEncryResp
	SendCodeReq
	SendCodeResult
	SendChangePhoneCodeReq
	SignInReq
	SignInOrReqitsterResult
	SignUpReq
	AuthSignUpResult
	ChangePhoneReq
	ChangePhoneResult
	AuthCheckPasswdReq
	AuthCheckPasswdResult
	AuthImportAuthorizationReq
	AuthImportAuthorizationResult
	AuthExportAuthorizationReq
	AuthExportAuthorizationResult
	AuthRecoverPasswdReq
	AuthRecoverPasswdResult
	ContactsSearchReq
	ContactsSearcResult
	AuthRequestPasswordRecoveryReq
	AuthRequestPasswordRecoveryResult
	PhonecallSessionInformation
	PhonecallEndpointInformation
	PhonecallAllocSessionReq
	PhonecallAllocSessionResult
	PhonecallOnReceivedCallCheckReq
	PhonecallOnReceivedCallCheckResult
	PhonecallOnAcceptCallUpdateReq
	PhonecallOnAcceptCallUpdateResult
	PhonecallOnConfirmCallUpdateReq
	PhonecallOnConfirmCallUpdateResult
	PhonecallOnDiscardCallUpdateReq
	PhonecallOnDiscardCallUpdateResult
	PhonecallQueryEndpointsReq
	PhonecallQueryEndpointsResult
	AuthCancelCodeReq
	AuthCancelCodeResult
	Langpack
	LangpackList
	LangpackStrings
	LangpackStringsList
	LangPacktReq
	VirtualPhoneNumberInfo
	CmdVirtualPhoneNumberGenerateReq
	CmdVirtualPhoneNumberGenerateResult
	CmdVirtualPhoneNumberSpecialGenReq
	CmdVirtualPhoneNumberSpecialGenResult
	CmdVirtualPhoneNumberBindRealPhoneNumberReq
	CmdVirtualPhoneNumberBindRealPhoneNumberResult
	CmdVirtualPhoneNumberUnbindRealPhoneNumberReq
	CmdVirtualPhoneNumberUnbindRealPhoneNumberResult
	CmdVirtualPhoneNumberQueryInfoReq
	CmdVirtualPhoneNumberQueryInfoResult
	CmdSysPhoneNumberBindRealPhoneNumberReq
	CmdSysPhoneNumberBindRealPhoneNumberResult
	CmdBlockSignInReq
	CmdBlockSignInResult
	CmdUnblockSignInReq
	CmdUnblockSignInResult
	CmdBlockSignUpReq
	CmdBlockSignUpResult
	CmdUnblockSignUpReq
	CmdUnblockSignUpResult
	ContactRevoleUserNameReq
	ContactRevoleUserNameResult
	GetFullUserReq
	GetFullUserResult
	GetFullUserSimReq
	UserLocation
	GetFullUserSimResult
	AuthSignUpPasswordReq
	AuthSignUpPasswordResult
	AuthSignInPasswordReq
	AuthSignInPasswordResult
	AccountResetPasswordReq
	AccountResetPasswordResult
	CheckDeviceBanReq
	CheckDeviceBanResult
	HeartbeatReq
	HeartbeatResult
	QueryDebugingUserIDReq
	QueryDebugingUserIDResult
	GetUserChannelByUserNameReq
	GetUserChannelByUserNameResult
	DeleteAuthKeysReq
	DeleteAuthKeysResult
	SendSetPasswordPhoneCodeReq
	PhoneCheckUpdatesReq
	PhoneCheckUpdatesResult
	PhoneAcceptCallReq
	PhoneAcceptCallResult
	PhoneConfirmCallReq
	PhoneConfirmCallResult
	PhoneDiscardCallReq
	PhoneDiscardCallResult
	PhoneGetCallConfigReq
	PhoneGetCallConfigResult
	PhoneReceivedCallReq
	PhoneReceivedCallResult
	PhoneRequestCallReq
	PhoneRequestCallResult
	PhoneSaveCallDebugReq
	PhoneSaveCallDebugResult
	PhoneSetCallRatingReq
	PhoneSetCallRatingResult
	ReqUpdateMoments
	ResUpdateMoments
	GetUserInfoByIdReq
	UserInfoArray
	UserInfo
	GetUserExpireByIdReq
	GetUserExpireByIdResult
	GetUserByphone
	GetUserInfoResult
	GetUserByUsername
	UpdatePhotoInfoReq
	GetPhotoInfoReq
	UpdateUserPhotoResult
	GetUserPhotoResult
	UpdateUserProfileReq
	UpdateUserProfileResult
	StatusReq
	StatusResult
	UpdateExpireReq
	UpdateExpireResult
	UserClusterChange
	UserClusterChangeResult
	UpdateuserNameReq
	UpdateuserNameResult
	CheckPhoneRegisterReq
	CheckPhoneRegisterResult
	DeleteAccountByIdReq
	DelAccountResult
	BotUpdateInfo
	BotUpdateInfoResult
	DelContactReq
	DelContactResult
	ContactIdHash
	DelContactArrReq
	CmdResetUserContactsReq
	CmdResetUserContactsResult
	DelContactArrResult
	ContatsGetContactsReq
	ContactInfo
	ContatsGetContactsResult
	PhoneBookContact
	ContactsImportPhoneContactsReq
	ImportContact
	PopularContact
	ContactsImportPhoneContactsResult
	AddRelationIdInfo
	DelRelationIdInfo
	AddRelationIdInfoResult
	DelRelationIdInfoResult
	BlockeduserReq
	BlockeduserResult
	ContactUnblockedReq
	ContactsGetBlockedReq
	Blockeduser
	ContactsGetBlockedResult
	SystemWhiteUser
	StoreSysWhiteUserReq
	StoreSysWhiteUserResult
	UpdateSystemWhiteUserLevelReq
	UpdateSystemWhiteUserLevelResult
	GetSysWhiteUserReq
	GetSysWhiteUserResult
	GetSysWhiteUserArrReq
	GetSysWhiteUserArrResult
	DelSysWhiteUserReq
	DelSysWhiteUserResult
	UserDc
	GetAllDcReq
	SetPrivacyReq
	SetPrivacyResult
	GetPrivacyReq
	CheckPrivacyReq
	CheckPrivacyResult
	GetPrivacyResult
	StoreShopStickerSetReq
	StoreShopStickerSetResult
	StoreShopStickerSetDocumentsReq
	StoreShopStickerSetDocumentsResult
	DeleteStickerSetReq
	DeleteStickerSetResult
	StickerSetInfo
	GetStickerSetInfoReq
	GetStickerSetInfoResult
	StickerPackDocumentBase
	StickerPackDocumentInfo
	StoreStickerPackDcReq
	StoreStickerPackDcResult
	StoreStickerPackDcArrReq
	StoreStickerPackDcArrResult
	GetStickerSetPackDcInfosReq
	GetStickerSetPackDcInfosResult
	AddOrDeleteFaveSticerReq
	AddOrDeleteFaveSticerResult
	GetFavedStickersReq
	GetFavedStickersResult
	StickerPack
	StoreUserStickerSetReq
	StoreUserStickerSetResult
	UpdateUserStickerSetDisabledReq
	UpdateUserStickerSetDisabledResult
	UpdateUserStickerSetOrderReq
	UpdateUserStickerSetOrderResult
	UpdateUserStickerSetInstallArReq
	UpdateUserStickerSetInstallArResult
	DeleteuserStickerReq
	DeleteuserStickerResult
	UserStickerInfo
	UserStickerInfoArr
	StickerSetInfoArr
	GetuserAllStickersReq
	GetuserAllStickersResult
	GetAllStickerSetsReq
	GetAllStickerSetsResult
	DeleteStickerPackDocumentReq
	DeleteStickerPackDocumentResult
	GetAuthorStickerSetReq
	GetAuthorStickerSetResult
	GetAuthorAllStickerSetReq
	GetAuthorAllStickerSetResult
	AuthorStickerSet
	CountAuthorAllStickerSetReq
	CountAuthorAllStickerSetResult
	UserGifInfoArr
	UserSaveGifInfo
	SaveUserGifReq
	SaveUserGifResult
	DelUserGifReq
	DelUserGifResult
	GetUserGifsReq
	GetUserGifsResult
	CheckUserIsBlockedReq
	CheckUserIsBlockedResult
	RegisterUserInfo
	UpdateUserInfoResult
	CheckUserAccessHashValidReq
	CheckUserAccessHashValidResult
	RegisterUserInfoReq
	RegisterUserInfoResult
	GetNotifySettingsReq
	GetNotifySettingsResult
	UpdateNotifySettingsReq
	UpdateNotifySettingsResult
	GetContactsStatusReq
	UserStaus
	GetContactsStatusResult
	UpdateBotPicRequest
	UpdateBotPicResult
	GetAllProxyConfigReq
	ProxyAddr
	GetAllProxyConfigResult
	CheckUserNameOccupiedReq
	CheckUserNameOccupiedResult
	GetUserGpsReq
	GetUserGpsResult
	CheckSelfIsContactReq
	CheckSelfIsContactResult
	UpdateSwitchReq
	UpdateSwitchResult
	GetSwitchStatusReq
	GetSwitchStatusResult
	UpdateBotInfoSuppReq
	UpdateBotInfoSuppResult
	DeleteUserUsernameReq
	DeleteUserUsernameResult
	UpdateUserLocationReq
	UpdateUserLocationResult
	UpdateUserGrenderReq
	UpdateUserGrenderResult
	UpdateUserEmailReq
	UpdateUserEmailResult
	UploadContactsReq
	UploadContactsResult
	ApplyContactReq
	ApplyContactResult
	GetAppliedContactsReq
	GetAppliedContactsResult
	Applied
	VerifyContactReq
	VerifyContactResult
	DeleteAppliedContactReq
	DeleteAppliedContactResult
	SearchUserByPhoneReq
	SearchUserByPhoneResult
*/
package infoserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/pbcomm"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type SessionUpdateOnHandshakeDoneResult_FailCode int32

const (
	SessionUpdateOnHandshakeDoneResult_Internal       SessionUpdateOnHandshakeDoneResult_FailCode = 0
	SessionUpdateOnHandshakeDoneResult_DuplicateKeyid SessionUpdateOnHandshakeDoneResult_FailCode = 1
)

var SessionUpdateOnHandshakeDoneResult_FailCode_name = map[int32]string{
	0: "Internal",
	1: "DuplicateKeyid",
}
var SessionUpdateOnHandshakeDoneResult_FailCode_value = map[string]int32{
	"Internal":       0,
	"DuplicateKeyid": 1,
}

func (x SessionUpdateOnHandshakeDoneResult_FailCode) String() string {
	return proto.EnumName(SessionUpdateOnHandshakeDoneResult_FailCode_name, int32(x))
}
func (SessionUpdateOnHandshakeDoneResult_FailCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{7, 0}
}

type SessionQueryByKeyidResult_ResultCode int32

const (
	SessionQueryByKeyidResult_Success       SessionQueryByKeyidResult_ResultCode = 0
	SessionQueryByKeyidResult_InternalError SessionQueryByKeyidResult_ResultCode = 1
)

var SessionQueryByKeyidResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionQueryByKeyidResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionQueryByKeyidResult_ResultCode) String() string {
	return proto.EnumName(SessionQueryByKeyidResult_ResultCode_name, int32(x))
}
func (SessionQueryByKeyidResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{14, 0}
}

type SessionQueryByPhoneResult_ResultCode int32

const (
	SessionQueryByPhoneResult_Success       SessionQueryByPhoneResult_ResultCode = 0
	SessionQueryByPhoneResult_InternalError SessionQueryByPhoneResult_ResultCode = 1
)

var SessionQueryByPhoneResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionQueryByPhoneResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionQueryByPhoneResult_ResultCode) String() string {
	return proto.EnumName(SessionQueryByPhoneResult_ResultCode_name, int32(x))
}
func (SessionQueryByPhoneResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{16, 0}
}

type SessionIncQtsResult_ResultCode int32

const (
	SessionIncQtsResult_Success       SessionIncQtsResult_ResultCode = 0
	SessionIncQtsResult_InternalError SessionIncQtsResult_ResultCode = 1
)

var SessionIncQtsResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionIncQtsResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionIncQtsResult_ResultCode) String() string {
	return proto.EnumName(SessionIncQtsResult_ResultCode_name, int32(x))
}
func (SessionIncQtsResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{18, 0}
}

type SessionUpdateInitConnectionResult_ResultCode int32

const (
	SessionUpdateInitConnectionResult_Success       SessionUpdateInitConnectionResult_ResultCode = 0
	SessionUpdateInitConnectionResult_InternalError SessionUpdateInitConnectionResult_ResultCode = 1
)

var SessionUpdateInitConnectionResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateInitConnectionResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateInitConnectionResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateInitConnectionResult_ResultCode_name, int32(x))
}
func (SessionUpdateInitConnectionResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{20, 0}
}

type SessionUpdateRegisterDeviceResult_ResultCode int32

const (
	SessionUpdateRegisterDeviceResult_Success       SessionUpdateRegisterDeviceResult_ResultCode = 0
	SessionUpdateRegisterDeviceResult_InternalError SessionUpdateRegisterDeviceResult_ResultCode = 1
)

var SessionUpdateRegisterDeviceResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateRegisterDeviceResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateRegisterDeviceResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateRegisterDeviceResult_ResultCode_name, int32(x))
}
func (SessionUpdateRegisterDeviceResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{22, 0}
}

type SessionUpdateSignInResult_ResultCode int32

const (
	SessionUpdateSignInResult_Success       SessionUpdateSignInResult_ResultCode = 0
	SessionUpdateSignInResult_InternalError SessionUpdateSignInResult_ResultCode = 1
)

var SessionUpdateSignInResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateSignInResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateSignInResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateSignInResult_ResultCode_name, int32(x))
}
func (SessionUpdateSignInResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{24, 0}
}

type SessionUpdatePingResult_ResultCode int32

const (
	SessionUpdatePingResult_Success             SessionUpdatePingResult_ResultCode = 0
	SessionUpdatePingResult_InternalError       SessionUpdatePingResult_ResultCode = 1
	SessionUpdatePingResult_AuthkeyUnregistered SessionUpdatePingResult_ResultCode = 2
)

var SessionUpdatePingResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
	2: "AuthkeyUnregistered",
}
var SessionUpdatePingResult_ResultCode_value = map[string]int32{
	"Success":             0,
	"InternalError":       1,
	"AuthkeyUnregistered": 2,
}

func (x SessionUpdatePingResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdatePingResult_ResultCode_name, int32(x))
}
func (SessionUpdatePingResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{26, 0}
}

type SessionUpdateLogoutResult_ResultCode int32

const (
	SessionUpdateLogoutResult_Success       SessionUpdateLogoutResult_ResultCode = 0
	SessionUpdateLogoutResult_InternalError SessionUpdateLogoutResult_ResultCode = 1
)

var SessionUpdateLogoutResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionUpdateLogoutResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionUpdateLogoutResult_ResultCode) String() string {
	return proto.EnumName(SessionUpdateLogoutResult_ResultCode_name, int32(x))
}
func (SessionUpdateLogoutResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{28, 0}
}

type SessionTerminateByKeyidResult_ResultCode int32

const (
	SessionTerminateByKeyidResult_Success       SessionTerminateByKeyidResult_ResultCode = 0
	SessionTerminateByKeyidResult_InternalError SessionTerminateByKeyidResult_ResultCode = 1
)

var SessionTerminateByKeyidResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionTerminateByKeyidResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionTerminateByKeyidResult_ResultCode) String() string {
	return proto.EnumName(SessionTerminateByKeyidResult_ResultCode_name, int32(x))
}
func (SessionTerminateByKeyidResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{30, 0}
}

type SessionTerminateExceptKeyidResult_ResultCode int32

const (
	SessionTerminateExceptKeyidResult_Success       SessionTerminateExceptKeyidResult_ResultCode = 0
	SessionTerminateExceptKeyidResult_InternalError SessionTerminateExceptKeyidResult_ResultCode = 1
)

var SessionTerminateExceptKeyidResult_ResultCode_name = map[int32]string{
	0: "Success",
	1: "InternalError",
}
var SessionTerminateExceptKeyidResult_ResultCode_value = map[string]int32{
	"Success":       0,
	"InternalError": 1,
}

func (x SessionTerminateExceptKeyidResult_ResultCode) String() string {
	return proto.EnumName(SessionTerminateExceptKeyidResult_ResultCode_name, int32(x))
}
func (SessionTerminateExceptKeyidResult_ResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{32, 0}
}

type BoolResult_ErrorCode int32

const (
	BoolResult_Internal         BoolResult_ErrorCode = 0
	BoolResult_InvalidPassword  BoolResult_ErrorCode = 1
	BoolResult_EmailUnconfirmed BoolResult_ErrorCode = 2
	BoolResult_CheckFlood       BoolResult_ErrorCode = 3
	BoolResult_PhoneCodeExpired BoolResult_ErrorCode = 4
	BoolResult_CodeInvalid      BoolResult_ErrorCode = 5
)

var BoolResult_ErrorCode_name = map[int32]string{
	0: "Internal",
	1: "InvalidPassword",
	2: "EmailUnconfirmed",
	3: "CheckFlood",
	4: "PhoneCodeExpired",
	5: "CodeInvalid",
}
var BoolResult_ErrorCode_value = map[string]int32{
	"Internal":         0,
	"InvalidPassword":  1,
	"EmailUnconfirmed": 2,
	"CheckFlood":       3,
	"PhoneCodeExpired": 4,
	"CodeInvalid":      5,
}

func (x BoolResult_ErrorCode) String() string {
	return proto.EnumName(BoolResult_ErrorCode_name, int32(x))
}
func (BoolResult_ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{38, 0}
}

type SessionUpdate_UpdateType int32

const (
	SessionUpdate_Type0NoUse          SessionUpdate_UpdateType = 0
	SessionUpdate_Type1Logout         SessionUpdate_UpdateType = 1
	SessionUpdate_Type2InitConnection SessionUpdate_UpdateType = 2
	SessionUpdate_Type3PushToken      SessionUpdate_UpdateType = 3
	SessionUpdate_Type4CurrentStatus  SessionUpdate_UpdateType = 4
	SessionUpdate_Type5SignIn         SessionUpdate_UpdateType = 5
	SessionUpdate_Type6Ping           SessionUpdate_UpdateType = 6
)

var SessionUpdate_UpdateType_name = map[int32]string{
	0: "Type0NoUse",
	1: "Type1Logout",
	2: "Type2InitConnection",
	3: "Type3PushToken",
	4: "Type4CurrentStatus",
	5: "Type5SignIn",
	6: "Type6Ping",
}
var SessionUpdate_UpdateType_value = map[string]int32{
	"Type0NoUse":          0,
	"Type1Logout":         1,
	"Type2InitConnection": 2,
	"Type3PushToken":      3,
	"Type4CurrentStatus":  4,
	"Type5SignIn":         5,
	"Type6Ping":           6,
}

func (x SessionUpdate_UpdateType) String() string {
	return proto.EnumName(SessionUpdate_UpdateType_name, int32(x))
}
func (SessionUpdate_UpdateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{48, 0}
}

type SessionTerminateReq_Type int32

const (
	SessionTerminateReq_SELF   SessionTerminateReq_Type = 0
	SessionTerminateReq_OTHERS SessionTerminateReq_Type = 1
)

var SessionTerminateReq_Type_name = map[int32]string{
	0: "SELF",
	1: "OTHERS",
}
var SessionTerminateReq_Type_value = map[string]int32{
	"SELF":   0,
	"OTHERS": 1,
}

func (x SessionTerminateReq_Type) String() string {
	return proto.EnumName(SessionTerminateReq_Type_name, int32(x))
}
func (SessionTerminateReq_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{52, 0}
}

type GetUniqueNumberByKeyIdReq struct {
	KeyId int64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *GetUniqueNumberByKeyIdReq) Reset()         { *m = GetUniqueNumberByKeyIdReq{} }
func (m *GetUniqueNumberByKeyIdReq) String() string { return proto.CompactTextString(m) }
func (*GetUniqueNumberByKeyIdReq) ProtoMessage()    {}
func (*GetUniqueNumberByKeyIdReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{0}
}

func (m *GetUniqueNumberByKeyIdReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type GetUniqueNumberByKeyIdResult struct {
	UniqueNumber string `protobuf:"bytes,1,opt,name=unique_number,json=uniqueNumber,proto3" json:"unique_number,omitempty"`
}

func (m *GetUniqueNumberByKeyIdResult) Reset()         { *m = GetUniqueNumberByKeyIdResult{} }
func (m *GetUniqueNumberByKeyIdResult) String() string { return proto.CompactTextString(m) }
func (*GetUniqueNumberByKeyIdResult) ProtoMessage()    {}
func (*GetUniqueNumberByKeyIdResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{1}
}

func (m *GetUniqueNumberByKeyIdResult) GetUniqueNumber() string {
	if m != nil {
		return m.UniqueNumber
	}
	return ""
}

type SessionDisconnectReq struct {
	KeyId       uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	PhoneNumber string `protobuf:"bytes,2,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Disconnect  bool   `protobuf:"varint,3,opt,name=disconnect,proto3" json:"disconnect,omitempty"`
	ClientIp    string `protobuf:"bytes,4,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	Country     string `protobuf:"bytes,5,opt,name=country,proto3" json:"country,omitempty"`
}

func (m *SessionDisconnectReq) Reset()                    { *m = SessionDisconnectReq{} }
func (m *SessionDisconnectReq) String() string            { return proto.CompactTextString(m) }
func (*SessionDisconnectReq) ProtoMessage()               {}
func (*SessionDisconnectReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{2} }

func (m *SessionDisconnectReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionDisconnectReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionDisconnectReq) GetDisconnect() bool {
	if m != nil {
		return m.Disconnect
	}
	return false
}

func (m *SessionDisconnectReq) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *SessionDisconnectReq) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

type SessionDisconnectResult struct {
}

func (m *SessionDisconnectResult) Reset()                    { *m = SessionDisconnectResult{} }
func (m *SessionDisconnectResult) String() string            { return proto.CompactTextString(m) }
func (*SessionDisconnectResult) ProtoMessage()               {}
func (*SessionDisconnectResult) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{3} }

type SessionQueryApiIDbyKeyidReq struct {
	KeyId uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *SessionQueryApiIDbyKeyidReq) Reset()         { *m = SessionQueryApiIDbyKeyidReq{} }
func (m *SessionQueryApiIDbyKeyidReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryApiIDbyKeyidReq) ProtoMessage()    {}
func (*SessionQueryApiIDbyKeyidReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{4}
}

func (m *SessionQueryApiIDbyKeyidReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type SessionQueryApiIDbyKeyidResult struct {
	ApiId         int32 `protobuf:"varint,1,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	InternalError bool  `protobuf:"varint,2,opt,name=internal_error,json=internalError,proto3" json:"internal_error,omitempty"`
}

func (m *SessionQueryApiIDbyKeyidResult) Reset()         { *m = SessionQueryApiIDbyKeyidResult{} }
func (m *SessionQueryApiIDbyKeyidResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryApiIDbyKeyidResult) ProtoMessage()    {}
func (*SessionQueryApiIDbyKeyidResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{5}
}

func (m *SessionQueryApiIDbyKeyidResult) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *SessionQueryApiIDbyKeyidResult) GetInternalError() bool {
	if m != nil {
		return m.InternalError
	}
	return false
}

type SessionUpdateOnHandshakeDoneReq struct {
	KeyId   uint64 `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	AuthKey []byte `protobuf:"bytes,2,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
}

func (m *SessionUpdateOnHandshakeDoneReq) Reset()         { *m = SessionUpdateOnHandshakeDoneReq{} }
func (m *SessionUpdateOnHandshakeDoneReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateOnHandshakeDoneReq) ProtoMessage()    {}
func (*SessionUpdateOnHandshakeDoneReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{6}
}

func (m *SessionUpdateOnHandshakeDoneReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateOnHandshakeDoneReq) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

type SessionUpdateOnHandshakeDoneResult struct {
	Success bool                                        `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Code    SessionUpdateOnHandshakeDoneResult_FailCode `protobuf:"varint,2,opt,name=code,proto3,enum=infoserver.SessionUpdateOnHandshakeDoneResult_FailCode" json:"code,omitempty"`
}

func (m *SessionUpdateOnHandshakeDoneResult) Reset()         { *m = SessionUpdateOnHandshakeDoneResult{} }
func (m *SessionUpdateOnHandshakeDoneResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateOnHandshakeDoneResult) ProtoMessage()    {}
func (*SessionUpdateOnHandshakeDoneResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{7}
}

func (m *SessionUpdateOnHandshakeDoneResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *SessionUpdateOnHandshakeDoneResult) GetCode() SessionUpdateOnHandshakeDoneResult_FailCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateOnHandshakeDoneResult_Internal
}

type SessionQueryByUseridReq struct {
}

func (m *SessionQueryByUseridReq) Reset()                    { *m = SessionQueryByUseridReq{} }
func (m *SessionQueryByUseridReq) String() string            { return proto.CompactTextString(m) }
func (*SessionQueryByUseridReq) ProtoMessage()               {}
func (*SessionQueryByUseridReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{8} }

type SessionQueryByUseridResult struct {
}

func (m *SessionQueryByUseridResult) Reset()         { *m = SessionQueryByUseridResult{} }
func (m *SessionQueryByUseridResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryByUseridResult) ProtoMessage()    {}
func (*SessionQueryByUseridResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{9}
}

type SessionQueryUseridByKeyidReq struct {
	KeyId uint64        `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *SessionQueryUseridByKeyidReq) Reset()         { *m = SessionQueryUseridByKeyidReq{} }
func (m *SessionQueryUseridByKeyidReq) String() string { return proto.CompactTextString(m) }
func (*SessionQueryUseridByKeyidReq) ProtoMessage()    {}
func (*SessionQueryUseridByKeyidReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{10}
}

func (m *SessionQueryUseridByKeyidReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionQueryUseridByKeyidReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionQueryUseridByKeyidResult struct {
	InternalError bool  `protobuf:"varint,1,opt,name=internal_error,json=internalError,proto3" json:"internal_error,omitempty"`
	UserId        int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionQueryUseridByKeyidResult) Reset()         { *m = SessionQueryUseridByKeyidResult{} }
func (m *SessionQueryUseridByKeyidResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryUseridByKeyidResult) ProtoMessage()    {}
func (*SessionQueryUseridByKeyidResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{11}
}

func (m *SessionQueryUseridByKeyidResult) GetInternalError() bool {
	if m != nil {
		return m.InternalError
	}
	return false
}

func (m *SessionQueryUseridByKeyidResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionInformation struct {
	ApiId         int32  `protobuf:"varint,1,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel   string `protobuf:"bytes,2,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion string `protobuf:"bytes,3,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion    string `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	LangCode      string `protobuf:"bytes,5,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Ip            string `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	Country       string `protobuf:"bytes,7,opt,name=country,proto3" json:"country,omitempty"`
	Layer         int32  `protobuf:"varint,8,opt,name=layer,proto3" json:"layer,omitempty"`
	AuthKey       []byte `protobuf:"bytes,9,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	Qts           int32  `protobuf:"varint,10,opt,name=qts,proto3" json:"qts,omitempty"`
	PushTokenType int32  `protobuf:"varint,11,opt,name=push_token_type,json=pushTokenType,proto3" json:"push_token_type,omitempty"`
	PushToken     string `protobuf:"bytes,12,opt,name=push_token,json=pushToken,proto3" json:"push_token,omitempty"`
	CallTokenType int32  `protobuf:"varint,13,opt,name=call_token_type,json=callTokenType,proto3" json:"call_token_type,omitempty"`
	CallToken     string `protobuf:"bytes,14,opt,name=call_token,json=callToken,proto3" json:"call_token,omitempty"`
	PingTime      int64  `protobuf:"varint,15,opt,name=ping_time,json=pingTime,proto3" json:"ping_time,omitempty"`
	PhoneNumber   string `protobuf:"bytes,16,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	UserId        int32  `protobuf:"varint,17,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AccessHash    int64  `protobuf:"varint,18,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Seq           int32  `protobuf:"varint,19,opt,name=seq,proto3" json:"seq,omitempty"`
	KeyId         uint64 `protobuf:"varint,20,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	AppName       string `protobuf:"bytes,21,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	Disconnect    bool   `protobuf:"varint,22,opt,name=disconnect,proto3" json:"disconnect,omitempty"`
}

func (m *SessionInformation) Reset()                    { *m = SessionInformation{} }
func (m *SessionInformation) String() string            { return proto.CompactTextString(m) }
func (*SessionInformation) ProtoMessage()               {}
func (*SessionInformation) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{12} }

func (m *SessionInformation) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *SessionInformation) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *SessionInformation) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *SessionInformation) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *SessionInformation) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *SessionInformation) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *SessionInformation) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *SessionInformation) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *SessionInformation) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *SessionInformation) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

func (m *SessionInformation) GetPushTokenType() int32 {
	if m != nil {
		return m.PushTokenType
	}
	return 0
}

func (m *SessionInformation) GetPushToken() string {
	if m != nil {
		return m.PushToken
	}
	return ""
}

func (m *SessionInformation) GetCallTokenType() int32 {
	if m != nil {
		return m.CallTokenType
	}
	return 0
}

func (m *SessionInformation) GetCallToken() string {
	if m != nil {
		return m.CallToken
	}
	return ""
}

func (m *SessionInformation) GetPingTime() int64 {
	if m != nil {
		return m.PingTime
	}
	return 0
}

func (m *SessionInformation) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionInformation) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionInformation) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *SessionInformation) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SessionInformation) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionInformation) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *SessionInformation) GetDisconnect() bool {
	if m != nil {
		return m.Disconnect
	}
	return false
}

type SessionQueryByKeyidReq struct {
	KeyId uint64        `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *SessionQueryByKeyidReq) Reset()                    { *m = SessionQueryByKeyidReq{} }
func (m *SessionQueryByKeyidReq) String() string            { return proto.CompactTextString(m) }
func (*SessionQueryByKeyidReq) ProtoMessage()               {}
func (*SessionQueryByKeyidReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{13} }

func (m *SessionQueryByKeyidReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionQueryByKeyidReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionQueryByKeyidResult struct {
	Code SessionQueryByKeyidResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionQueryByKeyidResult_ResultCode" json:"code,omitempty"`
	Info *SessionInformation                  `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
}

func (m *SessionQueryByKeyidResult) Reset()         { *m = SessionQueryByKeyidResult{} }
func (m *SessionQueryByKeyidResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryByKeyidResult) ProtoMessage()    {}
func (*SessionQueryByKeyidResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{14}
}

func (m *SessionQueryByKeyidResult) GetCode() SessionQueryByKeyidResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionQueryByKeyidResult_Success
}

func (m *SessionQueryByKeyidResult) GetInfo() *SessionInformation {
	if m != nil {
		return m.Info
	}
	return nil
}

type SessionQueryByPhoneReq struct {
	PhoneNumber string        `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *SessionQueryByPhoneReq) Reset()                    { *m = SessionQueryByPhoneReq{} }
func (m *SessionQueryByPhoneReq) String() string            { return proto.CompactTextString(m) }
func (*SessionQueryByPhoneReq) ProtoMessage()               {}
func (*SessionQueryByPhoneReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{15} }

func (m *SessionQueryByPhoneReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionQueryByPhoneReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionQueryByPhoneResult struct {
	Code  SessionQueryByPhoneResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionQueryByPhoneResult_ResultCode" json:"code,omitempty"`
	Infos []*SessionInformation                `protobuf:"bytes,2,rep,name=infos" json:"infos,omitempty"`
}

func (m *SessionQueryByPhoneResult) Reset()         { *m = SessionQueryByPhoneResult{} }
func (m *SessionQueryByPhoneResult) String() string { return proto.CompactTextString(m) }
func (*SessionQueryByPhoneResult) ProtoMessage()    {}
func (*SessionQueryByPhoneResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{16}
}

func (m *SessionQueryByPhoneResult) GetCode() SessionQueryByPhoneResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionQueryByPhoneResult_Success
}

func (m *SessionQueryByPhoneResult) GetInfos() []*SessionInformation {
	if m != nil {
		return m.Infos
	}
	return nil
}

type SessionIncQtsReq struct {
	KeyId uint64        `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *SessionIncQtsReq) Reset()                    { *m = SessionIncQtsReq{} }
func (m *SessionIncQtsReq) String() string            { return proto.CompactTextString(m) }
func (*SessionIncQtsReq) ProtoMessage()               {}
func (*SessionIncQtsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{17} }

func (m *SessionIncQtsReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionIncQtsReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionIncQtsResult struct {
	Code SessionIncQtsResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionIncQtsResult_ResultCode" json:"code,omitempty"`
	Qts  int32                          `protobuf:"varint,2,opt,name=qts,proto3" json:"qts,omitempty"`
}

func (m *SessionIncQtsResult) Reset()                    { *m = SessionIncQtsResult{} }
func (m *SessionIncQtsResult) String() string            { return proto.CompactTextString(m) }
func (*SessionIncQtsResult) ProtoMessage()               {}
func (*SessionIncQtsResult) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{18} }

func (m *SessionIncQtsResult) GetCode() SessionIncQtsResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionIncQtsResult_Success
}

func (m *SessionIncQtsResult) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

type SessionUpdateInitConnectionReq struct {
	ApiId         int32         `protobuf:"varint,1,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel   string        `protobuf:"bytes,2,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion string        `protobuf:"bytes,3,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion    string        `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	LangCode      string        `protobuf:"bytes,5,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Ip            string        `protobuf:"bytes,6,opt,name=ip,proto3" json:"ip,omitempty"`
	Country       string        `protobuf:"bytes,7,opt,name=country,proto3" json:"country,omitempty"`
	Layer         int32         `protobuf:"varint,8,opt,name=layer,proto3" json:"layer,omitempty"`
	KeyId         uint64        `protobuf:"varint,9,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,10,opt,name=debug" json:"debug,omitempty"`
	AppName       string        `protobuf:"bytes,11,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
}

func (m *SessionUpdateInitConnectionReq) Reset()         { *m = SessionUpdateInitConnectionReq{} }
func (m *SessionUpdateInitConnectionReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateInitConnectionReq) ProtoMessage()    {}
func (*SessionUpdateInitConnectionReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{19}
}

func (m *SessionUpdateInitConnectionReq) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *SessionUpdateInitConnectionReq) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *SessionUpdateInitConnectionReq) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *SessionUpdateInitConnectionReq) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *SessionUpdateInitConnectionReq) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *SessionUpdateInitConnectionReq) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *SessionUpdateInitConnectionReq) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *SessionUpdateInitConnectionReq) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *SessionUpdateInitConnectionReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateInitConnectionReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SessionUpdateInitConnectionReq) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

type SessionUpdateInitConnectionResult struct {
	Code SessionUpdateInitConnectionResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionUpdateInitConnectionResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateInitConnectionResult) Reset()         { *m = SessionUpdateInitConnectionResult{} }
func (m *SessionUpdateInitConnectionResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateInitConnectionResult) ProtoMessage()    {}
func (*SessionUpdateInitConnectionResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{20}
}

func (m *SessionUpdateInitConnectionResult) GetCode() SessionUpdateInitConnectionResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateInitConnectionResult_Success
}

type SessionUpdateRegisterDeviceReq struct {
	PushTokenType int32         `protobuf:"varint,1,opt,name=push_token_type,json=pushTokenType,proto3" json:"push_token_type,omitempty"`
	PushToken     string        `protobuf:"bytes,2,opt,name=push_token,json=pushToken,proto3" json:"push_token,omitempty"`
	KeyId         uint64        `protobuf:"varint,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
	CallTokenType int32         `protobuf:"varint,5,opt,name=call_token_type,json=callTokenType,proto3" json:"call_token_type,omitempty"`
	CallToken     string        `protobuf:"bytes,6,opt,name=call_token,json=callToken,proto3" json:"call_token,omitempty"`
}

func (m *SessionUpdateRegisterDeviceReq) Reset()         { *m = SessionUpdateRegisterDeviceReq{} }
func (m *SessionUpdateRegisterDeviceReq) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateRegisterDeviceReq) ProtoMessage()    {}
func (*SessionUpdateRegisterDeviceReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{21}
}

func (m *SessionUpdateRegisterDeviceReq) GetPushTokenType() int32 {
	if m != nil {
		return m.PushTokenType
	}
	return 0
}

func (m *SessionUpdateRegisterDeviceReq) GetPushToken() string {
	if m != nil {
		return m.PushToken
	}
	return ""
}

func (m *SessionUpdateRegisterDeviceReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateRegisterDeviceReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SessionUpdateRegisterDeviceReq) GetCallTokenType() int32 {
	if m != nil {
		return m.CallTokenType
	}
	return 0
}

func (m *SessionUpdateRegisterDeviceReq) GetCallToken() string {
	if m != nil {
		return m.CallToken
	}
	return ""
}

type SessionUpdateRegisterDeviceResult struct {
	Code SessionUpdateRegisterDeviceResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionUpdateRegisterDeviceResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateRegisterDeviceResult) Reset()         { *m = SessionUpdateRegisterDeviceResult{} }
func (m *SessionUpdateRegisterDeviceResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateRegisterDeviceResult) ProtoMessage()    {}
func (*SessionUpdateRegisterDeviceResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{22}
}

func (m *SessionUpdateRegisterDeviceResult) GetCode() SessionUpdateRegisterDeviceResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateRegisterDeviceResult_Success
}

type SessionUpdateSignInReq struct {
	PhoneNumber string        `protobuf:"bytes,1,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	KeyId       uint64        `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
	UserId      int32         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AccessHash  int64         `protobuf:"varint,5,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *SessionUpdateSignInReq) Reset()                    { *m = SessionUpdateSignInReq{} }
func (m *SessionUpdateSignInReq) String() string            { return proto.CompactTextString(m) }
func (*SessionUpdateSignInReq) ProtoMessage()               {}
func (*SessionUpdateSignInReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{23} }

func (m *SessionUpdateSignInReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionUpdateSignInReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateSignInReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SessionUpdateSignInReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdateSignInReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

type SessionUpdateSignInResult struct {
	Code SessionUpdateSignInResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionUpdateSignInResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateSignInResult) Reset()         { *m = SessionUpdateSignInResult{} }
func (m *SessionUpdateSignInResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateSignInResult) ProtoMessage()    {}
func (*SessionUpdateSignInResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{24}
}

func (m *SessionUpdateSignInResult) GetCode() SessionUpdateSignInResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateSignInResult_Success
}

type SessionUpdatePingReq struct {
	KeyId       uint64        `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	PingTime    int64         `protobuf:"varint,2,opt,name=ping_time,json=pingTime,proto3" json:"ping_time,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
	PhoneNumber string        `protobuf:"bytes,4,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	UpdateTime  bool          `protobuf:"varint,5,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
}

func (m *SessionUpdatePingReq) Reset()                    { *m = SessionUpdatePingReq{} }
func (m *SessionUpdatePingReq) String() string            { return proto.CompactTextString(m) }
func (*SessionUpdatePingReq) ProtoMessage()               {}
func (*SessionUpdatePingReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{25} }

func (m *SessionUpdatePingReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdatePingReq) GetPingTime() int64 {
	if m != nil {
		return m.PingTime
	}
	return 0
}

func (m *SessionUpdatePingReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SessionUpdatePingReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionUpdatePingReq) GetUpdateTime() bool {
	if m != nil {
		return m.UpdateTime
	}
	return false
}

type SessionUpdatePingResult struct {
	Code   SessionUpdatePingResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionUpdatePingResult_ResultCode" json:"code,omitempty"`
	UserId int32                              `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Phone  string                             `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
}

func (m *SessionUpdatePingResult) Reset()                    { *m = SessionUpdatePingResult{} }
func (m *SessionUpdatePingResult) String() string            { return proto.CompactTextString(m) }
func (*SessionUpdatePingResult) ProtoMessage()               {}
func (*SessionUpdatePingResult) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{26} }

func (m *SessionUpdatePingResult) GetCode() SessionUpdatePingResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdatePingResult_Success
}

func (m *SessionUpdatePingResult) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionUpdatePingResult) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

type SessionUpdateLogoutReq struct {
	KeyId       uint64        `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
	PhoneNumber string        `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
}

func (m *SessionUpdateLogoutReq) Reset()                    { *m = SessionUpdateLogoutReq{} }
func (m *SessionUpdateLogoutReq) String() string            { return proto.CompactTextString(m) }
func (*SessionUpdateLogoutReq) ProtoMessage()               {}
func (*SessionUpdateLogoutReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{27} }

func (m *SessionUpdateLogoutReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionUpdateLogoutReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SessionUpdateLogoutReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

type SessionUpdateLogoutResult struct {
	Code SessionUpdateLogoutResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionUpdateLogoutResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionUpdateLogoutResult) Reset()         { *m = SessionUpdateLogoutResult{} }
func (m *SessionUpdateLogoutResult) String() string { return proto.CompactTextString(m) }
func (*SessionUpdateLogoutResult) ProtoMessage()    {}
func (*SessionUpdateLogoutResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{28}
}

func (m *SessionUpdateLogoutResult) GetCode() SessionUpdateLogoutResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionUpdateLogoutResult_Success
}

type SessionTerminateByKeyidReq struct {
	KeyId        uint64        `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug        *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
	PhoneNumber  string        `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	UserId       int32         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CurrentKeyId uint64        `protobuf:"varint,5,opt,name=current_key_id,json=currentKeyId,proto3" json:"current_key_id,omitempty"`
}

func (m *SessionTerminateByKeyidReq) Reset()         { *m = SessionTerminateByKeyidReq{} }
func (m *SessionTerminateByKeyidReq) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateByKeyidReq) ProtoMessage()    {}
func (*SessionTerminateByKeyidReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{29}
}

func (m *SessionTerminateByKeyidReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionTerminateByKeyidReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SessionTerminateByKeyidReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionTerminateByKeyidReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionTerminateByKeyidReq) GetCurrentKeyId() uint64 {
	if m != nil {
		return m.CurrentKeyId
	}
	return 0
}

type SessionTerminateByKeyidResult struct {
	Code SessionTerminateByKeyidResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionTerminateByKeyidResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionTerminateByKeyidResult) Reset()         { *m = SessionTerminateByKeyidResult{} }
func (m *SessionTerminateByKeyidResult) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateByKeyidResult) ProtoMessage()    {}
func (*SessionTerminateByKeyidResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{30}
}

func (m *SessionTerminateByKeyidResult) GetCode() SessionTerminateByKeyidResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionTerminateByKeyidResult_Success
}

type SessionTerminateExceptKeyidReq struct {
	KeyId       uint64        `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
	PhoneNumber string        `protobuf:"bytes,3,opt,name=phone_number,json=phoneNumber,proto3" json:"phone_number,omitempty"`
	UserId      int32         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *SessionTerminateExceptKeyidReq) Reset()         { *m = SessionTerminateExceptKeyidReq{} }
func (m *SessionTerminateExceptKeyidReq) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateExceptKeyidReq) ProtoMessage()    {}
func (*SessionTerminateExceptKeyidReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{31}
}

func (m *SessionTerminateExceptKeyidReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionTerminateExceptKeyidReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SessionTerminateExceptKeyidReq) GetPhoneNumber() string {
	if m != nil {
		return m.PhoneNumber
	}
	return ""
}

func (m *SessionTerminateExceptKeyidReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type SessionTerminateExceptKeyidResult struct {
	Code SessionTerminateExceptKeyidResult_ResultCode `protobuf:"varint,1,opt,name=code,proto3,enum=infoserver.SessionTerminateExceptKeyidResult_ResultCode" json:"code,omitempty"`
}

func (m *SessionTerminateExceptKeyidResult) Reset()         { *m = SessionTerminateExceptKeyidResult{} }
func (m *SessionTerminateExceptKeyidResult) String() string { return proto.CompactTextString(m) }
func (*SessionTerminateExceptKeyidResult) ProtoMessage()    {}
func (*SessionTerminateExceptKeyidResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{32}
}

func (m *SessionTerminateExceptKeyidResult) GetCode() SessionTerminateExceptKeyidResult_ResultCode {
	if m != nil {
		return m.Code
	}
	return SessionTerminateExceptKeyidResult_Success
}

type CheckUserIdAndAccessHashReq struct {
	UserId     int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AccessHash int64         `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *CheckUserIdAndAccessHashReq) Reset()         { *m = CheckUserIdAndAccessHashReq{} }
func (m *CheckUserIdAndAccessHashReq) String() string { return proto.CompactTextString(m) }
func (*CheckUserIdAndAccessHashReq) ProtoMessage()    {}
func (*CheckUserIdAndAccessHashReq) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{33}
}

func (m *CheckUserIdAndAccessHashReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CheckUserIdAndAccessHashReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *CheckUserIdAndAccessHashReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type CheckUserIdAndAccessHashResult struct {
	Match         bool `protobuf:"varint,1,opt,name=match,proto3" json:"match,omitempty"`
	InternalError bool `protobuf:"varint,2,opt,name=internal_error,json=internalError,proto3" json:"internal_error,omitempty"`
}

func (m *CheckUserIdAndAccessHashResult) Reset()         { *m = CheckUserIdAndAccessHashResult{} }
func (m *CheckUserIdAndAccessHashResult) String() string { return proto.CompactTextString(m) }
func (*CheckUserIdAndAccessHashResult) ProtoMessage()    {}
func (*CheckUserIdAndAccessHashResult) Descriptor() ([]byte, []int) {
	return fileDescriptorAccount, []int{34}
}

func (m *CheckUserIdAndAccessHashResult) GetMatch() bool {
	if m != nil {
		return m.Match
	}
	return false
}

func (m *CheckUserIdAndAccessHashResult) GetInternalError() bool {
	if m != nil {
		return m.InternalError
	}
	return false
}

type PasswordReq struct {
	UserId      int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId       int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Flags       int32         `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`
	CurrPwdHash []byte        `protobuf:"bytes,4,opt,name=curr_pwd_hash,json=currPwdHash,proto3" json:"curr_pwd_hash,omitempty"`
	NewPwdHash  []byte        `protobuf:"bytes,5,opt,name=new_pwd_hash,json=newPwdHash,proto3" json:"new_pwd_hash,omitempty"`
	Salt        []byte        `protobuf:"bytes,6,opt,name=salt,proto3" json:"salt,omitempty"`
	Hint        string        `protobuf:"bytes,7,opt,name=hint,proto3" json:"hint,omitempty"`
	Email       string        `protobuf:"bytes,8,opt,name=email,proto3" json:"email,omitempty"`
	ReqType     int32         `protobuf:"varint,9,opt,name=req_type,json=reqType,proto3" json:"req_type,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,10,opt,name=debug" json:"debug,omitempty"`
}

func (m *PasswordReq) Reset()                    { *m = PasswordReq{} }
func (m *PasswordReq) String() string            { return proto.CompactTextString(m) }
func (*PasswordReq) ProtoMessage()               {}
func (*PasswordReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{35} }

func (m *PasswordReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PasswordReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *PasswordReq) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PasswordReq) GetCurrPwdHash() []byte {
	if m != nil {
		return m.CurrPwdHash
	}
	return nil
}

func (m *PasswordReq) GetNewPwdHash() []byte {
	if m != nil {
		return m.NewPwdHash
	}
	return nil
}

func (m *PasswordReq) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *PasswordReq) GetHint() string {
	if m != nil {
		return m.Hint
	}
	return ""
}

func (m *PasswordReq) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *PasswordReq) GetReqType() int32 {
	if m != nil {
		return m.ReqType
	}
	return 0
}

func (m *PasswordReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type PtPasswordReq struct {
	UserId        int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId         int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	Flags         int32         `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`
	CurrPwdHash   []byte        `protobuf:"bytes,4,opt,name=curr_pwd_hash,json=currPwdHash,proto3" json:"curr_pwd_hash,omitempty"`
	NewPwdHash    []byte        `protobuf:"bytes,5,opt,name=new_pwd_hash,json=newPwdHash,proto3" json:"new_pwd_hash,omitempty"`
	Salt          []byte        `protobuf:"bytes,6,opt,name=salt,proto3" json:"salt,omitempty"`
	Hint          string        `protobuf:"bytes,7,opt,name=hint,proto3" json:"hint,omitempty"`
	Email         string        `protobuf:"bytes,8,opt,name=email,proto3" json:"email,omitempty"`
	ReqType       int32         `protobuf:"varint,9,opt,name=req_type,json=reqType,proto3" json:"req_type,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,10,opt,name=debug" json:"debug,omitempty"`
	CodeCheckOnly bool          `protobuf:"varint,11,opt,name=code_check_only,json=codeCheckOnly,proto3" json:"code_check_only,omitempty"`
	PhoneCode     string        `protobuf:"bytes,12,opt,name=phone_code,json=phoneCode,proto3" json:"phone_code,omitempty"`
	PhoneCodeHash string        `protobuf:"bytes,13,opt,name=phone_code_hash,json=phoneCodeHash,proto3" json:"phone_code_hash,omitempty"`
}

func (m *PtPasswordReq) Reset()                    { *m = PtPasswordReq{} }
func (m *PtPasswordReq) String() string            { return proto.CompactTextString(m) }
func (*PtPasswordReq) ProtoMessage()               {}
func (*PtPasswordReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{36} }

func (m *PtPasswordReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PtPasswordReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *PtPasswordReq) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *PtPasswordReq) GetCurrPwdHash() []byte {
	if m != nil {
		return m.CurrPwdHash
	}
	return nil
}

func (m *PtPasswordReq) GetNewPwdHash() []byte {
	if m != nil {
		return m.NewPwdHash
	}
	return nil
}

func (m *PtPasswordReq) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *PtPasswordReq) GetHint() string {
	if m != nil {
		return m.Hint
	}
	return ""
}

func (m *PtPasswordReq) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *PtPasswordReq) GetReqType() int32 {
	if m != nil {
		return m.ReqType
	}
	return 0
}

func (m *PtPasswordReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *PtPasswordReq) GetCodeCheckOnly() bool {
	if m != nil {
		return m.CodeCheckOnly
	}
	return false
}

func (m *PtPasswordReq) GetPhoneCode() string {
	if m != nil {
		return m.PhoneCode
	}
	return ""
}

func (m *PtPasswordReq) GetPhoneCodeHash() string {
	if m != nil {
		return m.PhoneCodeHash
	}
	return ""
}

type PasswordRsp struct {
	PwdHash          []byte `protobuf:"bytes,1,opt,name=pwd_hash,json=pwdHash,proto3" json:"pwd_hash,omitempty"`
	Email            string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Hint             string `protobuf:"bytes,3,opt,name=hint,proto3" json:"hint,omitempty"`
	Salt             []byte `protobuf:"bytes,4,opt,name=salt,proto3" json:"salt,omitempty"`
	InternalError    bool   `protobuf:"varint,5,opt,name=internal_error,json=internalError,proto3" json:"internal_error,omitempty"`
	EmailUnconfirmed bool   `protobuf:"varint,6,opt,name=email_unconfirmed,json=emailUnconfirmed,proto3" json:"email_unconfirmed,omitempty"`
}

func (m *PasswordRsp) Reset()                    { *m = PasswordRsp{} }
func (m *PasswordRsp) String() string            { return proto.CompactTextString(m) }
func (*PasswordRsp) ProtoMessage()               {}
func (*PasswordRsp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{37} }

func (m *PasswordRsp) GetPwdHash() []byte {
	if m != nil {
		return m.PwdHash
	}
	return nil
}

func (m *PasswordRsp) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *PasswordRsp) GetHint() string {
	if m != nil {
		return m.Hint
	}
	return ""
}

func (m *PasswordRsp) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *PasswordRsp) GetInternalError() bool {
	if m != nil {
		return m.InternalError
	}
	return false
}

func (m *PasswordRsp) GetEmailUnconfirmed() bool {
	if m != nil {
		return m.EmailUnconfirmed
	}
	return false
}

type BoolResult struct {
	Ret           bool                 `protobuf:"varint,1,opt,name=ret,proto3" json:"ret,omitempty"`
	InternalError bool                 `protobuf:"varint,2,opt,name=internal_error,json=internalError,proto3" json:"internal_error,omitempty"`
	ECode         BoolResult_ErrorCode `protobuf:"varint,6,opt,name=e_code,json=eCode,proto3,enum=infoserver.BoolResult_ErrorCode" json:"e_code,omitempty"`
}

func (m *BoolResult) Reset()                    { *m = BoolResult{} }
func (m *BoolResult) String() string            { return proto.CompactTextString(m) }
func (*BoolResult) ProtoMessage()               {}
func (*BoolResult) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{38} }

func (m *BoolResult) GetRet() bool {
	if m != nil {
		return m.Ret
	}
	return false
}

func (m *BoolResult) GetInternalError() bool {
	if m != nil {
		return m.InternalError
	}
	return false
}

func (m *BoolResult) GetECode() BoolResult_ErrorCode {
	if m != nil {
		return m.ECode
	}
	return BoolResult_Internal
}

type IntResult struct {
	Ret int32 `protobuf:"varint,1,opt,name=ret,proto3" json:"ret,omitempty"`
}

func (m *IntResult) Reset()                    { *m = IntResult{} }
func (m *IntResult) String() string            { return proto.CompactTextString(m) }
func (*IntResult) ProtoMessage()               {}
func (*IntResult) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{39} }

func (m *IntResult) GetRet() int32 {
	if m != nil {
		return m.Ret
	}
	return 0
}

type UserInfoReq struct {
	FirstName string        `protobuf:"bytes,1,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty"`
	LastName  string        `protobuf:"bytes,2,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty"`
	Phone     string        `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	UserId    int32         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,5,opt,name=debug" json:"debug,omitempty"`
}

func (m *UserInfoReq) Reset()                    { *m = UserInfoReq{} }
func (m *UserInfoReq) String() string            { return proto.CompactTextString(m) }
func (*UserInfoReq) ProtoMessage()               {}
func (*UserInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{40} }

func (m *UserInfoReq) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *UserInfoReq) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *UserInfoReq) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *UserInfoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserInfoReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type UserInfoRsp struct {
	UserId     int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AccessHash int64         `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *UserInfoRsp) Reset()                    { *m = UserInfoRsp{} }
func (m *UserInfoRsp) String() string            { return proto.CompactTextString(m) }
func (*UserInfoRsp) ProtoMessage()               {}
func (*UserInfoRsp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{41} }

func (m *UserInfoRsp) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserInfoRsp) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *UserInfoRsp) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type GroupIdReq struct {
	UserId int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Type   int32         `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *GroupIdReq) Reset()                    { *m = GroupIdReq{} }
func (m *GroupIdReq) String() string            { return proto.CompactTextString(m) }
func (*GroupIdReq) ProtoMessage()               {}
func (*GroupIdReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{42} }

func (m *GroupIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GroupIdReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *GroupIdReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type GroupIdRsp struct {
	GroupId    int32         `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	AccessHash int64         `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	UserId     int32         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *GroupIdRsp) Reset()                    { *m = GroupIdRsp{} }
func (m *GroupIdRsp) String() string            { return proto.CompactTextString(m) }
func (*GroupIdRsp) ProtoMessage()               {}
func (*GroupIdRsp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{43} }

func (m *GroupIdRsp) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *GroupIdRsp) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GroupIdRsp) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GroupIdRsp) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type IdAssiginReq struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Type   int32 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *IdAssiginReq) Reset()                    { *m = IdAssiginReq{} }
func (m *IdAssiginReq) String() string            { return proto.CompactTextString(m) }
func (*IdAssiginReq) ProtoMessage()               {}
func (*IdAssiginReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{44} }

func (m *IdAssiginReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *IdAssiginReq) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type IdAssiginRsp struct {
	Id         int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash int64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	UserId     int32 `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *IdAssiginRsp) Reset()                    { *m = IdAssiginRsp{} }
func (m *IdAssiginRsp) String() string            { return proto.CompactTextString(m) }
func (*IdAssiginRsp) ProtoMessage()               {}
func (*IdAssiginRsp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{45} }

func (m *IdAssiginRsp) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *IdAssiginRsp) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *IdAssiginRsp) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type Session struct {
	UserId        int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId         int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	SessionId     int64         `protobuf:"varint,3,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	AuthKey       []byte        `protobuf:"bytes,4,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	AccessHash    int64         `protobuf:"varint,5,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Status        int32         `protobuf:"varint,6,opt,name=status,proto3" json:"status,omitempty"`
	Layer         int32         `protobuf:"varint,7,opt,name=layer,proto3" json:"layer,omitempty"`
	Seq           int32         `protobuf:"varint,8,opt,name=seq,proto3" json:"seq,omitempty"`
	Qts           int32         `protobuf:"varint,9,opt,name=qts,proto3" json:"qts,omitempty"`
	LogoutTime    int64         `protobuf:"varint,10,opt,name=logout_time,json=logoutTime,proto3" json:"logout_time,omitempty"`
	CurrentStatus int32         `protobuf:"varint,11,opt,name=current_status,json=currentStatus,proto3" json:"current_status,omitempty"`
	Ip            string        `protobuf:"bytes,12,opt,name=ip,proto3" json:"ip,omitempty"`
	DeviceModel   string        `protobuf:"bytes,13,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	DeviceTp      int32         `protobuf:"varint,14,opt,name=device_tp,json=deviceTp,proto3" json:"device_tp,omitempty"`
	SystemVer     string        `protobuf:"bytes,15,opt,name=system_ver,json=systemVer,proto3" json:"system_ver,omitempty"`
	AppVer        string        `protobuf:"bytes,16,opt,name=app_ver,json=appVer,proto3" json:"app_ver,omitempty"`
	LangCode      string        `protobuf:"bytes,17,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	ApiId         int32         `protobuf:"varint,18,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	AppName       string        `protobuf:"bytes,19,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	Phone         string        `protobuf:"bytes,20,opt,name=phone,proto3" json:"phone,omitempty"`
	LoginCountry  string        `protobuf:"bytes,21,opt,name=login_country,json=loginCountry,proto3" json:"login_country,omitempty"`
	LoginRegion   string        `protobuf:"bytes,22,opt,name=login_region,json=loginRegion,proto3" json:"login_region,omitempty"`
	PushToken     string        `protobuf:"bytes,23,opt,name=push_token,json=pushToken,proto3" json:"push_token,omitempty"`
	PushTokenTp   int32         `protobuf:"varint,24,opt,name=push_token_tp,json=pushTokenTp,proto3" json:"push_token_tp,omitempty"`
	CallToken     string        `protobuf:"bytes,25,opt,name=call_token,json=callToken,proto3" json:"call_token,omitempty"`
	CallTokenTp   int32         `protobuf:"varint,26,opt,name=call_token_tp,json=callTokenTp,proto3" json:"call_token_tp,omitempty"`
	CreateTime    int64         `protobuf:"varint,27,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	LastTime      int64         `protobuf:"varint,28,opt,name=last_time,json=lastTime,proto3" json:"last_time,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,29,opt,name=debug" json:"debug,omitempty"`
}

func (m *Session) Reset()                    { *m = Session{} }
func (m *Session) String() string            { return proto.CompactTextString(m) }
func (*Session) ProtoMessage()               {}
func (*Session) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{46} }

func (m *Session) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Session) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *Session) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *Session) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *Session) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Session) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Session) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *Session) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *Session) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

func (m *Session) GetLogoutTime() int64 {
	if m != nil {
		return m.LogoutTime
	}
	return 0
}

func (m *Session) GetCurrentStatus() int32 {
	if m != nil {
		return m.CurrentStatus
	}
	return 0
}

func (m *Session) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Session) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *Session) GetDeviceTp() int32 {
	if m != nil {
		return m.DeviceTp
	}
	return 0
}

func (m *Session) GetSystemVer() string {
	if m != nil {
		return m.SystemVer
	}
	return ""
}

func (m *Session) GetAppVer() string {
	if m != nil {
		return m.AppVer
	}
	return ""
}

func (m *Session) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *Session) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *Session) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *Session) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *Session) GetLoginCountry() string {
	if m != nil {
		return m.LoginCountry
	}
	return ""
}

func (m *Session) GetLoginRegion() string {
	if m != nil {
		return m.LoginRegion
	}
	return ""
}

func (m *Session) GetPushToken() string {
	if m != nil {
		return m.PushToken
	}
	return ""
}

func (m *Session) GetPushTokenTp() int32 {
	if m != nil {
		return m.PushTokenTp
	}
	return 0
}

func (m *Session) GetCallToken() string {
	if m != nil {
		return m.CallToken
	}
	return ""
}

func (m *Session) GetCallTokenTp() int32 {
	if m != nil {
		return m.CallTokenTp
	}
	return 0
}

func (m *Session) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Session) GetLastTime() int64 {
	if m != nil {
		return m.LastTime
	}
	return 0
}

func (m *Session) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionArray struct {
	Sessions []*Session `protobuf:"bytes,1,rep,name=sessions" json:"sessions,omitempty"`
}

func (m *SessionArray) Reset()                    { *m = SessionArray{} }
func (m *SessionArray) String() string            { return proto.CompactTextString(m) }
func (*SessionArray) ProtoMessage()               {}
func (*SessionArray) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{47} }

func (m *SessionArray) GetSessions() []*Session {
	if m != nil {
		return m.Sessions
	}
	return nil
}

type SessionUpdate struct {
	Session *Session `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	//    int32   type = 2;
	Type  SessionUpdate_UpdateType `protobuf:"varint,2,opt,name=type,proto3,enum=infoserver.SessionUpdate_UpdateType" json:"type,omitempty"`
	Debug *pbcomm.Debug            `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *SessionUpdate) Reset()                    { *m = SessionUpdate{} }
func (m *SessionUpdate) String() string            { return proto.CompactTextString(m) }
func (*SessionUpdate) ProtoMessage()               {}
func (*SessionUpdate) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{48} }

func (m *SessionUpdate) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *SessionUpdate) GetType() SessionUpdate_UpdateType {
	if m != nil {
		return m.Type
	}
	return SessionUpdate_Type0NoUse
}

func (m *SessionUpdate) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionsReq struct {
	Uids  []int32       `protobuf:"varint,1,rep,packed,name=uids" json:"uids,omitempty"`
	Debug *pbcomm.Debug `protobuf:"bytes,2,opt,name=debug" json:"debug,omitempty"`
}

func (m *SessionsReq) Reset()                    { *m = SessionsReq{} }
func (m *SessionsReq) String() string            { return proto.CompactTextString(m) }
func (*SessionsReq) ProtoMessage()               {}
func (*SessionsReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{49} }

func (m *SessionsReq) GetUids() []int32 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *SessionsReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionsStatus struct {
	UserId        int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId         int64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	CurrentStatus int32 `protobuf:"varint,3,opt,name=current_status,json=currentStatus,proto3" json:"current_status,omitempty"`
}

func (m *SessionsStatus) Reset()                    { *m = SessionsStatus{} }
func (m *SessionsStatus) String() string            { return proto.CompactTextString(m) }
func (*SessionsStatus) ProtoMessage()               {}
func (*SessionsStatus) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{50} }

func (m *SessionsStatus) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SessionsStatus) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *SessionsStatus) GetCurrentStatus() int32 {
	if m != nil {
		return m.CurrentStatus
	}
	return 0
}

type SessionsRsp struct {
	Ss []*SessionsStatus `protobuf:"bytes,1,rep,name=ss" json:"ss,omitempty"`
}

func (m *SessionsRsp) Reset()                    { *m = SessionsRsp{} }
func (m *SessionsRsp) String() string            { return proto.CompactTextString(m) }
func (*SessionsRsp) ProtoMessage()               {}
func (*SessionsRsp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{51} }

func (m *SessionsRsp) GetSs() []*SessionsStatus {
	if m != nil {
		return m.Ss
	}
	return nil
}

type SessionTerminateReq struct {
	Session *Session                 `protobuf:"bytes,1,opt,name=session" json:"session,omitempty"`
	Type    SessionTerminateReq_Type `protobuf:"varint,2,opt,name=type,proto3,enum=infoserver.SessionTerminateReq_Type" json:"type,omitempty"`
	Debug   *pbcomm.Debug            `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *SessionTerminateReq) Reset()                    { *m = SessionTerminateReq{} }
func (m *SessionTerminateReq) String() string            { return proto.CompactTextString(m) }
func (*SessionTerminateReq) ProtoMessage()               {}
func (*SessionTerminateReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{52} }

func (m *SessionTerminateReq) GetSession() *Session {
	if m != nil {
		return m.Session
	}
	return nil
}

func (m *SessionTerminateReq) GetType() SessionTerminateReq_Type {
	if m != nil {
		return m.Type
	}
	return SessionTerminateReq_SELF
}

func (m *SessionTerminateReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type SessionTerminateRsp struct {
	Ret  bool    `protobuf:"varint,1,opt,name=ret,proto3" json:"ret,omitempty"`
	Desc string  `protobuf:"bytes,2,opt,name=desc,proto3" json:"desc,omitempty"`
	Keys []int64 `protobuf:"varint,3,rep,packed,name=keys" json:"keys,omitempty"`
}

func (m *SessionTerminateRsp) Reset()                    { *m = SessionTerminateRsp{} }
func (m *SessionTerminateRsp) String() string            { return proto.CompactTextString(m) }
func (*SessionTerminateRsp) ProtoMessage()               {}
func (*SessionTerminateRsp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{53} }

func (m *SessionTerminateRsp) GetRet() bool {
	if m != nil {
		return m.Ret
	}
	return false
}

func (m *SessionTerminateRsp) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *SessionTerminateRsp) GetKeys() []int64 {
	if m != nil {
		return m.Keys
	}
	return nil
}

type Authorization struct {
	UserId int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId  int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	AuthId int32         `protobuf:"varint,3,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Data   []byte        `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	DcId   int32         `protobuf:"varint,5,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	Debug  *pbcomm.Debug `protobuf:"bytes,6,opt,name=debug" json:"debug,omitempty"`
}

func (m *Authorization) Reset()                    { *m = Authorization{} }
func (m *Authorization) String() string            { return proto.CompactTextString(m) }
func (*Authorization) ProtoMessage()               {}
func (*Authorization) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{54} }

func (m *Authorization) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *Authorization) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *Authorization) GetAuthId() int32 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *Authorization) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Authorization) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *Authorization) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type CheckCodeReq struct {
	SendType     int32  `protobuf:"varint,1,opt,name=send_type,json=sendType,proto3" json:"send_type,omitempty"`
	BusinessType int32  `protobuf:"varint,2,opt,name=business_type,json=businessType,proto3" json:"business_type,omitempty"`
	Email        string `protobuf:"bytes,3,opt,name=email,proto3" json:"email,omitempty"`
	Phone        string `protobuf:"bytes,4,opt,name=phone,proto3" json:"phone,omitempty"`
	UserId       int32  `protobuf:"varint,5,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Code         string `protobuf:"bytes,6,opt,name=code,proto3" json:"code,omitempty"`
	CodeLen      int32  `protobuf:"varint,7,opt,name=code_len,json=codeLen,proto3" json:"code_len,omitempty"`
	CodeHash     string `protobuf:"bytes,8,opt,name=code_hash,json=codeHash,proto3" json:"code_hash,omitempty"`
	ResendFlag   bool   `protobuf:"varint,9,opt,name=resend_flag,json=resendFlag,proto3" json:"resend_flag,omitempty"`
	KeyId        int64  `protobuf:"varint,10,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
}

func (m *CheckCodeReq) Reset()                    { *m = CheckCodeReq{} }
func (m *CheckCodeReq) String() string            { return proto.CompactTextString(m) }
func (*CheckCodeReq) ProtoMessage()               {}
func (*CheckCodeReq) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{55} }

func (m *CheckCodeReq) GetSendType() int32 {
	if m != nil {
		return m.SendType
	}
	return 0
}

func (m *CheckCodeReq) GetBusinessType() int32 {
	if m != nil {
		return m.BusinessType
	}
	return 0
}

func (m *CheckCodeReq) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *CheckCodeReq) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *CheckCodeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CheckCodeReq) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *CheckCodeReq) GetCodeLen() int32 {
	if m != nil {
		return m.CodeLen
	}
	return 0
}

func (m *CheckCodeReq) GetCodeHash() string {
	if m != nil {
		return m.CodeHash
	}
	return ""
}

func (m *CheckCodeReq) GetResendFlag() bool {
	if m != nil {
		return m.ResendFlag
	}
	return false
}

func (m *CheckCodeReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

type CheckCodeRsp struct {
	Right    bool   `protobuf:"varint,1,opt,name=right,proto3" json:"right,omitempty"`
	Code     string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	CodeHash string `protobuf:"bytes,3,opt,name=code_hash,json=codeHash,proto3" json:"code_hash,omitempty"`
	Desc     string `protobuf:"bytes,4,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *CheckCodeRsp) Reset()                    { *m = CheckCodeRsp{} }
func (m *CheckCodeRsp) String() string            { return proto.CompactTextString(m) }
func (*CheckCodeRsp) ProtoMessage()               {}
func (*CheckCodeRsp) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{56} }

func (m *CheckCodeRsp) GetRight() bool {
	if m != nil {
		return m.Right
	}
	return false
}

func (m *CheckCodeRsp) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *CheckCodeRsp) GetCodeHash() string {
	if m != nil {
		return m.CodeHash
	}
	return ""
}

func (m *CheckCodeRsp) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

type SetResult struct {
	Ret bool   `protobuf:"varint,1,opt,name=ret,proto3" json:"ret,omitempty"`
	Str string `protobuf:"bytes,2,opt,name=str,proto3" json:"str,omitempty"`
	Num int32  `protobuf:"varint,3,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *SetResult) Reset()                    { *m = SetResult{} }
func (m *SetResult) String() string            { return proto.CompactTextString(m) }
func (*SetResult) ProtoMessage()               {}
func (*SetResult) Descriptor() ([]byte, []int) { return fileDescriptorAccount, []int{57} }

func (m *SetResult) GetRet() bool {
	if m != nil {
		return m.Ret
	}
	return false
}

func (m *SetResult) GetStr() string {
	if m != nil {
		return m.Str
	}
	return ""
}

func (m *SetResult) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func init() {
	proto.RegisterType((*GetUniqueNumberByKeyIdReq)(nil), "infoserver.GetUniqueNumberByKeyIdReq")
	proto.RegisterType((*GetUniqueNumberByKeyIdResult)(nil), "infoserver.GetUniqueNumberByKeyIdResult")
	proto.RegisterType((*SessionDisconnectReq)(nil), "infoserver.SessionDisconnectReq")
	proto.RegisterType((*SessionDisconnectResult)(nil), "infoserver.SessionDisconnectResult")
	proto.RegisterType((*SessionQueryApiIDbyKeyidReq)(nil), "infoserver.SessionQueryApiIDbyKeyidReq")
	proto.RegisterType((*SessionQueryApiIDbyKeyidResult)(nil), "infoserver.SessionQueryApiIDbyKeyidResult")
	proto.RegisterType((*SessionUpdateOnHandshakeDoneReq)(nil), "infoserver.SessionUpdateOnHandshakeDoneReq")
	proto.RegisterType((*SessionUpdateOnHandshakeDoneResult)(nil), "infoserver.SessionUpdateOnHandshakeDoneResult")
	proto.RegisterType((*SessionQueryByUseridReq)(nil), "infoserver.SessionQueryByUseridReq")
	proto.RegisterType((*SessionQueryByUseridResult)(nil), "infoserver.SessionQueryByUseridResult")
	proto.RegisterType((*SessionQueryUseridByKeyidReq)(nil), "infoserver.SessionQueryUseridByKeyidReq")
	proto.RegisterType((*SessionQueryUseridByKeyidResult)(nil), "infoserver.SessionQueryUseridByKeyidResult")
	proto.RegisterType((*SessionInformation)(nil), "infoserver.SessionInformation")
	proto.RegisterType((*SessionQueryByKeyidReq)(nil), "infoserver.SessionQueryByKeyidReq")
	proto.RegisterType((*SessionQueryByKeyidResult)(nil), "infoserver.SessionQueryByKeyidResult")
	proto.RegisterType((*SessionQueryByPhoneReq)(nil), "infoserver.SessionQueryByPhoneReq")
	proto.RegisterType((*SessionQueryByPhoneResult)(nil), "infoserver.SessionQueryByPhoneResult")
	proto.RegisterType((*SessionIncQtsReq)(nil), "infoserver.SessionIncQtsReq")
	proto.RegisterType((*SessionIncQtsResult)(nil), "infoserver.SessionIncQtsResult")
	proto.RegisterType((*SessionUpdateInitConnectionReq)(nil), "infoserver.SessionUpdateInitConnectionReq")
	proto.RegisterType((*SessionUpdateInitConnectionResult)(nil), "infoserver.SessionUpdateInitConnectionResult")
	proto.RegisterType((*SessionUpdateRegisterDeviceReq)(nil), "infoserver.SessionUpdateRegisterDeviceReq")
	proto.RegisterType((*SessionUpdateRegisterDeviceResult)(nil), "infoserver.SessionUpdateRegisterDeviceResult")
	proto.RegisterType((*SessionUpdateSignInReq)(nil), "infoserver.SessionUpdateSignInReq")
	proto.RegisterType((*SessionUpdateSignInResult)(nil), "infoserver.SessionUpdateSignInResult")
	proto.RegisterType((*SessionUpdatePingReq)(nil), "infoserver.SessionUpdatePingReq")
	proto.RegisterType((*SessionUpdatePingResult)(nil), "infoserver.SessionUpdatePingResult")
	proto.RegisterType((*SessionUpdateLogoutReq)(nil), "infoserver.SessionUpdateLogoutReq")
	proto.RegisterType((*SessionUpdateLogoutResult)(nil), "infoserver.SessionUpdateLogoutResult")
	proto.RegisterType((*SessionTerminateByKeyidReq)(nil), "infoserver.SessionTerminateByKeyidReq")
	proto.RegisterType((*SessionTerminateByKeyidResult)(nil), "infoserver.SessionTerminateByKeyidResult")
	proto.RegisterType((*SessionTerminateExceptKeyidReq)(nil), "infoserver.SessionTerminateExceptKeyidReq")
	proto.RegisterType((*SessionTerminateExceptKeyidResult)(nil), "infoserver.SessionTerminateExceptKeyidResult")
	proto.RegisterType((*CheckUserIdAndAccessHashReq)(nil), "infoserver.CheckUserIdAndAccessHashReq")
	proto.RegisterType((*CheckUserIdAndAccessHashResult)(nil), "infoserver.CheckUserIdAndAccessHashResult")
	proto.RegisterType((*PasswordReq)(nil), "infoserver.PasswordReq")
	proto.RegisterType((*PtPasswordReq)(nil), "infoserver.PtPasswordReq")
	proto.RegisterType((*PasswordRsp)(nil), "infoserver.PasswordRsp")
	proto.RegisterType((*BoolResult)(nil), "infoserver.BoolResult")
	proto.RegisterType((*IntResult)(nil), "infoserver.IntResult")
	proto.RegisterType((*UserInfoReq)(nil), "infoserver.UserInfoReq")
	proto.RegisterType((*UserInfoRsp)(nil), "infoserver.UserInfoRsp")
	proto.RegisterType((*GroupIdReq)(nil), "infoserver.GroupIdReq")
	proto.RegisterType((*GroupIdRsp)(nil), "infoserver.GroupIdRsp")
	proto.RegisterType((*IdAssiginReq)(nil), "infoserver.IdAssiginReq")
	proto.RegisterType((*IdAssiginRsp)(nil), "infoserver.IdAssiginRsp")
	proto.RegisterType((*Session)(nil), "infoserver.Session")
	proto.RegisterType((*SessionArray)(nil), "infoserver.SessionArray")
	proto.RegisterType((*SessionUpdate)(nil), "infoserver.SessionUpdate")
	proto.RegisterType((*SessionsReq)(nil), "infoserver.SessionsReq")
	proto.RegisterType((*SessionsStatus)(nil), "infoserver.SessionsStatus")
	proto.RegisterType((*SessionsRsp)(nil), "infoserver.SessionsRsp")
	proto.RegisterType((*SessionTerminateReq)(nil), "infoserver.SessionTerminateReq")
	proto.RegisterType((*SessionTerminateRsp)(nil), "infoserver.SessionTerminateRsp")
	proto.RegisterType((*Authorization)(nil), "infoserver.Authorization")
	proto.RegisterType((*CheckCodeReq)(nil), "infoserver.CheckCodeReq")
	proto.RegisterType((*CheckCodeRsp)(nil), "infoserver.CheckCodeRsp")
	proto.RegisterType((*SetResult)(nil), "infoserver.SetResult")
	proto.RegisterEnum("infoserver.SessionUpdateOnHandshakeDoneResult_FailCode", SessionUpdateOnHandshakeDoneResult_FailCode_name, SessionUpdateOnHandshakeDoneResult_FailCode_value)
	proto.RegisterEnum("infoserver.SessionQueryByKeyidResult_ResultCode", SessionQueryByKeyidResult_ResultCode_name, SessionQueryByKeyidResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionQueryByPhoneResult_ResultCode", SessionQueryByPhoneResult_ResultCode_name, SessionQueryByPhoneResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionIncQtsResult_ResultCode", SessionIncQtsResult_ResultCode_name, SessionIncQtsResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionUpdateInitConnectionResult_ResultCode", SessionUpdateInitConnectionResult_ResultCode_name, SessionUpdateInitConnectionResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionUpdateRegisterDeviceResult_ResultCode", SessionUpdateRegisterDeviceResult_ResultCode_name, SessionUpdateRegisterDeviceResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionUpdateSignInResult_ResultCode", SessionUpdateSignInResult_ResultCode_name, SessionUpdateSignInResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionUpdatePingResult_ResultCode", SessionUpdatePingResult_ResultCode_name, SessionUpdatePingResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionUpdateLogoutResult_ResultCode", SessionUpdateLogoutResult_ResultCode_name, SessionUpdateLogoutResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionTerminateByKeyidResult_ResultCode", SessionTerminateByKeyidResult_ResultCode_name, SessionTerminateByKeyidResult_ResultCode_value)
	proto.RegisterEnum("infoserver.SessionTerminateExceptKeyidResult_ResultCode", SessionTerminateExceptKeyidResult_ResultCode_name, SessionTerminateExceptKeyidResult_ResultCode_value)
	proto.RegisterEnum("infoserver.BoolResult_ErrorCode", BoolResult_ErrorCode_name, BoolResult_ErrorCode_value)
	proto.RegisterEnum("infoserver.SessionUpdate_UpdateType", SessionUpdate_UpdateType_name, SessionUpdate_UpdateType_value)
	proto.RegisterEnum("infoserver.SessionTerminateReq_Type", SessionTerminateReq_Type_name, SessionTerminateReq_Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Accounter service

type AccounterClient interface {
	// 获取用户id和用户hash id
	AssignUserInfo(ctx context.Context, in *UserInfoReq, opts ...grpc.CallOption) (*UserInfoRsp, error)
	UnAssignUserInfo(ctx context.Context, in *UserInfoRsp, opts ...grpc.CallOption) (*BoolResult, error)
	CheckPhoneRegistered(ctx context.Context, in *UserInfoReq, opts ...grpc.CallOption) (*BoolResult, error)
	// group
	AssignGroupId(ctx context.Context, in *GroupIdReq, opts ...grpc.CallOption) (*GroupIdRsp, error)
	UnAssignGroupId(ctx context.Context, in *GroupIdRsp, opts ...grpc.CallOption) (*BoolResult, error)
	// session
	//    rpc NewKeyIdSession(Session) returns (BoolResult) {}
	//    rpc QueryUserSessions(Session) returns (SessionArray) {}
	//    rpc UpdateUserSessions(SessionUpdate) returns (BoolResult) {}
	//    rpc QueryKeyIdSession(Session) returns (Session) {}
	//    rpc UpdateSessionQts(SessionUpdate) returns (Session) {}
	//    rpc QueryUsersSessionStatus(SessionsReq) returns (SessionsRsp) {}
	//    rpc TerminateSessions(SessionTerminateReq) returns (SessionTerminateRsp) {}
	// init connetion 调用
	SessionUpdateInitConnection(ctx context.Context, in *SessionUpdateInitConnectionReq, opts ...grpc.CallOption) (*SessionUpdateInitConnectionResult, error)
	// register device 调用
	SessionUpdateRegisterDevice(ctx context.Context, in *SessionUpdateRegisterDeviceReq, opts ...grpc.CallOption) (*SessionUpdateRegisterDeviceResult, error)
	// 登陆时调用
	SessionUpdateSignIn(ctx context.Context, in *SessionUpdateSignInReq, opts ...grpc.CallOption) (*SessionUpdateSignInResult, error)
	// ping 或者ping delay等有活动时调用
	SessionUpdatePing(ctx context.Context, in *SessionUpdatePingReq, opts ...grpc.CallOption) (*SessionUpdatePingResult, error)
	// logout 调用
	SessionUpdateLogout(ctx context.Context, in *SessionUpdateLogoutReq, opts ...grpc.CallOption) (*SessionUpdateLogoutResult, error)
	// 剔除单个
	SessionTerminateByKeyid(ctx context.Context, in *SessionTerminateByKeyidReq, opts ...grpc.CallOption) (*SessionTerminateByKeyidResult, error)
	// 剔除多个
	SessionTerminateExceptKeyid(ctx context.Context, in *SessionTerminateExceptKeyidReq, opts ...grpc.CallOption) (*SessionTerminateExceptKeyidResult, error)
	// 查询单个session
	SessionQueryByKeyid(ctx context.Context, in *SessionQueryByKeyidReq, opts ...grpc.CallOption) (*SessionQueryByKeyidResult, error)
	// 查询所有
	SessionQueryByPhone(ctx context.Context, in *SessionQueryByPhoneReq, opts ...grpc.CallOption) (*SessionQueryByPhoneResult, error)
	// 更新qts
	SessionIncQts(ctx context.Context, in *SessionIncQtsReq, opts ...grpc.CallOption) (*SessionIncQtsResult, error)
	// 檢查session是否被踢
	SessionQueryUseridByKeyid(ctx context.Context, in *SessionQueryUseridByKeyidReq, opts ...grpc.CallOption) (*SessionQueryUseridByKeyidResult, error)
	// 根据userid查所有session
	SessionQueryByUserid(ctx context.Context, in *SessionQueryByUseridReq, opts ...grpc.CallOption) (*SessionQueryByUseridResult, error)
	// 客户端握手完成时保存auth key
	SessionUpdateOnHandshakeDone(ctx context.Context, in *SessionUpdateOnHandshakeDoneReq, opts ...grpc.CallOption) (*SessionUpdateOnHandshakeDoneResult, error)
	// 根据keyid获取apiid
	SessionQueryApiIDbyKeyid(ctx context.Context, in *SessionQueryApiIDbyKeyidReq, opts ...grpc.CallOption) (*SessionQueryApiIDbyKeyidResult, error)
	// 客户端连接断开
	SessionDisconnect(ctx context.Context, in *SessionDisconnectReq, opts ...grpc.CallOption) (*SessionDisconnectResult, error)
	// authorization
	SaveAuthorizationInfo(ctx context.Context, in *Authorization, opts ...grpc.CallOption) (*BoolResult, error)
	QueryAuthorizationInfo(ctx context.Context, in *Authorization, opts ...grpc.CallOption) (*Authorization, error)
	// password
	UpdatePassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*BoolResult, error)
	GetPassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*PasswordRsp, error)
	DeletePassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*BoolResult, error)
	// 检查userid和access hash是否匹配
	CheckUserIdAndAccessHash(ctx context.Context, in *CheckUserIdAndAccessHashReq, opts ...grpc.CallOption) (*CheckUserIdAndAccessHashResult, error)
	// get unique number by key id
	GetUniqueNumberByKeyId(ctx context.Context, in *GetUniqueNumberByKeyIdReq, opts ...grpc.CallOption) (*GetUniqueNumberByKeyIdResult, error)
	PtUpdatePassword(ctx context.Context, in *PtPasswordReq, opts ...grpc.CallOption) (*BoolResult, error)
}

type accounterClient struct {
	cc *grpc.ClientConn
}

func NewAccounterClient(cc *grpc.ClientConn) AccounterClient {
	return &accounterClient{cc}
}

func (c *accounterClient) AssignUserInfo(ctx context.Context, in *UserInfoReq, opts ...grpc.CallOption) (*UserInfoRsp, error) {
	out := new(UserInfoRsp)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/AssignUserInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) UnAssignUserInfo(ctx context.Context, in *UserInfoRsp, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/UnAssignUserInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) CheckPhoneRegistered(ctx context.Context, in *UserInfoReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/CheckPhoneRegistered", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) AssignGroupId(ctx context.Context, in *GroupIdReq, opts ...grpc.CallOption) (*GroupIdRsp, error) {
	out := new(GroupIdRsp)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/AssignGroupId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) UnAssignGroupId(ctx context.Context, in *GroupIdRsp, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/UnAssignGroupId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionUpdateInitConnection(ctx context.Context, in *SessionUpdateInitConnectionReq, opts ...grpc.CallOption) (*SessionUpdateInitConnectionResult, error) {
	out := new(SessionUpdateInitConnectionResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionUpdateInitConnection", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionUpdateRegisterDevice(ctx context.Context, in *SessionUpdateRegisterDeviceReq, opts ...grpc.CallOption) (*SessionUpdateRegisterDeviceResult, error) {
	out := new(SessionUpdateRegisterDeviceResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionUpdateRegisterDevice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionUpdateSignIn(ctx context.Context, in *SessionUpdateSignInReq, opts ...grpc.CallOption) (*SessionUpdateSignInResult, error) {
	out := new(SessionUpdateSignInResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionUpdateSignIn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionUpdatePing(ctx context.Context, in *SessionUpdatePingReq, opts ...grpc.CallOption) (*SessionUpdatePingResult, error) {
	out := new(SessionUpdatePingResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionUpdatePing", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionUpdateLogout(ctx context.Context, in *SessionUpdateLogoutReq, opts ...grpc.CallOption) (*SessionUpdateLogoutResult, error) {
	out := new(SessionUpdateLogoutResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionUpdateLogout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionTerminateByKeyid(ctx context.Context, in *SessionTerminateByKeyidReq, opts ...grpc.CallOption) (*SessionTerminateByKeyidResult, error) {
	out := new(SessionTerminateByKeyidResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionTerminateByKeyid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionTerminateExceptKeyid(ctx context.Context, in *SessionTerminateExceptKeyidReq, opts ...grpc.CallOption) (*SessionTerminateExceptKeyidResult, error) {
	out := new(SessionTerminateExceptKeyidResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionTerminateExceptKeyid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionQueryByKeyid(ctx context.Context, in *SessionQueryByKeyidReq, opts ...grpc.CallOption) (*SessionQueryByKeyidResult, error) {
	out := new(SessionQueryByKeyidResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionQueryByKeyid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionQueryByPhone(ctx context.Context, in *SessionQueryByPhoneReq, opts ...grpc.CallOption) (*SessionQueryByPhoneResult, error) {
	out := new(SessionQueryByPhoneResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionQueryByPhone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionIncQts(ctx context.Context, in *SessionIncQtsReq, opts ...grpc.CallOption) (*SessionIncQtsResult, error) {
	out := new(SessionIncQtsResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionIncQts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionQueryUseridByKeyid(ctx context.Context, in *SessionQueryUseridByKeyidReq, opts ...grpc.CallOption) (*SessionQueryUseridByKeyidResult, error) {
	out := new(SessionQueryUseridByKeyidResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionQueryUseridByKeyid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionQueryByUserid(ctx context.Context, in *SessionQueryByUseridReq, opts ...grpc.CallOption) (*SessionQueryByUseridResult, error) {
	out := new(SessionQueryByUseridResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionQueryByUserid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionUpdateOnHandshakeDone(ctx context.Context, in *SessionUpdateOnHandshakeDoneReq, opts ...grpc.CallOption) (*SessionUpdateOnHandshakeDoneResult, error) {
	out := new(SessionUpdateOnHandshakeDoneResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionUpdateOnHandshakeDone", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionQueryApiIDbyKeyid(ctx context.Context, in *SessionQueryApiIDbyKeyidReq, opts ...grpc.CallOption) (*SessionQueryApiIDbyKeyidResult, error) {
	out := new(SessionQueryApiIDbyKeyidResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionQueryApiIDbyKeyid", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SessionDisconnect(ctx context.Context, in *SessionDisconnectReq, opts ...grpc.CallOption) (*SessionDisconnectResult, error) {
	out := new(SessionDisconnectResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SessionDisconnect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) SaveAuthorizationInfo(ctx context.Context, in *Authorization, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/SaveAuthorizationInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) QueryAuthorizationInfo(ctx context.Context, in *Authorization, opts ...grpc.CallOption) (*Authorization, error) {
	out := new(Authorization)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/QueryAuthorizationInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) UpdatePassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/UpdatePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) GetPassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*PasswordRsp, error) {
	out := new(PasswordRsp)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/GetPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) DeletePassword(ctx context.Context, in *PasswordReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/DeletePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) CheckUserIdAndAccessHash(ctx context.Context, in *CheckUserIdAndAccessHashReq, opts ...grpc.CallOption) (*CheckUserIdAndAccessHashResult, error) {
	out := new(CheckUserIdAndAccessHashResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/CheckUserIdAndAccessHash", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) GetUniqueNumberByKeyId(ctx context.Context, in *GetUniqueNumberByKeyIdReq, opts ...grpc.CallOption) (*GetUniqueNumberByKeyIdResult, error) {
	out := new(GetUniqueNumberByKeyIdResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/GetUniqueNumberByKeyId", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accounterClient) PtUpdatePassword(ctx context.Context, in *PtPasswordReq, opts ...grpc.CallOption) (*BoolResult, error) {
	out := new(BoolResult)
	err := grpc.Invoke(ctx, "/infoserver.Accounter/PtUpdatePassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Accounter service

type AccounterServer interface {
	// 获取用户id和用户hash id
	AssignUserInfo(context.Context, *UserInfoReq) (*UserInfoRsp, error)
	UnAssignUserInfo(context.Context, *UserInfoRsp) (*BoolResult, error)
	CheckPhoneRegistered(context.Context, *UserInfoReq) (*BoolResult, error)
	// group
	AssignGroupId(context.Context, *GroupIdReq) (*GroupIdRsp, error)
	UnAssignGroupId(context.Context, *GroupIdRsp) (*BoolResult, error)
	// session
	//    rpc NewKeyIdSession(Session) returns (BoolResult) {}
	//    rpc QueryUserSessions(Session) returns (SessionArray) {}
	//    rpc UpdateUserSessions(SessionUpdate) returns (BoolResult) {}
	//    rpc QueryKeyIdSession(Session) returns (Session) {}
	//    rpc UpdateSessionQts(SessionUpdate) returns (Session) {}
	//    rpc QueryUsersSessionStatus(SessionsReq) returns (SessionsRsp) {}
	//    rpc TerminateSessions(SessionTerminateReq) returns (SessionTerminateRsp) {}
	// init connetion 调用
	SessionUpdateInitConnection(context.Context, *SessionUpdateInitConnectionReq) (*SessionUpdateInitConnectionResult, error)
	// register device 调用
	SessionUpdateRegisterDevice(context.Context, *SessionUpdateRegisterDeviceReq) (*SessionUpdateRegisterDeviceResult, error)
	// 登陆时调用
	SessionUpdateSignIn(context.Context, *SessionUpdateSignInReq) (*SessionUpdateSignInResult, error)
	// ping 或者ping delay等有活动时调用
	SessionUpdatePing(context.Context, *SessionUpdatePingReq) (*SessionUpdatePingResult, error)
	// logout 调用
	SessionUpdateLogout(context.Context, *SessionUpdateLogoutReq) (*SessionUpdateLogoutResult, error)
	// 剔除单个
	SessionTerminateByKeyid(context.Context, *SessionTerminateByKeyidReq) (*SessionTerminateByKeyidResult, error)
	// 剔除多个
	SessionTerminateExceptKeyid(context.Context, *SessionTerminateExceptKeyidReq) (*SessionTerminateExceptKeyidResult, error)
	// 查询单个session
	SessionQueryByKeyid(context.Context, *SessionQueryByKeyidReq) (*SessionQueryByKeyidResult, error)
	// 查询所有
	SessionQueryByPhone(context.Context, *SessionQueryByPhoneReq) (*SessionQueryByPhoneResult, error)
	// 更新qts
	SessionIncQts(context.Context, *SessionIncQtsReq) (*SessionIncQtsResult, error)
	// 檢查session是否被踢
	SessionQueryUseridByKeyid(context.Context, *SessionQueryUseridByKeyidReq) (*SessionQueryUseridByKeyidResult, error)
	// 根据userid查所有session
	SessionQueryByUserid(context.Context, *SessionQueryByUseridReq) (*SessionQueryByUseridResult, error)
	// 客户端握手完成时保存auth key
	SessionUpdateOnHandshakeDone(context.Context, *SessionUpdateOnHandshakeDoneReq) (*SessionUpdateOnHandshakeDoneResult, error)
	// 根据keyid获取apiid
	SessionQueryApiIDbyKeyid(context.Context, *SessionQueryApiIDbyKeyidReq) (*SessionQueryApiIDbyKeyidResult, error)
	// 客户端连接断开
	SessionDisconnect(context.Context, *SessionDisconnectReq) (*SessionDisconnectResult, error)
	// authorization
	SaveAuthorizationInfo(context.Context, *Authorization) (*BoolResult, error)
	QueryAuthorizationInfo(context.Context, *Authorization) (*Authorization, error)
	// password
	UpdatePassword(context.Context, *PasswordReq) (*BoolResult, error)
	GetPassword(context.Context, *PasswordReq) (*PasswordRsp, error)
	DeletePassword(context.Context, *PasswordReq) (*BoolResult, error)
	// 检查userid和access hash是否匹配
	CheckUserIdAndAccessHash(context.Context, *CheckUserIdAndAccessHashReq) (*CheckUserIdAndAccessHashResult, error)
	// get unique number by key id
	GetUniqueNumberByKeyId(context.Context, *GetUniqueNumberByKeyIdReq) (*GetUniqueNumberByKeyIdResult, error)
	PtUpdatePassword(context.Context, *PtPasswordReq) (*BoolResult, error)
}

func RegisterAccounterServer(s *grpc.Server, srv AccounterServer) {
	s.RegisterService(&_Accounter_serviceDesc, srv)
}

func _Accounter_AssignUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).AssignUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/AssignUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).AssignUserInfo(ctx, req.(*UserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_UnAssignUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoRsp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).UnAssignUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/UnAssignUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).UnAssignUserInfo(ctx, req.(*UserInfoRsp))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_CheckPhoneRegistered_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).CheckPhoneRegistered(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/CheckPhoneRegistered",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).CheckPhoneRegistered(ctx, req.(*UserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_AssignGroupId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).AssignGroupId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/AssignGroupId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).AssignGroupId(ctx, req.(*GroupIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_UnAssignGroupId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupIdRsp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).UnAssignGroupId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/UnAssignGroupId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).UnAssignGroupId(ctx, req.(*GroupIdRsp))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionUpdateInitConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateInitConnectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionUpdateInitConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionUpdateInitConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionUpdateInitConnection(ctx, req.(*SessionUpdateInitConnectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionUpdateRegisterDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateRegisterDeviceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionUpdateRegisterDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionUpdateRegisterDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionUpdateRegisterDevice(ctx, req.(*SessionUpdateRegisterDeviceReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionUpdateSignIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateSignInReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionUpdateSignIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionUpdateSignIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionUpdateSignIn(ctx, req.(*SessionUpdateSignInReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionUpdatePing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdatePingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionUpdatePing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionUpdatePing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionUpdatePing(ctx, req.(*SessionUpdatePingReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionUpdateLogout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateLogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionUpdateLogout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionUpdateLogout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionUpdateLogout(ctx, req.(*SessionUpdateLogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionTerminateByKeyid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionTerminateByKeyidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionTerminateByKeyid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionTerminateByKeyid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionTerminateByKeyid(ctx, req.(*SessionTerminateByKeyidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionTerminateExceptKeyid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionTerminateExceptKeyidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionTerminateExceptKeyid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionTerminateExceptKeyid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionTerminateExceptKeyid(ctx, req.(*SessionTerminateExceptKeyidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionQueryByKeyid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryByKeyidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionQueryByKeyid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionQueryByKeyid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionQueryByKeyid(ctx, req.(*SessionQueryByKeyidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionQueryByPhone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryByPhoneReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionQueryByPhone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionQueryByPhone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionQueryByPhone(ctx, req.(*SessionQueryByPhoneReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionIncQts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionIncQtsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionIncQts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionIncQts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionIncQts(ctx, req.(*SessionIncQtsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionQueryUseridByKeyid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryUseridByKeyidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionQueryUseridByKeyid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionQueryUseridByKeyid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionQueryUseridByKeyid(ctx, req.(*SessionQueryUseridByKeyidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionQueryByUserid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryByUseridReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionQueryByUserid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionQueryByUserid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionQueryByUserid(ctx, req.(*SessionQueryByUseridReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionUpdateOnHandshakeDone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionUpdateOnHandshakeDoneReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionUpdateOnHandshakeDone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionUpdateOnHandshakeDone",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionUpdateOnHandshakeDone(ctx, req.(*SessionUpdateOnHandshakeDoneReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionQueryApiIDbyKeyid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionQueryApiIDbyKeyidReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionQueryApiIDbyKeyid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionQueryApiIDbyKeyid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionQueryApiIDbyKeyid(ctx, req.(*SessionQueryApiIDbyKeyidReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SessionDisconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionDisconnectReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SessionDisconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SessionDisconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SessionDisconnect(ctx, req.(*SessionDisconnectReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_SaveAuthorizationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Authorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).SaveAuthorizationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/SaveAuthorizationInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).SaveAuthorizationInfo(ctx, req.(*Authorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_QueryAuthorizationInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Authorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).QueryAuthorizationInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/QueryAuthorizationInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).QueryAuthorizationInfo(ctx, req.(*Authorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_UpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).UpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/UpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).UpdatePassword(ctx, req.(*PasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_GetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).GetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/GetPassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).GetPassword(ctx, req.(*PasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_DeletePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).DeletePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/DeletePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).DeletePassword(ctx, req.(*PasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_CheckUserIdAndAccessHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckUserIdAndAccessHashReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).CheckUserIdAndAccessHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/CheckUserIdAndAccessHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).CheckUserIdAndAccessHash(ctx, req.(*CheckUserIdAndAccessHashReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_GetUniqueNumberByKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUniqueNumberByKeyIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).GetUniqueNumberByKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/GetUniqueNumberByKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).GetUniqueNumberByKeyId(ctx, req.(*GetUniqueNumberByKeyIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Accounter_PtUpdatePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PtPasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccounterServer).PtUpdatePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/infoserver.Accounter/PtUpdatePassword",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccounterServer).PtUpdatePassword(ctx, req.(*PtPasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Accounter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "infoserver.Accounter",
	HandlerType: (*AccounterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AssignUserInfo",
			Handler:    _Accounter_AssignUserInfo_Handler,
		},
		{
			MethodName: "UnAssignUserInfo",
			Handler:    _Accounter_UnAssignUserInfo_Handler,
		},
		{
			MethodName: "CheckPhoneRegistered",
			Handler:    _Accounter_CheckPhoneRegistered_Handler,
		},
		{
			MethodName: "AssignGroupId",
			Handler:    _Accounter_AssignGroupId_Handler,
		},
		{
			MethodName: "UnAssignGroupId",
			Handler:    _Accounter_UnAssignGroupId_Handler,
		},
		{
			MethodName: "SessionUpdateInitConnection",
			Handler:    _Accounter_SessionUpdateInitConnection_Handler,
		},
		{
			MethodName: "SessionUpdateRegisterDevice",
			Handler:    _Accounter_SessionUpdateRegisterDevice_Handler,
		},
		{
			MethodName: "SessionUpdateSignIn",
			Handler:    _Accounter_SessionUpdateSignIn_Handler,
		},
		{
			MethodName: "SessionUpdatePing",
			Handler:    _Accounter_SessionUpdatePing_Handler,
		},
		{
			MethodName: "SessionUpdateLogout",
			Handler:    _Accounter_SessionUpdateLogout_Handler,
		},
		{
			MethodName: "SessionTerminateByKeyid",
			Handler:    _Accounter_SessionTerminateByKeyid_Handler,
		},
		{
			MethodName: "SessionTerminateExceptKeyid",
			Handler:    _Accounter_SessionTerminateExceptKeyid_Handler,
		},
		{
			MethodName: "SessionQueryByKeyid",
			Handler:    _Accounter_SessionQueryByKeyid_Handler,
		},
		{
			MethodName: "SessionQueryByPhone",
			Handler:    _Accounter_SessionQueryByPhone_Handler,
		},
		{
			MethodName: "SessionIncQts",
			Handler:    _Accounter_SessionIncQts_Handler,
		},
		{
			MethodName: "SessionQueryUseridByKeyid",
			Handler:    _Accounter_SessionQueryUseridByKeyid_Handler,
		},
		{
			MethodName: "SessionQueryByUserid",
			Handler:    _Accounter_SessionQueryByUserid_Handler,
		},
		{
			MethodName: "SessionUpdateOnHandshakeDone",
			Handler:    _Accounter_SessionUpdateOnHandshakeDone_Handler,
		},
		{
			MethodName: "SessionQueryApiIDbyKeyid",
			Handler:    _Accounter_SessionQueryApiIDbyKeyid_Handler,
		},
		{
			MethodName: "SessionDisconnect",
			Handler:    _Accounter_SessionDisconnect_Handler,
		},
		{
			MethodName: "SaveAuthorizationInfo",
			Handler:    _Accounter_SaveAuthorizationInfo_Handler,
		},
		{
			MethodName: "QueryAuthorizationInfo",
			Handler:    _Accounter_QueryAuthorizationInfo_Handler,
		},
		{
			MethodName: "UpdatePassword",
			Handler:    _Accounter_UpdatePassword_Handler,
		},
		{
			MethodName: "GetPassword",
			Handler:    _Accounter_GetPassword_Handler,
		},
		{
			MethodName: "DeletePassword",
			Handler:    _Accounter_DeletePassword_Handler,
		},
		{
			MethodName: "CheckUserIdAndAccessHash",
			Handler:    _Accounter_CheckUserIdAndAccessHash_Handler,
		},
		{
			MethodName: "GetUniqueNumberByKeyId",
			Handler:    _Accounter_GetUniqueNumberByKeyId_Handler,
		},
		{
			MethodName: "PtUpdatePassword",
			Handler:    _Accounter_PtUpdatePassword_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/account.proto",
}

func (m *GetUniqueNumberByKeyIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUniqueNumberByKeyIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *GetUniqueNumberByKeyIdResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetUniqueNumberByKeyIdResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.UniqueNumber)))
		i += copy(dAtA[i:], m.UniqueNumber)
	}
	return i, nil
}

func (m *SessionDisconnectReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDisconnectReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.Disconnect {
		dAtA[i] = 0x18
		i++
		if m.Disconnect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ClientIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.ClientIp)))
		i += copy(dAtA[i:], m.ClientIp)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	return i, nil
}

func (m *SessionDisconnectResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionDisconnectResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SessionQueryApiIDbyKeyidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryApiIDbyKeyidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *SessionQueryApiIDbyKeyidResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryApiIDbyKeyidResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.ApiId))
	}
	if m.InternalError {
		dAtA[i] = 0x10
		i++
		if m.InternalError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionUpdateOnHandshakeDoneReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateOnHandshakeDoneReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	return i, nil
}

func (m *SessionUpdateOnHandshakeDoneResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateOnHandshakeDoneResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionQueryByUseridReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByUseridReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SessionQueryByUseridResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByUseridResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SessionQueryUseridByKeyidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryUseridByKeyidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n1, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *SessionQueryUseridByKeyidResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryUseridByKeyidResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.InternalError {
		dAtA[i] = 0x8
		i++
		if m.InternalError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionInformation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionInformation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.ApiId))
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Layer))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if m.Qts != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Qts))
	}
	if m.PushTokenType != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.PushTokenType))
	}
	if len(m.PushToken) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PushToken)))
		i += copy(dAtA[i:], m.PushToken)
	}
	if m.CallTokenType != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CallTokenType))
	}
	if len(m.CallToken) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.CallToken)))
		i += copy(dAtA[i:], m.CallToken)
	}
	if m.PingTime != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.PingTime))
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AccessHash))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Seq))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if m.Disconnect {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		if m.Disconnect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionQueryByKeyidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByKeyidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n2, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *SessionQueryByKeyidResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByKeyidResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	if m.Info != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Info.Size()))
		n3, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *SessionQueryByPhoneReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByPhoneReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n4, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *SessionQueryByPhoneResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionQueryByPhoneResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	if len(m.Infos) > 0 {
		for _, msg := range m.Infos {
			dAtA[i] = 0x12
			i++
			i = encodeVarintAccount(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SessionIncQtsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionIncQtsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n5, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *SessionIncQtsResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionIncQtsResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	if m.Qts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Qts))
	}
	return i, nil
}

func (m *SessionUpdateInitConnectionReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateInitConnectionReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ApiId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.ApiId))
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Layer))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n6, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	return i, nil
}

func (m *SessionUpdateInitConnectionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateInitConnectionResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionUpdateRegisterDeviceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateRegisterDeviceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PushTokenType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.PushTokenType))
	}
	if len(m.PushToken) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PushToken)))
		i += copy(dAtA[i:], m.PushToken)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n7, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.CallTokenType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CallTokenType))
	}
	if len(m.CallToken) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.CallToken)))
		i += copy(dAtA[i:], m.CallToken)
	}
	return i, nil
}

func (m *SessionUpdateRegisterDeviceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateRegisterDeviceResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionUpdateSignInReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateSignInReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n8, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AccessHash))
	}
	return i, nil
}

func (m *SessionUpdateSignInResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateSignInResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionUpdatePingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdatePingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.PingTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.PingTime))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n9, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UpdateTime {
		dAtA[i] = 0x28
		i++
		if m.UpdateTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SessionUpdatePingResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdatePingResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	return i, nil
}

func (m *SessionUpdateLogoutReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateLogoutReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n10, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	return i, nil
}

func (m *SessionUpdateLogoutResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdateLogoutResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionTerminateByKeyidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateByKeyidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n11, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.CurrentKeyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CurrentKeyId))
	}
	return i, nil
}

func (m *SessionTerminateByKeyidResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateByKeyidResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *SessionTerminateExceptKeyidReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateExceptKeyidReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n12, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.PhoneNumber) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneNumber)))
		i += copy(dAtA[i:], m.PhoneNumber)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *SessionTerminateExceptKeyidResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateExceptKeyidResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Code))
	}
	return i, nil
}

func (m *CheckUserIdAndAccessHashReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUserIdAndAccessHashReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n13, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *CheckUserIdAndAccessHashResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckUserIdAndAccessHashResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Match {
		dAtA[i] = 0x8
		i++
		if m.Match {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InternalError {
		dAtA[i] = 0x10
		i++
		if m.InternalError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PasswordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PasswordReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Flags))
	}
	if len(m.CurrPwdHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.CurrPwdHash)))
		i += copy(dAtA[i:], m.CurrPwdHash)
	}
	if len(m.NewPwdHash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.NewPwdHash)))
		i += copy(dAtA[i:], m.NewPwdHash)
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if len(m.Hint) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Hint)))
		i += copy(dAtA[i:], m.Hint)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.ReqType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.ReqType))
	}
	if m.Debug != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n14, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *PtPasswordReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PtPasswordReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Flags))
	}
	if len(m.CurrPwdHash) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.CurrPwdHash)))
		i += copy(dAtA[i:], m.CurrPwdHash)
	}
	if len(m.NewPwdHash) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.NewPwdHash)))
		i += copy(dAtA[i:], m.NewPwdHash)
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if len(m.Hint) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Hint)))
		i += copy(dAtA[i:], m.Hint)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.ReqType != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.ReqType))
	}
	if m.Debug != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n15, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.CodeCheckOnly {
		dAtA[i] = 0x58
		i++
		if m.CodeCheckOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.PhoneCode) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneCode)))
		i += copy(dAtA[i:], m.PhoneCode)
	}
	if len(m.PhoneCodeHash) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PhoneCodeHash)))
		i += copy(dAtA[i:], m.PhoneCodeHash)
	}
	return i, nil
}

func (m *PasswordRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PasswordRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PwdHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PwdHash)))
		i += copy(dAtA[i:], m.PwdHash)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Hint) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Hint)))
		i += copy(dAtA[i:], m.Hint)
	}
	if len(m.Salt) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Salt)))
		i += copy(dAtA[i:], m.Salt)
	}
	if m.InternalError {
		dAtA[i] = 0x28
		i++
		if m.InternalError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EmailUnconfirmed {
		dAtA[i] = 0x30
		i++
		if m.EmailUnconfirmed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *BoolResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BoolResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ret {
		dAtA[i] = 0x8
		i++
		if m.Ret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InternalError {
		dAtA[i] = 0x10
		i++
		if m.InternalError {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ECode != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.ECode))
	}
	return i, nil
}

func (m *IntResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IntResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ret != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Ret))
	}
	return i, nil
}

func (m *UserInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FirstName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n16, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *UserInfoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserInfoRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n17, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *GroupIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Type))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n18, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *GroupIdRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupIdRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.GroupId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AccessHash))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n19, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *IdAssiginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdAssiginReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *IdAssiginRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdAssiginRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Id))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AccessHash))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *Session) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Session) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.SessionId))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AccessHash))
	}
	if m.Status != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Status))
	}
	if m.Layer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Layer))
	}
	if m.Seq != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Seq))
	}
	if m.Qts != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Qts))
	}
	if m.LogoutTime != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.LogoutTime))
	}
	if m.CurrentStatus != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CurrentStatus))
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if m.DeviceTp != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.DeviceTp))
	}
	if len(m.SystemVer) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.SystemVer)))
		i += copy(dAtA[i:], m.SystemVer)
	}
	if len(m.AppVer) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AppVer)))
		i += copy(dAtA[i:], m.AppVer)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if m.ApiId != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.ApiId))
	}
	if len(m.AppName) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.AppName)))
		i += copy(dAtA[i:], m.AppName)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if len(m.LoginCountry) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.LoginCountry)))
		i += copy(dAtA[i:], m.LoginCountry)
	}
	if len(m.LoginRegion) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.LoginRegion)))
		i += copy(dAtA[i:], m.LoginRegion)
	}
	if len(m.PushToken) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.PushToken)))
		i += copy(dAtA[i:], m.PushToken)
	}
	if m.PushTokenTp != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.PushTokenTp))
	}
	if len(m.CallToken) > 0 {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.CallToken)))
		i += copy(dAtA[i:], m.CallToken)
	}
	if m.CallTokenTp != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CallTokenTp))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CreateTime))
	}
	if m.LastTime != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.LastTime))
	}
	if m.Debug != nil {
		dAtA[i] = 0xea
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n20, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *SessionArray) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionArray) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, msg := range m.Sessions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccount(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SessionUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Session != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Session.Size()))
		n21, err := m.Session.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Type))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n22, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *SessionsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		dAtA24 := make([]byte, len(m.Uids)*10)
		var j23 int
		for _, num1 := range m.Uids {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA24[j23] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j23++
			}
			dAtA24[j23] = uint8(num)
			j23++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(j23))
		i += copy(dAtA[i:], dAtA24[:j23])
	}
	if m.Debug != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n25, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *SessionsStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionsStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.CurrentStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CurrentStatus))
	}
	return i, nil
}

func (m *SessionsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ss) > 0 {
		for _, msg := range m.Ss {
			dAtA[i] = 0xa
			i++
			i = encodeVarintAccount(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SessionTerminateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Session != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Session.Size()))
		n26, err := m.Session.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Type))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n27, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *SessionTerminateRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionTerminateRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ret {
		dAtA[i] = 0x8
		i++
		if m.Ret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	if len(m.Keys) > 0 {
		dAtA29 := make([]byte, len(m.Keys)*10)
		var j28 int
		for _, num1 := range m.Keys {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA29[j28] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j28++
			}
			dAtA29[j28] = uint8(num)
			j28++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(j28))
		i += copy(dAtA[i:], dAtA29[:j28])
	}
	return i, nil
}

func (m *Authorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Authorization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	if m.AuthId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.AuthId))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.DcId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.DcId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Debug.Size()))
		n30, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *CheckCodeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckCodeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SendType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.SendType))
	}
	if m.BusinessType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.BusinessType))
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.UserId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.UserId))
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if m.CodeLen != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.CodeLen))
	}
	if len(m.CodeHash) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.CodeHash)))
		i += copy(dAtA[i:], m.CodeHash)
	}
	if m.ResendFlag {
		dAtA[i] = 0x48
		i++
		if m.ResendFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.KeyId))
	}
	return i, nil
}

func (m *CheckCodeRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckCodeRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Right {
		dAtA[i] = 0x8
		i++
		if m.Right {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Code) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	if len(m.CodeHash) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.CodeHash)))
		i += copy(dAtA[i:], m.CodeHash)
	}
	if len(m.Desc) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Desc)))
		i += copy(dAtA[i:], m.Desc)
	}
	return i, nil
}

func (m *SetResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ret {
		dAtA[i] = 0x8
		i++
		if m.Ret {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Str) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAccount(dAtA, i, uint64(len(m.Str)))
		i += copy(dAtA[i:], m.Str)
	}
	if m.Num != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAccount(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func encodeVarintAccount(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetUniqueNumberByKeyIdReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	return n
}

func (m *GetUniqueNumberByKeyIdResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionDisconnectReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Disconnect {
		n += 2
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionDisconnectResult) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SessionQueryApiIDbyKeyidReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	return n
}

func (m *SessionQueryApiIDbyKeyidResult) Size() (n int) {
	var l int
	_ = l
	if m.ApiId != 0 {
		n += 1 + sovAccount(uint64(m.ApiId))
	}
	if m.InternalError {
		n += 2
	}
	return n
}

func (m *SessionUpdateOnHandshakeDoneReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionUpdateOnHandshakeDoneResult) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	return n
}

func (m *SessionQueryByUseridReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SessionQueryByUseridResult) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SessionQueryUseridByKeyidReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionQueryUseridByKeyidResult) Size() (n int) {
	var l int
	_ = l
	if m.InternalError {
		n += 2
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	return n
}

func (m *SessionInformation) Size() (n int) {
	var l int
	_ = l
	if m.ApiId != 0 {
		n += 1 + sovAccount(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovAccount(uint64(m.Layer))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Qts != 0 {
		n += 1 + sovAccount(uint64(m.Qts))
	}
	if m.PushTokenType != 0 {
		n += 1 + sovAccount(uint64(m.PushTokenType))
	}
	l = len(m.PushToken)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.CallTokenType != 0 {
		n += 1 + sovAccount(uint64(m.CallTokenType))
	}
	l = len(m.CallToken)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.PingTime != 0 {
		n += 1 + sovAccount(uint64(m.PingTime))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.UserId != 0 {
		n += 2 + sovAccount(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 2 + sovAccount(uint64(m.AccessHash))
	}
	if m.Seq != 0 {
		n += 2 + sovAccount(uint64(m.Seq))
	}
	if m.KeyId != 0 {
		n += 2 + sovAccount(uint64(m.KeyId))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.Disconnect {
		n += 3
	}
	return n
}

func (m *SessionQueryByKeyidReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionQueryByKeyidResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionQueryByPhoneReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionQueryByPhoneResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *SessionIncQtsReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionIncQtsResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	if m.Qts != 0 {
		n += 1 + sovAccount(uint64(m.Qts))
	}
	return n
}

func (m *SessionUpdateInitConnectionReq) Size() (n int) {
	var l int
	_ = l
	if m.ApiId != 0 {
		n += 1 + sovAccount(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovAccount(uint64(m.Layer))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionUpdateInitConnectionResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	return n
}

func (m *SessionUpdateRegisterDeviceReq) Size() (n int) {
	var l int
	_ = l
	if m.PushTokenType != 0 {
		n += 1 + sovAccount(uint64(m.PushTokenType))
	}
	l = len(m.PushToken)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.CallTokenType != 0 {
		n += 1 + sovAccount(uint64(m.CallTokenType))
	}
	l = len(m.CallToken)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionUpdateRegisterDeviceResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	return n
}

func (m *SessionUpdateSignInReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovAccount(uint64(m.AccessHash))
	}
	return n
}

func (m *SessionUpdateSignInResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	return n
}

func (m *SessionUpdatePingReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.PingTime != 0 {
		n += 1 + sovAccount(uint64(m.PingTime))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.UpdateTime {
		n += 2
	}
	return n
}

func (m *SessionUpdatePingResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionUpdateLogoutReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionUpdateLogoutResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	return n
}

func (m *SessionTerminateByKeyidReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.CurrentKeyId != 0 {
		n += 1 + sovAccount(uint64(m.CurrentKeyId))
	}
	return n
}

func (m *SessionTerminateByKeyidResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	return n
}

func (m *SessionTerminateExceptKeyidReq) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PhoneNumber)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	return n
}

func (m *SessionTerminateExceptKeyidResult) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovAccount(uint64(m.Code))
	}
	return n
}

func (m *CheckUserIdAndAccessHashReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovAccount(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CheckUserIdAndAccessHashResult) Size() (n int) {
	var l int
	_ = l
	if m.Match {
		n += 2
	}
	if m.InternalError {
		n += 2
	}
	return n
}

func (m *PasswordReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Flags != 0 {
		n += 1 + sovAccount(uint64(m.Flags))
	}
	l = len(m.CurrPwdHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.NewPwdHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Hint)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.ReqType != 0 {
		n += 1 + sovAccount(uint64(m.ReqType))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *PtPasswordReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.Flags != 0 {
		n += 1 + sovAccount(uint64(m.Flags))
	}
	l = len(m.CurrPwdHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.NewPwdHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Hint)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.ReqType != 0 {
		n += 1 + sovAccount(uint64(m.ReqType))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.CodeCheckOnly {
		n += 2
	}
	l = len(m.PhoneCode)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.PhoneCodeHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *PasswordRsp) Size() (n int) {
	var l int
	_ = l
	l = len(m.PwdHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Hint)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.InternalError {
		n += 2
	}
	if m.EmailUnconfirmed {
		n += 2
	}
	return n
}

func (m *BoolResult) Size() (n int) {
	var l int
	_ = l
	if m.Ret {
		n += 2
	}
	if m.InternalError {
		n += 2
	}
	if m.ECode != 0 {
		n += 1 + sovAccount(uint64(m.ECode))
	}
	return n
}

func (m *IntResult) Size() (n int) {
	var l int
	_ = l
	if m.Ret != 0 {
		n += 1 + sovAccount(uint64(m.Ret))
	}
	return n
}

func (m *UserInfoReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *UserInfoRsp) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovAccount(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GroupIdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.Type != 0 {
		n += 1 + sovAccount(uint64(m.Type))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *GroupIdRsp) Size() (n int) {
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovAccount(uint64(m.GroupId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovAccount(uint64(m.AccessHash))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *IdAssiginReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.Type != 0 {
		n += 1 + sovAccount(uint64(m.Type))
	}
	return n
}

func (m *IdAssiginRsp) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAccount(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovAccount(uint64(m.AccessHash))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	return n
}

func (m *Session) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.SessionId != 0 {
		n += 1 + sovAccount(uint64(m.SessionId))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.AccessHash != 0 {
		n += 1 + sovAccount(uint64(m.AccessHash))
	}
	if m.Status != 0 {
		n += 1 + sovAccount(uint64(m.Status))
	}
	if m.Layer != 0 {
		n += 1 + sovAccount(uint64(m.Layer))
	}
	if m.Seq != 0 {
		n += 1 + sovAccount(uint64(m.Seq))
	}
	if m.Qts != 0 {
		n += 1 + sovAccount(uint64(m.Qts))
	}
	if m.LogoutTime != 0 {
		n += 1 + sovAccount(uint64(m.LogoutTime))
	}
	if m.CurrentStatus != 0 {
		n += 1 + sovAccount(uint64(m.CurrentStatus))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.DeviceTp != 0 {
		n += 1 + sovAccount(uint64(m.DeviceTp))
	}
	l = len(m.SystemVer)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.AppVer)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.ApiId != 0 {
		n += 2 + sovAccount(uint64(m.ApiId))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	l = len(m.LoginCountry)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	l = len(m.LoginRegion)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	l = len(m.PushToken)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.PushTokenTp != 0 {
		n += 2 + sovAccount(uint64(m.PushTokenTp))
	}
	l = len(m.CallToken)
	if l > 0 {
		n += 2 + l + sovAccount(uint64(l))
	}
	if m.CallTokenTp != 0 {
		n += 2 + sovAccount(uint64(m.CallTokenTp))
	}
	if m.CreateTime != 0 {
		n += 2 + sovAccount(uint64(m.CreateTime))
	}
	if m.LastTime != 0 {
		n += 2 + sovAccount(uint64(m.LastTime))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 2 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionArray) Size() (n int) {
	var l int
	_ = l
	if len(m.Sessions) > 0 {
		for _, e := range m.Sessions {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *SessionUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAccount(uint64(m.Type))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionsReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovAccount(uint64(e))
		}
		n += 1 + sovAccount(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionsStatus) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.CurrentStatus != 0 {
		n += 1 + sovAccount(uint64(m.CurrentStatus))
	}
	return n
}

func (m *SessionsRsp) Size() (n int) {
	var l int
	_ = l
	if len(m.Ss) > 0 {
		for _, e := range m.Ss {
			l = e.Size()
			n += 1 + l + sovAccount(uint64(l))
		}
	}
	return n
}

func (m *SessionTerminateReq) Size() (n int) {
	var l int
	_ = l
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAccount(uint64(m.Type))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SessionTerminateRsp) Size() (n int) {
	var l int
	_ = l
	if m.Ret {
		n += 2
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovAccount(uint64(e))
		}
		n += 1 + sovAccount(uint64(l)) + l
	}
	return n
}

func (m *Authorization) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	if m.AuthId != 0 {
		n += 1 + sovAccount(uint64(m.AuthId))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.DcId != 0 {
		n += 1 + sovAccount(uint64(m.DcId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *CheckCodeReq) Size() (n int) {
	var l int
	_ = l
	if m.SendType != 0 {
		n += 1 + sovAccount(uint64(m.SendType))
	}
	if m.BusinessType != 0 {
		n += 1 + sovAccount(uint64(m.BusinessType))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovAccount(uint64(m.UserId))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.CodeLen != 0 {
		n += 1 + sovAccount(uint64(m.CodeLen))
	}
	l = len(m.CodeHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.ResendFlag {
		n += 2
	}
	if m.KeyId != 0 {
		n += 1 + sovAccount(uint64(m.KeyId))
	}
	return n
}

func (m *CheckCodeRsp) Size() (n int) {
	var l int
	_ = l
	if m.Right {
		n += 2
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.CodeHash)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	l = len(m.Desc)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	return n
}

func (m *SetResult) Size() (n int) {
	var l int
	_ = l
	if m.Ret {
		n += 2
	}
	l = len(m.Str)
	if l > 0 {
		n += 1 + l + sovAccount(uint64(l))
	}
	if m.Num != 0 {
		n += 1 + sovAccount(uint64(m.Num))
	}
	return n
}

func sovAccount(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAccount(x uint64) (n int) {
	return sovAccount(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetUniqueNumberByKeyIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUniqueNumberByKeyIdResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUniqueNumberByKeyIdResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDisconnectReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDisconnectReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDisconnectReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disconnect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disconnect = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionDisconnectResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionDisconnectResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionDisconnectResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryApiIDbyKeyidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryApiIDbyKeyidResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyidResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryApiIDbyKeyidResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalError = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateOnHandshakeDoneReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateOnHandshakeDoneResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateOnHandshakeDoneResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateOnHandshakeDoneResult_FailCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByUseridReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByUseridReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByUseridReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByUseridResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByUseridResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByUseridResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryUseridByKeyidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryUseridByKeyidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryUseridByKeyidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryUseridByKeyidResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryUseridByKeyidResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryUseridByKeyidResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalError = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionInformation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionInformation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionInformation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTokenType", wireType)
			}
			m.PushTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallTokenType", wireType)
			}
			m.CallTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingTime", wireType)
			}
			m.PingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disconnect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disconnect = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByKeyidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByKeyidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByKeyidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByKeyidResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByKeyidResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByKeyidResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionQueryByKeyidResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SessionInformation{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByPhoneReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByPhoneReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByPhoneReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionQueryByPhoneResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionQueryByPhoneResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionQueryByPhoneResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionQueryByPhoneResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &SessionInformation{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionIncQtsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionIncQtsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionIncQtsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionIncQtsResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionIncQtsResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionIncQtsResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionIncQtsResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateInitConnectionReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateInitConnectionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateInitConnectionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateInitConnectionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateInitConnectionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateInitConnectionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateInitConnectionResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateRegisterDeviceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTokenType", wireType)
			}
			m.PushTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallTokenType", wireType)
			}
			m.CallTokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallTokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateRegisterDeviceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateRegisterDeviceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateRegisterDeviceResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateSignInReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateSignInReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateSignInReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateSignInResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateSignInResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateSignInResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateSignInResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdatePingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdatePingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdatePingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingTime", wireType)
			}
			m.PingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateTime = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdatePingResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdatePingResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdatePingResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdatePingResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateLogoutReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateLogoutReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateLogoutReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdateLogoutResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdateLogoutResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdateLogoutResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionUpdateLogoutResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateByKeyidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateByKeyidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateByKeyidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentKeyId", wireType)
			}
			m.CurrentKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentKeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateByKeyidResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateByKeyidResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateByKeyidResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionTerminateByKeyidResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateExceptKeyidReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyidReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyidReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateExceptKeyidResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyidResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateExceptKeyidResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (SessionTerminateExceptKeyidResult_ResultCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUserIdAndAccessHashReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUserIdAndAccessHashReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUserIdAndAccessHashReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckUserIdAndAccessHashResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckUserIdAndAccessHashResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckUserIdAndAccessHashResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Match = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalError = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrPwdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrPwdHash = append(m.CurrPwdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CurrPwdHash == nil {
				m.CurrPwdHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPwdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPwdHash = append(m.NewPwdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.NewPwdHash == nil {
				m.NewPwdHash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = append(m.Salt[:0], dAtA[iNdEx:postIndex]...)
			if m.Salt == nil {
				m.Salt = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqType", wireType)
			}
			m.ReqType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PtPasswordReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PtPasswordReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PtPasswordReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrPwdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrPwdHash = append(m.CurrPwdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.CurrPwdHash == nil {
				m.CurrPwdHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPwdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewPwdHash = append(m.NewPwdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.NewPwdHash == nil {
				m.NewPwdHash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = append(m.Salt[:0], dAtA[iNdEx:postIndex]...)
			if m.Salt == nil {
				m.Salt = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqType", wireType)
			}
			m.ReqType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeCheckOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CodeCheckOnly = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhoneCodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhoneCodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PasswordRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PasswordRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PasswordRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PwdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PwdHash = append(m.PwdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PwdHash == nil {
				m.PwdHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = append(m.Salt[:0], dAtA[iNdEx:postIndex]...)
			if m.Salt == nil {
				m.Salt = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalError = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmailUnconfirmed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmailUnconfirmed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BoolResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BoolResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BoolResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ret = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalError", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InternalError = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ECode", wireType)
			}
			m.ECode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ECode |= (BoolResult_ErrorCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IntResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IntResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IntResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			m.Ret = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ret |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserInfoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserInfoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserInfoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupIdRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupIdRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupIdRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdAssiginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdAssiginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdAssiginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdAssiginRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdAssiginRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdAssiginRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Session) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Session: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Session: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogoutTime", wireType)
			}
			m.LogoutTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogoutTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStatus", wireType)
			}
			m.CurrentStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceTp", wireType)
			}
			m.DeviceTp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeviceTp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginCountry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginCountry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PushToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushTokenTp", wireType)
			}
			m.PushTokenTp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PushTokenTp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallTokenTp", wireType)
			}
			m.CallTokenTp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallTokenTp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTime", wireType)
			}
			m.LastTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionArray) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionArray: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionArray: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sessions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sessions = append(m.Sessions, &Session{})
			if err := m.Sessions[len(m.Sessions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SessionUpdate_UpdateType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccount
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccount
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAccount
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccount
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionsStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionsStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionsStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentStatus", wireType)
			}
			m.CurrentStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentStatus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ss", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ss = append(m.Ss, &SessionsStatus{})
			if err := m.Ss[len(m.Ss)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &Session{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SessionTerminateReq_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionTerminateRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionTerminateRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionTerminateRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ret = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccount
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAccount
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAccount
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAccount
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Authorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Authorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Authorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckCodeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckCodeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckCodeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendType", wireType)
			}
			m.SendType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessType", wireType)
			}
			m.BusinessType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BusinessType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeLen", wireType)
			}
			m.CodeLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CodeLen |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResendFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ResendFlag = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckCodeRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckCodeRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckCodeRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Right = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ret", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ret = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Str", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAccount
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Str = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAccount(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAccount
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAccount(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAccount
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAccount
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAccount
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAccount
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAccount(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAccount = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAccount   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/infoserver/account.proto", fileDescriptorAccount)
}

var fileDescriptorAccount = []byte{
	// 3147 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5a, 0xcd, 0x8f, 0x1b, 0x49,
	0x15, 0x77, 0xfb, 0x6b, 0xec, 0x67, 0x7b, 0xe2, 0x54, 0x26, 0x89, 0xe3, 0x24, 0x93, 0xa4, 0xb3,
	0xbb, 0x84, 0xec, 0xee, 0x64, 0x99, 0x0d, 0xec, 0x22, 0x24, 0xd0, 0x64, 0x66, 0x92, 0x58, 0x9b,
	0x4d, 0x66, 0x7b, 0x66, 0x10, 0x42, 0xb0, 0xa6, 0xc7, 0x5d, 0x63, 0xb7, 0xc6, 0xee, 0x6e, 0x77,
	0xb7, 0x93, 0xf5, 0x02, 0x57, 0xc4, 0x01, 0x09, 0x09, 0x09, 0x2d, 0x1c, 0x10, 0x37, 0x38, 0x03,
	0x27, 0xf6, 0x86, 0x10, 0x12, 0x07, 0x0e, 0x08, 0x24, 0xce, 0x68, 0x8f, 0xfc, 0x0b, 0x5c, 0x50,
	0xbd, 0xaa, 0xfe, 0xfe, 0x18, 0x9b, 0x59, 0x84, 0x84, 0x38, 0xd9, 0xfd, 0xaa, 0xea, 0x55, 0xbd,
	0xdf, 0xfb, 0xa8, 0x57, 0xaf, 0x0a, 0xde, 0x1d, 0xea, 0xee, 0x58, 0x3d, 0xda, 0x18, 0x8c, 0x54,
	0xd7, 0xa1, 0xf6, 0x73, 0x6a, 0x6f, 0xe8, 0x93, 0x7b, 0xba, 0xe1, 0x52, 0xfb, 0x58, 0x1d, 0x50,
	0xcb, 0x36, 0x8f, 0x66, 0xc7, 0xf7, 0x2c, 0xd3, 0x55, 0x5d, 0xd3, 0xb2, 0x4d, 0x97, 0x7d, 0x3a,
	0xf7, 0x74, 0xe3, 0xd8, 0xe4, 0xbd, 0xef, 0xa9, 0x83, 0x81, 0x39, 0x33, 0xdc, 0x0d, 0x6c, 0x24,
	0x10, 0xb4, 0x74, 0x1f, 0xff, 0x5b, 0xac, 0xad, 0xa3, 0x81, 0x39, 0x99, 0x88, 0x1f, 0xce, 0x55,
	0xde, 0x84, 0x2b, 0x8f, 0xa8, 0x7b, 0x68, 0xe8, 0xd3, 0x19, 0x7d, 0x3a, 0x9b, 0x1c, 0x51, 0xfb,
	0xc1, 0xfc, 0x1d, 0x3a, 0xef, 0x69, 0x0a, 0x9d, 0x92, 0x8b, 0x50, 0x3d, 0xa1, 0xf3, 0xbe, 0xae,
	0x75, 0xa4, 0x9b, 0xd2, 0x9d, 0x92, 0x52, 0x39, 0x61, 0x2d, 0xf2, 0x36, 0x5c, 0xcb, 0x1a, 0xe3,
	0xcc, 0xc6, 0x2e, 0xb9, 0x0d, 0xad, 0x19, 0x36, 0xf6, 0x0d, 0x6c, 0xc5, 0xd1, 0x75, 0xa5, 0x39,
	0x0b, 0x8d, 0x90, 0x7f, 0x29, 0xc1, 0xda, 0x3e, 0x75, 0x1c, 0xdd, 0x34, 0x76, 0x74, 0x67, 0x60,
	0x1a, 0x06, 0x1d, 0xb8, 0xc9, 0x49, 0xcb, 0x62, 0x52, 0x72, 0x0b, 0x9a, 0xd6, 0xc8, 0x34, 0x7c,
	0x9e, 0x45, 0xe4, 0xd9, 0x40, 0x1a, 0x67, 0x49, 0xd6, 0x01, 0x34, 0x9f, 0x55, 0xa7, 0x74, 0x53,
	0xba, 0x53, 0x53, 0x42, 0x14, 0x72, 0x15, 0xea, 0x83, 0xb1, 0x4e, 0x0d, 0xb7, 0xaf, 0x5b, 0x9d,
	0x32, 0x8e, 0xaf, 0x71, 0x42, 0xcf, 0x22, 0x1d, 0x58, 0x41, 0xb4, 0xed, 0x79, 0xa7, 0x82, 0x4d,
	0xde, 0xa7, 0x7c, 0x05, 0x2e, 0xa7, 0x2c, 0x94, 0x49, 0x2a, 0xdf, 0x87, 0xab, 0xa2, 0xe9, 0xbd,
	0x19, 0xb5, 0xe7, 0x5b, 0x96, 0xde, 0xdb, 0x39, 0x62, 0x58, 0xe8, 0x5a, 0xb6, 0x28, 0xf2, 0xfb,
	0xb0, 0x9e, 0x3d, 0x0a, 0x11, 0xbc, 0x08, 0x55, 0xd5, 0xd2, 0xbd, 0x81, 0x15, 0xa5, 0xa2, 0x5a,
	0x7a, 0x4f, 0x23, 0x2f, 0xc3, 0x2a, 0xea, 0xd8, 0x50, 0xc7, 0x7d, 0x6a, 0xdb, 0x26, 0x47, 0xa1,
	0xa6, 0xb4, 0x3c, 0xea, 0x2e, 0x23, 0xca, 0xfb, 0x70, 0x43, 0xf0, 0x3f, 0xb4, 0x34, 0xd5, 0xa5,
	0xcf, 0x8c, 0xc7, 0xaa, 0xa1, 0x39, 0x23, 0xf5, 0x84, 0xee, 0x98, 0x06, 0xcd, 0x01, 0xf9, 0x0a,
	0xd4, 0xd4, 0x99, 0x3b, 0xea, 0x9f, 0xd0, 0x39, 0xb2, 0x6e, 0x2a, 0x2b, 0xec, 0xfb, 0x1d, 0x3a,
	0x97, 0x7f, 0x2b, 0x81, 0x9c, 0xcf, 0x15, 0x57, 0xde, 0x81, 0x15, 0x67, 0x36, 0x18, 0x50, 0xc7,
	0x41, 0xce, 0x35, 0xc5, 0xfb, 0x24, 0xef, 0x40, 0x79, 0x60, 0x6a, 0x14, 0xf9, 0xae, 0x6e, 0xbe,
	0xb5, 0x11, 0x98, 0xf3, 0xc6, 0xe9, 0x7c, 0x37, 0x1e, 0xaa, 0xfa, 0x78, 0xdb, 0xd4, 0xa8, 0x82,
	0x4c, 0xe4, 0xd7, 0xa0, 0xe6, 0x51, 0x48, 0x13, 0x6a, 0x3d, 0x21, 0x7f, 0xbb, 0x40, 0x08, 0xac,
	0xee, 0xcc, 0xac, 0xb1, 0x3e, 0x50, 0x5d, 0x8a, 0x90, 0xb6, 0xa5, 0x90, 0x06, 0x11, 0xf0, 0x07,
	0xf3, 0x43, 0x87, 0xda, 0xa8, 0x22, 0xf9, 0x1a, 0x74, 0xd3, 0x9b, 0x50, 0xbf, 0x5f, 0x87, 0x6b,
	0xe1, 0x56, 0xde, 0xf6, 0xe0, 0x34, 0x05, 0x93, 0xdb, 0x50, 0xd1, 0xe8, 0xd1, 0x6c, 0x88, 0xb2,
	0x36, 0x36, 0x5b, 0x1b, 0xc2, 0xe5, 0x76, 0x18, 0x51, 0xe1, 0x6d, 0xb2, 0xea, 0x6b, 0x29, 0x8d,
	0x37, 0x82, 0x99, 0xd4, 0xb7, 0x94, 0xa2, 0x6f, 0x72, 0x19, 0x56, 0x66, 0x0e, 0xb5, 0xd9, 0x32,
	0x8a, 0x68, 0x2e, 0x55, 0xf6, 0xd9, 0xd3, 0xe4, 0x1f, 0x54, 0x80, 0x88, 0x39, 0x7a, 0xc6, 0xb1,
	0x69, 0x4f, 0x54, 0x57, 0x37, 0x8d, 0x2c, 0xeb, 0xba, 0x05, 0x4d, 0x8d, 0x3e, 0xd7, 0x07, 0xb4,
	0x3f, 0x31, 0x35, 0x3a, 0xf6, 0x3c, 0x8c, 0xd3, 0xde, 0x65, 0x24, 0xb6, 0x20, 0x67, 0xee, 0xb8,
	0x74, 0xd2, 0x7f, 0x4e, 0x6d, 0xc6, 0x16, 0xbd, 0xac, 0xae, 0xb4, 0x38, 0xf5, 0xab, 0x9c, 0x48,
	0x6e, 0x40, 0x43, 0xb5, 0x2c, 0xbf, 0x0f, 0x77, 0x35, 0x50, 0x2d, 0xcb, 0xeb, 0x70, 0x15, 0xea,
	0x63, 0xd5, 0x18, 0xf6, 0xd1, 0x20, 0xb8, 0xbb, 0xd5, 0x18, 0x01, 0xf5, 0xb9, 0x0a, 0x45, 0xdd,
	0xea, 0x54, 0x91, 0x5a, 0xd4, 0x23, 0x9e, 0xb9, 0x12, 0xf1, 0x4c, 0xb2, 0x06, 0x95, 0xb1, 0x3a,
	0xa7, 0x76, 0xa7, 0xc6, 0xe5, 0xc0, 0x8f, 0x88, 0x11, 0xd7, 0x23, 0x46, 0x4c, 0xda, 0x50, 0x9a,
	0xba, 0x4e, 0x07, 0xb0, 0x3b, 0xfb, 0x4b, 0x5e, 0x81, 0x73, 0xd6, 0xcc, 0x19, 0xf5, 0x5d, 0xf3,
	0x84, 0x1a, 0x7d, 0x77, 0x6e, 0xd1, 0x4e, 0x03, 0x5b, 0x5b, 0x8c, 0x7c, 0xc0, 0xa8, 0x07, 0x73,
	0x8b, 0x92, 0xeb, 0x00, 0x41, 0xbf, 0x4e, 0x13, 0xd7, 0x51, 0xf7, 0xbb, 0x30, 0x36, 0x03, 0x75,
	0x3c, 0x0e, 0xb3, 0x69, 0x71, 0x36, 0x8c, 0x1c, 0x61, 0x13, 0xf4, 0xeb, 0xac, 0x72, 0x36, 0x7e,
	0x17, 0x86, 0x8b, 0xa5, 0x1b, 0xc3, 0xbe, 0xab, 0x4f, 0x68, 0xe7, 0x1c, 0xc6, 0xdc, 0x1a, 0x23,
	0x1c, 0xe8, 0x13, 0x9a, 0x88, 0x80, 0xed, 0x64, 0x04, 0x0c, 0x59, 0xc2, 0xf9, 0xb0, 0x25, 0xa0,
	0x46, 0xd0, 0x0d, 0xfb, 0x23, 0xd5, 0x19, 0x75, 0x08, 0xb2, 0x06, 0x4e, 0x7a, 0xac, 0x3a, 0x23,
	0x86, 0x8c, 0x43, 0xa7, 0x9d, 0x0b, 0x1c, 0x19, 0x27, 0x62, 0xdb, 0x6b, 0xf1, 0x10, 0x61, 0x59,
	0x7d, 0x43, 0x9d, 0xd0, 0xce, 0x45, 0xae, 0x0e, 0xd5, 0xb2, 0x9e, 0xaa, 0x13, 0x1a, 0x8b, 0xbf,
	0x97, 0xe2, 0xf1, 0x57, 0x3e, 0x80, 0x4b, 0x51, 0x5f, 0xfb, 0x54, 0xfc, 0xe8, 0xf7, 0x12, 0x5c,
	0x49, 0x65, 0x8b, 0x2e, 0xb4, 0x23, 0xa2, 0x8e, 0x84, 0x51, 0xe7, 0x8d, 0x94, 0xa8, 0x93, 0x1c,
	0xb4, 0xc1, 0x7f, 0x82, 0x70, 0x43, 0x36, 0xa1, 0xcc, 0x06, 0x8a, 0x75, 0xac, 0xa7, 0x70, 0x09,
	0xf9, 0x97, 0x82, 0x7d, 0xe5, 0xd7, 0x00, 0x02, 0x3e, 0xa4, 0x01, 0x2b, 0xfb, 0x3c, 0x10, 0xb6,
	0x0b, 0xe4, 0x3c, 0xb4, 0x7a, 0x61, 0x0f, 0x6e, 0x4b, 0xf2, 0xb7, 0xe2, 0xd8, 0xec, 0x8d, 0x44,
	0xa8, 0x8e, 0xab, 0x5d, 0x4a, 0xaa, 0x7d, 0x21, 0x9c, 0xfe, 0x90, 0xc0, 0x49, 0x4c, 0xb1, 0x1c,
	0x4e, 0xa1, 0x41, 0x49, 0x9c, 0xee, 0x43, 0x05, 0x07, 0x76, 0x8a, 0x37, 0x4b, 0x0b, 0x00, 0xc5,
	0x3b, 0x2f, 0x89, 0xd4, 0x53, 0x68, 0xfb, 0xac, 0x06, 0xef, 0xb9, 0xce, 0x59, 0xed, 0xe7, 0xc7,
	0x12, 0x5c, 0x88, 0x31, 0x44, 0x44, 0xbe, 0x1c, 0x41, 0xe4, 0x6e, 0xaa, 0x28, 0x41, 0xf7, 0x24,
	0x16, 0x22, 0xd6, 0x14, 0xfd, 0x58, 0xb3, 0xa4, 0x9c, 0x7f, 0x2b, 0xfa, 0x69, 0x02, 0xdf, 0x18,
	0x7b, 0x86, 0xee, 0x6e, 0x73, 0x57, 0x62, 0xe0, 0x71, 0xb1, 0xff, 0x97, 0x03, 0x79, 0xa0, 0xd5,
	0x7a, 0xaa, 0x56, 0x21, 0x5b, 0xab, 0x91, 0x30, 0xd5, 0x88, 0x84, 0x29, 0xf9, 0xe7, 0x12, 0xdc,
	0xca, 0x05, 0x16, 0xd5, 0xff, 0x24, 0xa2, 0xfe, 0xb7, 0x33, 0xd3, 0x95, 0xb4, 0xc1, 0x09, 0x63,
	0x58, 0x52, 0xf5, 0xff, 0x90, 0x62, 0xaa, 0x57, 0xe8, 0x50, 0x77, 0x5c, 0x6a, 0xef, 0xa0, 0x0a,
	0x99, 0xea, 0x53, 0xf6, 0x2d, 0xe9, 0xf4, 0x7d, 0xab, 0x18, 0xdf, 0xb7, 0x02, 0x88, 0x4b, 0xa9,
	0x10, 0x97, 0x73, 0x20, 0x4e, 0xd9, 0xf3, 0x2a, 0xa7, 0xef, 0x79, 0xd5, 0xd8, 0x9e, 0x97, 0x54,
	0x47, 0x5c, 0xd8, 0xa5, 0xd4, 0x91, 0x36, 0xf8, 0xac, 0xea, 0xf8, 0x95, 0xe4, 0x07, 0x67, 0x3e,
	0xc9, 0xbe, 0x3e, 0x34, 0x7a, 0xc6, 0x82, 0xc1, 0x39, 0x80, 0xb8, 0x98, 0x0a, 0x71, 0x29, 0x07,
	0xe2, 0xd0, 0x7e, 0x5e, 0xce, 0xdb, 0xcf, 0x2b, 0xf1, 0xfd, 0x5c, 0xfe, 0x61, 0x10, 0xed, 0xa3,
	0x6b, 0x5e, 0x30, 0xda, 0x27, 0x07, 0x9d, 0x15, 0xc5, 0xdf, 0x04, 0x07, 0x3e, 0xce, 0x7c, 0x4f,
	0x37, 0x86, 0x39, 0xc1, 0x3b, 0x92, 0x0b, 0x15, 0x63, 0xb9, 0xd0, 0x42, 0xe8, 0xc5, 0x95, 0x53,
	0x4e, 0x2a, 0xe7, 0x06, 0x34, 0x66, 0xb8, 0x18, 0x3e, 0x4d, 0x85, 0xe7, 0x2c, 0x9c, 0xc4, 0x26,
	0x92, 0xff, 0x2a, 0xf9, 0x67, 0x87, 0xf0, 0xaa, 0x11, 0xc5, 0x07, 0x11, 0x14, 0x37, 0x32, 0x51,
	0x0c, 0x86, 0x24, 0x77, 0x89, 0xac, 0xdc, 0x9d, 0x85, 0x44, 0x5c, 0xa8, 0x08, 0xcc, 0xfc, 0x43,
	0xde, 0x5d, 0x06, 0x72, 0x72, 0x19, 0x2e, 0x6c, 0xcd, 0xdc, 0xd1, 0x09, 0x9d, 0x1f, 0x1a, 0xb6,
	0x70, 0x0c, 0xaa, 0xb5, 0x8b, 0xf2, 0x8b, 0x98, 0x41, 0x3f, 0x31, 0x87, 0xe6, 0xcc, 0x3d, 0xe3,
	0x4e, 0x9a, 0xc0, 0xbb, 0x94, 0xc0, 0x3b, 0x69, 0x96, 0xde, 0xcc, 0x4b, 0x99, 0x65, 0x78, 0xd0,
	0x59, 0xcd, 0xf2, 0x63, 0xc9, 0x3f, 0x01, 0x1e, 0x50, 0x7b, 0xa2, 0x1b, 0xaa, 0x4b, 0x3f, 0x9d,
	0xcc, 0x74, 0x01, 0x3c, 0xb2, 0x1d, 0xfc, 0x25, 0x58, 0x1d, 0xcc, 0x6c, 0x9b, 0x1a, 0x6e, 0x5f,
	0xcc, 0x5f, 0xc1, 0xf9, 0x9b, 0x82, 0x8a, 0xf5, 0x16, 0xf9, 0x23, 0x09, 0xae, 0x67, 0x2e, 0x1e,
	0x21, 0x7d, 0x1c, 0x81, 0xf4, 0x7e, 0x0a, 0xa4, 0xe9, 0x03, 0xcf, 0x0a, 0xeb, 0x4f, 0x82, 0x2d,
	0xcc, 0x9f, 0x60, 0xf7, 0x83, 0x01, 0xb5, 0xdc, 0xff, 0x36, 0xb4, 0xe1, 0x0d, 0x27, 0x7d, 0x69,
	0x0b, 0x6e, 0x38, 0xd9, 0x83, 0xcf, 0x0a, 0xde, 0x77, 0xe0, 0xea, 0xf6, 0x88, 0x0e, 0x4e, 0x0e,
	0x71, 0xc1, 0x5b, 0x86, 0xb6, 0xe5, 0x07, 0x76, 0x06, 0x5c, 0x48, 0x32, 0x29, 0x6f, 0x57, 0x28,
	0x26, 0x4e, 0x79, 0x8b, 0x84, 0x4d, 0xf9, 0x9b, 0xb0, 0x9e, 0x3d, 0x3b, 0x62, 0xb3, 0x06, 0x95,
	0x89, 0xea, 0x0e, 0x46, 0xa2, 0x1c, 0xc1, 0x3f, 0x16, 0xad, 0x4e, 0x7d, 0x54, 0x84, 0xc6, 0x9e,
	0xea, 0x38, 0x2f, 0x4c, 0x5b, 0xcb, 0x95, 0x26, 0xba, 0x71, 0x7a, 0xd5, 0x47, 0x36, 0xf9, 0xf1,
	0x58, 0x1d, 0x3a, 0x28, 0x43, 0x45, 0xe1, 0x1f, 0x44, 0x86, 0x16, 0xf3, 0x8c, 0xbe, 0xf5, 0x42,
	0xe3, 0xc2, 0x97, 0xf1, 0xe4, 0xdf, 0x60, 0xc4, 0xbd, 0x17, 0x1a, 0x4a, 0x7f, 0x13, 0x9a, 0x06,
	0x7d, 0x11, 0x74, 0xa9, 0x60, 0x17, 0x30, 0xe8, 0x0b, 0xaf, 0x07, 0x81, 0xb2, 0xa3, 0x8e, 0x5d,
	0x4c, 0x52, 0x9a, 0x0a, 0xfe, 0x67, 0xb4, 0x91, 0x6e, 0xb8, 0x22, 0x65, 0xc5, 0xff, 0x6c, 0x0d,
	0x74, 0xa2, 0xea, 0x63, 0xcc, 0x57, 0xeb, 0x0a, 0xff, 0x60, 0x39, 0xa7, 0x4d, 0xa7, 0x3c, 0x13,
	0xaa, 0xe3, 0xe2, 0x56, 0x6c, 0x3a, 0xc5, 0x1c, 0x68, 0x91, 0x9c, 0x55, 0xfe, 0x7e, 0x09, 0x5a,
	0x7b, 0xee, 0xff, 0xb1, 0xc9, 0x4a, 0x36, 0x4d, 0x8d, 0xf6, 0x07, 0xcc, 0x32, 0xfb, 0xa6, 0x31,
	0x9e, 0x63, 0x5a, 0x5f, 0x53, 0x5a, 0x8c, 0x8c, 0xf6, 0xfa, 0xcc, 0x18, 0xcf, 0x31, 0xdf, 0xc5,
	0xc0, 0x80, 0xce, 0xeb, 0xd5, 0x69, 0x18, 0x05, 0x3d, 0x8f, 0xa5, 0xcd, 0x7e, 0x33, 0x97, 0xb4,
	0xc5, 0x0f, 0x3e, 0x7e, 0x1f, 0x4c, 0x9f, 0x3e, 0x96, 0x42, 0x46, 0xea, 0x58, 0x6c, 0xf9, 0x3e,
	0x34, 0x12, 0xaf, 0x29, 0x59, 0x02, 0x17, 0x5f, 0xde, 0x62, 0x58, 0x5e, 0x0f, 0x99, 0x52, 0x08,
	0x19, 0x0f, 0xc1, 0x72, 0x08, 0xc1, 0xa4, 0xd3, 0x54, 0xd2, 0x4a, 0x7c, 0xaf, 0xc2, 0x79, 0xe4,
	0xdb, 0x9f, 0x19, 0x03, 0xd3, 0x38, 0xd6, 0xed, 0x09, 0xd5, 0x50, 0x13, 0x35, 0xa5, 0x8d, 0x0d,
	0x87, 0x01, 0x5d, 0xfe, 0xa7, 0x04, 0xf0, 0xc0, 0x34, 0xc7, 0xc2, 0x5b, 0xdb, 0x50, 0xb2, 0xa9,
	0x2b, 0x7c, 0x95, 0xfd, 0x5d, 0xd0, 0x53, 0xc9, 0x5b, 0x50, 0x15, 0x38, 0x56, 0x31, 0x08, 0xde,
	0x0c, 0x07, 0xc1, 0x60, 0x82, 0x0d, 0xec, 0x8d, 0xc1, 0xae, 0x82, 0x08, 0xca, 0xdf, 0x86, 0xba,
	0x4f, 0x8b, 0x95, 0x67, 0x2f, 0xc0, 0xb9, 0x9e, 0xf1, 0x5c, 0x1d, 0xeb, 0x9a, 0x07, 0x6f, 0x5b,
	0x22, 0x6b, 0xd0, 0xde, 0x8d, 0x09, 0xd1, 0x2e, 0x92, 0x55, 0x00, 0xd4, 0xeb, 0xc3, 0xb1, 0x69,
	0x6a, 0xed, 0x12, 0xeb, 0xb5, 0xe7, 0x29, 0x69, 0xf7, 0x03, 0x4b, 0x67, 0xa9, 0x4c, 0x99, 0x9c,
	0x83, 0x06, 0x23, 0x08, 0xa6, 0xed, 0x8a, 0x7c, 0x1d, 0xea, 0x3d, 0xc3, 0x4d, 0xca, 0x5e, 0x41,
	0xd9, 0xe5, 0x9f, 0x49, 0xd0, 0xc0, 0xc8, 0x66, 0x1c, 0x9b, 0xcc, 0xc5, 0xae, 0x03, 0x1c, 0xeb,
	0xb6, 0xe3, 0xf2, 0xa3, 0x22, 0xcf, 0xdf, 0xeb, 0x48, 0xc1, 0x9a, 0x16, 0x1e, 0x70, 0xbd, 0xd6,
	0xa2, 0x77, 0xc0, 0x15, 0x8d, 0xa9, 0x39, 0x5a, 0xf6, 0x9e, 0xee, 0x1b, 0x7a, 0x25, 0x27, 0x08,
	0x8c, 0x43, 0xcb, 0x73, 0xac, 0xff, 0x74, 0xac, 0x7f, 0x1f, 0xe0, 0x91, 0x6d, 0xce, 0xac, 0x5e,
	0x7e, 0xb8, 0x21, 0x50, 0x46, 0xcf, 0xe5, 0x29, 0x2a, 0xfe, 0x5f, 0x8c, 0xff, 0xf7, 0xa4, 0x60,
	0x02, 0xee, 0x46, 0x43, 0xf6, 0x15, 0xcc, 0xb0, 0x32, 0xe4, 0xad, 0xa7, 0xcb, 0x13, 0x5a, 0x5c,
	0x29, 0x1d, 0xd6, 0x9c, 0xc3, 0xaa, 0xfc, 0x25, 0x68, 0xf6, 0xb4, 0x2d, 0xc7, 0xd1, 0x87, 0xba,
	0xb1, 0xac, 0xa8, 0xf2, 0xd7, 0xc2, 0x83, 0x1d, 0x0b, 0x0b, 0x1b, 0xde, 0x9d, 0x58, 0x51, 0x3f,
	0xc3, 0xda, 0xe5, 0x3f, 0x55, 0x61, 0x45, 0xa4, 0x13, 0x4b, 0x07, 0xfb, 0xeb, 0x00, 0x0e, 0x1f,
	0xea, 0xf1, 0x2d, 0x29, 0x75, 0x41, 0x89, 0xdd, 0xe5, 0x94, 0xa3, 0x65, 0xf0, 0xd3, 0x4e, 0x8f,
	0xe4, 0x12, 0x54, 0x1d, 0x57, 0x75, 0x67, 0x0e, 0x7a, 0x7e, 0x45, 0x11, 0x5f, 0x41, 0x9d, 0x66,
	0x25, 0x5c, 0xa7, 0x11, 0xb5, 0xe3, 0x5a, 0x50, 0x3b, 0x16, 0xb5, 0xaf, 0x7a, 0x50, 0x67, 0xbf,
	0x01, 0x8d, 0x31, 0x66, 0xed, 0xfc, 0xa0, 0x05, 0x7c, 0x4a, 0x4e, 0xc2, 0x13, 0xdd, 0xcb, 0x41,
	0xc2, 0x2b, 0xa6, 0x16, 0x75, 0x78, 0x41, 0xdd, 0xe7, 0x2b, 0xe0, 0x35, 0xa5, 0xa6, 0x5f, 0x53,
	0x8a, 0xd7, 0xba, 0x5a, 0xc9, 0x5a, 0xd7, 0x55, 0xa8, 0x8b, 0x2e, 0xae, 0x85, 0x25, 0xf7, 0x8a,
	0x52, 0xe3, 0x84, 0x03, 0x0b, 0x41, 0xf4, 0x0b, 0x61, 0x58, 0x72, 0xaf, 0x2b, 0x75, 0xbf, 0x08,
	0xc6, 0x74, 0x22, 0x0a, 0x60, 0xa2, 0xdc, 0x5e, 0xe5, 0xc5, 0xaf, 0x68, 0xe1, 0xeb, 0x7c, 0xac,
	0xf0, 0x15, 0xd4, 0xe5, 0x48, 0xb8, 0x2e, 0x17, 0xae, 0x49, 0x5d, 0x88, 0x96, 0xce, 0xfd, 0x48,
	0xb2, 0x16, 0x8e, 0x24, 0xb7, 0xa1, 0x35, 0x36, 0x87, 0xba, 0xd1, 0xf7, 0xca, 0x66, 0xbc, 0xe0,
	0xde, 0x44, 0xe2, 0xb6, 0xa8, 0x9d, 0xdd, 0x02, 0xfe, 0xdd, 0x67, 0x27, 0x3c, 0xd3, 0xc0, 0xba,
	0x7b, 0x5d, 0x69, 0x20, 0x4d, 0x41, 0x52, 0xac, 0x08, 0x74, 0x39, 0x5e, 0x04, 0x92, 0xa1, 0x15,
	0xae, 0x25, 0x59, 0x9d, 0x0e, 0xae, 0xba, 0x11, 0x54, 0x92, 0xac, 0x58, 0x11, 0xe7, 0x4a, 0xfc,
	0xe2, 0x82, 0xa5, 0x18, 0xa1, 0x5a, 0x90, 0xd5, 0xe9, 0x72, 0x16, 0x41, 0x25, 0xc8, 0x62, 0x26,
	0x30, 0xb0, 0xa9, 0x7f, 0xd6, 0xbe, 0xca, 0x4d, 0x80, 0x93, 0xd0, 0x04, 0xbc, 0x58, 0x8b, 0xcd,
	0xd7, 0xf8, 0x89, 0x9f, 0x11, 0xa2, 0x27, 0xfe, 0xeb, 0x39, 0x5e, 0xfe, 0x15, 0x68, 0x0a, 0x6f,
	0xda, 0xb2, 0x6d, 0x75, 0x4e, 0xee, 0x41, 0x4d, 0x38, 0x84, 0xd3, 0x91, 0xb0, 0x24, 0x7d, 0x21,
	0x25, 0x91, 0x57, 0xfc, 0x4e, 0xf2, 0xaf, 0x8b, 0xd0, 0x8a, 0x1c, 0x35, 0xc9, 0xeb, 0xb0, 0x22,
	0x5a, 0xd1, 0x2b, 0x33, 0x38, 0x78, 0x7d, 0xc8, 0xdb, 0xa1, 0xf0, 0xb1, 0xba, 0xf9, 0x52, 0xe6,
	0x11, 0x76, 0x83, 0xff, 0xb0, 0x04, 0x68, 0x99, 0x78, 0xfa, 0x23, 0x09, 0x20, 0x18, 0xc9, 0xb6,
	0x48, 0xf6, 0xfb, 0xc6, 0x53, 0xf3, 0xd0, 0xa1, 0xed, 0x02, 0xdb, 0x0c, 0xd9, 0xf7, 0xe7, 0xf8,
	0x01, 0x99, 0x57, 0x00, 0x18, 0x61, 0x33, 0x5a, 0xa5, 0x6c, 0x17, 0x09, 0x81, 0x55, 0xd6, 0xf0,
	0xe6, 0x9e, 0xa7, 0xe3, 0x76, 0x89, 0x5c, 0x02, 0xc2, 0x68, 0xf7, 0xb7, 0xc3, 0x1e, 0xc7, 0xb7,
	0x58, 0x46, 0xff, 0x3c, 0xaf, 0x06, 0xb5, 0x2b, 0xa4, 0x05, 0x75, 0x46, 0xf8, 0xc2, 0x9e, 0x6e,
	0x0c, 0xdb, 0x55, 0xf9, 0x21, 0x34, 0x84, 0x6c, 0x58, 0x8c, 0x27, 0x50, 0x9e, 0xe9, 0x1a, 0x07,
	0xbc, 0xa2, 0xe0, 0xff, 0xc5, 0x2a, 0xf1, 0x43, 0x58, 0xf5, 0xf8, 0x08, 0x6f, 0x5f, 0x36, 0x24,
	0x26, 0x83, 0x48, 0x29, 0x25, 0x88, 0xc8, 0x5f, 0x0c, 0x2d, 0xd8, 0xb1, 0xc8, 0x5d, 0x28, 0x3a,
	0x9e, 0x7d, 0x74, 0x53, 0x34, 0x26, 0x56, 0xa3, 0x14, 0x1d, 0x47, 0xfe, 0x5d, 0x70, 0x5b, 0xe0,
	0x9f, 0xff, 0x98, 0xd0, 0x9f, 0xba, 0x99, 0x84, 0xb9, 0x6f, 0x2c, 0x6b, 0x26, 0xd7, 0xa0, 0x8c,
	0xf6, 0x51, 0x83, 0xf2, 0xfe, 0xee, 0x93, 0x87, 0xed, 0x02, 0x01, 0xa8, 0x3e, 0x3b, 0x78, 0xbc,
	0xab, 0xec, 0xb7, 0x25, 0xf9, 0x59, 0x8a, 0x08, 0x8e, 0x95, 0x92, 0x27, 0x12, 0x28, 0x6b, 0xd4,
	0x19, 0x88, 0xbc, 0x07, 0xff, 0x33, 0xda, 0x09, 0x9d, 0x33, 0x60, 0x4b, 0x77, 0x4a, 0x0a, 0xfe,
	0x97, 0x7f, 0x21, 0x41, 0x6b, 0x6b, 0xe6, 0x8e, 0x4c, 0x5b, 0xff, 0x90, 0x5f, 0x31, 0x2f, 0xab,
	0x38, 0x16, 0x67, 0xd9, 0x66, 0x15, 0x6c, 0x90, 0xec, 0x93, 0x6f, 0xc7, 0x9a, 0xea, 0xaa, 0x5e,
	0xce, 0xcc, 0xfe, 0x93, 0x0b, 0x50, 0xd1, 0x06, 0x5e, 0x49, 0xa4, 0xa2, 0x94, 0xb5, 0x41, 0x38,
	0x0b, 0xa8, 0xe6, 0xe0, 0xf2, 0xd3, 0x22, 0x34, 0x31, 0xa7, 0xc4, 0x6c, 0x95, 0x4e, 0x59, 0xc8,
	0x71, 0xa8, 0xa1, 0x85, 0x0b, 0xe8, 0x35, 0x46, 0x10, 0x07, 0x93, 0xd6, 0xd1, 0xcc, 0xd1, 0x0d,
	0xb6, 0x51, 0x86, 0x72, 0x82, 0xa6, 0x47, 0xc4, 0x4e, 0x7e, 0xfa, 0x5f, 0x0a, 0xa7, 0xff, 0x7e,
	0x3c, 0x2f, 0x67, 0x64, 0x86, 0x95, 0x78, 0xd2, 0xe1, 0xe7, 0xd9, 0x75, 0x51, 0x19, 0xbc, 0x02,
	0x35, 0x3c, 0xa4, 0x8c, 0xa9, 0x21, 0xb6, 0xdb, 0x15, 0xf6, 0xfd, 0x84, 0x5f, 0x13, 0x07, 0xe7,
	0x97, 0x9a, 0x78, 0xc8, 0x22, 0x8e, 0x2e, 0x2c, 0xcc, 0xda, 0x14, 0x85, 0x62, 0xa7, 0x3f, 0xdc,
	0x83, 0x6b, 0x0a, 0x70, 0xd2, 0xc3, 0xb1, 0x3a, 0x0c, 0xa9, 0x00, 0xc2, 0xaf, 0x7a, 0xf4, 0x30,
	0x34, 0x8e, 0xc5, 0x44, 0xb0, 0xf5, 0xe1, 0xc8, 0x33, 0x08, 0xfe, 0xe1, 0xaf, 0xb4, 0x18, 0x5a,
	0x69, 0x64, 0x39, 0xa5, 0xd8, 0x72, 0x3c, 0x1b, 0x2a, 0x07, 0x36, 0x24, 0x6f, 0x41, 0x7d, 0x9f,
	0xba, 0x99, 0xc7, 0x13, 0x96, 0x4f, 0xb8, 0xde, 0x0b, 0x1f, 0xf6, 0x97, 0x51, 0x8c, 0xd9, 0x44,
	0x98, 0x06, 0xfb, 0xbb, 0xf9, 0x97, 0x35, 0xa8, 0x6f, 0xf1, 0xf7, 0x51, 0xd4, 0x26, 0x3b, 0xb0,
	0x8a, 0xe9, 0x99, 0xe1, 0xa5, 0xce, 0xe4, 0x72, 0xd8, 0xa5, 0x42, 0xf9, 0x7e, 0x37, 0xbd, 0xc1,
	0xb1, 0xe4, 0x02, 0xd9, 0x85, 0xf6, 0xa1, 0xb1, 0x10, 0x1f, 0xc7, 0xea, 0x5e, 0x4a, 0x3f, 0x0c,
	0xc9, 0x05, 0xd2, 0x83, 0x35, 0x04, 0x52, 0xdc, 0x94, 0x7a, 0x65, 0xd7, 0xec, 0x25, 0x65, 0xb3,
	0xda, 0x82, 0x16, 0x5f, 0x8f, 0xc8, 0xa1, 0x49, 0xa4, 0x6b, 0x90, 0xb9, 0x77, 0x53, 0xe9, 0x28,
	0xd4, 0x36, 0x9c, 0xf3, 0x84, 0xca, 0x65, 0x92, 0x2b, 0xd2, 0x87, 0xfe, 0x3b, 0xa7, 0xb4, 0x4b,
	0x2f, 0x72, 0x77, 0xe1, 0xdb, 0xb1, 0x69, 0xf7, 0xf5, 0xa5, 0x6e, 0xd2, 0x52, 0xe6, 0x8e, 0xde,
	0xf0, 0xe4, 0xcc, 0x9d, 0xb8, 0x34, 0xcb, 0x99, 0x3b, 0xed, 0xda, 0x48, 0x2e, 0x90, 0x23, 0x3f,
	0x52, 0x86, 0xef, 0x43, 0x88, 0x7c, 0xea, 0x85, 0xc9, 0xb4, 0xfb, 0xf2, 0x42, 0x97, 0x2a, 0x72,
	0x81, 0x7c, 0x03, 0xce, 0x27, 0x6e, 0x0b, 0xc8, 0xcd, 0x53, 0x2e, 0x13, 0xa6, 0xdd, 0xdb, 0x0b,
	0x5c, 0x37, 0xa4, 0x48, 0xc0, 0x33, 0x83, 0x1c, 0x09, 0xfc, 0xab, 0x80, 0x1c, 0x09, 0xc2, 0xf5,
	0x77, 0xb9, 0x40, 0x0c, 0xff, 0x8a, 0x24, 0x5e, 0x4b, 0x26, 0xaf, 0x2c, 0x54, 0x70, 0x9e, 0x76,
	0x3f, 0xbb, 0x70, 0x61, 0x3a, 0x62, 0x11, 0x69, 0x25, 0xd8, 0x54, 0x8b, 0xc8, 0xa8, 0x41, 0xa7,
	0x5a, 0x44, 0x76, 0x5d, 0x37, 0x82, 0x67, 0xf8, 0xdd, 0x48, 0x2a, 0x9e, 0xb1, 0x47, 0x2e, 0xa9,
	0x78, 0x26, 0x1f, 0x9f, 0xa4, 0xcd, 0x81, 0x91, 0x24, 0x6f, 0x0e, 0xef, 0xb1, 0x48, 0xde, 0x1c,
	0xa1, 0x87, 0x1b, 0x72, 0x81, 0xec, 0xf9, 0x79, 0x2e, 0x7f, 0xc5, 0x40, 0xae, 0xe5, 0x3c, 0x70,
	0x98, 0x76, 0x6f, 0x9c, 0xf2, 0xfc, 0x41, 0x2e, 0x10, 0x37, 0xfa, 0xbc, 0x24, 0xf2, 0x9e, 0x8d,
	0xdc, 0xc9, 0x5a, 0x57, 0xfc, 0x49, 0x5d, 0xf7, 0xd5, 0x05, 0x7b, 0x8a, 0x59, 0xa9, 0x7f, 0xa9,
	0x18, 0x79, 0xbf, 0x47, 0x6e, 0x67, 0x03, 0xe1, 0x3f, 0xfe, 0xeb, 0xbe, 0x72, 0x7a, 0x27, 0x31,
	0xcd, 0x77, 0xfd, 0x87, 0x80, 0xa9, 0x8f, 0x14, 0xc9, 0xab, 0x8b, 0x3f, 0x67, 0x9c, 0x76, 0x37,
	0x96, 0x7b, 0xfb, 0x28, 0x17, 0xc8, 0x14, 0x3a, 0x59, 0x2f, 0x46, 0xc9, 0x67, 0xb2, 0x84, 0x88,
	0xbd, 0x46, 0xed, 0xde, 0x5d, 0xac, 0x63, 0x22, 0x2c, 0x05, 0xaf, 0x5e, 0x53, 0xc3, 0x52, 0xe4,
	0xf5, 0x6e, 0x6a, 0x58, 0x4a, 0x3c, 0x9b, 0x2d, 0x90, 0x27, 0x70, 0x71, 0x5f, 0x7d, 0x4e, 0x23,
	0x49, 0x23, 0xee, 0xb7, 0x57, 0xc2, 0xe3, 0x23, 0xcd, 0x39, 0xdb, 0xd3, 0x1e, 0x5c, 0xe2, 0x82,
	0x2c, 0xc3, 0x2e, 0xbb, 0x09, 0x77, 0xcd, 0x55, 0x11, 0x4c, 0x45, 0x95, 0x32, 0xba, 0x7b, 0x87,
	0x6a, 0xf4, 0xb9, 0xbb, 0x77, 0xe3, 0x11, 0x75, 0x4f, 0xe7, 0x90, 0xde, 0x20, 0x76, 0xef, 0xd5,
	0x1d, 0x3a, 0xa6, 0x67, 0x5b, 0xc7, 0x14, 0x3a, 0x59, 0x17, 0x3a, 0x51, 0xeb, 0xc9, 0xb9, 0x74,
	0x8a, 0x5a, 0x4f, 0xfe, 0xfd, 0x90, 0x5c, 0x20, 0x27, 0x70, 0x29, 0xfd, 0x89, 0x38, 0x89, 0x44,
	0xa8, 0xcc, 0xa7, 0xe7, 0xdd, 0x3b, 0x8b, 0x74, 0x13, 0x93, 0x3d, 0x82, 0xf6, 0x9e, 0x1b, 0x53,
	0x57, 0x44, 0xbb, 0x91, 0x4b, 0x95, 0x6c, 0xa0, 0x1e, 0x34, 0xff, 0xf8, 0xc9, 0xba, 0xf4, 0xe7,
	0x4f, 0xd6, 0xa5, 0xbf, 0x7f, 0xb2, 0x2e, 0x1d, 0x55, 0xf1, 0x85, 0xfc, 0x9b, 0xff, 0x0a, 0x00,
	0x00, 0xff, 0xff, 0x12, 0x93, 0xfc, 0x60, 0xc8, 0x2f, 0x00, 0x00,
}
