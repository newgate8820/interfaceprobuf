// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/updates/userupdatesserver.proto

/*
Package updates is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/updates/userupdatesserver.proto

It has these top-level messages:

	ReqMonitor
	ReplyMonitor
	ReqStoreOtherInfoMsg
	ReplyStoreOtherInfoMsg
	ReqBatchStoreOtherInfoMsg
	ReplyBatchStoreOtherInfoMsg
	ReqGetOtherInfoMsg
	ReplyGetOtherInfoMsg
	ReqStoreUserPtsHandle
	ReplyStoreUserPtsHandle
	ReqGetUserPtsHandle
	ReplyGetUserPtsHandle
	ReqDeleteUserPtsHandle
	ReplyDeleteUserPtsHandle
	ReqClearUserPtsHandle
	ReplyClearUserPtsHandle
	ReqClearUserDialogPtsHandle
	ReplysClearUserDialogPtsHandle
	ReqDiffByPts
	ReplyDiffByPts
*/
package updates

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/pbcomm"
import messagedb "gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/messagedb"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ReqMonitor struct {
	Command    string   `protobuf:"bytes,1,opt,name=Command,proto3" json:"Command,omitempty"`
	SubCommand string   `protobuf:"bytes,2,opt,name=SubCommand,proto3" json:"SubCommand,omitempty"`
	Args       []string `protobuf:"bytes,3,rep,name=Args" json:"Args,omitempty"`
}

func (m *ReqMonitor) Reset()                    { *m = ReqMonitor{} }
func (m *ReqMonitor) String() string            { return proto.CompactTextString(m) }
func (*ReqMonitor) ProtoMessage()               {}
func (*ReqMonitor) Descriptor() ([]byte, []int) { return fileDescriptorUserupdatesserver, []int{0} }

func (m *ReqMonitor) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *ReqMonitor) GetSubCommand() string {
	if m != nil {
		return m.SubCommand
	}
	return ""
}

func (m *ReqMonitor) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type ReplyMonitor struct {
	Message string `protobuf:"bytes,1,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *ReplyMonitor) Reset()                    { *m = ReplyMonitor{} }
func (m *ReplyMonitor) String() string            { return proto.CompactTextString(m) }
func (*ReplyMonitor) ProtoMessage()               {}
func (*ReplyMonitor) Descriptor() ([]byte, []int) { return fileDescriptorUserupdatesserver, []int{1} }

func (m *ReplyMonitor) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ReqStoreOtherInfoMsg struct {
	OtherInfoMsg *messagedb.OtherInfoMsg `protobuf:"bytes,1,opt,name=OtherInfoMsg" json:"OtherInfoMsg,omitempty"`
}

func (m *ReqStoreOtherInfoMsg) Reset()         { *m = ReqStoreOtherInfoMsg{} }
func (m *ReqStoreOtherInfoMsg) String() string { return proto.CompactTextString(m) }
func (*ReqStoreOtherInfoMsg) ProtoMessage()    {}
func (*ReqStoreOtherInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{2}
}

func (m *ReqStoreOtherInfoMsg) GetOtherInfoMsg() *messagedb.OtherInfoMsg {
	if m != nil {
		return m.OtherInfoMsg
	}
	return nil
}

type ReplyStoreOtherInfoMsg struct {
}

func (m *ReplyStoreOtherInfoMsg) Reset()         { *m = ReplyStoreOtherInfoMsg{} }
func (m *ReplyStoreOtherInfoMsg) String() string { return proto.CompactTextString(m) }
func (*ReplyStoreOtherInfoMsg) ProtoMessage()    {}
func (*ReplyStoreOtherInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{3}
}

type ReqBatchStoreOtherInfoMsg struct {
	OtherInfoMsgs []*messagedb.OtherInfoMsg `protobuf:"bytes,1,rep,name=OtherInfoMsgs" json:"OtherInfoMsgs,omitempty"`
}

func (m *ReqBatchStoreOtherInfoMsg) Reset()         { *m = ReqBatchStoreOtherInfoMsg{} }
func (m *ReqBatchStoreOtherInfoMsg) String() string { return proto.CompactTextString(m) }
func (*ReqBatchStoreOtherInfoMsg) ProtoMessage()    {}
func (*ReqBatchStoreOtherInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{4}
}

func (m *ReqBatchStoreOtherInfoMsg) GetOtherInfoMsgs() []*messagedb.OtherInfoMsg {
	if m != nil {
		return m.OtherInfoMsgs
	}
	return nil
}

type ReplyBatchStoreOtherInfoMsg struct {
}

func (m *ReplyBatchStoreOtherInfoMsg) Reset()         { *m = ReplyBatchStoreOtherInfoMsg{} }
func (m *ReplyBatchStoreOtherInfoMsg) String() string { return proto.CompactTextString(m) }
func (*ReplyBatchStoreOtherInfoMsg) ProtoMessage()    {}
func (*ReplyBatchStoreOtherInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{5}
}

type ReqGetOtherInfoMsg struct {
	UserId int32 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Date   int64 `protobuf:"varint,2,opt,name=Date,proto3" json:"Date,omitempty"`
}

func (m *ReqGetOtherInfoMsg) Reset()         { *m = ReqGetOtherInfoMsg{} }
func (m *ReqGetOtherInfoMsg) String() string { return proto.CompactTextString(m) }
func (*ReqGetOtherInfoMsg) ProtoMessage()    {}
func (*ReqGetOtherInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{6}
}

func (m *ReqGetOtherInfoMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetOtherInfoMsg) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

type ReplyGetOtherInfoMsg struct {
	OtherInfoMsgs []*messagedb.OtherInfoMsg `protobuf:"bytes,1,rep,name=OtherInfoMsgs" json:"OtherInfoMsgs,omitempty"`
}

func (m *ReplyGetOtherInfoMsg) Reset()         { *m = ReplyGetOtherInfoMsg{} }
func (m *ReplyGetOtherInfoMsg) String() string { return proto.CompactTextString(m) }
func (*ReplyGetOtherInfoMsg) ProtoMessage()    {}
func (*ReplyGetOtherInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{7}
}

func (m *ReplyGetOtherInfoMsg) GetOtherInfoMsgs() []*messagedb.OtherInfoMsg {
	if m != nil {
		return m.OtherInfoMsgs
	}
	return nil
}

type ReqStoreUserPtsHandle struct {
	PtsHandle *messagedb.PtsHandle `protobuf:"bytes,1,opt,name=PtsHandle" json:"PtsHandle,omitempty"`
}

func (m *ReqStoreUserPtsHandle) Reset()         { *m = ReqStoreUserPtsHandle{} }
func (m *ReqStoreUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReqStoreUserPtsHandle) ProtoMessage()    {}
func (*ReqStoreUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{8}
}

func (m *ReqStoreUserPtsHandle) GetPtsHandle() *messagedb.PtsHandle {
	if m != nil {
		return m.PtsHandle
	}
	return nil
}

type ReplyStoreUserPtsHandle struct {
}

func (m *ReplyStoreUserPtsHandle) Reset()         { *m = ReplyStoreUserPtsHandle{} }
func (m *ReplyStoreUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReplyStoreUserPtsHandle) ProtoMessage()    {}
func (*ReplyStoreUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{9}
}

type ReqGetUserPtsHandle struct {
	UserId int32 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Pts    int32 `protobuf:"varint,2,opt,name=Pts,proto3" json:"Pts,omitempty"`
	Limit  int32 `protobuf:"varint,3,opt,name=Limit,proto3" json:"Limit,omitempty"`
}

func (m *ReqGetUserPtsHandle) Reset()         { *m = ReqGetUserPtsHandle{} }
func (m *ReqGetUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReqGetUserPtsHandle) ProtoMessage()    {}
func (*ReqGetUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{10}
}

func (m *ReqGetUserPtsHandle) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqGetUserPtsHandle) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *ReqGetUserPtsHandle) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type ReplyGetUserPtsHandle struct {
	Msgs    [][]byte `protobuf:"bytes,1,rep,name=Msgs" json:"Msgs,omitempty"`
	LastPts int32    `protobuf:"varint,2,opt,name=LastPts,proto3" json:"LastPts,omitempty"`
}

func (m *ReplyGetUserPtsHandle) Reset()         { *m = ReplyGetUserPtsHandle{} }
func (m *ReplyGetUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReplyGetUserPtsHandle) ProtoMessage()    {}
func (*ReplyGetUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{11}
}

func (m *ReplyGetUserPtsHandle) GetMsgs() [][]byte {
	if m != nil {
		return m.Msgs
	}
	return nil
}

func (m *ReplyGetUserPtsHandle) GetLastPts() int32 {
	if m != nil {
		return m.LastPts
	}
	return 0
}

type ReqDeleteUserPtsHandle struct {
	UserId int32   `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Ptss   []int32 `protobuf:"varint,2,rep,packed,name=Ptss" json:"Ptss,omitempty"`
}

func (m *ReqDeleteUserPtsHandle) Reset()         { *m = ReqDeleteUserPtsHandle{} }
func (m *ReqDeleteUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReqDeleteUserPtsHandle) ProtoMessage()    {}
func (*ReqDeleteUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{12}
}

func (m *ReqDeleteUserPtsHandle) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqDeleteUserPtsHandle) GetPtss() []int32 {
	if m != nil {
		return m.Ptss
	}
	return nil
}

type ReplyDeleteUserPtsHandle struct {
}

func (m *ReplyDeleteUserPtsHandle) Reset()         { *m = ReplyDeleteUserPtsHandle{} }
func (m *ReplyDeleteUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReplyDeleteUserPtsHandle) ProtoMessage()    {}
func (*ReplyDeleteUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{13}
}

type ReqClearUserPtsHandle struct {
	UserId int32 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	MaxPts int32 `protobuf:"varint,2,opt,name=MaxPts,proto3" json:"MaxPts,omitempty"`
}

func (m *ReqClearUserPtsHandle) Reset()         { *m = ReqClearUserPtsHandle{} }
func (m *ReqClearUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReqClearUserPtsHandle) ProtoMessage()    {}
func (*ReqClearUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{14}
}

func (m *ReqClearUserPtsHandle) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqClearUserPtsHandle) GetMaxPts() int32 {
	if m != nil {
		return m.MaxPts
	}
	return 0
}

type ReplyClearUserPtsHandle struct {
}

func (m *ReplyClearUserPtsHandle) Reset()         { *m = ReplyClearUserPtsHandle{} }
func (m *ReplyClearUserPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReplyClearUserPtsHandle) ProtoMessage()    {}
func (*ReplyClearUserPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{15}
}

type ReqClearUserDialogPtsHandle struct {
	UserId int32 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId int32 `protobuf:"varint,2,opt,name=WithId,proto3" json:"WithId,omitempty"`
	MaxPts int32 `protobuf:"varint,3,opt,name=MaxPts,proto3" json:"MaxPts,omitempty"`
}

func (m *ReqClearUserDialogPtsHandle) Reset()         { *m = ReqClearUserDialogPtsHandle{} }
func (m *ReqClearUserDialogPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReqClearUserDialogPtsHandle) ProtoMessage()    {}
func (*ReqClearUserDialogPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{16}
}

func (m *ReqClearUserDialogPtsHandle) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqClearUserDialogPtsHandle) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *ReqClearUserDialogPtsHandle) GetMaxPts() int32 {
	if m != nil {
		return m.MaxPts
	}
	return 0
}

type ReplysClearUserDialogPtsHandle struct {
}

func (m *ReplysClearUserDialogPtsHandle) Reset()         { *m = ReplysClearUserDialogPtsHandle{} }
func (m *ReplysClearUserDialogPtsHandle) String() string { return proto.CompactTextString(m) }
func (*ReplysClearUserDialogPtsHandle) ProtoMessage()    {}
func (*ReplysClearUserDialogPtsHandle) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{17}
}

// ############################# pts 矫正 ##########################
type ReqDiffByPts struct {
	Fromid        int32         `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	FromKeyid     uint64        `protobuf:"varint,2,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Pts           int32         `protobuf:"varint,3,opt,name=pts,proto3" json:"pts,omitempty"`
	Flags         int32         `protobuf:"varint,4,opt,name=flags,proto3" json:"flags,omitempty"`
	PtsTotalLimit int32         `protobuf:"varint,5,opt,name=Pts_total_limit,json=PtsTotalLimit,proto3" json:"Pts_total_limit,omitempty"`
	Date          int32         `protobuf:"varint,6,opt,name=Date,proto3" json:"Date,omitempty"`
	Qts           int32         `protobuf:"varint,7,opt,name=Qts,proto3" json:"Qts,omitempty"`
	Debug         *pbcomm.Debug `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqDiffByPts) Reset()                    { *m = ReqDiffByPts{} }
func (m *ReqDiffByPts) String() string            { return proto.CompactTextString(m) }
func (*ReqDiffByPts) ProtoMessage()               {}
func (*ReqDiffByPts) Descriptor() ([]byte, []int) { return fileDescriptorUserupdatesserver, []int{18} }

func (m *ReqDiffByPts) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqDiffByPts) GetFromKeyid() uint64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqDiffByPts) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *ReqDiffByPts) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ReqDiffByPts) GetPtsTotalLimit() int32 {
	if m != nil {
		return m.PtsTotalLimit
	}
	return 0
}

func (m *ReqDiffByPts) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ReqDiffByPts) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

func (m *ReqDiffByPts) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyDiffByPts struct {
	Result  []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	Error   int32  `protobuf:"varint,2,opt,name=error,proto3" json:"error,omitempty"`
	Usetime int32  `protobuf:"varint,3,opt,name=usetime,proto3" json:"usetime,omitempty"`
}

func (m *ReplyDiffByPts) Reset()         { *m = ReplyDiffByPts{} }
func (m *ReplyDiffByPts) String() string { return proto.CompactTextString(m) }
func (*ReplyDiffByPts) ProtoMessage()    {}
func (*ReplyDiffByPts) Descriptor() ([]byte, []int) {
	return fileDescriptorUserupdatesserver, []int{19}
}

func (m *ReplyDiffByPts) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyDiffByPts) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

func (m *ReplyDiffByPts) GetUsetime() int32 {
	if m != nil {
		return m.Usetime
	}
	return 0
}

func init() {
	proto.RegisterType((*ReqMonitor)(nil), "updates.ReqMonitor")
	proto.RegisterType((*ReplyMonitor)(nil), "updates.ReplyMonitor")
	proto.RegisterType((*ReqStoreOtherInfoMsg)(nil), "updates.ReqStoreOtherInfoMsg")
	proto.RegisterType((*ReplyStoreOtherInfoMsg)(nil), "updates.ReplyStoreOtherInfoMsg")
	proto.RegisterType((*ReqBatchStoreOtherInfoMsg)(nil), "updates.ReqBatchStoreOtherInfoMsg")
	proto.RegisterType((*ReplyBatchStoreOtherInfoMsg)(nil), "updates.ReplyBatchStoreOtherInfoMsg")
	proto.RegisterType((*ReqGetOtherInfoMsg)(nil), "updates.ReqGetOtherInfoMsg")
	proto.RegisterType((*ReplyGetOtherInfoMsg)(nil), "updates.ReplyGetOtherInfoMsg")
	proto.RegisterType((*ReqStoreUserPtsHandle)(nil), "updates.ReqStoreUserPtsHandle")
	proto.RegisterType((*ReplyStoreUserPtsHandle)(nil), "updates.ReplyStoreUserPtsHandle")
	proto.RegisterType((*ReqGetUserPtsHandle)(nil), "updates.ReqGetUserPtsHandle")
	proto.RegisterType((*ReplyGetUserPtsHandle)(nil), "updates.ReplyGetUserPtsHandle")
	proto.RegisterType((*ReqDeleteUserPtsHandle)(nil), "updates.ReqDeleteUserPtsHandle")
	proto.RegisterType((*ReplyDeleteUserPtsHandle)(nil), "updates.ReplyDeleteUserPtsHandle")
	proto.RegisterType((*ReqClearUserPtsHandle)(nil), "updates.ReqClearUserPtsHandle")
	proto.RegisterType((*ReplyClearUserPtsHandle)(nil), "updates.ReplyClearUserPtsHandle")
	proto.RegisterType((*ReqClearUserDialogPtsHandle)(nil), "updates.ReqClearUserDialogPtsHandle")
	proto.RegisterType((*ReplysClearUserDialogPtsHandle)(nil), "updates.ReplysClearUserDialogPtsHandle")
	proto.RegisterType((*ReqDiffByPts)(nil), "updates.ReqDiffByPts")
	proto.RegisterType((*ReplyDiffByPts)(nil), "updates.ReplyDiffByPts")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for UserUpdatesServer service

type UserUpdatesServerClient interface {
	// 单聊、普通群离线pts消息
	StoreUserPtsHandle(ctx context.Context, in *ReqStoreUserPtsHandle, opts ...grpc.CallOption) (*ReplyStoreUserPtsHandle, error)
	// 获取单聊、普通群离线pts消息
	GetUserPtsHandle(ctx context.Context, in *ReqGetUserPtsHandle, opts ...grpc.CallOption) (*ReplyGetUserPtsHandle, error)
	// 删除单条pts离线消息
	DeleteUserPtsHandle(ctx context.Context, in *ReqDeleteUserPtsHandle, opts ...grpc.CallOption) (*ReplyDeleteUserPtsHandle, error)
	// 清除用户单聊、普通群所有的离线消息
	ClearUserPtsHandle(ctx context.Context, in *ReqClearUserPtsHandle, opts ...grpc.CallOption) (*ReplyClearUserPtsHandle, error)
	// 清除对话框的离线消息
	ClearUserDialogPtsHandle(ctx context.Context, in *ReqClearUserDialogPtsHandle, opts ...grpc.CallOption) (*ReplysClearUserDialogPtsHandle, error)
	// ================== 存储 电话信息 联系人 加密聊天请求 二进制信息 ==================
	// infoService 调用存储信息
	StoreOtherInfoMsg(ctx context.Context, in *ReqStoreOtherInfoMsg, opts ...grpc.CallOption) (*ReplyStoreOtherInfoMsg, error)
	// 批量 存储 otherInfoMsg
	BatchStoreOtherInfoMsg(ctx context.Context, in *ReqBatchStoreOtherInfoMsg, opts ...grpc.CallOption) (*ReplyBatchStoreOtherInfoMsg, error)
	// 获取infoMsg信息
	GetOtherInfoMsg(ctx context.Context, in *ReqGetOtherInfoMsg, opts ...grpc.CallOption) (*ReplyGetOtherInfoMsg, error)
	// 用与实时交互查数据
	Monitor(ctx context.Context, in *ReqMonitor, opts ...grpc.CallOption) (*ReplyMonitor, error)
	// pts矫正
	GetDiffByPts(ctx context.Context, in *ReqDiffByPts, opts ...grpc.CallOption) (*ReplyDiffByPts, error)
}

type userUpdatesServerClient struct {
	cc *grpc.ClientConn
}

func NewUserUpdatesServerClient(cc *grpc.ClientConn) UserUpdatesServerClient {
	return &userUpdatesServerClient{cc}
}

func (c *userUpdatesServerClient) StoreUserPtsHandle(ctx context.Context, in *ReqStoreUserPtsHandle, opts ...grpc.CallOption) (*ReplyStoreUserPtsHandle, error) {
	out := new(ReplyStoreUserPtsHandle)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/StoreUserPtsHandle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) GetUserPtsHandle(ctx context.Context, in *ReqGetUserPtsHandle, opts ...grpc.CallOption) (*ReplyGetUserPtsHandle, error) {
	out := new(ReplyGetUserPtsHandle)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/GetUserPtsHandle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) DeleteUserPtsHandle(ctx context.Context, in *ReqDeleteUserPtsHandle, opts ...grpc.CallOption) (*ReplyDeleteUserPtsHandle, error) {
	out := new(ReplyDeleteUserPtsHandle)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/DeleteUserPtsHandle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) ClearUserPtsHandle(ctx context.Context, in *ReqClearUserPtsHandle, opts ...grpc.CallOption) (*ReplyClearUserPtsHandle, error) {
	out := new(ReplyClearUserPtsHandle)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/ClearUserPtsHandle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) ClearUserDialogPtsHandle(ctx context.Context, in *ReqClearUserDialogPtsHandle, opts ...grpc.CallOption) (*ReplysClearUserDialogPtsHandle, error) {
	out := new(ReplysClearUserDialogPtsHandle)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/ClearUserDialogPtsHandle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) StoreOtherInfoMsg(ctx context.Context, in *ReqStoreOtherInfoMsg, opts ...grpc.CallOption) (*ReplyStoreOtherInfoMsg, error) {
	out := new(ReplyStoreOtherInfoMsg)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/StoreOtherInfoMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) BatchStoreOtherInfoMsg(ctx context.Context, in *ReqBatchStoreOtherInfoMsg, opts ...grpc.CallOption) (*ReplyBatchStoreOtherInfoMsg, error) {
	out := new(ReplyBatchStoreOtherInfoMsg)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/BatchStoreOtherInfoMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) GetOtherInfoMsg(ctx context.Context, in *ReqGetOtherInfoMsg, opts ...grpc.CallOption) (*ReplyGetOtherInfoMsg, error) {
	out := new(ReplyGetOtherInfoMsg)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/GetOtherInfoMsg", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) Monitor(ctx context.Context, in *ReqMonitor, opts ...grpc.CallOption) (*ReplyMonitor, error) {
	out := new(ReplyMonitor)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/Monitor", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userUpdatesServerClient) GetDiffByPts(ctx context.Context, in *ReqDiffByPts, opts ...grpc.CallOption) (*ReplyDiffByPts, error) {
	out := new(ReplyDiffByPts)
	err := grpc.Invoke(ctx, "/updates.UserUpdatesServer/GetDiffByPts", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UserUpdatesServer service

type UserUpdatesServerServer interface {
	// 单聊、普通群离线pts消息
	StoreUserPtsHandle(context.Context, *ReqStoreUserPtsHandle) (*ReplyStoreUserPtsHandle, error)
	// 获取单聊、普通群离线pts消息
	GetUserPtsHandle(context.Context, *ReqGetUserPtsHandle) (*ReplyGetUserPtsHandle, error)
	// 删除单条pts离线消息
	DeleteUserPtsHandle(context.Context, *ReqDeleteUserPtsHandle) (*ReplyDeleteUserPtsHandle, error)
	// 清除用户单聊、普通群所有的离线消息
	ClearUserPtsHandle(context.Context, *ReqClearUserPtsHandle) (*ReplyClearUserPtsHandle, error)
	// 清除对话框的离线消息
	ClearUserDialogPtsHandle(context.Context, *ReqClearUserDialogPtsHandle) (*ReplysClearUserDialogPtsHandle, error)
	// ================== 存储 电话信息 联系人 加密聊天请求 二进制信息 ==================
	// infoService 调用存储信息
	StoreOtherInfoMsg(context.Context, *ReqStoreOtherInfoMsg) (*ReplyStoreOtherInfoMsg, error)
	// 批量 存储 otherInfoMsg
	BatchStoreOtherInfoMsg(context.Context, *ReqBatchStoreOtherInfoMsg) (*ReplyBatchStoreOtherInfoMsg, error)
	// 获取infoMsg信息
	GetOtherInfoMsg(context.Context, *ReqGetOtherInfoMsg) (*ReplyGetOtherInfoMsg, error)
	// 用与实时交互查数据
	Monitor(context.Context, *ReqMonitor) (*ReplyMonitor, error)
	// pts矫正
	GetDiffByPts(context.Context, *ReqDiffByPts) (*ReplyDiffByPts, error)
}

func RegisterUserUpdatesServerServer(s *grpc.Server, srv UserUpdatesServerServer) {
	s.RegisterService(&_UserUpdatesServer_serviceDesc, srv)
}

func _UserUpdatesServer_StoreUserPtsHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStoreUserPtsHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).StoreUserPtsHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/StoreUserPtsHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).StoreUserPtsHandle(ctx, req.(*ReqStoreUserPtsHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_GetUserPtsHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetUserPtsHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).GetUserPtsHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/GetUserPtsHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).GetUserPtsHandle(ctx, req.(*ReqGetUserPtsHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_DeleteUserPtsHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqDeleteUserPtsHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).DeleteUserPtsHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/DeleteUserPtsHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).DeleteUserPtsHandle(ctx, req.(*ReqDeleteUserPtsHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_ClearUserPtsHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqClearUserPtsHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).ClearUserPtsHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/ClearUserPtsHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).ClearUserPtsHandle(ctx, req.(*ReqClearUserPtsHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_ClearUserDialogPtsHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqClearUserDialogPtsHandle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).ClearUserDialogPtsHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/ClearUserDialogPtsHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).ClearUserDialogPtsHandle(ctx, req.(*ReqClearUserDialogPtsHandle))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_StoreOtherInfoMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqStoreOtherInfoMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).StoreOtherInfoMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/StoreOtherInfoMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).StoreOtherInfoMsg(ctx, req.(*ReqStoreOtherInfoMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_BatchStoreOtherInfoMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqBatchStoreOtherInfoMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).BatchStoreOtherInfoMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/BatchStoreOtherInfoMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).BatchStoreOtherInfoMsg(ctx, req.(*ReqBatchStoreOtherInfoMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_GetOtherInfoMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetOtherInfoMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).GetOtherInfoMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/GetOtherInfoMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).GetOtherInfoMsg(ctx, req.(*ReqGetOtherInfoMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_Monitor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqMonitor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).Monitor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/Monitor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).Monitor(ctx, req.(*ReqMonitor))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserUpdatesServer_GetDiffByPts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqDiffByPts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserUpdatesServerServer).GetDiffByPts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/updates.UserUpdatesServer/GetDiffByPts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserUpdatesServerServer).GetDiffByPts(ctx, req.(*ReqDiffByPts))
	}
	return interceptor(ctx, in, info, handler)
}

var _UserUpdatesServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "updates.UserUpdatesServer",
	HandlerType: (*UserUpdatesServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StoreUserPtsHandle",
			Handler:    _UserUpdatesServer_StoreUserPtsHandle_Handler,
		},
		{
			MethodName: "GetUserPtsHandle",
			Handler:    _UserUpdatesServer_GetUserPtsHandle_Handler,
		},
		{
			MethodName: "DeleteUserPtsHandle",
			Handler:    _UserUpdatesServer_DeleteUserPtsHandle_Handler,
		},
		{
			MethodName: "ClearUserPtsHandle",
			Handler:    _UserUpdatesServer_ClearUserPtsHandle_Handler,
		},
		{
			MethodName: "ClearUserDialogPtsHandle",
			Handler:    _UserUpdatesServer_ClearUserDialogPtsHandle_Handler,
		},
		{
			MethodName: "StoreOtherInfoMsg",
			Handler:    _UserUpdatesServer_StoreOtherInfoMsg_Handler,
		},
		{
			MethodName: "BatchStoreOtherInfoMsg",
			Handler:    _UserUpdatesServer_BatchStoreOtherInfoMsg_Handler,
		},
		{
			MethodName: "GetOtherInfoMsg",
			Handler:    _UserUpdatesServer_GetOtherInfoMsg_Handler,
		},
		{
			MethodName: "Monitor",
			Handler:    _UserUpdatesServer_Monitor_Handler,
		},
		{
			MethodName: "GetDiffByPts",
			Handler:    _UserUpdatesServer_GetDiffByPts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/updates/userupdatesserver.proto",
}

func (m *ReqMonitor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqMonitor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Command) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(len(m.Command)))
		i += copy(dAtA[i:], m.Command)
	}
	if len(m.SubCommand) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(len(m.SubCommand)))
		i += copy(dAtA[i:], m.SubCommand)
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *ReplyMonitor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyMonitor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	return i, nil
}

func (m *ReqStoreOtherInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqStoreOtherInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OtherInfoMsg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.OtherInfoMsg.Size()))
		n1, err := m.OtherInfoMsg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ReplyStoreOtherInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyStoreOtherInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReqBatchStoreOtherInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqBatchStoreOtherInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OtherInfoMsgs) > 0 {
		for _, msg := range m.OtherInfoMsgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintUserupdatesserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplyBatchStoreOtherInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyBatchStoreOtherInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReqGetOtherInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetOtherInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.UserId))
	}
	if m.Date != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Date))
	}
	return i, nil
}

func (m *ReplyGetOtherInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetOtherInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OtherInfoMsgs) > 0 {
		for _, msg := range m.OtherInfoMsgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintUserupdatesserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqStoreUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqStoreUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PtsHandle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.PtsHandle.Size()))
		n2, err := m.PtsHandle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ReplyStoreUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyStoreUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReqGetUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.UserId))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Pts))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Limit))
	}
	return i, nil
}

func (m *ReplyGetUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintUserupdatesserver(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.LastPts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.LastPts))
	}
	return i, nil
}

func (m *ReqDeleteUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDeleteUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.UserId))
	}
	if len(m.Ptss) > 0 {
		dAtA4 := make([]byte, len(m.Ptss)*10)
		var j3 int
		for _, num1 := range m.Ptss {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *ReplyDeleteUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyDeleteUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReqClearUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqClearUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.UserId))
	}
	if m.MaxPts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.MaxPts))
	}
	return i, nil
}

func (m *ReplyClearUserPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyClearUserPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReqClearUserDialogPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqClearUserDialogPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.WithId))
	}
	if m.MaxPts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.MaxPts))
	}
	return i, nil
}

func (m *ReplysClearUserDialogPtsHandle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplysClearUserDialogPtsHandle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ReqDiffByPts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqDiffByPts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Fromid))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Pts))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Flags))
	}
	if m.PtsTotalLimit != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.PtsTotalLimit))
	}
	if m.Date != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Date))
	}
	if m.Qts != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Qts))
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Debug.Size()))
		n5, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *ReplyDiffByPts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyDiffByPts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Error))
	}
	if m.Usetime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintUserupdatesserver(dAtA, i, uint64(m.Usetime))
	}
	return i, nil
}

func encodeVarintUserupdatesserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ReqMonitor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovUserupdatesserver(uint64(l))
	}
	l = len(m.SubCommand)
	if l > 0 {
		n += 1 + l + sovUserupdatesserver(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovUserupdatesserver(uint64(l))
		}
	}
	return n
}

func (m *ReplyMonitor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovUserupdatesserver(uint64(l))
	}
	return n
}

func (m *ReqStoreOtherInfoMsg) Size() (n int) {
	var l int
	_ = l
	if m.OtherInfoMsg != nil {
		l = m.OtherInfoMsg.Size()
		n += 1 + l + sovUserupdatesserver(uint64(l))
	}
	return n
}

func (m *ReplyStoreOtherInfoMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReqBatchStoreOtherInfoMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.OtherInfoMsgs) > 0 {
		for _, e := range m.OtherInfoMsgs {
			l = e.Size()
			n += 1 + l + sovUserupdatesserver(uint64(l))
		}
	}
	return n
}

func (m *ReplyBatchStoreOtherInfoMsg) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReqGetOtherInfoMsg) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.UserId))
	}
	if m.Date != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Date))
	}
	return n
}

func (m *ReplyGetOtherInfoMsg) Size() (n int) {
	var l int
	_ = l
	if len(m.OtherInfoMsgs) > 0 {
		for _, e := range m.OtherInfoMsgs {
			l = e.Size()
			n += 1 + l + sovUserupdatesserver(uint64(l))
		}
	}
	return n
}

func (m *ReqStoreUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	if m.PtsHandle != nil {
		l = m.PtsHandle.Size()
		n += 1 + l + sovUserupdatesserver(uint64(l))
	}
	return n
}

func (m *ReplyStoreUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReqGetUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.UserId))
	}
	if m.Pts != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Pts))
	}
	if m.Limit != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Limit))
	}
	return n
}

func (m *ReplyGetUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for _, b := range m.Msgs {
			l = len(b)
			n += 1 + l + sovUserupdatesserver(uint64(l))
		}
	}
	if m.LastPts != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.LastPts))
	}
	return n
}

func (m *ReqDeleteUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.UserId))
	}
	if len(m.Ptss) > 0 {
		l = 0
		for _, e := range m.Ptss {
			l += sovUserupdatesserver(uint64(e))
		}
		n += 1 + sovUserupdatesserver(uint64(l)) + l
	}
	return n
}

func (m *ReplyDeleteUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReqClearUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.UserId))
	}
	if m.MaxPts != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.MaxPts))
	}
	return n
}

func (m *ReplyClearUserPtsHandle) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReqClearUserDialogPtsHandle) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.WithId))
	}
	if m.MaxPts != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.MaxPts))
	}
	return n
}

func (m *ReplysClearUserDialogPtsHandle) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ReqDiffByPts) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Fromid))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.FromKeyid))
	}
	if m.Pts != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Pts))
	}
	if m.Flags != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Flags))
	}
	if m.PtsTotalLimit != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.PtsTotalLimit))
	}
	if m.Date != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Date))
	}
	if m.Qts != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Qts))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovUserupdatesserver(uint64(l))
	}
	return n
}

func (m *ReplyDiffByPts) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovUserupdatesserver(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Error))
	}
	if m.Usetime != 0 {
		n += 1 + sovUserupdatesserver(uint64(m.Usetime))
	}
	return n
}

func sovUserupdatesserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozUserupdatesserver(x uint64) (n int) {
	return sovUserupdatesserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReqMonitor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqMonitor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqMonitor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubCommand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyMonitor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyMonitor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyMonitor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqStoreOtherInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqStoreOtherInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqStoreOtherInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherInfoMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtherInfoMsg == nil {
				m.OtherInfoMsg = &messagedb.OtherInfoMsg{}
			}
			if err := m.OtherInfoMsg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyStoreOtherInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyStoreOtherInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyStoreOtherInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqBatchStoreOtherInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqBatchStoreOtherInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqBatchStoreOtherInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherInfoMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherInfoMsgs = append(m.OtherInfoMsgs, &messagedb.OtherInfoMsg{})
			if err := m.OtherInfoMsgs[len(m.OtherInfoMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyBatchStoreOtherInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyBatchStoreOtherInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyBatchStoreOtherInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetOtherInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetOtherInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetOtherInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetOtherInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetOtherInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetOtherInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtherInfoMsgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OtherInfoMsgs = append(m.OtherInfoMsgs, &messagedb.OtherInfoMsg{})
			if err := m.OtherInfoMsgs[len(m.OtherInfoMsgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqStoreUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqStoreUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqStoreUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PtsHandle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PtsHandle == nil {
				m.PtsHandle = &messagedb.PtsHandle{}
			}
			if err := m.PtsHandle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyStoreUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyStoreUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyStoreUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, make([]byte, postIndex-iNdEx))
			copy(m.Msgs[len(m.Msgs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPts", wireType)
			}
			m.LastPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastPts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDeleteUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDeleteUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDeleteUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUserupdatesserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ptss = append(m.Ptss, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUserupdatesserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUserupdatesserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUserupdatesserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ptss = append(m.Ptss, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ptss", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyDeleteUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyDeleteUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyDeleteUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqClearUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqClearUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqClearUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPts", wireType)
			}
			m.MaxPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyClearUserPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyClearUserPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyClearUserPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqClearUserDialogPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqClearUserDialogPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqClearUserDialogPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPts", wireType)
			}
			m.MaxPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplysClearUserDialogPtsHandle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplysClearUserDialogPtsHandle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplysClearUserDialogPtsHandle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqDiffByPts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqDiffByPts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqDiffByPts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PtsTotalLimit", wireType)
			}
			m.PtsTotalLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PtsTotalLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyDiffByPts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyDiffByPts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyDiffByPts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usetime", wireType)
			}
			m.Usetime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usetime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUserupdatesserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUserupdatesserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUserupdatesserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUserupdatesserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUserupdatesserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthUserupdatesserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowUserupdatesserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipUserupdatesserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthUserupdatesserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUserupdatesserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/iminterfaceprotobufs/updates/userupdatesserver.proto", fileDescriptorUserupdatesserver)
}

var fileDescriptorUserupdatesserver = []byte{
	// 897 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xdb, 0x36,
	0x14, 0x96, 0xe7, 0x9f, 0x2c, 0x67, 0xce, 0xda, 0x32, 0x89, 0xa3, 0xaa, 0x8b, 0xeb, 0x71, 0xc5,
	0x96, 0x2b, 0x07, 0xc8, 0x2e, 0x76, 0x31, 0x0c, 0xe8, 0x52, 0x0f, 0x69, 0xd0, 0x66, 0x75, 0x99,
	0x1a, 0x2b, 0xba, 0x8b, 0x80, 0x8e, 0x69, 0x47, 0xa8, 0x64, 0xc9, 0x24, 0x3d, 0xcc, 0x6f, 0xb8,
	0xcb, 0x3d, 0x42, 0x91, 0x07, 0xd8, 0x33, 0x0c, 0x24, 0x25, 0x4b, 0x94, 0xe4, 0x21, 0xc8, 0xae,
	0x7c, 0xbe, 0x73, 0xe8, 0xef, 0xa3, 0x3e, 0x9e, 0x23, 0x0a, 0xde, 0xcd, 0x7c, 0x19, 0xd0, 0x71,
	0xff, 0xfa, 0x86, 0x4a, 0xc1, 0xf8, 0x1f, 0x8c, 0xf7, 0xfd, 0xf0, 0xd8, 0x9f, 0x4b, 0xc6, 0xa7,
	0xf4, 0x9a, 0xc5, 0x3c, 0x1a, 0x2f, 0xa7, 0xc7, 0x71, 0x24, 0xa9, 0x8c, 0x62, 0x1e, 0x49, 0x05,
	0xc5, 0xf1, 0x32, 0x9e, 0x50, 0xc9, 0xc4, 0xf1, 0x52, 0x30, 0x9e, 0xc4, 0xc9, 0x9f, 0xf5, 0x1a,
	0xb4, 0x95, 0x24, 0xbd, 0x97, 0xf7, 0xa2, 0x8f, 0xc7, 0xd7, 0x51, 0x18, 0x26, 0x3f, 0x86, 0xd2,
	0xfb, 0xf5, 0x5e, 0x4c, 0x21, 0x13, 0x82, 0xce, 0xd8, 0x64, 0x9c, 0x45, 0x86, 0x0f, 0x7f, 0x00,
	0x20, 0x6c, 0x71, 0x11, 0xcd, 0x7d, 0x19, 0x71, 0xe4, 0xc2, 0xd6, 0x8b, 0x28, 0x0c, 0xe9, 0x7c,
	0xe2, 0xd6, 0x7a, 0xb5, 0xa3, 0x6d, 0x92, 0x42, 0xd4, 0x05, 0xb8, 0x5c, 0x8e, 0xd3, 0xe2, 0x67,
	0xba, 0x98, 0xcb, 0x20, 0x04, 0x8d, 0x9f, 0xf9, 0x4c, 0xb8, 0xf5, 0x5e, 0xfd, 0x68, 0x9b, 0xe8,
	0x18, 0x1f, 0x41, 0x9b, 0xb0, 0x38, 0x58, 0xe5, 0xd8, 0x2f, 0x8c, 0x7c, 0xca, 0x9e, 0x40, 0x7c,
	0x09, 0x7b, 0x84, 0x2d, 0x2e, 0x65, 0xc4, 0xd9, 0x1b, 0x79, 0xc3, 0xf8, 0xf9, 0x7c, 0x1a, 0x5d,
	0x88, 0x19, 0xfa, 0x11, 0xda, 0x79, 0xac, 0xff, 0xf6, 0xc5, 0xc9, 0x41, 0x3f, 0x7b, 0x8a, 0x7c,
	0x99, 0x58, 0x8b, 0xb1, 0x0b, 0x1d, 0x2d, 0x5f, 0xa2, 0xc5, 0x1f, 0xe0, 0x31, 0x61, 0x8b, 0x53,
	0x2a, 0xaf, 0x6f, 0xca, 0x9a, 0x3f, 0xc1, 0x4e, 0x1e, 0x0b, 0xb7, 0xd6, 0xab, 0xff, 0x97, 0xa8,
	0xbd, 0x1a, 0x1f, 0xc2, 0x13, 0xad, 0x5a, 0xcd, 0x8e, 0x9f, 0x03, 0x22, 0x6c, 0x71, 0xc6, 0xa4,
	0xa5, 0xd9, 0x81, 0xd6, 0x48, 0x30, 0x7e, 0x6e, 0x6c, 0x6f, 0x92, 0x04, 0x29, 0x57, 0x07, 0x54,
	0x32, 0xed, 0x77, 0x9d, 0xe8, 0x18, 0x8f, 0x94, 0x57, 0x71, 0xb0, 0x2a, 0x72, 0xfc, 0xcf, 0x7d,
	0xbf, 0x82, 0xfd, 0xf4, 0x08, 0x94, 0xf8, 0x50, 0x8a, 0x97, 0x74, 0x3e, 0x09, 0x18, 0x3a, 0x81,
	0xed, 0x35, 0x48, 0x0e, 0x60, 0x2f, 0xc7, 0xb9, 0xae, 0x91, 0x6c, 0x19, 0x7e, 0x0c, 0x07, 0x99,
	0xf5, 0x16, 0x1d, 0x1e, 0xc1, 0xae, 0x31, 0xc0, 0x56, 0xd9, 0xe4, 0xc0, 0x43, 0xa8, 0x0f, 0xa5,
	0xd0, 0x06, 0x34, 0x89, 0x0a, 0xd1, 0x1e, 0x34, 0x5f, 0xfb, 0xa1, 0x2f, 0xdd, 0xba, 0xce, 0x19,
	0x80, 0x7f, 0x51, 0xdb, 0x37, 0xae, 0xd8, 0xc4, 0x08, 0x1a, 0x6b, 0x37, 0xda, 0x44, 0xc7, 0xaa,
	0x11, 0x5f, 0x53, 0x21, 0x33, 0xe2, 0x14, 0xe2, 0x81, 0xea, 0x99, 0xc5, 0x80, 0x05, 0x4c, 0xb2,
	0xbb, 0x6d, 0x10, 0x41, 0x63, 0x28, 0x85, 0x22, 0xaa, 0x1f, 0x35, 0x89, 0x8e, 0xb1, 0x07, 0xae,
	0xde, 0x4c, 0x05, 0x0f, 0x3e, 0xd3, 0x3e, 0xbf, 0x08, 0x18, 0xe5, 0x77, 0x13, 0xe8, 0x40, 0xeb,
	0x82, 0xfe, 0x99, 0xed, 0x35, 0x41, 0x6b, 0x8f, 0xcb, 0x54, 0x98, 0xa9, 0x1e, 0xcc, 0x34, 0x06,
	0x3e, 0x0d, 0xa2, 0xd9, 0x9d, 0x94, 0x7e, 0xf3, 0xe5, 0xcd, 0xf9, 0x24, 0x55, 0x32, 0x28, 0xb7,
	0x83, 0xba, 0xb5, 0x83, 0x1e, 0x74, 0xf5, 0x0e, 0xc4, 0x26, 0x25, 0xfc, 0xa9, 0xa6, 0x5e, 0x01,
	0x8b, 0x81, 0x3f, 0x9d, 0x9e, 0xae, 0xd4, 0xe1, 0x75, 0xa0, 0x35, 0xe5, 0x51, 0xe8, 0xaf, 0xa5,
	0x0d, 0x42, 0x87, 0x00, 0x2a, 0xba, 0xfa, 0xc8, 0x56, 0xbe, 0x91, 0x6f, 0x90, 0x6d, 0x95, 0x79,
	0xa5, 0x12, 0xaa, 0x0b, 0xe2, 0xb5, 0xbc, 0x0a, 0x55, 0x17, 0x4c, 0x03, 0x3a, 0x13, 0x6e, 0xc3,
	0x74, 0x81, 0x06, 0xe8, 0x5b, 0x78, 0x30, 0x94, 0xe2, 0x4a, 0x46, 0x92, 0x06, 0x57, 0x81, 0xee,
	0x92, 0xa6, 0xae, 0xef, 0x0c, 0xa5, 0x78, 0xa7, 0xb2, 0xba, 0x5b, 0xd6, 0x73, 0xd5, 0xd2, 0x45,
	0x1d, 0x2b, 0x8d, 0xb7, 0x52, 0xb8, 0x5b, 0x46, 0xe3, 0xad, 0x14, 0xe8, 0x1b, 0x68, 0x4e, 0xd8,
	0x78, 0x39, 0x73, 0x3f, 0xd7, 0x5d, 0xbf, 0xd3, 0x4f, 0xde, 0xc4, 0x03, 0x95, 0x24, 0xa6, 0x86,
	0xdf, 0xc3, 0x97, 0xe6, 0xac, 0xf3, 0xcf, 0xc8, 0x99, 0x58, 0x06, 0x52, 0x3f, 0x63, 0x9b, 0x24,
	0x48, 0x6d, 0x99, 0x71, 0x1e, 0xf1, 0xc4, 0x5d, 0x03, 0x54, 0x2f, 0x2e, 0x05, 0x93, 0x7e, 0xc8,
	0x92, 0xc7, 0x4b, 0xe1, 0xc9, 0x3f, 0x2d, 0x78, 0xa4, 0x4c, 0x1d, 0x99, 0x4b, 0xe4, 0x52, 0xbf,
	0xed, 0xd1, 0x7b, 0x40, 0x15, 0x43, 0xda, 0xed, 0x27, 0x57, 0x4d, 0xbf, 0x72, 0x88, 0xbd, 0x5e,
	0xae, 0x5e, 0x3d, 0x97, 0x0e, 0x22, 0xf0, 0xb0, 0x34, 0x3d, 0x5f, 0xe5, 0x79, 0x8b, 0x55, 0xaf,
	0x6b, 0xb3, 0x16, 0xeb, 0xd8, 0x41, 0xbf, 0xc3, 0x6e, 0xd5, 0x30, 0x3d, 0xcd, 0xd3, 0x56, 0x2c,
	0xf0, 0xbe, 0xb6, 0x99, 0xab, 0x06, 0xc9, 0x51, 0x56, 0x54, 0xcc, 0x91, 0x65, 0x45, 0xb9, 0x5e,
	0xb4, 0xa2, 0x62, 0x7c, 0x1c, 0xf4, 0x11, 0xdc, 0x8d, 0xd3, 0xf3, 0xac, 0x92, 0xbf, 0xb0, 0xca,
	0xfb, 0xce, 0x56, 0xd9, 0x3c, 0x22, 0x0e, 0x1a, 0xc1, 0xa3, 0xf2, 0x2d, 0x74, 0x58, 0x3a, 0xd0,
	0x7c, 0xd9, 0x7b, 0x5a, 0x71, 0x9e, 0xd6, 0x3d, 0xe3, 0xa0, 0x09, 0x74, 0x36, 0xdc, 0x70, 0x38,
	0xcf, 0x5d, 0xbd, 0xc6, 0x7b, 0x66, 0x0b, 0x6c, 0xb8, 0xcd, 0x1c, 0xf4, 0x06, 0x1e, 0x14, 0x2f,
	0xa2, 0x27, 0x85, 0x9e, 0xb1, 0x78, 0x0f, 0x4b, 0x2d, 0x53, 0x20, 0xfc, 0x01, 0xb6, 0xd2, 0xef,
	0x85, 0xdd, 0x3c, 0x51, 0x92, 0xf4, 0xf6, 0x6d, 0x82, 0x24, 0x8d, 0x1d, 0xf4, 0x1c, 0xda, 0x67,
	0x4c, 0x66, 0x63, 0xb8, 0x6f, 0xf5, 0x58, 0x9a, 0xf6, 0x0e, 0x0a, 0x9d, 0x95, 0x16, 0xb0, 0x73,
	0xda, 0xfe, 0xeb, 0xb6, 0x5b, 0xfb, 0xfb, 0xb6, 0x5b, 0xfb, 0x74, 0xdb, 0xad, 0x8d, 0x5b, 0xfa,
	0x03, 0xe9, 0xfb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x47, 0x15, 0xc0, 0xf1, 0x1b, 0x0a, 0x00,
	0x00,
}
