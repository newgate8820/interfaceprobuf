// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imgeoserver/imgeoserver.proto

/*
Package imgeoserver is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/imgeoserver/imgeoserver.proto

It has these top-level messages:

	Location
	GetNearContactAndChannelResp
	GetNearContactAndChannelReq
	SetChnlGeoReq
	SetChnlGeoRsp
	SetUserGeoReq
	SetUserGeoRsp
	QueryNearbyVenuesReq
	QueryNearbyVenuesRsp
	VenueInfo
	StoreNearbyVenuesReq
	StoreNearbyVenuesRsp
*/
package imgeoserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type GeoResCode int32

const (
	GeoResCode_Successful GeoResCode = 0
	GeoResCode_UnknownErr GeoResCode = 1
	GeoResCode_InParamErr GeoResCode = 2
	GeoResCode_ModelOpErr GeoResCode = 3
	GeoResCode_CacheOpErr GeoResCode = 4
)

var GeoResCode_name = map[int32]string{
	0: "Successful",
	1: "UnknownErr",
	2: "InParamErr",
	3: "ModelOpErr",
	4: "CacheOpErr",
}
var GeoResCode_value = map[string]int32{
	"Successful": 0,
	"UnknownErr": 1,
	"InParamErr": 2,
	"ModelOpErr": 3,
	"CacheOpErr": 4,
}

func (x GeoResCode) String() string {
	return proto.EnumName(GeoResCode_name, int32(x))
}
func (GeoResCode) EnumDescriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{0} }

type Location struct {
	Lng float64 `protobuf:"fixed64,1,opt,name=lng,proto3" json:"lng,omitempty"`
	Lat float64 `protobuf:"fixed64,2,opt,name=lat,proto3" json:"lat,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{0} }

func (m *Location) GetLng() float64 {
	if m != nil {
		return m.Lng
	}
	return 0
}

func (m *Location) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

type GetNearContactAndChannelResp struct {
	Respbyts []byte `protobuf:"bytes,1,opt,name=respbyts,proto3" json:"respbyts,omitempty"`
}

func (m *GetNearContactAndChannelResp) Reset()         { *m = GetNearContactAndChannelResp{} }
func (m *GetNearContactAndChannelResp) String() string { return proto.CompactTextString(m) }
func (*GetNearContactAndChannelResp) ProtoMessage()    {}
func (*GetNearContactAndChannelResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImgeoserver, []int{1}
}

func (m *GetNearContactAndChannelResp) GetRespbyts() []byte {
	if m != nil {
		return m.Respbyts
	}
	return nil
}

type GetNearContactAndChannelReq struct {
	UserId          int32         `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyId           int64         `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	ReqMessageId    int64         `protobuf:"varint,3,opt,name=reqMessageId,proto3" json:"reqMessageId,omitempty"`
	ReqBytes        []byte        `protobuf:"bytes,4,opt,name=ReqBytes,proto3" json:"ReqBytes,omitempty"`
	IsAllowedChgGeo bool          `protobuf:"varint,5,opt,name=IsAllowedChgGeo,proto3" json:"IsAllowedChgGeo,omitempty"`
	ReqDebug        *pbcomm.Debug `protobuf:"bytes,6,opt,name=ReqDebug" json:"ReqDebug,omitempty"`
}

func (m *GetNearContactAndChannelReq) Reset()         { *m = GetNearContactAndChannelReq{} }
func (m *GetNearContactAndChannelReq) String() string { return proto.CompactTextString(m) }
func (*GetNearContactAndChannelReq) ProtoMessage()    {}
func (*GetNearContactAndChannelReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImgeoserver, []int{2}
}

func (m *GetNearContactAndChannelReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GetNearContactAndChannelReq) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *GetNearContactAndChannelReq) GetReqMessageId() int64 {
	if m != nil {
		return m.ReqMessageId
	}
	return 0
}

func (m *GetNearContactAndChannelReq) GetReqBytes() []byte {
	if m != nil {
		return m.ReqBytes
	}
	return nil
}

func (m *GetNearContactAndChannelReq) GetIsAllowedChgGeo() bool {
	if m != nil {
		return m.IsAllowedChgGeo
	}
	return false
}

func (m *GetNearContactAndChannelReq) GetReqDebug() *pbcomm.Debug {
	if m != nil {
		return m.ReqDebug
	}
	return nil
}

// 设置群地理信息
type SetChnlGeoReq struct {
	ChnlId  int32   `protobuf:"varint,1,opt,name=Chnl_id,json=ChnlId,proto3" json:"Chnl_id,omitempty"`
	GeoLng  float64 `protobuf:"fixed64,2,opt,name=Geo_lng,json=GeoLng,proto3" json:"Geo_lng,omitempty"`
	GeoLat  float64 `protobuf:"fixed64,3,opt,name=Geo_lat,json=GeoLat,proto3" json:"Geo_lat,omitempty"`
	GeoAddr string  `protobuf:"bytes,4,opt,name=GeoAddr,proto3" json:"GeoAddr,omitempty"`
}

func (m *SetChnlGeoReq) Reset()                    { *m = SetChnlGeoReq{} }
func (m *SetChnlGeoReq) String() string            { return proto.CompactTextString(m) }
func (*SetChnlGeoReq) ProtoMessage()               {}
func (*SetChnlGeoReq) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{3} }

func (m *SetChnlGeoReq) GetChnlId() int32 {
	if m != nil {
		return m.ChnlId
	}
	return 0
}

func (m *SetChnlGeoReq) GetGeoLng() float64 {
	if m != nil {
		return m.GeoLng
	}
	return 0
}

func (m *SetChnlGeoReq) GetGeoLat() float64 {
	if m != nil {
		return m.GeoLat
	}
	return 0
}

func (m *SetChnlGeoReq) GetGeoAddr() string {
	if m != nil {
		return m.GeoAddr
	}
	return ""
}

type SetChnlGeoRsp struct {
	ErrCode GeoResCode `protobuf:"varint,1,opt,name=ErrCode,proto3,enum=imgeoserver.GeoResCode" json:"ErrCode,omitempty"`
	ErrInfo string     `protobuf:"bytes,2,opt,name=ErrInfo,proto3" json:"ErrInfo,omitempty"`
}

func (m *SetChnlGeoRsp) Reset()                    { *m = SetChnlGeoRsp{} }
func (m *SetChnlGeoRsp) String() string            { return proto.CompactTextString(m) }
func (*SetChnlGeoRsp) ProtoMessage()               {}
func (*SetChnlGeoRsp) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{4} }

func (m *SetChnlGeoRsp) GetErrCode() GeoResCode {
	if m != nil {
		return m.ErrCode
	}
	return GeoResCode_Successful
}

func (m *SetChnlGeoRsp) GetErrInfo() string {
	if m != nil {
		return m.ErrInfo
	}
	return ""
}

// 设置用户地理信息
type SetUserGeoReq struct {
	UserId   int32         `protobuf:"varint,1,opt,name=User_id,json=UserId,proto3" json:"User_id,omitempty"`
	UserKey  int64         `protobuf:"varint,2,opt,name=UserKey,proto3" json:"UserKey,omitempty"`
	GeoLng   float64       `protobuf:"fixed64,3,opt,name=Geo_lng,json=GeoLng,proto3" json:"Geo_lng,omitempty"`
	GeoLat   float64       `protobuf:"fixed64,4,opt,name=Geo_lat,json=GeoLat,proto3" json:"Geo_lat,omitempty"`
	ReqDebug *pbcomm.Debug `protobuf:"bytes,5,opt,name=ReqDebug" json:"ReqDebug,omitempty"`
}

func (m *SetUserGeoReq) Reset()                    { *m = SetUserGeoReq{} }
func (m *SetUserGeoReq) String() string            { return proto.CompactTextString(m) }
func (*SetUserGeoReq) ProtoMessage()               {}
func (*SetUserGeoReq) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{5} }

func (m *SetUserGeoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SetUserGeoReq) GetUserKey() int64 {
	if m != nil {
		return m.UserKey
	}
	return 0
}

func (m *SetUserGeoReq) GetGeoLng() float64 {
	if m != nil {
		return m.GeoLng
	}
	return 0
}

func (m *SetUserGeoReq) GetGeoLat() float64 {
	if m != nil {
		return m.GeoLat
	}
	return 0
}

func (m *SetUserGeoReq) GetReqDebug() *pbcomm.Debug {
	if m != nil {
		return m.ReqDebug
	}
	return nil
}

type SetUserGeoRsp struct {
	ErrCode GeoResCode `protobuf:"varint,1,opt,name=ErrCode,proto3,enum=imgeoserver.GeoResCode" json:"ErrCode,omitempty"`
	ErrInfo string     `protobuf:"bytes,2,opt,name=ErrInfo,proto3" json:"ErrInfo,omitempty"`
}

func (m *SetUserGeoRsp) Reset()                    { *m = SetUserGeoRsp{} }
func (m *SetUserGeoRsp) String() string            { return proto.CompactTextString(m) }
func (*SetUserGeoRsp) ProtoMessage()               {}
func (*SetUserGeoRsp) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{6} }

func (m *SetUserGeoRsp) GetErrCode() GeoResCode {
	if m != nil {
		return m.ErrCode
	}
	return GeoResCode_Successful
}

func (m *SetUserGeoRsp) GetErrInfo() string {
	if m != nil {
		return m.ErrInfo
	}
	return ""
}

type QueryNearbyVenuesReq struct {
	UserId  int32   `protobuf:"varint,1,opt,name=User_id,json=UserId,proto3" json:"User_id,omitempty"`
	HashId  int64   `protobuf:"varint,2,opt,name=Hash_id,json=HashId,proto3" json:"Hash_id,omitempty"`
	GeoLng  float64 `protobuf:"fixed64,3,opt,name=Geo_lng,json=GeoLng,proto3" json:"Geo_lng,omitempty"`
	GeoLat  float64 `protobuf:"fixed64,4,opt,name=Geo_lat,json=GeoLat,proto3" json:"Geo_lat,omitempty"`
	Keyword string  `protobuf:"bytes,5,opt,name=Keyword,proto3" json:"Keyword,omitempty"`
}

func (m *QueryNearbyVenuesReq) Reset()                    { *m = QueryNearbyVenuesReq{} }
func (m *QueryNearbyVenuesReq) String() string            { return proto.CompactTextString(m) }
func (*QueryNearbyVenuesReq) ProtoMessage()               {}
func (*QueryNearbyVenuesReq) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{7} }

func (m *QueryNearbyVenuesReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *QueryNearbyVenuesReq) GetHashId() int64 {
	if m != nil {
		return m.HashId
	}
	return 0
}

func (m *QueryNearbyVenuesReq) GetGeoLng() float64 {
	if m != nil {
		return m.GeoLng
	}
	return 0
}

func (m *QueryNearbyVenuesReq) GetGeoLat() float64 {
	if m != nil {
		return m.GeoLat
	}
	return 0
}

func (m *QueryNearbyVenuesReq) GetKeyword() string {
	if m != nil {
		return m.Keyword
	}
	return ""
}

type QueryNearbyVenuesRsp struct {
	ErrCode GeoResCode   `protobuf:"varint,1,opt,name=ErrCode,proto3,enum=imgeoserver.GeoResCode" json:"ErrCode,omitempty"`
	ErrInfo string       `protobuf:"bytes,2,opt,name=ErrInfo,proto3" json:"ErrInfo,omitempty"`
	Venues  []*VenueInfo `protobuf:"bytes,3,rep,name=Venues" json:"Venues,omitempty"`
}

func (m *QueryNearbyVenuesRsp) Reset()                    { *m = QueryNearbyVenuesRsp{} }
func (m *QueryNearbyVenuesRsp) String() string            { return proto.CompactTextString(m) }
func (*QueryNearbyVenuesRsp) ProtoMessage()               {}
func (*QueryNearbyVenuesRsp) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{8} }

func (m *QueryNearbyVenuesRsp) GetErrCode() GeoResCode {
	if m != nil {
		return m.ErrCode
	}
	return GeoResCode_Successful
}

func (m *QueryNearbyVenuesRsp) GetErrInfo() string {
	if m != nil {
		return m.ErrInfo
	}
	return ""
}

func (m *QueryNearbyVenuesRsp) GetVenues() []*VenueInfo {
	if m != nil {
		return m.Venues
	}
	return nil
}

type VenueInfo struct {
	VenueId   string  `protobuf:"bytes,1,opt,name=VenueId,proto3" json:"VenueId,omitempty"`
	VenueName string  `protobuf:"bytes,2,opt,name=VenueName,proto3" json:"VenueName,omitempty"`
	VenueType string  `protobuf:"bytes,3,opt,name=VenueType,proto3" json:"VenueType,omitempty"`
	GeoLat    float64 `protobuf:"fixed64,4,opt,name=GeoLat,proto3" json:"GeoLat,omitempty"`
	GeoLng    float64 `protobuf:"fixed64,5,opt,name=GeoLng,proto3" json:"GeoLng,omitempty"`
	Region    string  `protobuf:"bytes,6,opt,name=Region,proto3" json:"Region,omitempty"`
	Street    string  `protobuf:"bytes,7,opt,name=Street,proto3" json:"Street,omitempty"`
	Address   string  `protobuf:"bytes,8,opt,name=Address,proto3" json:"Address,omitempty"`
	Country   string  `protobuf:"bytes,9,opt,name=Country,proto3" json:"Country,omitempty"`
	Locality  string  `protobuf:"bytes,10,opt,name=Locality,proto3" json:"Locality,omitempty"`
	PostTown  string  `protobuf:"bytes,11,opt,name=PostTown,proto3" json:"PostTown,omitempty"`
	Timezone  string  `protobuf:"bytes,12,opt,name=Timezone,proto3" json:"Timezone,omitempty"`
}

func (m *VenueInfo) Reset()                    { *m = VenueInfo{} }
func (m *VenueInfo) String() string            { return proto.CompactTextString(m) }
func (*VenueInfo) ProtoMessage()               {}
func (*VenueInfo) Descriptor() ([]byte, []int) { return fileDescriptorImgeoserver, []int{9} }

func (m *VenueInfo) GetVenueId() string {
	if m != nil {
		return m.VenueId
	}
	return ""
}

func (m *VenueInfo) GetVenueName() string {
	if m != nil {
		return m.VenueName
	}
	return ""
}

func (m *VenueInfo) GetVenueType() string {
	if m != nil {
		return m.VenueType
	}
	return ""
}

func (m *VenueInfo) GetGeoLat() float64 {
	if m != nil {
		return m.GeoLat
	}
	return 0
}

func (m *VenueInfo) GetGeoLng() float64 {
	if m != nil {
		return m.GeoLng
	}
	return 0
}

func (m *VenueInfo) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *VenueInfo) GetStreet() string {
	if m != nil {
		return m.Street
	}
	return ""
}

func (m *VenueInfo) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *VenueInfo) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *VenueInfo) GetLocality() string {
	if m != nil {
		return m.Locality
	}
	return ""
}

func (m *VenueInfo) GetPostTown() string {
	if m != nil {
		return m.PostTown
	}
	return ""
}

func (m *VenueInfo) GetTimezone() string {
	if m != nil {
		return m.Timezone
	}
	return ""
}

// store venue information.
type StoreNearbyVenuesReq struct {
	Venues []*VenueInfo `protobuf:"bytes,1,rep,name=Venues" json:"Venues,omitempty"`
}

func (m *StoreNearbyVenuesReq) Reset()         { *m = StoreNearbyVenuesReq{} }
func (m *StoreNearbyVenuesReq) String() string { return proto.CompactTextString(m) }
func (*StoreNearbyVenuesReq) ProtoMessage()    {}
func (*StoreNearbyVenuesReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImgeoserver, []int{10}
}

func (m *StoreNearbyVenuesReq) GetVenues() []*VenueInfo {
	if m != nil {
		return m.Venues
	}
	return nil
}

type StoreNearbyVenuesRsp struct {
	ErrCode GeoResCode `protobuf:"varint,1,opt,name=ErrCode,proto3,enum=imgeoserver.GeoResCode" json:"ErrCode,omitempty"`
	ErrInfo string     `protobuf:"bytes,2,opt,name=ErrInfo,proto3" json:"ErrInfo,omitempty"`
}

func (m *StoreNearbyVenuesRsp) Reset()         { *m = StoreNearbyVenuesRsp{} }
func (m *StoreNearbyVenuesRsp) String() string { return proto.CompactTextString(m) }
func (*StoreNearbyVenuesRsp) ProtoMessage()    {}
func (*StoreNearbyVenuesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImgeoserver, []int{11}
}

func (m *StoreNearbyVenuesRsp) GetErrCode() GeoResCode {
	if m != nil {
		return m.ErrCode
	}
	return GeoResCode_Successful
}

func (m *StoreNearbyVenuesRsp) GetErrInfo() string {
	if m != nil {
		return m.ErrInfo
	}
	return ""
}

func init() {
	proto.RegisterType((*Location)(nil), "imgeoserver.Location")
	proto.RegisterType((*GetNearContactAndChannelResp)(nil), "imgeoserver.GetNearContactAndChannelResp")
	proto.RegisterType((*GetNearContactAndChannelReq)(nil), "imgeoserver.GetNearContactAndChannelReq")
	proto.RegisterType((*SetChnlGeoReq)(nil), "imgeoserver.SetChnlGeoReq")
	proto.RegisterType((*SetChnlGeoRsp)(nil), "imgeoserver.SetChnlGeoRsp")
	proto.RegisterType((*SetUserGeoReq)(nil), "imgeoserver.SetUserGeoReq")
	proto.RegisterType((*SetUserGeoRsp)(nil), "imgeoserver.SetUserGeoRsp")
	proto.RegisterType((*QueryNearbyVenuesReq)(nil), "imgeoserver.QueryNearbyVenuesReq")
	proto.RegisterType((*QueryNearbyVenuesRsp)(nil), "imgeoserver.QueryNearbyVenuesRsp")
	proto.RegisterType((*VenueInfo)(nil), "imgeoserver.VenueInfo")
	proto.RegisterType((*StoreNearbyVenuesReq)(nil), "imgeoserver.StoreNearbyVenuesReq")
	proto.RegisterType((*StoreNearbyVenuesRsp)(nil), "imgeoserver.StoreNearbyVenuesRsp")
	proto.RegisterEnum("imgeoserver.GeoResCode", GeoResCode_name, GeoResCode_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ServerService service

type ServerServiceClient interface {
	// 超找附近的人或者群的操作
	GetNearContactAndChannel(ctx context.Context, in *GetNearContactAndChannelReq, opts ...grpc.CallOption) (*GetNearContactAndChannelResp, error)
	// 管理段设置群地理位置
	SetChnlGeo(ctx context.Context, in *SetChnlGeoReq, opts ...grpc.CallOption) (*SetChnlGeoRsp, error)
	// 管理端设置用户地理位置
	SetUserGeo(ctx context.Context, in *SetUserGeoReq, opts ...grpc.CallOption) (*SetUserGeoRsp, error)
	// 查询
	QueryNearbyVenues(ctx context.Context, in *QueryNearbyVenuesReq, opts ...grpc.CallOption) (*QueryNearbyVenuesRsp, error)
	// 存储
	StoreNearbyVenues(ctx context.Context, in *StoreNearbyVenuesReq, opts ...grpc.CallOption) (*StoreNearbyVenuesRsp, error)
}

type serverServiceClient struct {
	cc *grpc.ClientConn
}

func NewServerServiceClient(cc *grpc.ClientConn) ServerServiceClient {
	return &serverServiceClient{cc}
}

func (c *serverServiceClient) GetNearContactAndChannel(ctx context.Context, in *GetNearContactAndChannelReq, opts ...grpc.CallOption) (*GetNearContactAndChannelResp, error) {
	out := new(GetNearContactAndChannelResp)
	err := grpc.Invoke(ctx, "/imgeoserver.ServerService/GetNearContactAndChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SetChnlGeo(ctx context.Context, in *SetChnlGeoReq, opts ...grpc.CallOption) (*SetChnlGeoRsp, error) {
	out := new(SetChnlGeoRsp)
	err := grpc.Invoke(ctx, "/imgeoserver.ServerService/SetChnlGeo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SetUserGeo(ctx context.Context, in *SetUserGeoReq, opts ...grpc.CallOption) (*SetUserGeoRsp, error) {
	out := new(SetUserGeoRsp)
	err := grpc.Invoke(ctx, "/imgeoserver.ServerService/SetUserGeo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) QueryNearbyVenues(ctx context.Context, in *QueryNearbyVenuesReq, opts ...grpc.CallOption) (*QueryNearbyVenuesRsp, error) {
	out := new(QueryNearbyVenuesRsp)
	err := grpc.Invoke(ctx, "/imgeoserver.ServerService/QueryNearbyVenues", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) StoreNearbyVenues(ctx context.Context, in *StoreNearbyVenuesReq, opts ...grpc.CallOption) (*StoreNearbyVenuesRsp, error) {
	out := new(StoreNearbyVenuesRsp)
	err := grpc.Invoke(ctx, "/imgeoserver.ServerService/StoreNearbyVenues", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServerService service

type ServerServiceServer interface {
	// 超找附近的人或者群的操作
	GetNearContactAndChannel(context.Context, *GetNearContactAndChannelReq) (*GetNearContactAndChannelResp, error)
	// 管理段设置群地理位置
	SetChnlGeo(context.Context, *SetChnlGeoReq) (*SetChnlGeoRsp, error)
	// 管理端设置用户地理位置
	SetUserGeo(context.Context, *SetUserGeoReq) (*SetUserGeoRsp, error)
	// 查询
	QueryNearbyVenues(context.Context, *QueryNearbyVenuesReq) (*QueryNearbyVenuesRsp, error)
	// 存储
	StoreNearbyVenues(context.Context, *StoreNearbyVenuesReq) (*StoreNearbyVenuesRsp, error)
}

func RegisterServerServiceServer(s *grpc.Server, srv ServerServiceServer) {
	s.RegisterService(&_ServerService_serviceDesc, srv)
}

func _ServerService_GetNearContactAndChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNearContactAndChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetNearContactAndChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imgeoserver.ServerService/GetNearContactAndChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetNearContactAndChannel(ctx, req.(*GetNearContactAndChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SetChnlGeo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetChnlGeoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SetChnlGeo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imgeoserver.ServerService/SetChnlGeo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SetChnlGeo(ctx, req.(*SetChnlGeoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SetUserGeo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserGeoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SetUserGeo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imgeoserver.ServerService/SetUserGeo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SetUserGeo(ctx, req.(*SetUserGeoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_QueryNearbyVenues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryNearbyVenuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).QueryNearbyVenues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imgeoserver.ServerService/QueryNearbyVenues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).QueryNearbyVenues(ctx, req.(*QueryNearbyVenuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_StoreNearbyVenues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreNearbyVenuesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).StoreNearbyVenues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imgeoserver.ServerService/StoreNearbyVenues",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).StoreNearbyVenues(ctx, req.(*StoreNearbyVenuesReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imgeoserver.ServerService",
	HandlerType: (*ServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetNearContactAndChannel",
			Handler:    _ServerService_GetNearContactAndChannel_Handler,
		},
		{
			MethodName: "SetChnlGeo",
			Handler:    _ServerService_SetChnlGeo_Handler,
		},
		{
			MethodName: "SetUserGeo",
			Handler:    _ServerService_SetUserGeo_Handler,
		},
		{
			MethodName: "QueryNearbyVenues",
			Handler:    _ServerService_QueryNearbyVenues_Handler,
		},
		{
			MethodName: "StoreNearbyVenues",
			Handler:    _ServerService_StoreNearbyVenues_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imgeoserver/imgeoserver.proto",
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Lng != 0 {
		dAtA[i] = 0x9
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lng))))
		i += 8
	}
	if m.Lat != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i += 8
	}
	return i, nil
}

func (m *GetNearContactAndChannelResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNearContactAndChannelResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Respbyts) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Respbyts)))
		i += copy(dAtA[i:], m.Respbyts)
	}
	return i, nil
}

func (m *GetNearContactAndChannelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNearContactAndChannelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.UserId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.KeyId))
	}
	if m.ReqMessageId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ReqMessageId))
	}
	if len(m.ReqBytes) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.ReqBytes)))
		i += copy(dAtA[i:], m.ReqBytes)
	}
	if m.IsAllowedChgGeo {
		dAtA[i] = 0x28
		i++
		if m.IsAllowedChgGeo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ReqDebug != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ReqDebug.Size()))
		n1, err := m.ReqDebug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *SetChnlGeoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChnlGeoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChnlId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ChnlId))
	}
	if m.GeoLng != 0 {
		dAtA[i] = 0x11
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLng))))
		i += 8
	}
	if m.GeoLat != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLat))))
		i += 8
	}
	if len(m.GeoAddr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.GeoAddr)))
		i += copy(dAtA[i:], m.GeoAddr)
	}
	return i, nil
}

func (m *SetChnlGeoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChnlGeoRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.ErrInfo)))
		i += copy(dAtA[i:], m.ErrInfo)
	}
	return i, nil
}

func (m *SetUserGeoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUserGeoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.UserId))
	}
	if m.UserKey != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.UserKey))
	}
	if m.GeoLng != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLng))))
		i += 8
	}
	if m.GeoLat != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLat))))
		i += 8
	}
	if m.ReqDebug != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ReqDebug.Size()))
		n2, err := m.ReqDebug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *SetUserGeoRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetUserGeoRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.ErrInfo)))
		i += copy(dAtA[i:], m.ErrInfo)
	}
	return i, nil
}

func (m *QueryNearbyVenuesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNearbyVenuesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.UserId))
	}
	if m.HashId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.HashId))
	}
	if m.GeoLng != 0 {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLng))))
		i += 8
	}
	if m.GeoLat != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLat))))
		i += 8
	}
	if len(m.Keyword) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Keyword)))
		i += copy(dAtA[i:], m.Keyword)
	}
	return i, nil
}

func (m *QueryNearbyVenuesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryNearbyVenuesRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.ErrInfo)))
		i += copy(dAtA[i:], m.ErrInfo)
	}
	if len(m.Venues) > 0 {
		for _, msg := range m.Venues {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImgeoserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VenueInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VenueInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VenueId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.VenueId)))
		i += copy(dAtA[i:], m.VenueId)
	}
	if len(m.VenueName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.VenueName)))
		i += copy(dAtA[i:], m.VenueName)
	}
	if len(m.VenueType) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.VenueType)))
		i += copy(dAtA[i:], m.VenueType)
	}
	if m.GeoLat != 0 {
		dAtA[i] = 0x21
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLat))))
		i += 8
	}
	if m.GeoLng != 0 {
		dAtA[i] = 0x29
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.GeoLng))))
		i += 8
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Street) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Street)))
		i += copy(dAtA[i:], m.Street)
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.Locality) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Locality)))
		i += copy(dAtA[i:], m.Locality)
	}
	if len(m.PostTown) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.PostTown)))
		i += copy(dAtA[i:], m.PostTown)
	}
	if len(m.Timezone) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.Timezone)))
		i += copy(dAtA[i:], m.Timezone)
	}
	return i, nil
}

func (m *StoreNearbyVenuesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreNearbyVenuesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Venues) > 0 {
		for _, msg := range m.Venues {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImgeoserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StoreNearbyVenuesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreNearbyVenuesRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ErrCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImgeoserver(dAtA, i, uint64(len(m.ErrInfo)))
		i += copy(dAtA[i:], m.ErrInfo)
	}
	return i, nil
}

func encodeVarintImgeoserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Location) Size() (n int) {
	var l int
	_ = l
	if m.Lng != 0 {
		n += 9
	}
	if m.Lat != 0 {
		n += 9
	}
	return n
}

func (m *GetNearContactAndChannelResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Respbyts)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *GetNearContactAndChannelReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImgeoserver(uint64(m.UserId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImgeoserver(uint64(m.KeyId))
	}
	if m.ReqMessageId != 0 {
		n += 1 + sovImgeoserver(uint64(m.ReqMessageId))
	}
	l = len(m.ReqBytes)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	if m.IsAllowedChgGeo {
		n += 2
	}
	if m.ReqDebug != nil {
		l = m.ReqDebug.Size()
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *SetChnlGeoReq) Size() (n int) {
	var l int
	_ = l
	if m.ChnlId != 0 {
		n += 1 + sovImgeoserver(uint64(m.ChnlId))
	}
	if m.GeoLng != 0 {
		n += 9
	}
	if m.GeoLat != 0 {
		n += 9
	}
	l = len(m.GeoAddr)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *SetChnlGeoRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImgeoserver(uint64(m.ErrCode))
	}
	l = len(m.ErrInfo)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *SetUserGeoReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImgeoserver(uint64(m.UserId))
	}
	if m.UserKey != 0 {
		n += 1 + sovImgeoserver(uint64(m.UserKey))
	}
	if m.GeoLng != 0 {
		n += 9
	}
	if m.GeoLat != 0 {
		n += 9
	}
	if m.ReqDebug != nil {
		l = m.ReqDebug.Size()
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *SetUserGeoRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImgeoserver(uint64(m.ErrCode))
	}
	l = len(m.ErrInfo)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *QueryNearbyVenuesReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImgeoserver(uint64(m.UserId))
	}
	if m.HashId != 0 {
		n += 1 + sovImgeoserver(uint64(m.HashId))
	}
	if m.GeoLng != 0 {
		n += 9
	}
	if m.GeoLat != 0 {
		n += 9
	}
	l = len(m.Keyword)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *QueryNearbyVenuesRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImgeoserver(uint64(m.ErrCode))
	}
	l = len(m.ErrInfo)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	if len(m.Venues) > 0 {
		for _, e := range m.Venues {
			l = e.Size()
			n += 1 + l + sovImgeoserver(uint64(l))
		}
	}
	return n
}

func (m *VenueInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.VenueId)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.VenueName)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.VenueType)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	if m.GeoLat != 0 {
		n += 9
	}
	if m.GeoLng != 0 {
		n += 9
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.Street)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.Locality)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.PostTown)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	l = len(m.Timezone)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func (m *StoreNearbyVenuesReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Venues) > 0 {
		for _, e := range m.Venues {
			l = e.Size()
			n += 1 + l + sovImgeoserver(uint64(l))
		}
	}
	return n
}

func (m *StoreNearbyVenuesRsp) Size() (n int) {
	var l int
	_ = l
	if m.ErrCode != 0 {
		n += 1 + sovImgeoserver(uint64(m.ErrCode))
	}
	l = len(m.ErrInfo)
	if l > 0 {
		n += 1 + l + sovImgeoserver(uint64(l))
	}
	return n
}

func sovImgeoserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImgeoserver(x uint64) (n int) {
	return sovImgeoserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lng = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNearContactAndChannelResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNearContactAndChannelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNearContactAndChannelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Respbyts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Respbyts = append(m.Respbyts[:0], dAtA[iNdEx:postIndex]...)
			if m.Respbyts == nil {
				m.Respbyts = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNearContactAndChannelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNearContactAndChannelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNearContactAndChannelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMessageId", wireType)
			}
			m.ReqMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMessageId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqBytes = append(m.ReqBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.ReqBytes == nil {
				m.ReqBytes = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAllowedChgGeo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAllowedChgGeo = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqDebug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReqDebug == nil {
				m.ReqDebug = &pbcomm.Debug{}
			}
			if err := m.ReqDebug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChnlGeoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChnlGeoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChnlGeoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChnlId", wireType)
			}
			m.ChnlId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChnlId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLng = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLat = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeoAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChnlGeoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChnlGeoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChnlGeoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (GeoResCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUserGeoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUserGeoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUserGeoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserKey", wireType)
			}
			m.UserKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserKey |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLng = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLat = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqDebug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReqDebug == nil {
				m.ReqDebug = &pbcomm.Debug{}
			}
			if err := m.ReqDebug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUserGeoRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUserGeoRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUserGeoRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (GeoResCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryNearbyVenuesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNearbyVenuesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNearbyVenuesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
			}
			m.HashId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLng = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLat = float64(math.Float64frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryNearbyVenuesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryNearbyVenuesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryNearbyVenuesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (GeoResCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Venues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Venues = append(m.Venues, &VenueInfo{})
			if err := m.Venues[len(m.Venues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VenueInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VenueInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VenueInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VenueId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VenueId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VenueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VenueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VenueType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VenueType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLat = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoLng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.GeoLng = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Street", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Street = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locality = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostTown", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostTown = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timezone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Timezone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreNearbyVenuesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreNearbyVenuesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreNearbyVenuesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Venues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Venues = append(m.Venues, &VenueInfo{})
			if err := m.Venues[len(m.Venues)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreNearbyVenuesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreNearbyVenuesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreNearbyVenuesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (GeoResCode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImgeoserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImgeoserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImgeoserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImgeoserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImgeoserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImgeoserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImgeoserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImgeoserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImgeoserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImgeoserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImgeoserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imgeoserver/imgeoserver.proto", fileDescriptorImgeoserver)
}

var fileDescriptorImgeoserver = []byte{
	// 852 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x4e, 0x23, 0x47,
	0x10, 0xde, 0xc1, 0x60, 0xe3, 0x86, 0xdd, 0x90, 0xd6, 0x06, 0x5a, 0xce, 0x0a, 0x91, 0x39, 0x79,
	0x73, 0xf0, 0x2a, 0xe4, 0x12, 0xe5, 0x06, 0x0e, 0xeb, 0x58, 0xfb, 0x93, 0x4d, 0x03, 0xb9, 0x04,
	0x69, 0xd5, 0x9e, 0x29, 0xec, 0x11, 0xe3, 0xee, 0xa1, 0xbb, 0x1d, 0x34, 0x79, 0x8d, 0xe4, 0x9e,
	0xd7, 0x49, 0xa4, 0x1c, 0xf2, 0x08, 0x11, 0x4f, 0xb2, 0xaa, 0xee, 0x19, 0xdb, 0x63, 0xf0, 0xae,
	0x0f, 0x5c, 0xc0, 0x5f, 0x7d, 0xd5, 0xdf, 0x54, 0x7d, 0x5d, 0x53, 0x36, 0x39, 0x1e, 0x26, 0x36,
	0x15, 0x83, 0x4e, 0x34, 0x12, 0xd6, 0x80, 0xfe, 0x0d, 0x74, 0x27, 0x19, 0xbf, 0x48, 0xa4, 0x05,
	0x7d, 0x29, 0x22, 0xc8, 0xb4, 0x1a, 0x4c, 0x2e, 0x5f, 0x24, 0xe3, 0x21, 0x28, 0x4f, 0xcf, 0x7f,
	0xee, 0x64, 0x5a, 0x59, 0x45, 0xb7, 0xe6, 0x42, 0xad, 0xef, 0x56, 0x12, 0xcc, 0x06, 0x91, 0x1a,
	0x8f, 0x8b, 0x7f, 0x5e, 0x26, 0xec, 0x90, 0xcd, 0xd7, 0x2a, 0x12, 0x36, 0x51, 0x92, 0xee, 0x90,
	0x5a, 0x2a, 0x87, 0x2c, 0x38, 0x08, 0xda, 0x01, 0xc7, 0x8f, 0x2e, 0x22, 0x2c, 0x5b, 0x2b, 0x22,
	0xc2, 0x86, 0xdf, 0x93, 0x67, 0x3d, 0xb0, 0x6f, 0x41, 0xe8, 0xae, 0x92, 0x56, 0x44, 0xf6, 0x48,
	0xc6, 0xdd, 0x91, 0x90, 0x12, 0x52, 0x0e, 0x26, 0xa3, 0x2d, 0xb2, 0xa9, 0xc1, 0x64, 0x83, 0xdc,
	0x1a, 0x27, 0xb4, 0xcd, 0xa7, 0x38, 0xbc, 0x0d, 0xc8, 0x97, 0xcb, 0x0f, 0x5f, 0xd3, 0x3d, 0xd2,
	0x98, 0x18, 0xd0, 0xef, 0x93, 0xd8, 0x1d, 0xdd, 0xe0, 0x75, 0x84, 0xfd, 0x98, 0x7e, 0x41, 0xea,
	0x57, 0x90, 0x63, 0x1c, 0x2b, 0xa9, 0xf1, 0x8d, 0x2b, 0xc8, 0xfb, 0x31, 0x0d, 0xc9, 0xb6, 0x86,
	0xeb, 0x37, 0x60, 0x8c, 0x18, 0x42, 0x3f, 0x66, 0x35, 0x47, 0x56, 0x62, 0x58, 0x0f, 0x87, 0xeb,
	0xe3, 0xdc, 0x82, 0x61, 0xeb, 0xbe, 0x9e, 0x12, 0xd3, 0x36, 0xf9, 0xac, 0x6f, 0x8e, 0xd2, 0x54,
	0xdd, 0x40, 0xdc, 0x1d, 0x0d, 0x7b, 0xa0, 0xd8, 0xc6, 0x41, 0xd0, 0xde, 0xe4, 0x8b, 0x61, 0xfa,
	0xdc, 0xa9, 0xfc, 0x00, 0x83, 0xc9, 0x90, 0xd5, 0x0f, 0x82, 0xf6, 0xd6, 0xe1, 0xe3, 0x4e, 0x61,
	0xa3, 0x0b, 0xf2, 0x29, 0x1d, 0x5a, 0xf2, 0xf8, 0x14, 0x6c, 0x77, 0x24, 0xd3, 0x1e, 0xa8, 0xa2,
	0x2b, 0x44, 0x73, 0x5d, 0x21, 0xec, 0xc7, 0x48, 0xf4, 0x40, 0xbd, 0x47, 0xcb, 0xbd, 0xc1, 0xf5,
	0x1e, 0xa8, 0xd7, 0x72, 0x38, 0x25, 0x84, 0x75, 0x2d, 0x15, 0x84, 0xb0, 0x94, 0x39, 0xe2, 0x28,
	0x8e, 0xb5, 0xeb, 0xa5, 0xc9, 0x4b, 0x18, 0x5e, 0x54, 0x9e, 0x6a, 0x32, 0xfa, 0x0d, 0x69, 0x9c,
	0x68, 0xdd, 0x55, 0x31, 0xb8, 0xa7, 0x3e, 0x39, 0xdc, 0xeb, 0xcc, 0xcf, 0x90, 0xab, 0xcd, 0x20,
	0xcd, 0xcb, 0x3c, 0x54, 0x3f, 0xd1, 0xba, 0x2f, 0x2f, 0x95, 0xab, 0xa7, 0xc9, 0x4b, 0x18, 0xfe,
	0x15, 0x38, 0xf9, 0x73, 0x03, 0x7a, 0xd6, 0xd4, 0x79, 0xf5, 0xaa, 0xce, 0xfd, 0x55, 0x31, 0x4f,
	0xbc, 0x82, 0xbc, 0xb8, 0xab, 0x12, 0xce, 0xb7, 0x5b, 0x5b, 0xd6, 0xee, 0x7a, 0xa5, 0xdd, 0x79,
	0xd7, 0x37, 0x3e, 0xee, 0xfa, 0x45, 0xa5, 0xc0, 0x87, 0xee, 0xff, 0xcf, 0x80, 0x3c, 0xfd, 0x79,
	0x02, 0x3a, 0xc7, 0xd1, 0x1d, 0xe4, 0xbf, 0x80, 0x9c, 0x80, 0xf9, 0xa8, 0x0d, 0x7b, 0xa4, 0xf1,
	0xa3, 0x30, 0xa3, 0xd9, 0xc8, 0xd6, 0x11, 0x56, 0x2f, 0x7d, 0x45, 0x17, 0x18, 0x69, 0xbc, 0x82,
	0xfc, 0x46, 0xe9, 0xd8, 0x99, 0xd0, 0xe4, 0x25, 0x0c, 0xff, 0xb8, 0xb7, 0xac, 0x07, 0x6e, 0x9e,
	0x76, 0x48, 0xdd, 0x2b, 0xb3, 0xda, 0x41, 0xad, 0xbd, 0x75, 0xb8, 0x5b, 0xd1, 0x72, 0x14, 0xe6,
	0xf1, 0x22, 0x2b, 0xfc, 0x67, 0x8d, 0x34, 0xa7, 0x51, 0xd4, 0xf5, 0xc0, 0x3b, 0xd4, 0xe4, 0x25,
	0xa4, 0xcf, 0x8a, 0xb4, 0xb7, 0x62, 0x0c, 0xc5, 0x33, 0x67, 0x81, 0x29, 0x7b, 0x96, 0x67, 0xe0,
	0x9c, 0x2a, 0x59, 0x0c, 0xd0, 0x5d, 0x52, 0xb8, 0xb3, 0xe0, 0x55, 0x11, 0x97, 0x7e, 0x5e, 0x66,
	0xe6, 0xee, 0x92, 0x3a, 0x87, 0x61, 0xa2, 0xa4, 0x7b, 0x7b, 0x9b, 0xbc, 0x40, 0x18, 0x3f, 0xb5,
	0x1a, 0xc0, 0xb2, 0x86, 0x8f, 0x7b, 0x84, 0x55, 0xe3, 0x6b, 0x05, 0xc6, 0xb0, 0x4d, 0x5f, 0x75,
	0x01, 0x91, 0xe9, 0xaa, 0x89, 0xb4, 0x3a, 0x67, 0x4d, 0xcf, 0x14, 0x10, 0x37, 0x0d, 0x6e, 0xd2,
	0x34, 0xb1, 0x39, 0x23, 0x8e, 0x9a, 0x62, 0xe4, 0xde, 0x29, 0x63, 0xcf, 0xd4, 0x8d, 0x64, 0x5b,
	0x9e, 0x2b, 0x31, 0x72, 0x67, 0xc9, 0x18, 0x7e, 0x57, 0x12, 0xd8, 0xb6, 0xe7, 0x4a, 0x1c, 0xbe,
	0x24, 0x4f, 0x4f, 0xad, 0xd2, 0xb0, 0x38, 0x77, 0xb3, 0x3b, 0x09, 0x56, 0xba, 0x93, 0xe8, 0x3e,
	0x9d, 0x07, 0x1e, 0x94, 0xaf, 0x2f, 0x08, 0x99, 0x1d, 0xa0, 0x4f, 0x08, 0x39, 0x9d, 0x44, 0x11,
	0x18, 0x73, 0x39, 0x49, 0x77, 0x1e, 0x21, 0x3e, 0x97, 0x57, 0x52, 0xdd, 0xc8, 0x13, 0xad, 0x77,
	0x02, 0xc4, 0x7d, 0xf9, 0x4e, 0x68, 0x31, 0x46, 0xbc, 0x86, 0xf8, 0x8d, 0x8a, 0x21, 0xfd, 0x29,
	0x43, 0x5c, 0x43, 0xdc, 0x15, 0xd1, 0x08, 0x3c, 0x5e, 0x3f, 0xfc, 0xb7, 0x86, 0xaf, 0x38, 0x96,
	0x85, 0x7f, 0x93, 0x08, 0xe8, 0x35, 0x61, 0xcb, 0xbe, 0x4d, 0x68, 0x7b, 0xa1, 0x8f, 0xa5, 0x5f,
	0x3a, 0xad, 0xe7, 0x2b, 0x66, 0x9a, 0x2c, 0x7c, 0x44, 0x5f, 0x12, 0x32, 0x5b, 0xb3, 0xb4, 0x55,
	0x39, 0x5a, 0xd9, 0xfa, 0xad, 0xa5, 0xdc, 0x9c, 0x4e, 0xb1, 0xae, 0xee, 0xea, 0xcc, 0x16, 0x6d,
	0x6b, 0x29, 0xe7, 0x74, 0x7e, 0x25, 0x9f, 0xdf, 0x59, 0x00, 0xf4, 0xab, 0xca, 0x91, 0xfb, 0xf6,
	0x56, 0xeb, 0x53, 0x29, 0xa5, 0xf8, 0x9d, 0xa1, 0x59, 0x10, 0xbf, 0x6f, 0x38, 0x5b, 0x9f, 0x4a,
	0x41, 0xf1, 0xe3, 0xed, 0xbf, 0x6f, 0xf7, 0x83, 0xff, 0x6e, 0xf7, 0x83, 0xff, 0x6f, 0xf7, 0x83,
	0x41, 0xdd, 0xfd, 0x18, 0xf9, 0xf6, 0x43, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x7a, 0xe9, 0x6a,
	0x19, 0x09, 0x00, 0x00,
}
