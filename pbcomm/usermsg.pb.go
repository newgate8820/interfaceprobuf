// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: usermsg.proto

package pbcomm

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// 用户消息
type UserMsg struct {
	Id           int64        `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	UserId       int32        `protobuf:"varint,2,opt,name=UserId,proto3" json:"UserId,omitempty"`
	WithId       int32        `protobuf:"varint,3,opt,name=WithId,proto3" json:"WithId,omitempty"`
	WithIdType   int32        `protobuf:"varint,4,opt,name=WithIdType,proto3" json:"WithIdType,omitempty"`
	MessageType  int32        `protobuf:"varint,5,opt,name=MessageType,proto3" json:"MessageType,omitempty"`
	Flags        int32        `protobuf:"varint,6,opt,name=Flags,proto3" json:"Flags,omitempty"`
	Out          bool         `protobuf:"varint,7,opt,name=Out,proto3" json:"Out,omitempty"`
	Mentioned    bool         `protobuf:"varint,8,opt,name=Mentioned,proto3" json:"Mentioned,omitempty"`
	MediaUnread  bool         `protobuf:"varint,9,opt,name=MediaUnread,proto3" json:"MediaUnread,omitempty"`
	Silent       bool         `protobuf:"varint,10,opt,name=Silent,proto3" json:"Silent,omitempty"`
	Post         bool         `protobuf:"varint,11,opt,name=Post,proto3" json:"Post,omitempty"`
	GroupId      int64        `protobuf:"varint,12,opt,name=GroupId,proto3" json:"GroupId,omitempty"`
	MsgId        int32        `protobuf:"varint,13,opt,name=MsgId,proto3" json:"MsgId,omitempty"`
	ToId         int32        `protobuf:"varint,14,opt,name=ToId,proto3" json:"ToId,omitempty"`
	Pts          int32        `protobuf:"varint,15,opt,name=Pts,proto3" json:"Pts,omitempty"`
	FwdFrom      []byte       `protobuf:"bytes,16,opt,name=FwdFrom,proto3" json:"FwdFrom,omitempty"`
	ViaBotId     int32        `protobuf:"varint,17,opt,name=ViaBotId,proto3" json:"ViaBotId,omitempty"`
	ReplyToMsgId int32        `protobuf:"varint,18,opt,name=ReplyToMsgId,proto3" json:"ReplyToMsgId,omitempty"`
	Date         int32        `protobuf:"varint,19,opt,name=Date,proto3" json:"Date,omitempty"`
	Message      string       `protobuf:"bytes,20,opt,name=Message,proto3" json:"Message,omitempty"`
	Media        int64        `protobuf:"varint,21,opt,name=Media,proto3" json:"Media,omitempty"`
	MediaData    []byte       `protobuf:"bytes,22,opt,name=MediaData,proto3" json:"MediaData,omitempty"`
	ReplyMarkup  []byte       `protobuf:"bytes,23,opt,name=ReplyMarkup,proto3" json:"ReplyMarkup,omitempty"`
	Entities     [][]byte     `protobuf:"bytes,24,rep,name=Entities" json:"Entities,omitempty"`
	FromId       int32        `protobuf:"varint,25,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Views        int32        `protobuf:"varint,26,opt,name=Views,proto3" json:"Views,omitempty"`
	EditDate     int32        `protobuf:"varint,27,opt,name=EditDate,proto3" json:"EditDate,omitempty"`
	Action       []byte       `protobuf:"bytes,28,opt,name=Action,proto3" json:"Action,omitempty"`
	RandomId     int64        `protobuf:"varint,29,opt,name=RandomId,proto3" json:"RandomId,omitempty"`
	Uuid         int64        `protobuf:"varint,30,opt,name=Uuid,proto3" json:"Uuid,omitempty"`
	InsertDate   int32        `protobuf:"varint,31,opt,name=InsertDate,proto3" json:"InsertDate,omitempty"`
	UpdateDate   int32        `protobuf:"varint,32,opt,name=UpdateDate,proto3" json:"UpdateDate,omitempty"`
	Encry        int32        `protobuf:"varint,33,opt,name=Encry,proto3" json:"Encry,omitempty"`
	Combination  *Combination `protobuf:"bytes,34,opt,name=Combination" json:"Combination,omitempty" xorm:"json"`
}

func (m *UserMsg) Reset()                    { *m = UserMsg{} }
func (m *UserMsg) String() string            { return proto.CompactTextString(m) }
func (*UserMsg) ProtoMessage()               {}
func (*UserMsg) Descriptor() ([]byte, []int) { return fileDescriptorUsermsg, []int{0} }

func (m *UserMsg) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserMsg) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserMsg) GetWithId() int32 {
	if m != nil {
		return m.WithId
	}
	return 0
}

func (m *UserMsg) GetWithIdType() int32 {
	if m != nil {
		return m.WithIdType
	}
	return 0
}

func (m *UserMsg) GetMessageType() int32 {
	if m != nil {
		return m.MessageType
	}
	return 0
}

func (m *UserMsg) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *UserMsg) GetOut() bool {
	if m != nil {
		return m.Out
	}
	return false
}

func (m *UserMsg) GetMentioned() bool {
	if m != nil {
		return m.Mentioned
	}
	return false
}

func (m *UserMsg) GetMediaUnread() bool {
	if m != nil {
		return m.MediaUnread
	}
	return false
}

func (m *UserMsg) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *UserMsg) GetPost() bool {
	if m != nil {
		return m.Post
	}
	return false
}

func (m *UserMsg) GetGroupId() int64 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UserMsg) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *UserMsg) GetToId() int32 {
	if m != nil {
		return m.ToId
	}
	return 0
}

func (m *UserMsg) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *UserMsg) GetFwdFrom() []byte {
	if m != nil {
		return m.FwdFrom
	}
	return nil
}

func (m *UserMsg) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

func (m *UserMsg) GetReplyToMsgId() int32 {
	if m != nil {
		return m.ReplyToMsgId
	}
	return 0
}

func (m *UserMsg) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *UserMsg) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *UserMsg) GetMedia() int64 {
	if m != nil {
		return m.Media
	}
	return 0
}

func (m *UserMsg) GetMediaData() []byte {
	if m != nil {
		return m.MediaData
	}
	return nil
}

func (m *UserMsg) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *UserMsg) GetEntities() [][]byte {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *UserMsg) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *UserMsg) GetViews() int32 {
	if m != nil {
		return m.Views
	}
	return 0
}

func (m *UserMsg) GetEditDate() int32 {
	if m != nil {
		return m.EditDate
	}
	return 0
}

func (m *UserMsg) GetAction() []byte {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *UserMsg) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *UserMsg) GetUuid() int64 {
	if m != nil {
		return m.Uuid
	}
	return 0
}

func (m *UserMsg) GetInsertDate() int32 {
	if m != nil {
		return m.InsertDate
	}
	return 0
}

func (m *UserMsg) GetUpdateDate() int32 {
	if m != nil {
		return m.UpdateDate
	}
	return 0
}

func (m *UserMsg) GetEncry() int32 {
	if m != nil {
		return m.Encry
	}
	return 0
}

func (m *UserMsg) GetCombination() *Combination {
	if m != nil {
		return m.Combination
	}
	return nil
}

type MentionStatus struct {
	UserId int32 `protobuf:"varint,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	Status int32 `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *MentionStatus) Reset()                    { *m = MentionStatus{} }
func (m *MentionStatus) String() string            { return proto.CompactTextString(m) }
func (*MentionStatus) ProtoMessage()               {}
func (*MentionStatus) Descriptor() ([]byte, []int) { return fileDescriptorUsermsg, []int{1} }

func (m *MentionStatus) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MentionStatus) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type Combination struct {
	MentionedSlice []*MentionStatus `protobuf:"bytes,1,rep,name=MentionedSlice" json:"MentionedSlice,omitempty"`
	KeyId          []int64          `protobuf:"varint,2,rep,packed,name=KeyId" json:"KeyId,omitempty"`
}

func (m *Combination) Reset()                    { *m = Combination{} }
func (m *Combination) String() string            { return proto.CompactTextString(m) }
func (*Combination) ProtoMessage()               {}
func (*Combination) Descriptor() ([]byte, []int) { return fileDescriptorUsermsg, []int{2} }

func (m *Combination) GetMentionedSlice() []*MentionStatus {
	if m != nil {
		return m.MentionedSlice
	}
	return nil
}

func (m *Combination) GetKeyId() []int64 {
	if m != nil {
		return m.KeyId
	}
	return nil
}

func init() {
	proto.RegisterType((*UserMsg)(nil), "pbcomm.UserMsg")
	proto.RegisterType((*MentionStatus)(nil), "pbcomm.MentionStatus")
	proto.RegisterType((*Combination)(nil), "pbcomm.Combination")
}
func (m *UserMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Id))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.UserId))
	}
	if m.WithId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.WithIdType))
	}
	if m.MessageType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.MessageType))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Flags))
	}
	if m.Out {
		dAtA[i] = 0x38
		i++
		if m.Out {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mentioned {
		dAtA[i] = 0x40
		i++
		if m.Mentioned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MediaUnread {
		dAtA[i] = 0x48
		i++
		if m.MediaUnread {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Silent {
		dAtA[i] = 0x50
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Post {
		dAtA[i] = 0x58
		i++
		if m.Post {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.GroupId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.GroupId))
	}
	if m.MsgId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.MsgId))
	}
	if m.ToId != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.ToId))
	}
	if m.Pts != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Pts))
	}
	if len(m.FwdFrom) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(len(m.FwdFrom)))
		i += copy(dAtA[i:], m.FwdFrom)
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.ViaBotId))
	}
	if m.ReplyToMsgId != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.ReplyToMsgId))
	}
	if m.Date != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Date))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.Media != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Media))
	}
	if len(m.MediaData) > 0 {
		dAtA[i] = 0xb2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(len(m.MediaData)))
		i += copy(dAtA[i:], m.MediaData)
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintUsermsg(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.FromId != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.FromId))
	}
	if m.Views != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Views))
	}
	if m.EditDate != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.EditDate))
	}
	if len(m.Action) > 0 {
		dAtA[i] = 0xe2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(len(m.Action)))
		i += copy(dAtA[i:], m.Action)
	}
	if m.RandomId != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.RandomId))
	}
	if m.Uuid != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Uuid))
	}
	if m.InsertDate != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.UpdateDate))
	}
	if m.Encry != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Encry))
	}
	if m.Combination != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Combination.Size()))
		n1, err := m.Combination.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *MentionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MentionStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.UserId))
	}
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(m.Status))
	}
	return i, nil
}

func (m *Combination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Combination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MentionedSlice) > 0 {
		for _, msg := range m.MentionedSlice {
			dAtA[i] = 0xa
			i++
			i = encodeVarintUsermsg(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.KeyId) > 0 {
		dAtA3 := make([]byte, len(m.KeyId)*10)
		var j2 int
		for _, num1 := range m.KeyId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintUsermsg(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func encodeVarintUsermsg(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserMsg) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovUsermsg(uint64(m.Id))
	}
	if m.UserId != 0 {
		n += 1 + sovUsermsg(uint64(m.UserId))
	}
	if m.WithId != 0 {
		n += 1 + sovUsermsg(uint64(m.WithId))
	}
	if m.WithIdType != 0 {
		n += 1 + sovUsermsg(uint64(m.WithIdType))
	}
	if m.MessageType != 0 {
		n += 1 + sovUsermsg(uint64(m.MessageType))
	}
	if m.Flags != 0 {
		n += 1 + sovUsermsg(uint64(m.Flags))
	}
	if m.Out {
		n += 2
	}
	if m.Mentioned {
		n += 2
	}
	if m.MediaUnread {
		n += 2
	}
	if m.Silent {
		n += 2
	}
	if m.Post {
		n += 2
	}
	if m.GroupId != 0 {
		n += 1 + sovUsermsg(uint64(m.GroupId))
	}
	if m.MsgId != 0 {
		n += 1 + sovUsermsg(uint64(m.MsgId))
	}
	if m.ToId != 0 {
		n += 1 + sovUsermsg(uint64(m.ToId))
	}
	if m.Pts != 0 {
		n += 1 + sovUsermsg(uint64(m.Pts))
	}
	l = len(m.FwdFrom)
	if l > 0 {
		n += 2 + l + sovUsermsg(uint64(l))
	}
	if m.ViaBotId != 0 {
		n += 2 + sovUsermsg(uint64(m.ViaBotId))
	}
	if m.ReplyToMsgId != 0 {
		n += 2 + sovUsermsg(uint64(m.ReplyToMsgId))
	}
	if m.Date != 0 {
		n += 2 + sovUsermsg(uint64(m.Date))
	}
	l = len(m.Message)
	if l > 0 {
		n += 2 + l + sovUsermsg(uint64(l))
	}
	if m.Media != 0 {
		n += 2 + sovUsermsg(uint64(m.Media))
	}
	l = len(m.MediaData)
	if l > 0 {
		n += 2 + l + sovUsermsg(uint64(l))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 2 + l + sovUsermsg(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			l = len(b)
			n += 2 + l + sovUsermsg(uint64(l))
		}
	}
	if m.FromId != 0 {
		n += 2 + sovUsermsg(uint64(m.FromId))
	}
	if m.Views != 0 {
		n += 2 + sovUsermsg(uint64(m.Views))
	}
	if m.EditDate != 0 {
		n += 2 + sovUsermsg(uint64(m.EditDate))
	}
	l = len(m.Action)
	if l > 0 {
		n += 2 + l + sovUsermsg(uint64(l))
	}
	if m.RandomId != 0 {
		n += 2 + sovUsermsg(uint64(m.RandomId))
	}
	if m.Uuid != 0 {
		n += 2 + sovUsermsg(uint64(m.Uuid))
	}
	if m.InsertDate != 0 {
		n += 2 + sovUsermsg(uint64(m.InsertDate))
	}
	if m.UpdateDate != 0 {
		n += 2 + sovUsermsg(uint64(m.UpdateDate))
	}
	if m.Encry != 0 {
		n += 2 + sovUsermsg(uint64(m.Encry))
	}
	if m.Combination != nil {
		l = m.Combination.Size()
		n += 2 + l + sovUsermsg(uint64(l))
	}
	return n
}

func (m *MentionStatus) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovUsermsg(uint64(m.UserId))
	}
	if m.Status != 0 {
		n += 1 + sovUsermsg(uint64(m.Status))
	}
	return n
}

func (m *Combination) Size() (n int) {
	var l int
	_ = l
	if len(m.MentionedSlice) > 0 {
		for _, e := range m.MentionedSlice {
			l = e.Size()
			n += 1 + l + sovUsermsg(uint64(l))
		}
	}
	if len(m.KeyId) > 0 {
		l = 0
		for _, e := range m.KeyId {
			l += sovUsermsg(uint64(e))
		}
		n += 1 + sovUsermsg(uint64(l)) + l
	}
	return n
}

func sovUsermsg(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozUsermsg(x uint64) (n int) {
	return sovUsermsg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsermsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithId", wireType)
			}
			m.WithId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithIdType", wireType)
			}
			m.WithIdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithIdType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Out", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Out = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mentioned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mentioned = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaUnread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MediaUnread = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Post = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToId", wireType)
			}
			m.ToId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FwdFrom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FwdFrom = append(m.FwdFrom[:0], dAtA[iNdEx:postIndex]...)
			if m.FwdFrom == nil {
				m.FwdFrom = []byte{}
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMsgId", wireType)
			}
			m.ReplyToMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			m.Media = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Media |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MediaData = append(m.MediaData[:0], dAtA[iNdEx:postIndex]...)
			if m.MediaData == nil {
				m.MediaData = []byte{}
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, make([]byte, postIndex-iNdEx))
			copy(m.Entities[len(m.Entities)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Views", wireType)
			}
			m.Views = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Views |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EditDate", wireType)
			}
			m.EditDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EditDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = append(m.Action[:0], dAtA[iNdEx:postIndex]...)
			if m.Action == nil {
				m.Action = []byte{}
			}
			iNdEx = postIndex
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			m.Uuid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uuid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InsertDate", wireType)
			}
			m.InsertDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InsertDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDate", wireType)
			}
			m.UpdateDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encry", wireType)
			}
			m.Encry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Encry |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Combination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Combination == nil {
				m.Combination = &Combination{}
			}
			if err := m.Combination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsermsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUsermsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MentionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsermsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MentionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MentionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsermsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUsermsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Combination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsermsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Combination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Combination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MentionedSlice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsermsg
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MentionedSlice = append(m.MentionedSlice, &MentionStatus{})
			if err := m.MentionedSlice[len(m.MentionedSlice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUsermsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KeyId = append(m.KeyId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowUsermsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthUsermsg
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowUsermsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.KeyId = append(m.KeyId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsermsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthUsermsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUsermsg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUsermsg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUsermsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthUsermsg
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowUsermsg
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipUsermsg(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthUsermsg = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUsermsg   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("usermsg.proto", fileDescriptorUsermsg) }

var fileDescriptorUsermsg = []byte{
	// 589 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x5c, 0x54, 0xcf, 0x6e, 0xda, 0x4e,
	0x10, 0xd6, 0xc6, 0x09, 0x24, 0x0b, 0xc9, 0x2f, 0xbf, 0xcd, 0x9f, 0x4e, 0xd3, 0x94, 0xba, 0x9c,
	0x7c, 0xe2, 0x90, 0xaa, 0xc7, 0xaa, 0x6a, 0x9a, 0x50, 0x59, 0x15, 0x6a, 0x64, 0x20, 0x3d, 0x2f,
	0xec, 0x8a, 0xae, 0x0a, 0xb6, 0xe5, 0x5d, 0x2b, 0xe2, 0x25, 0xfa, 0x5c, 0x3d, 0xf6, 0x11, 0x2a,
	0x9e, 0xa4, 0x9a, 0x59, 0x0c, 0x26, 0xb7, 0xf9, 0xbe, 0x6f, 0xd8, 0x6f, 0x66, 0x98, 0x31, 0x3f,
	0x2e, 0xad, 0x2e, 0x16, 0x76, 0xd6, 0xcb, 0x8b, 0xcc, 0x65, 0xa2, 0x91, 0x4f, 0xa6, 0xd9, 0x62,
	0xd1, 0xfd, 0xd5, 0xe4, 0xcd, 0xb1, 0xd5, 0xc5, 0xc0, 0xce, 0xc4, 0x09, 0xdf, 0x8b, 0x15, 0xb0,
	0x90, 0x45, 0x41, 0xb2, 0x17, 0x2b, 0x71, 0xc9, 0x1b, 0x28, 0xc5, 0x0a, 0xf6, 0x42, 0x16, 0x1d,
	0x24, 0x6b, 0x84, 0xfc, 0x77, 0xe3, 0x7e, 0xc4, 0x0a, 0x02, 0xcf, 0x7b, 0x24, 0x3a, 0x9c, 0xfb,
	0x68, 0xb4, 0xcc, 0x35, 0xec, 0x93, 0x56, 0x63, 0x44, 0xc8, 0x5b, 0x03, 0x6d, 0xad, 0x9c, 0x69,
	0x4a, 0x38, 0xa0, 0x84, 0x3a, 0x25, 0xce, 0xf9, 0x41, 0x7f, 0x2e, 0x67, 0x16, 0x1a, 0xa4, 0x79,
	0x20, 0x4e, 0x79, 0xf0, 0xad, 0x74, 0xd0, 0x0c, 0x59, 0x74, 0x98, 0x60, 0x28, 0xae, 0xf9, 0xd1,
	0x40, 0xa7, 0xce, 0x64, 0xa9, 0x56, 0x70, 0x48, 0xfc, 0x96, 0xf0, 0x3e, 0xca, 0xc8, 0x71, 0x5a,
	0x68, 0xa9, 0xe0, 0x88, 0xf4, 0x3a, 0x85, 0x1d, 0x0c, 0xcd, 0x5c, 0xa7, 0x0e, 0x38, 0x89, 0x6b,
	0x24, 0x04, 0xdf, 0x7f, 0xc8, 0xac, 0x83, 0x16, 0xb1, 0x14, 0x0b, 0xe0, 0xcd, 0x2f, 0x45, 0x56,
	0xe6, 0xb1, 0x82, 0x36, 0x8d, 0xa6, 0x82, 0x58, 0xed, 0xc0, 0xce, 0x62, 0x05, 0xc7, 0xbe, 0x5a,
	0x02, 0xf8, 0xc6, 0x28, 0x8b, 0x15, 0x9c, 0x10, 0x49, 0x31, 0x76, 0xf0, 0xe0, 0x2c, 0xfc, 0x47,
	0x14, 0x86, 0xf8, 0x6a, 0xff, 0x49, 0xf5, 0x8b, 0x6c, 0x01, 0xa7, 0x21, 0x8b, 0xda, 0x49, 0x05,
	0xc5, 0x15, 0x3f, 0x7c, 0x34, 0xf2, 0x36, 0x73, 0xb1, 0x82, 0xff, 0xe9, 0x07, 0x1b, 0x2c, 0xba,
	0xbc, 0x9d, 0xe8, 0x7c, 0xbe, 0x1c, 0x65, 0xde, 0x58, 0x90, 0xbe, 0xc3, 0xa1, 0xff, 0x9d, 0x74,
	0x1a, 0xce, 0xbc, 0x3f, 0xc6, 0xe8, 0xb6, 0x1e, 0x33, 0x9c, 0x87, 0x2c, 0x3a, 0x4a, 0x2a, 0x48,
	0x3d, 0xe0, 0x60, 0xe0, 0x82, 0x7a, 0xf3, 0xc0, 0xcf, 0x57, 0x19, 0x79, 0x27, 0x9d, 0x84, 0x4b,
	0xaa, 0x6f, 0x4b, 0xe0, 0x7c, 0xc9, 0x71, 0x20, 0x8b, 0x9f, 0x65, 0x0e, 0x2f, 0x48, 0xaf, 0x53,
	0xd8, 0xc3, 0x7d, 0xea, 0x8c, 0x33, 0xda, 0x02, 0x84, 0x41, 0xd4, 0x4e, 0x36, 0x18, 0x67, 0x8f,
	0x7d, 0xc6, 0x0a, 0x5e, 0xfa, 0xed, 0xf1, 0x08, 0x2b, 0x79, 0x34, 0xfa, 0xc9, 0xc2, 0x95, 0x9f,
	0x26, 0x01, 0x7a, 0x49, 0x19, 0x47, 0x1d, 0xbd, 0xf2, 0xd3, 0xa8, 0x30, 0xbe, 0xf4, 0x69, 0x8a,
	0xff, 0x39, 0x5c, 0x53, 0x09, 0x6b, 0x84, 0xbf, 0x49, 0x64, 0xaa, 0xc8, 0xe3, 0x35, 0xb5, 0xb5,
	0xc1, 0x38, 0x9d, 0x71, 0x69, 0x14, 0x74, 0x88, 0xa7, 0x18, 0xf7, 0x36, 0x4e, 0xad, 0x2e, 0xbc,
	0xcb, 0x1b, 0xbf, 0xb7, 0x5b, 0x06, 0xf5, 0x71, 0xae, 0xa4, 0xd3, 0xa4, 0x87, 0x5e, 0xdf, 0x32,
	0x58, 0xf9, 0x7d, 0x3a, 0x2d, 0x96, 0xf0, 0xd6, 0x57, 0x4e, 0x40, 0xbc, 0xe7, 0xad, 0xcf, 0xd9,
	0x62, 0x62, 0x52, 0x49, 0x25, 0x76, 0x43, 0x16, 0xb5, 0x6e, 0xce, 0x7a, 0xfe, 0xee, 0x7a, 0x35,
	0x29, 0xa9, 0xe7, 0x75, 0x3f, 0xf2, 0xe3, 0xf5, 0x26, 0x0f, 0x9d, 0x74, 0xa5, 0xad, 0x5d, 0x21,
	0x7b, 0x7e, 0x85, 0x3e, 0xa3, 0xba, 0x4e, 0x8f, 0xba, 0x93, 0x1d, 0x5f, 0xf1, 0x81, 0x9f, 0x6c,
	0x2e, 0x63, 0x38, 0x37, 0x53, 0x0d, 0x2c, 0x0c, 0xa2, 0xd6, 0xcd, 0x45, 0x55, 0xc9, 0x8e, 0x5b,
	0xf2, 0x2c, 0x19, 0x7b, 0xfb, 0xaa, 0x97, 0xf4, 0x09, 0x08, 0x70, 0x3f, 0x08, 0xdc, 0xb6, 0x7f,
	0xaf, 0x3a, 0xec, 0xcf, 0xaa, 0xc3, 0xfe, 0xae, 0x3a, 0x6c, 0xd2, 0xa0, 0x4f, 0xca, 0xbb, 0x7f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xec, 0x0e, 0x01, 0xf9, 0x63, 0x04, 0x00, 0x00,
}
