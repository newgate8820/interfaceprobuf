// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/imchannelserver/imchannelserver.proto

package imchannelserver

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import pbcomm "gitlab.chatserver.im/interfaceprobuf/pbcomm"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SendGameRdpReq struct {
	FromKeyId int64         `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    int32         `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte        `protobuf:"bytes,4,opt,name=Req,proto3" json:"Req,omitempty"`
	RdpRsp    []byte        `protobuf:"bytes,5,opt,name=RdpRsp,proto3" json:"RdpRsp,omitempty"`
	Dbg       *pbcomm.Debug `protobuf:"bytes,6,opt,name=Dbg" json:"Dbg,omitempty"`
}

func (m *SendGameRdpReq) Reset()                    { *m = SendGameRdpReq{} }
func (m *SendGameRdpReq) String() string            { return proto.CompactTextString(m) }
func (*SendGameRdpReq) ProtoMessage()               {}
func (*SendGameRdpReq) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{0} }

func (m *SendGameRdpReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *SendGameRdpReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *SendGameRdpReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *SendGameRdpReq) GetRdpRsp() []byte {
	if m != nil {
		return m.RdpRsp
	}
	return nil
}

func (m *SendGameRdpReq) GetDbg() *pbcomm.Debug {
	if m != nil {
		return m.Dbg
	}
	return nil
}

type RcvGameRdpReq struct {
	FromKeyId int64         `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    int32         `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte        `protobuf:"bytes,4,opt,name=Req,proto3" json:"Req,omitempty"`
	RdpRsp    []byte        `protobuf:"bytes,5,opt,name=RdpRsp,proto3" json:"RdpRsp,omitempty"`
	Dbg       *pbcomm.Debug `protobuf:"bytes,6,opt,name=Dbg" json:"Dbg,omitempty"`
}

func (m *RcvGameRdpReq) Reset()                    { *m = RcvGameRdpReq{} }
func (m *RcvGameRdpReq) String() string            { return proto.CompactTextString(m) }
func (*RcvGameRdpReq) ProtoMessage()               {}
func (*RcvGameRdpReq) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{1} }

func (m *RcvGameRdpReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *RcvGameRdpReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *RcvGameRdpReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *RcvGameRdpReq) GetRdpRsp() []byte {
	if m != nil {
		return m.RdpRsp
	}
	return nil
}

func (m *RcvGameRdpReq) GetDbg() *pbcomm.Debug {
	if m != nil {
		return m.Dbg
	}
	return nil
}

type CheckGameRdpReq struct {
	FromKeyId int64         `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    int32         `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte        `protobuf:"bytes,4,opt,name=Req,proto3" json:"Req,omitempty"`
	RdpRsp    []byte        `protobuf:"bytes,5,opt,name=RdpRsp,proto3" json:"RdpRsp,omitempty"`
	Dbg       *pbcomm.Debug `protobuf:"bytes,6,opt,name=Dbg" json:"Dbg,omitempty"`
}

func (m *CheckGameRdpReq) Reset()                    { *m = CheckGameRdpReq{} }
func (m *CheckGameRdpReq) String() string            { return proto.CompactTextString(m) }
func (*CheckGameRdpReq) ProtoMessage()               {}
func (*CheckGameRdpReq) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{2} }

func (m *CheckGameRdpReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *CheckGameRdpReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *CheckGameRdpReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *CheckGameRdpReq) GetRdpRsp() []byte {
	if m != nil {
		return m.RdpRsp
	}
	return nil
}

func (m *CheckGameRdpReq) GetDbg() *pbcomm.Debug {
	if m != nil {
		return m.Dbg
	}
	return nil
}

type QryGameRdpReq struct {
	FromKeyId int64         `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    int32         `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte        `protobuf:"bytes,4,opt,name=Req,proto3" json:"Req,omitempty"`
	Dbg       *pbcomm.Debug `protobuf:"bytes,5,opt,name=Dbg" json:"Dbg,omitempty"`
}

func (m *QryGameRdpReq) Reset()                    { *m = QryGameRdpReq{} }
func (m *QryGameRdpReq) String() string            { return proto.CompactTextString(m) }
func (*QryGameRdpReq) ProtoMessage()               {}
func (*QryGameRdpReq) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{3} }

func (m *QryGameRdpReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *QryGameRdpReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *QryGameRdpReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *QryGameRdpReq) GetDbg() *pbcomm.Debug {
	if m != nil {
		return m.Dbg
	}
	return nil
}

type QryGameHisRdpReq struct {
	FromKeyId int64         `protobuf:"varint,1,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	FromId    int32         `protobuf:"varint,2,opt,name=FromId,proto3" json:"FromId,omitempty"`
	Req       []byte        `protobuf:"bytes,4,opt,name=Req,proto3" json:"Req,omitempty"`
	Dbg       *pbcomm.Debug `protobuf:"bytes,5,opt,name=Dbg" json:"Dbg,omitempty"`
}

func (m *QryGameHisRdpReq) Reset()                    { *m = QryGameHisRdpReq{} }
func (m *QryGameHisRdpReq) String() string            { return proto.CompactTextString(m) }
func (*QryGameHisRdpReq) ProtoMessage()               {}
func (*QryGameHisRdpReq) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{4} }

func (m *QryGameHisRdpReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *QryGameHisRdpReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *QryGameHisRdpReq) GetReq() []byte {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *QryGameHisRdpReq) GetDbg() *pbcomm.Debug {
	if m != nil {
		return m.Dbg
	}
	return nil
}

type ChatMsgsMeta struct {
	TopMsg int32 `protobuf:"varint,1,opt,name=topMsg,proto3" json:"topMsg,omitempty"`
	TopPts int32 `protobuf:"varint,2,opt,name=topPts,proto3" json:"topPts,omitempty"`
	ToDate int32 `protobuf:"varint,3,opt,name=toDate,proto3" json:"toDate,omitempty"`
}

func (m *ChatMsgsMeta) Reset()                    { *m = ChatMsgsMeta{} }
func (m *ChatMsgsMeta) String() string            { return proto.CompactTextString(m) }
func (*ChatMsgsMeta) ProtoMessage()               {}
func (*ChatMsgsMeta) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{5} }

func (m *ChatMsgsMeta) GetTopMsg() int32 {
	if m != nil {
		return m.TopMsg
	}
	return 0
}

func (m *ChatMsgsMeta) GetTopPts() int32 {
	if m != nil {
		return m.TopPts
	}
	return 0
}

func (m *ChatMsgsMeta) GetToDate() int32 {
	if m != nil {
		return m.ToDate
	}
	return 0
}

type GameRdpRsp struct {
	Result []byte        `protobuf:"bytes,1,opt,name=Result,proto3" json:"Result,omitempty"`
	Code   int32         `protobuf:"varint,2,opt,name=Code,proto3" json:"Code,omitempty"`
	Msg    string        `protobuf:"bytes,3,opt,name=Msg,proto3" json:"Msg,omitempty"`
	Meta   *ChatMsgsMeta `protobuf:"bytes,4,opt,name=Meta" json:"Meta,omitempty"`
}

func (m *GameRdpRsp) Reset()                    { *m = GameRdpRsp{} }
func (m *GameRdpRsp) String() string            { return proto.CompactTextString(m) }
func (*GameRdpRsp) ProtoMessage()               {}
func (*GameRdpRsp) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{6} }

func (m *GameRdpRsp) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *GameRdpRsp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GameRdpRsp) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *GameRdpRsp) GetMeta() *ChatMsgsMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

// 超级群协议请求
type HandleLogicChannelReq struct {
	MessageId   uint64 `protobuf:"varint,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	KeyId       uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	UserId      int32  `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CrcId       uint32 `protobuf:"varint,4,opt,name=crc_id,json=crcId,proto3" json:"crc_id,omitempty"`
	ObjBin      []byte `protobuf:"bytes,5,opt,name=obj_bin,json=objBin,proto3" json:"obj_bin,omitempty"`
	Phone       string `protobuf:"bytes,6,opt,name=Phone,proto3" json:"Phone,omitempty"`
	Layer       int32  `protobuf:"varint,7,opt,name=layer,proto3" json:"layer,omitempty"`
	AppVersion  string `protobuf:"bytes,8,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	ClientIp    string `protobuf:"bytes,9,opt,name=ClientIp,proto3" json:"ClientIp,omitempty"`
	Ostype      uint32 `protobuf:"varint,10,opt,name=ostype,proto3" json:"ostype,omitempty"`
	SessionId   uint64 `protobuf:"varint,11,opt,name=sessionId,proto3" json:"sessionId,omitempty"`
	API         int32  `protobuf:"varint,12,opt,name=API,proto3" json:"API,omitempty"`
	OsTypeStr   string `protobuf:"bytes,13,opt,name=OsTypeStr,proto3" json:"OsTypeStr,omitempty"`
	DeviceModel string `protobuf:"bytes,14,opt,name=DeviceModel,proto3" json:"DeviceModel,omitempty"`
}

func (m *HandleLogicChannelReq) Reset()         { *m = HandleLogicChannelReq{} }
func (m *HandleLogicChannelReq) String() string { return proto.CompactTextString(m) }
func (*HandleLogicChannelReq) ProtoMessage()    {}
func (*HandleLogicChannelReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{7}
}

func (m *HandleLogicChannelReq) GetMessageId() uint64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *HandleLogicChannelReq) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *HandleLogicChannelReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HandleLogicChannelReq) GetCrcId() uint32 {
	if m != nil {
		return m.CrcId
	}
	return 0
}

func (m *HandleLogicChannelReq) GetObjBin() []byte {
	if m != nil {
		return m.ObjBin
	}
	return nil
}

func (m *HandleLogicChannelReq) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *HandleLogicChannelReq) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *HandleLogicChannelReq) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *HandleLogicChannelReq) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *HandleLogicChannelReq) GetOstype() uint32 {
	if m != nil {
		return m.Ostype
	}
	return 0
}

func (m *HandleLogicChannelReq) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *HandleLogicChannelReq) GetAPI() int32 {
	if m != nil {
		return m.API
	}
	return 0
}

func (m *HandleLogicChannelReq) GetOsTypeStr() string {
	if m != nil {
		return m.OsTypeStr
	}
	return ""
}

func (m *HandleLogicChannelReq) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

// 超级群协议响应
type HandleLogicChannelResp struct {
	Result []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *HandleLogicChannelResp) Reset()         { *m = HandleLogicChannelResp{} }
func (m *HandleLogicChannelResp) String() string { return proto.CompactTextString(m) }
func (*HandleLogicChannelResp) ProtoMessage()    {}
func (*HandleLogicChannelResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{8}
}

func (m *HandleLogicChannelResp) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

// 发送消息请求
type SendChannelMessageReq struct {
	Fromid       int32         `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	NoWebpage    bool          `protobuf:"varint,2,opt,name=no_webpage,json=noWebpage,proto3" json:"no_webpage,omitempty"`
	Silent       bool          `protobuf:"varint,3,opt,name=silent,proto3" json:"silent,omitempty"`
	Background   bool          `protobuf:"varint,4,opt,name=background,proto3" json:"background,omitempty"`
	ClearDraft   bool          `protobuf:"varint,5,opt,name=clear_draft,json=clearDraft,proto3" json:"clear_draft,omitempty"`
	Peer         []byte        `protobuf:"bytes,6,opt,name=peer,proto3" json:"peer,omitempty"`
	ReplyToMsgId int32         `protobuf:"varint,7,opt,name=reply_to_msg_id,json=replyToMsgId,proto3" json:"reply_to_msg_id,omitempty"`
	Message      string        `protobuf:"bytes,8,opt,name=message,proto3" json:"message,omitempty"`
	RandomId     int64         `protobuf:"varint,9,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	ReplyMarkup  []byte        `protobuf:"bytes,10,opt,name=reply_markup,json=replyMarkup,proto3" json:"reply_markup,omitempty"`
	Entities     [][]byte      `protobuf:"bytes,11,rep,name=entities" json:"entities,omitempty"`
	FromkeyId    uint64        `protobuf:"varint,13,opt,name=fromkey_id,json=fromkeyId,proto3" json:"fromkey_id,omitempty"`
	Debug        *pbcomm.Debug `protobuf:"bytes,15,opt,name=debug" json:"debug,omitempty"`
	IncludeChat  bool          `protobuf:"varint,16,opt,name=include_chat,json=includeChat,proto3" json:"include_chat,omitempty"`
	ViaBotId     int32         `protobuf:"varint,17,opt,name=via_bot_id,json=viaBotId,proto3" json:"via_bot_id,omitempty"`
}

func (m *SendChannelMessageReq) Reset()         { *m = SendChannelMessageReq{} }
func (m *SendChannelMessageReq) String() string { return proto.CompactTextString(m) }
func (*SendChannelMessageReq) ProtoMessage()    {}
func (*SendChannelMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{9}
}

func (m *SendChannelMessageReq) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *SendChannelMessageReq) GetNoWebpage() bool {
	if m != nil {
		return m.NoWebpage
	}
	return false
}

func (m *SendChannelMessageReq) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *SendChannelMessageReq) GetBackground() bool {
	if m != nil {
		return m.Background
	}
	return false
}

func (m *SendChannelMessageReq) GetClearDraft() bool {
	if m != nil {
		return m.ClearDraft
	}
	return false
}

func (m *SendChannelMessageReq) GetPeer() []byte {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *SendChannelMessageReq) GetReplyToMsgId() int32 {
	if m != nil {
		return m.ReplyToMsgId
	}
	return 0
}

func (m *SendChannelMessageReq) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *SendChannelMessageReq) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *SendChannelMessageReq) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *SendChannelMessageReq) GetEntities() [][]byte {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *SendChannelMessageReq) GetFromkeyId() uint64 {
	if m != nil {
		return m.FromkeyId
	}
	return 0
}

func (m *SendChannelMessageReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SendChannelMessageReq) GetIncludeChat() bool {
	if m != nil {
		return m.IncludeChat
	}
	return false
}

func (m *SendChannelMessageReq) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

// 发送媒体
type SendChannelMediaReq struct {
	Fromid       int32         `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Flags        int32         `protobuf:"varint,2,opt,name=flags,proto3" json:"flags,omitempty"`
	Silent       bool          `protobuf:"varint,3,opt,name=silent,proto3" json:"silent,omitempty"`
	Background   bool          `protobuf:"varint,4,opt,name=background,proto3" json:"background,omitempty"`
	ClearDraft   bool          `protobuf:"varint,5,opt,name=clear_draft,json=clearDraft,proto3" json:"clear_draft,omitempty"`
	Peer         []byte        `protobuf:"bytes,6,opt,name=peer,proto3" json:"peer,omitempty"`
	ReplyToMsgId int32         `protobuf:"varint,7,opt,name=reply_to_msg_id,json=replyToMsgId,proto3" json:"reply_to_msg_id,omitempty"`
	Media        []byte        `protobuf:"bytes,8,opt,name=media,proto3" json:"media,omitempty"`
	MultiMedia   [][]byte      `protobuf:"bytes,9,rep,name=multi_media,json=multiMedia" json:"multi_media,omitempty"`
	RandomId     int64         `protobuf:"varint,10,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	ReplyMarkup  []byte        `protobuf:"bytes,11,opt,name=reply_markup,json=replyMarkup,proto3" json:"reply_markup,omitempty"`
	Newfileid    int64         `protobuf:"varint,12,opt,name=newfileid,proto3" json:"newfileid,omitempty"`
	FromkeyId    uint64        `protobuf:"varint,13,opt,name=fromkey_id,json=fromkeyId,proto3" json:"fromkey_id,omitempty"`
	Chatmeber    []int32       `protobuf:"varint,14,rep,packed,name=chatmeber" json:"chatmeber,omitempty"`
	Debug        *pbcomm.Debug `protobuf:"bytes,15,opt,name=debug" json:"debug,omitempty"`
	ViaBotId     int32         `protobuf:"varint,16,opt,name=via_bot_id,json=viaBotId,proto3" json:"via_bot_id,omitempty"`
}

func (m *SendChannelMediaReq) Reset()         { *m = SendChannelMediaReq{} }
func (m *SendChannelMediaReq) String() string { return proto.CompactTextString(m) }
func (*SendChannelMediaReq) ProtoMessage()    {}
func (*SendChannelMediaReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{10}
}

func (m *SendChannelMediaReq) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *SendChannelMediaReq) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *SendChannelMediaReq) GetSilent() bool {
	if m != nil {
		return m.Silent
	}
	return false
}

func (m *SendChannelMediaReq) GetBackground() bool {
	if m != nil {
		return m.Background
	}
	return false
}

func (m *SendChannelMediaReq) GetClearDraft() bool {
	if m != nil {
		return m.ClearDraft
	}
	return false
}

func (m *SendChannelMediaReq) GetPeer() []byte {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *SendChannelMediaReq) GetReplyToMsgId() int32 {
	if m != nil {
		return m.ReplyToMsgId
	}
	return 0
}

func (m *SendChannelMediaReq) GetMedia() []byte {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *SendChannelMediaReq) GetMultiMedia() [][]byte {
	if m != nil {
		return m.MultiMedia
	}
	return nil
}

func (m *SendChannelMediaReq) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *SendChannelMediaReq) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *SendChannelMediaReq) GetNewfileid() int64 {
	if m != nil {
		return m.Newfileid
	}
	return 0
}

func (m *SendChannelMediaReq) GetFromkeyId() uint64 {
	if m != nil {
		return m.FromkeyId
	}
	return 0
}

func (m *SendChannelMediaReq) GetChatmeber() []int32 {
	if m != nil {
		return m.Chatmeber
	}
	return nil
}

func (m *SendChannelMediaReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *SendChannelMediaReq) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

// 状态返回
type SendChannelMessageResp struct {
	Result    []byte `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *SendChannelMessageResp) Reset()         { *m = SendChannelMessageResp{} }
func (m *SendChannelMessageResp) String() string { return proto.CompactTextString(m) }
func (*SendChannelMessageResp) ProtoMessage()    {}
func (*SendChannelMessageResp) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{11}
}

func (m *SendChannelMessageResp) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SendChannelMessageResp) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 编辑消息
type EditChannelMessageReq struct {
	FormId      int32         `protobuf:"varint,1,opt,name=form_id,json=formId,proto3" json:"form_id,omitempty"`
	FromKeyid   uint64        `protobuf:"varint,2,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Flags       int32         `protobuf:"varint,3,opt,name=flags,proto3" json:"flags,omitempty"`
	NoWebpage   bool          `protobuf:"varint,4,opt,name=no_webpage,json=noWebpage,proto3" json:"no_webpage,omitempty"`
	StopGeoLive bool          `protobuf:"varint,5,opt,name=Stop_geo_live,json=StopGeoLive,proto3" json:"Stop_geo_live,omitempty"`
	Peer        []byte        `protobuf:"bytes,6,opt,name=peer,proto3" json:"peer,omitempty"`
	Id          int32         `protobuf:"varint,7,opt,name=id,proto3" json:"id,omitempty"`
	Message     string        `protobuf:"bytes,8,opt,name=message,proto3" json:"message,omitempty"`
	ReplyMarkup []byte        `protobuf:"bytes,9,opt,name=reply_markup,json=replyMarkup,proto3" json:"reply_markup,omitempty"`
	Entities    [][]byte      `protobuf:"bytes,10,rep,name=entities" json:"entities,omitempty"`
	GeoPoint    []byte        `protobuf:"bytes,11,opt,name=Geo_point,json=GeoPoint,proto3" json:"Geo_point,omitempty"`
	ViaBotId    int32         `protobuf:"varint,12,opt,name=ViaBotId,proto3" json:"ViaBotId,omitempty"`
	Debug       *pbcomm.Debug `protobuf:"bytes,13,opt,name=debug" json:"debug,omitempty"`
}

func (m *EditChannelMessageReq) Reset()         { *m = EditChannelMessageReq{} }
func (m *EditChannelMessageReq) String() string { return proto.CompactTextString(m) }
func (*EditChannelMessageReq) ProtoMessage()    {}
func (*EditChannelMessageReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{12}
}

func (m *EditChannelMessageReq) GetFormId() int32 {
	if m != nil {
		return m.FormId
	}
	return 0
}

func (m *EditChannelMessageReq) GetFromKeyid() uint64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *EditChannelMessageReq) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *EditChannelMessageReq) GetNoWebpage() bool {
	if m != nil {
		return m.NoWebpage
	}
	return false
}

func (m *EditChannelMessageReq) GetStopGeoLive() bool {
	if m != nil {
		return m.StopGeoLive
	}
	return false
}

func (m *EditChannelMessageReq) GetPeer() []byte {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *EditChannelMessageReq) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *EditChannelMessageReq) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *EditChannelMessageReq) GetReplyMarkup() []byte {
	if m != nil {
		return m.ReplyMarkup
	}
	return nil
}

func (m *EditChannelMessageReq) GetEntities() [][]byte {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *EditChannelMessageReq) GetGeoPoint() []byte {
	if m != nil {
		return m.GeoPoint
	}
	return nil
}

func (m *EditChannelMessageReq) GetViaBotId() int32 {
	if m != nil {
		return m.ViaBotId
	}
	return 0
}

func (m *EditChannelMessageReq) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 返回participants
type ReplyParticipants struct {
	Updates   []byte `protobuf:"bytes,1,opt,name=Updates,proto3" json:"Updates,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyParticipants) Reset()         { *m = ReplyParticipants{} }
func (m *ReplyParticipants) String() string { return proto.CompactTextString(m) }
func (*ReplyParticipants) ProtoMessage()    {}
func (*ReplyParticipants) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{13}
}

func (m *ReplyParticipants) GetUpdates() []byte {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *ReplyParticipants) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 邀请操作的ACK
type ReplyJoinChannel struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyJoinChannel) Reset()         { *m = ReplyJoinChannel{} }
func (m *ReplyJoinChannel) String() string { return proto.CompactTextString(m) }
func (*ReplyJoinChannel) ProtoMessage()    {}
func (*ReplyJoinChannel) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{14}
}

func (m *ReplyJoinChannel) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyJoinChannel) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 推出超级群返回
type ReplyLeaveChannel struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyLeaveChannel) Reset()         { *m = ReplyLeaveChannel{} }
func (m *ReplyLeaveChannel) String() string { return proto.CompactTextString(m) }
func (*ReplyLeaveChannel) ProtoMessage()    {}
func (*ReplyLeaveChannel) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{15}
}

func (m *ReplyLeaveChannel) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyLeaveChannel) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// ################################ 升级超级群 #######################
type ReqMigrateChat struct {
	Fromid int32 `protobuf:"varint,1,opt,name=fromid,proto3" json:"fromid,omitempty"`
	Chatid int32 `protobuf:"varint,2,opt,name=chatid,proto3" json:"chatid,omitempty"`
	//    int32 channelid = 3; //升级后的超级群ID
	//    string title = 4; // 群标题
	//    repeated int32 members = 5; //现有用户
	//    string Phone = 6; //电话
	Fromkeyid uint64 `protobuf:"varint,3,opt,name=fromkeyid,proto3" json:"fromkeyid,omitempty"`
	//    bool isBroadCast = 8; //超级群还是频道
	Debug *pbcomm.Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqMigrateChat) Reset()                    { *m = ReqMigrateChat{} }
func (m *ReqMigrateChat) String() string            { return proto.CompactTextString(m) }
func (*ReqMigrateChat) ProtoMessage()               {}
func (*ReqMigrateChat) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{16} }

func (m *ReqMigrateChat) GetFromid() int32 {
	if m != nil {
		return m.Fromid
	}
	return 0
}

func (m *ReqMigrateChat) GetChatid() int32 {
	if m != nil {
		return m.Chatid
	}
	return 0
}

func (m *ReqMigrateChat) GetFromkeyid() uint64 {
	if m != nil {
		return m.Fromkeyid
	}
	return 0
}

func (m *ReqMigrateChat) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReplyMigrateChat struct {
	//    int32 msgid = 1; // 消息id
	//    int64 randomid = 2; // 消息随机id
	//    int32 date = 3; // 消息时间
	//    int32 pts = 4; // 消息pts
	//    int32 channelmsgid = 5; //频道的消息ID
	//    int32 channelpts = 6; //频道的PTS
	Result []byte `protobuf:"bytes,7,opt,name=result,proto3" json:"result,omitempty"`
	Error  int32  `protobuf:"varint,8,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ReplyMigrateChat) Reset()         { *m = ReplyMigrateChat{} }
func (m *ReplyMigrateChat) String() string { return proto.CompactTextString(m) }
func (*ReplyMigrateChat) ProtoMessage()    {}
func (*ReplyMigrateChat) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{17}
}

func (m *ReplyMigrateChat) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *ReplyMigrateChat) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

// 返回get channles
type ReplyGetChannels struct {
	Reply     []byte `protobuf:"bytes,1,opt,name=reply,proto3" json:"reply,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyGetChannels) Reset()         { *m = ReplyGetChannels{} }
func (m *ReplyGetChannels) String() string { return proto.CompactTextString(m) }
func (*ReplyGetChannels) ProtoMessage()    {}
func (*ReplyGetChannels) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{18}
}

func (m *ReplyGetChannels) GetReply() []byte {
	if m != nil {
		return m.Reply
	}
	return nil
}

func (m *ReplyGetChannels) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

type GetChannelInactiveUsersReq struct {
	ChannelId int32 `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Limit     int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Userid    int32 `protobuf:"varint,3,opt,name=userid,proto3" json:"userid,omitempty"`
}

func (m *GetChannelInactiveUsersReq) Reset()         { *m = GetChannelInactiveUsersReq{} }
func (m *GetChannelInactiveUsersReq) String() string { return proto.CompactTextString(m) }
func (*GetChannelInactiveUsersReq) ProtoMessage()    {}
func (*GetChannelInactiveUsersReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{19}
}

func (m *GetChannelInactiveUsersReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *GetChannelInactiveUsersReq) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *GetChannelInactiveUsersReq) GetUserid() int32 {
	if m != nil {
		return m.Userid
	}
	return 0
}

type ReplyBanChannelUser struct {
	Updates   []byte `protobuf:"bytes,1,opt,name=Updates,proto3" json:"Updates,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyBanChannelUser) Reset()         { *m = ReplyBanChannelUser{} }
func (m *ReplyBanChannelUser) String() string { return proto.CompactTextString(m) }
func (*ReplyBanChannelUser) ProtoMessage()    {}
func (*ReplyBanChannelUser) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{20}
}

func (m *ReplyBanChannelUser) GetUpdates() []byte {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *ReplyBanChannelUser) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// 获取participants
type ReqGetParticipants struct {
	OffSet    int32         `protobuf:"varint,1,opt,name=offSet,proto3" json:"offSet,omitempty"`
	Limit     int32         `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	PartiType int32         `protobuf:"varint,3,opt,name=partiType,proto3" json:"partiType,omitempty"`
	ChannelId int32         `protobuf:"varint,4,opt,name=channelId,proto3" json:"channelId,omitempty"`
	FromId    int32         `protobuf:"varint,5,opt,name=fromId,proto3" json:"fromId,omitempty"`
	Q         string        `protobuf:"bytes,6,opt,name=q,proto3" json:"q,omitempty"`
	Hash      int32         `protobuf:"varint,7,opt,name=Hash,proto3" json:"Hash,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetParticipants) Reset()         { *m = ReqGetParticipants{} }
func (m *ReqGetParticipants) String() string { return proto.CompactTextString(m) }
func (*ReqGetParticipants) ProtoMessage()    {}
func (*ReqGetParticipants) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{21}
}

func (m *ReqGetParticipants) GetOffSet() int32 {
	if m != nil {
		return m.OffSet
	}
	return 0
}

func (m *ReqGetParticipants) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ReqGetParticipants) GetPartiType() int32 {
	if m != nil {
		return m.PartiType
	}
	return 0
}

func (m *ReqGetParticipants) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqGetParticipants) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqGetParticipants) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

func (m *ReqGetParticipants) GetHash() int32 {
	if m != nil {
		return m.Hash
	}
	return 0
}

func (m *ReqGetParticipants) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 邀请用户进入超级群
type ReqJoinChannel struct {
	ChannelId  int32         `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	UserId     int32         `protobuf:"varint,3,opt,name=userId,proto3" json:"userId,omitempty"`
	FromKeyid  int64         `protobuf:"varint,5,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	AccessHash int64         `protobuf:"varint,6,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	ByLink     bool          `protobuf:"varint,7,opt,name=byLink,proto3" json:"byLink,omitempty"`
	Invitor    int32         `protobuf:"varint,8,opt,name=invitor,proto3" json:"invitor,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,9,opt,name=debug" json:"debug,omitempty"`
	InviteType int32         `protobuf:"varint,10,opt,name=invite_type,json=inviteType,proto3" json:"invite_type,omitempty"`
}

func (m *ReqJoinChannel) Reset()                    { *m = ReqJoinChannel{} }
func (m *ReqJoinChannel) String() string            { return proto.CompactTextString(m) }
func (*ReqJoinChannel) ProtoMessage()               {}
func (*ReqJoinChannel) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{22} }

func (m *ReqJoinChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqJoinChannel) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqJoinChannel) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqJoinChannel) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqJoinChannel) GetByLink() bool {
	if m != nil {
		return m.ByLink
	}
	return false
}

func (m *ReqJoinChannel) GetInvitor() int32 {
	if m != nil {
		return m.Invitor
	}
	return 0
}

func (m *ReqJoinChannel) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

func (m *ReqJoinChannel) GetInviteType() int32 {
	if m != nil {
		return m.InviteType
	}
	return 0
}

// 踢人
type ReqKickFromChannel struct {
	ChannelId int32         `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	Kicker    int32         `protobuf:"varint,2,opt,name=kicker,proto3" json:"kicker,omitempty"`
	Kickee    int32         `protobuf:"varint,3,opt,name=kickee,proto3" json:"kickee,omitempty"`
	IsBotUser bool          `protobuf:"varint,4,opt,name=is_bot_user,json=isBotUser,proto3" json:"is_bot_user,omitempty"`
	IsKicked  bool          `protobuf:"varint,5,opt,name=is_kicked,json=isKicked,proto3" json:"is_kicked,omitempty"`
	KickedId  int32         `protobuf:"varint,6,opt,name=Kicked_id,json=KickedId,proto3" json:"Kicked_id,omitempty"`
	FromKeyid int64         `protobuf:"varint,7,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqKickFromChannel) Reset()         { *m = ReqKickFromChannel{} }
func (m *ReqKickFromChannel) String() string { return proto.CompactTextString(m) }
func (*ReqKickFromChannel) ProtoMessage()    {}
func (*ReqKickFromChannel) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{23}
}

func (m *ReqKickFromChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqKickFromChannel) GetKicker() int32 {
	if m != nil {
		return m.Kicker
	}
	return 0
}

func (m *ReqKickFromChannel) GetKickee() int32 {
	if m != nil {
		return m.Kickee
	}
	return 0
}

func (m *ReqKickFromChannel) GetIsBotUser() bool {
	if m != nil {
		return m.IsBotUser
	}
	return false
}

func (m *ReqKickFromChannel) GetIsKicked() bool {
	if m != nil {
		return m.IsKicked
	}
	return false
}

func (m *ReqKickFromChannel) GetKickedId() int32 {
	if m != nil {
		return m.KickedId
	}
	return 0
}

func (m *ReqKickFromChannel) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqKickFromChannel) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 退出超级群
type ReqLeaveChannel struct {
	ChannelId int32         `protobuf:"varint,1,opt,name=channelId,proto3" json:"channelId,omitempty"`
	UserId    int32         `protobuf:"varint,2,opt,name=userId,proto3" json:"userId,omitempty"`
	FromKeyid int64         `protobuf:"varint,3,opt,name=from_keyid,json=fromKeyid,proto3" json:"from_keyid,omitempty"`
	Debug     *pbcomm.Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqLeaveChannel) Reset()                    { *m = ReqLeaveChannel{} }
func (m *ReqLeaveChannel) String() string            { return proto.CompactTextString(m) }
func (*ReqLeaveChannel) ProtoMessage()               {}
func (*ReqLeaveChannel) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{24} }

func (m *ReqLeaveChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqLeaveChannel) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReqLeaveChannel) GetFromKeyid() int64 {
	if m != nil {
		return m.FromKeyid
	}
	return 0
}

func (m *ReqLeaveChannel) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 请求给定channel
type ReqGetChannels struct {
	ChannelIds []int32       `protobuf:"varint,1,rep,packed,name=channelIds" json:"channelIds,omitempty"`
	FromId     int32         `protobuf:"varint,2,opt,name=fromId,proto3" json:"fromId,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,3,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetChannels) Reset()                    { *m = ReqGetChannels{} }
func (m *ReqGetChannels) String() string            { return proto.CompactTextString(m) }
func (*ReqGetChannels) ProtoMessage()               {}
func (*ReqGetChannels) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{25} }

func (m *ReqGetChannels) GetChannelIds() []int32 {
	if m != nil {
		return m.ChannelIds
	}
	return nil
}

func (m *ReqGetChannels) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqGetChannels) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ReqEditBanChannelUser struct {
	FromId              int32                `protobuf:"varint,1,opt,name=fromId,proto3" json:"fromId,omitempty"`
	FromKeyId           int64                `protobuf:"varint,2,opt,name=fromKeyId,proto3" json:"fromKeyId,omitempty"`
	ChannelId           int32                `protobuf:"varint,3,opt,name=channelId,proto3" json:"channelId,omitempty"`
	BannedUserId        int32                `protobuf:"varint,4,opt,name=bannedUserId,proto3" json:"bannedUserId,omitempty"`
	AccessHash          int64                `protobuf:"varint,5,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	UtilDate            int32                `protobuf:"varint,6,opt,name=util_date,json=utilDate,proto3" json:"util_date,omitempty"`
	ChannelBannedRights *ChannelBannedRights `protobuf:"bytes,7,opt,name=channelBannedRights" json:"channelBannedRights,omitempty"`
	Debug               *pbcomm.Debug        `protobuf:"bytes,8,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqEditBanChannelUser) Reset()         { *m = ReqEditBanChannelUser{} }
func (m *ReqEditBanChannelUser) String() string { return proto.CompactTextString(m) }
func (*ReqEditBanChannelUser) ProtoMessage()    {}
func (*ReqEditBanChannelUser) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{26}
}

func (m *ReqEditBanChannelUser) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetBannedUserId() int32 {
	if m != nil {
		return m.BannedUserId
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetUtilDate() int32 {
	if m != nil {
		return m.UtilDate
	}
	return 0
}

func (m *ReqEditBanChannelUser) GetChannelBannedRights() *ChannelBannedRights {
	if m != nil {
		return m.ChannelBannedRights
	}
	return nil
}

func (m *ReqEditBanChannelUser) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

type ChannelBannedRights struct {
	Flags        int32 `protobuf:"varint,1,opt,name=flags,proto3" json:"flags,omitempty"`
	ViewMessages bool  `protobuf:"varint,2,opt,name=view_messages,json=viewMessages,proto3" json:"view_messages,omitempty"`
	SendMessages bool  `protobuf:"varint,3,opt,name=send_messages,json=sendMessages,proto3" json:"send_messages,omitempty"`
	SendMedia    bool  `protobuf:"varint,4,opt,name=send_media,json=sendMedia,proto3" json:"send_media,omitempty"`
	SendStickers bool  `protobuf:"varint,5,opt,name=send_stickers,json=sendStickers,proto3" json:"send_stickers,omitempty"`
	SendGifs     bool  `protobuf:"varint,6,opt,name=send_gifs,json=sendGifs,proto3" json:"send_gifs,omitempty"`
	SendGames    bool  `protobuf:"varint,7,opt,name=send_games,json=sendGames,proto3" json:"send_games,omitempty"`
	SendInline   bool  `protobuf:"varint,8,opt,name=send_inline,json=sendInline,proto3" json:"send_inline,omitempty"`
	EmbedLinks   bool  `protobuf:"varint,9,opt,name=embed_links,json=embedLinks,proto3" json:"embed_links,omitempty"`
	UntilDate    int32 `protobuf:"varint,10,opt,name=until_date,json=untilDate,proto3" json:"until_date,omitempty"`
}

func (m *ChannelBannedRights) Reset()         { *m = ChannelBannedRights{} }
func (m *ChannelBannedRights) String() string { return proto.CompactTextString(m) }
func (*ChannelBannedRights) ProtoMessage()    {}
func (*ChannelBannedRights) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{27}
}

func (m *ChannelBannedRights) GetFlags() int32 {
	if m != nil {
		return m.Flags
	}
	return 0
}

func (m *ChannelBannedRights) GetViewMessages() bool {
	if m != nil {
		return m.ViewMessages
	}
	return false
}

func (m *ChannelBannedRights) GetSendMessages() bool {
	if m != nil {
		return m.SendMessages
	}
	return false
}

func (m *ChannelBannedRights) GetSendMedia() bool {
	if m != nil {
		return m.SendMedia
	}
	return false
}

func (m *ChannelBannedRights) GetSendStickers() bool {
	if m != nil {
		return m.SendStickers
	}
	return false
}

func (m *ChannelBannedRights) GetSendGifs() bool {
	if m != nil {
		return m.SendGifs
	}
	return false
}

func (m *ChannelBannedRights) GetSendGames() bool {
	if m != nil {
		return m.SendGames
	}
	return false
}

func (m *ChannelBannedRights) GetSendInline() bool {
	if m != nil {
		return m.SendInline
	}
	return false
}

func (m *ChannelBannedRights) GetEmbedLinks() bool {
	if m != nil {
		return m.EmbedLinks
	}
	return false
}

func (m *ChannelBannedRights) GetUntilDate() int32 {
	if m != nil {
		return m.UntilDate
	}
	return 0
}

type GetChannelInactiveUsersResult struct {
	Users []*ChannelInactiveUser `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
	Count int32                  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *GetChannelInactiveUsersResult) Reset()         { *m = GetChannelInactiveUsersResult{} }
func (m *GetChannelInactiveUsersResult) String() string { return proto.CompactTextString(m) }
func (*GetChannelInactiveUsersResult) ProtoMessage()    {}
func (*GetChannelInactiveUsersResult) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{28}
}

func (m *GetChannelInactiveUsersResult) GetUsers() []*ChannelInactiveUser {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *GetChannelInactiveUsersResult) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

type ChannelInactiveUser struct {
	Id      int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Time    int32  `protobuf:"varint,3,opt,name=time,proto3" json:"time,omitempty"`
	TimeStr string `protobuf:"bytes,4,opt,name=timeStr,proto3" json:"timeStr,omitempty"`
}

func (m *ChannelInactiveUser) Reset()         { *m = ChannelInactiveUser{} }
func (m *ChannelInactiveUser) String() string { return proto.CompactTextString(m) }
func (*ChannelInactiveUser) ProtoMessage()    {}
func (*ChannelInactiveUser) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{29}
}

func (m *ChannelInactiveUser) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChannelInactiveUser) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChannelInactiveUser) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *ChannelInactiveUser) GetTimeStr() string {
	if m != nil {
		return m.TimeStr
	}
	return ""
}

// 获取fullchannel
type ReqGetFullChannel struct {
	FromId     int32         `protobuf:"varint,1,opt,name=fromId,proto3" json:"fromId,omitempty"`
	ChannelId  int32         `protobuf:"varint,2,opt,name=channelId,proto3" json:"channelId,omitempty"`
	AccessHash int64         `protobuf:"varint,3,opt,name=accessHash,proto3" json:"accessHash,omitempty"`
	Debug      *pbcomm.Debug `protobuf:"bytes,4,opt,name=debug" json:"debug,omitempty"`
}

func (m *ReqGetFullChannel) Reset()         { *m = ReqGetFullChannel{} }
func (m *ReqGetFullChannel) String() string { return proto.CompactTextString(m) }
func (*ReqGetFullChannel) ProtoMessage()    {}
func (*ReqGetFullChannel) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{30}
}

func (m *ReqGetFullChannel) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ReqGetFullChannel) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReqGetFullChannel) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ReqGetFullChannel) GetDebug() *pbcomm.Debug {
	if m != nil {
		return m.Debug
	}
	return nil
}

// 返回fullchannel
type ReplyFullChannel struct {
	Updates   []byte `protobuf:"bytes,1,opt,name=Updates,proto3" json:"Updates,omitempty"`
	ErrorCode int32  `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
}

func (m *ReplyFullChannel) Reset()         { *m = ReplyFullChannel{} }
func (m *ReplyFullChannel) String() string { return proto.CompactTextString(m) }
func (*ReplyFullChannel) ProtoMessage()    {}
func (*ReplyFullChannel) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{31}
}

func (m *ReplyFullChannel) GetUpdates() []byte {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *ReplyFullChannel) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

// add by Qingsong at 2019-11-06 for call channel server to handler toggle slow mode
type HandleToggleSlowModeReq struct {
	ChnlId  int32 `protobuf:"varint,1,opt,name=Chnl_id,json=ChnlId,proto3" json:"Chnl_id,omitempty"`
	HashId  int64 `protobuf:"varint,2,opt,name=Hash_id,json=HashId,proto3" json:"Hash_id,omitempty"`
	UserId  int32 `protobuf:"varint,3,opt,name=User_id,json=UserId,proto3" json:"User_id,omitempty"`
	Seconds int32 `protobuf:"varint,4,opt,name=Seconds,proto3" json:"Seconds,omitempty"`
}

func (m *HandleToggleSlowModeReq) Reset()         { *m = HandleToggleSlowModeReq{} }
func (m *HandleToggleSlowModeReq) String() string { return proto.CompactTextString(m) }
func (*HandleToggleSlowModeReq) ProtoMessage()    {}
func (*HandleToggleSlowModeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{32}
}

func (m *HandleToggleSlowModeReq) GetChnlId() int32 {
	if m != nil {
		return m.ChnlId
	}
	return 0
}

func (m *HandleToggleSlowModeReq) GetHashId() int64 {
	if m != nil {
		return m.HashId
	}
	return 0
}

func (m *HandleToggleSlowModeReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *HandleToggleSlowModeReq) GetSeconds() int32 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

type HandleToggleSlowModeRsq struct {
	Results bool `protobuf:"varint,1,opt,name=Results,proto3" json:"Results,omitempty"`
}

func (m *HandleToggleSlowModeRsq) Reset()         { *m = HandleToggleSlowModeRsq{} }
func (m *HandleToggleSlowModeRsq) String() string { return proto.CompactTextString(m) }
func (*HandleToggleSlowModeRsq) ProtoMessage()    {}
func (*HandleToggleSlowModeRsq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{33}
}

func (m *HandleToggleSlowModeRsq) GetResults() bool {
	if m != nil {
		return m.Results
	}
	return false
}

// @ add by Qingsong at 2019-11-21 for channel toggle signatures
type HandleToggleSignaturesReq struct {
	ChnlId  int32 `protobuf:"varint,1,opt,name=chnl_id,json=chnlId,proto3" json:"chnl_id,omitempty"`
	HashId  int64 `protobuf:"varint,2,opt,name=Hash_id,json=HashId,proto3" json:"Hash_id,omitempty"`
	Is_Sign bool  `protobuf:"varint,3,opt,name=Is_Sign,json=IsSign,proto3" json:"Is_Sign,omitempty"`
}

func (m *HandleToggleSignaturesReq) Reset()         { *m = HandleToggleSignaturesReq{} }
func (m *HandleToggleSignaturesReq) String() string { return proto.CompactTextString(m) }
func (*HandleToggleSignaturesReq) ProtoMessage()    {}
func (*HandleToggleSignaturesReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{34}
}

func (m *HandleToggleSignaturesReq) GetChnlId() int32 {
	if m != nil {
		return m.ChnlId
	}
	return 0
}

func (m *HandleToggleSignaturesReq) GetHashId() int64 {
	if m != nil {
		return m.HashId
	}
	return 0
}

func (m *HandleToggleSignaturesReq) GetIs_Sign() bool {
	if m != nil {
		return m.Is_Sign
	}
	return false
}

type HandleToggleSignaturesRsp struct {
	Results bool `protobuf:"varint,1,opt,name=Results,proto3" json:"Results,omitempty"`
}

func (m *HandleToggleSignaturesRsp) Reset()         { *m = HandleToggleSignaturesRsp{} }
func (m *HandleToggleSignaturesRsp) String() string { return proto.CompactTextString(m) }
func (*HandleToggleSignaturesRsp) ProtoMessage()    {}
func (*HandleToggleSignaturesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{35}
}

func (m *HandleToggleSignaturesRsp) GetResults() bool {
	if m != nil {
		return m.Results
	}
	return false
}

// @ add by Qingsong at 2019-12-02 for im call channel server to toggle channel's history hidden.
type ChannelToggleHistoryHiddenReq struct {
	ChnlId int32 `protobuf:"varint,1,opt,name=Chnl_id,json=ChnlId,proto3" json:"Chnl_id,omitempty"`
	HashId int64 `protobuf:"varint,2,opt,name=Hash_id,json=HashId,proto3" json:"Hash_id,omitempty"`
	FromId int32 `protobuf:"varint,3,opt,name=From_id,json=FromId,proto3" json:"From_id,omitempty"`
	UserId int32 `protobuf:"varint,4,opt,name=User_id,json=UserId,proto3" json:"User_id,omitempty"`
	IsHide bool  `protobuf:"varint,5,opt,name=Is_hide,json=IsHide,proto3" json:"Is_hide,omitempty"`
}

func (m *ChannelToggleHistoryHiddenReq) Reset()         { *m = ChannelToggleHistoryHiddenReq{} }
func (m *ChannelToggleHistoryHiddenReq) String() string { return proto.CompactTextString(m) }
func (*ChannelToggleHistoryHiddenReq) ProtoMessage()    {}
func (*ChannelToggleHistoryHiddenReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{36}
}

func (m *ChannelToggleHistoryHiddenReq) GetChnlId() int32 {
	if m != nil {
		return m.ChnlId
	}
	return 0
}

func (m *ChannelToggleHistoryHiddenReq) GetHashId() int64 {
	if m != nil {
		return m.HashId
	}
	return 0
}

func (m *ChannelToggleHistoryHiddenReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ChannelToggleHistoryHiddenReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ChannelToggleHistoryHiddenReq) GetIsHide() bool {
	if m != nil {
		return m.IsHide
	}
	return false
}

type ChannelToggleHistoryHiddenRsp struct {
	Results   bool   `protobuf:"varint,1,opt,name=Results,proto3" json:"Results,omitempty"`
	ReplyByte []byte `protobuf:"bytes,2,opt,name=ReplyByte,proto3" json:"ReplyByte,omitempty"`
}

func (m *ChannelToggleHistoryHiddenRsp) Reset()         { *m = ChannelToggleHistoryHiddenRsp{} }
func (m *ChannelToggleHistoryHiddenRsp) String() string { return proto.CompactTextString(m) }
func (*ChannelToggleHistoryHiddenRsp) ProtoMessage()    {}
func (*ChannelToggleHistoryHiddenRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{37}
}

func (m *ChannelToggleHistoryHiddenRsp) GetResults() bool {
	if m != nil {
		return m.Results
	}
	return false
}

func (m *ChannelToggleHistoryHiddenRsp) GetReplyByte() []byte {
	if m != nil {
		return m.ReplyByte
	}
	return nil
}

// @ add by qingsong at 2019-12-23 for im call channel server to set channel ban mode.
type SetChannelBanModeReq struct {
	ChnlId  int32 `protobuf:"varint,1,opt,name=Chnl_id,json=ChnlId,proto3" json:"Chnl_id,omitempty"`
	HashId  int64 `protobuf:"varint,2,opt,name=Hash_id,json=HashId,proto3" json:"Hash_id,omitempty"`
	FromId  int32 `protobuf:"varint,3,opt,name=From_id,json=FromId,proto3" json:"From_id,omitempty"`
	BanMode bool  `protobuf:"varint,4,opt,name=Ban_mode,json=BanMode,proto3" json:"Ban_mode,omitempty"`
}

func (m *SetChannelBanModeReq) Reset()         { *m = SetChannelBanModeReq{} }
func (m *SetChannelBanModeReq) String() string { return proto.CompactTextString(m) }
func (*SetChannelBanModeReq) ProtoMessage()    {}
func (*SetChannelBanModeReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{38}
}

func (m *SetChannelBanModeReq) GetChnlId() int32 {
	if m != nil {
		return m.ChnlId
	}
	return 0
}

func (m *SetChannelBanModeReq) GetHashId() int64 {
	if m != nil {
		return m.HashId
	}
	return 0
}

func (m *SetChannelBanModeReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *SetChannelBanModeReq) GetBanMode() bool {
	if m != nil {
		return m.BanMode
	}
	return false
}

type SetChannelBanModeRsp struct {
	ReplyCode int32  `protobuf:"varint,1,opt,name=Reply_code,json=ReplyCode,proto3" json:"Reply_code,omitempty"`
	ReplyBuff []byte `protobuf:"bytes,2,opt,name=Reply_buff,json=ReplyBuff,proto3" json:"Reply_buff,omitempty"`
}

func (m *SetChannelBanModeRsp) Reset()         { *m = SetChannelBanModeRsp{} }
func (m *SetChannelBanModeRsp) String() string { return proto.CompactTextString(m) }
func (*SetChannelBanModeRsp) ProtoMessage()    {}
func (*SetChannelBanModeRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{39}
}

func (m *SetChannelBanModeRsp) GetReplyCode() int32 {
	if m != nil {
		return m.ReplyCode
	}
	return 0
}

func (m *SetChannelBanModeRsp) GetReplyBuff() []byte {
	if m != nil {
		return m.ReplyBuff
	}
	return nil
}

type RestrictChannelReq struct {
	ChannelId int32  `protobuf:"varint,1,opt,name=Channel_id,json=ChannelId,proto3" json:"Channel_id,omitempty"`
	Platfrom  string `protobuf:"bytes,2,opt,name=Platfrom,proto3" json:"Platfrom,omitempty"`
	Reason    string `protobuf:"bytes,3,opt,name=Reason,proto3" json:"Reason,omitempty"`
	Text      string `protobuf:"bytes,4,opt,name=Text,proto3" json:"Text,omitempty"`
}

func (m *RestrictChannelReq) Reset()         { *m = RestrictChannelReq{} }
func (m *RestrictChannelReq) String() string { return proto.CompactTextString(m) }
func (*RestrictChannelReq) ProtoMessage()    {}
func (*RestrictChannelReq) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{40}
}

func (m *RestrictChannelReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *RestrictChannelReq) GetPlatfrom() string {
	if m != nil {
		return m.Platfrom
	}
	return ""
}

func (m *RestrictChannelReq) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RestrictChannelReq) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

type RestrictChannelRsp struct {
	ReplyCode int32  `protobuf:"varint,1,opt,name=Reply_code,json=ReplyCode,proto3" json:"Reply_code,omitempty"`
	ReplyInfo string `protobuf:"bytes,2,opt,name=Reply_info,json=ReplyInfo,proto3" json:"Reply_info,omitempty"`
}

func (m *RestrictChannelRsp) Reset()         { *m = RestrictChannelRsp{} }
func (m *RestrictChannelRsp) String() string { return proto.CompactTextString(m) }
func (*RestrictChannelRsp) ProtoMessage()    {}
func (*RestrictChannelRsp) Descriptor() ([]byte, []int) {
	return fileDescriptorImchannelserver, []int{41}
}

func (m *RestrictChannelRsp) GetReplyCode() int32 {
	if m != nil {
		return m.ReplyCode
	}
	return 0
}

func (m *RestrictChannelRsp) GetReplyInfo() string {
	if m != nil {
		return m.ReplyInfo
	}
	return ""
}

// add by qingsong at 2020-05-11 for receive game rdp
type RecvGameRDPReq struct {
	FromId     int32         `protobuf:"varint,1,opt,name=FromId,proto3" json:"FromId,omitempty"`
	FromKeyId  int64         `protobuf:"varint,2,opt,name=FromKeyId,proto3" json:"FromKeyId,omitempty"`
	ChannelId  int32         `protobuf:"varint,3,opt,name=ChannelId,proto3" json:"ChannelId,omitempty"`
	AccessHash int64         `protobuf:"varint,4,opt,name=AccessHash,proto3" json:"AccessHash,omitempty"`
	MessageId  int32         `protobuf:"varint,5,opt,name=MessageId,proto3" json:"MessageId,omitempty"`
	DataJson   []byte        `protobuf:"bytes,6,opt,name=DataJson,proto3" json:"DataJson,omitempty"`
	Dbg        *pbcomm.Debug `protobuf:"bytes,7,opt,name=dbg" json:"dbg,omitempty"`
}

func (m *RecvGameRDPReq) Reset()                    { *m = RecvGameRDPReq{} }
func (m *RecvGameRDPReq) String() string            { return proto.CompactTextString(m) }
func (*RecvGameRDPReq) ProtoMessage()               {}
func (*RecvGameRDPReq) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{35} }

func (m *RecvGameRDPReq) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *RecvGameRDPReq) GetFromKeyId() int64 {
	if m != nil {
		return m.FromKeyId
	}
	return 0
}

func (m *RecvGameRDPReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *RecvGameRDPReq) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *RecvGameRDPReq) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *RecvGameRDPReq) GetDataJson() []byte {
	if m != nil {
		return m.DataJson
	}
	return nil
}

func (m *RecvGameRDPReq) GetDbg() *pbcomm.Debug {
	if m != nil {
		return m.Dbg
	}
	return nil
}

type RecvGameRDPRsp struct {
	Result  []byte `protobuf:"bytes,1,opt,name=Result,proto3" json:"Result,omitempty"`
	ErrCode int32  `protobuf:"varint,2,opt,name=Err_code,json=ErrCode,proto3" json:"Err_code,omitempty"`
	ErrInfo string `protobuf:"bytes,3,opt,name=Err_info,json=ErrInfo,proto3" json:"Err_info,omitempty"`
}

func (m *RecvGameRDPRsp) Reset()                    { *m = RecvGameRDPRsp{} }
func (m *RecvGameRDPRsp) String() string            { return proto.CompactTextString(m) }
func (*RecvGameRDPRsp) ProtoMessage()               {}
func (*RecvGameRDPRsp) Descriptor() ([]byte, []int) { return fileDescriptorImchannelserver, []int{36} }

func (m *RecvGameRDPRsp) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RecvGameRDPRsp) GetErrCode() int32 {
	if m != nil {
		return m.ErrCode
	}
	return 0
}

func (m *RecvGameRDPRsp) GetErrInfo() string {
	if m != nil {
		return m.ErrInfo
	}
	return ""
}

func init() {
	proto.RegisterType((*SendGameRdpReq)(nil), "imchannelserver.SendGameRdpReq")
	proto.RegisterType((*RcvGameRdpReq)(nil), "imchannelserver.RcvGameRdpReq")
	proto.RegisterType((*CheckGameRdpReq)(nil), "imchannelserver.CheckGameRdpReq")
	proto.RegisterType((*QryGameRdpReq)(nil), "imchannelserver.QryGameRdpReq")
	proto.RegisterType((*QryGameHisRdpReq)(nil), "imchannelserver.QryGameHisRdpReq")
	proto.RegisterType((*ChatMsgsMeta)(nil), "imchannelserver.ChatMsgsMeta")
	proto.RegisterType((*GameRdpRsp)(nil), "imchannelserver.GameRdpRsp")
	proto.RegisterType((*HandleLogicChannelReq)(nil), "imchannelserver.HandleLogicChannelReq")
	proto.RegisterType((*HandleLogicChannelResp)(nil), "imchannelserver.HandleLogicChannelResp")
	proto.RegisterType((*SendChannelMessageReq)(nil), "imchannelserver.SendChannelMessageReq")
	proto.RegisterType((*SendChannelMediaReq)(nil), "imchannelserver.SendChannelMediaReq")
	proto.RegisterType((*SendChannelMessageResp)(nil), "imchannelserver.SendChannelMessageResp")
	proto.RegisterType((*EditChannelMessageReq)(nil), "imchannelserver.EditChannelMessageReq")
	proto.RegisterType((*ReplyParticipants)(nil), "imchannelserver.ReplyParticipants")
	proto.RegisterType((*ReplyJoinChannel)(nil), "imchannelserver.ReplyJoinChannel")
	proto.RegisterType((*ReplyLeaveChannel)(nil), "imchannelserver.ReplyLeaveChannel")
	proto.RegisterType((*ReqMigrateChat)(nil), "imchannelserver.ReqMigrateChat")
	proto.RegisterType((*ReplyMigrateChat)(nil), "imchannelserver.ReplyMigrateChat")
	proto.RegisterType((*ReplyGetChannels)(nil), "imchannelserver.ReplyGetChannels")
	proto.RegisterType((*GetChannelInactiveUsersReq)(nil), "imchannelserver.GetChannelInactiveUsersReq")
	proto.RegisterType((*ReplyBanChannelUser)(nil), "imchannelserver.ReplyBanChannelUser")
	proto.RegisterType((*ReqGetParticipants)(nil), "imchannelserver.ReqGetParticipants")
	proto.RegisterType((*ReqJoinChannel)(nil), "imchannelserver.ReqJoinChannel")
	proto.RegisterType((*ReqKickFromChannel)(nil), "imchannelserver.ReqKickFromChannel")
	proto.RegisterType((*ReqLeaveChannel)(nil), "imchannelserver.ReqLeaveChannel")
	proto.RegisterType((*ReqGetChannels)(nil), "imchannelserver.ReqGetChannels")
	proto.RegisterType((*ReqEditBanChannelUser)(nil), "imchannelserver.ReqEditBanChannelUser")
	proto.RegisterType((*ChannelBannedRights)(nil), "imchannelserver.ChannelBannedRights")
	proto.RegisterType((*GetChannelInactiveUsersResult)(nil), "imchannelserver.GetChannelInactiveUsersResult")
	proto.RegisterType((*ChannelInactiveUser)(nil), "imchannelserver.ChannelInactiveUser")
	proto.RegisterType((*ReqGetFullChannel)(nil), "imchannelserver.ReqGetFullChannel")
	proto.RegisterType((*ReplyFullChannel)(nil), "imchannelserver.ReplyFullChannel")
	proto.RegisterType((*HandleToggleSlowModeReq)(nil), "imchannelserver.HandleToggleSlowModeReq")
	proto.RegisterType((*HandleToggleSlowModeRsq)(nil), "imchannelserver.HandleToggleSlowModeRsq")
	proto.RegisterType((*HandleToggleSignaturesReq)(nil), "imchannelserver.HandleToggleSignaturesReq")
	proto.RegisterType((*HandleToggleSignaturesRsp)(nil), "imchannelserver.HandleToggleSignaturesRsp")
	proto.RegisterType((*ChannelToggleHistoryHiddenReq)(nil), "imchannelserver.ChannelToggleHistoryHiddenReq")
	proto.RegisterType((*ChannelToggleHistoryHiddenRsp)(nil), "imchannelserver.ChannelToggleHistoryHiddenRsp")
	proto.RegisterType((*SetChannelBanModeReq)(nil), "imchannelserver.SetChannelBanModeReq")
	proto.RegisterType((*SetChannelBanModeRsp)(nil), "imchannelserver.SetChannelBanModeRsp")
	proto.RegisterType((*RestrictChannelReq)(nil), "imchannelserver.RestrictChannelReq")
	proto.RegisterType((*RestrictChannelRsp)(nil), "imchannelserver.RestrictChannelRsp")
	proto.RegisterType((*RecvGameRDPReq)(nil), "imchannelserver.RecvGameRDPReq")
	proto.RegisterType((*RecvGameRDPRsp)(nil), "imchannelserver.RecvGameRDPRsp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ServerService service

type ServerServiceClient interface {
	// 检查userName是否可用
	LogicCheckUserName(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 创建频道
	LogicCreateChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 邀请用户进入超级群或者频道
	LogicInviteToChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 踢人出超级群或者频道
	LogicKickFromChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 离开超级群或者频道
	LogicLeaveChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 编辑超级群标题
	LogicEditTitle(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 编辑超级群管理员权限
	LogicEditAdmin(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 修改超级群头像信息
	LogicEditPhoto(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 修改超级群描述信息
	LogicEditAbout(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 置顶超级群消息
	LogicUpdatePinnedMessage(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 通过username加入超级群
	LogicJoinChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 通过邀请链接加入超级群
	LogicImportChatInvite(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 删除超级群或频道
	LogicDeleteChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 获取操作日志
	LogicGetAdminLog(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 超级群踢人或解除该禁止
	LogicEditBanned(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 获取超级群完整信息
	LogicGetFullChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	GetFullChannel(ctx context.Context, in *ReqGetFullChannel, opts ...grpc.CallOption) (*ReplyFullChannel, error)
	// 获取单个超级群用户信息
	LogicGetParticipant(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 获取多个超级群用户信息（群获取最近成员、管理员、被踢用户、机器人、被禁权用户、群成员搜索、被踢用户搜索）
	LogicGetParticipants(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 创建超级群连接
	LogicExportInvite(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 设置所有人 邀请权限
	LogicToggleInvites(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 获取多个超级群的群信息
	LogicGetChannels(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 修改超级群全体禁言
	LogicEveryoneQuiet(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 获取公开超级群消息链接
	LogicExportMessageLink(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 修改超级群禁止私聊
	LogicPrivateChat(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 更新超级群Username
	LogicUpdateUsername(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 删除超级群消息
	LogicDeleteMessages(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 读取超级群消息内容
	LogicReadMessageContents(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	//
	LogicGetLeftChannels(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 发送消息
	SendChannelMessage(ctx context.Context, in *SendChannelMessageReq, opts ...grpc.CallOption) (*SendChannelMessageResp, error)
	LogicSendChannelMessage(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 发送媒体
	SendChannelMedia(ctx context.Context, in *SendChannelMediaReq, opts ...grpc.CallOption) (*SendChannelMessageResp, error)
	LogicSendChannelMedia(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 编辑消息
	EditChannelMessage(ctx context.Context, in *EditChannelMessageReq, opts ...grpc.CallOption) (*SendChannelMessageResp, error)
	LogicEditChannelMessage(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 升级超级群
	MessagesMigrateChat(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// 获取participants
	GetParticipants(ctx context.Context, in *ReqGetParticipants, opts ...grpc.CallOption) (*ReplyParticipants, error)
	// 主动加入超级群或者频道
	JoinChannel(ctx context.Context, in *ReqJoinChannel, opts ...grpc.CallOption) (*ReplyJoinChannel, error)
	// 离开超级群或者频道
	LeaveChannel(ctx context.Context, in *ReqLeaveChannel, opts ...grpc.CallOption) (*ReplyLeaveChannel, error)
	// 普通群升级超级群
	MigrateChat(ctx context.Context, in *ReqMigrateChat, opts ...grpc.CallOption) (*ReplyMigrateChat, error)
	// 获取给定channel
	Getchannels(ctx context.Context, in *ReqGetChannels, opts ...grpc.CallOption) (*ReplyGetChannels, error)
	GetChannelInactiveUsers(ctx context.Context, in *GetChannelInactiveUsersReq, opts ...grpc.CallOption) (*GetChannelInactiveUsersResult, error)
	// 踢人并进组其再次加入超级群或者频道，或者解除该禁止
	EditBanChannelUser(ctx context.Context, in *ReqEditBanChannelUser, opts ...grpc.CallOption) (*ReplyBanChannelUser, error)
	// 超级群红包
	LogicCheckRpm(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	LogicCheckRpmV2(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	LogicReceiveRpm(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	LogicReceiveRpmV2(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	LogicSendRpm(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	LogicSendRpmV2(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error)
	// @ add by Qingsong at 2019-11-06 for call channel server to handler toggle slow model
	HandleToggleSlowModel(ctx context.Context, in *HandleToggleSlowModeReq, opts ...grpc.CallOption) (*HandleToggleSlowModeRsq, error)
	// @ add by Qingsong at 2019-11-21 for channel toggle signatures
	HandleToggleSignatures(ctx context.Context, in *HandleToggleSignaturesReq, opts ...grpc.CallOption) (*HandleToggleSignaturesRsp, error)
	// @ add by qingsong at 2019-12-23 for im call channel server to set channel ban mode.
	SetChannelBanMode(ctx context.Context, in *SetChannelBanModeReq, opts ...grpc.CallOption) (*SetChannelBanModeRsp, error)
	// @ add by qingsong at 2020-04-21 for im call channel server to Restrict channel.
	RestrictChannel(ctx context.Context, in *RestrictChannelReq, opts ...grpc.CallOption) (*RestrictChannelRsp, error)

	// 发送游戏红包
	SendGameRdp(ctx context.Context, in *SendGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error)
	// 领取游戏红包
	RcvGameRdp(ctx context.Context, in *RcvGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error)
	// 查看游戏红包
	CheckGameRdp(ctx context.Context, in *CheckGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error)
	// 查询游戏红包详情
	QryGameRdp(ctx context.Context, in *QryGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error)
	// 发送游戏红包历史记录
	QryGameHisRdp(ctx context.Context, in *QryGameHisRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error)
}

type serverServiceClient struct {
	cc *grpc.ClientConn
}

func NewServerServiceClient(cc *grpc.ClientConn) ServerServiceClient {
	return &serverServiceClient{cc}
}

func (c *serverServiceClient) LogicCheckUserName(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicCheckUserName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicCreateChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicCreateChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicInviteToChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicInviteToChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicKickFromChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicKickFromChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicLeaveChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicLeaveChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicEditTitle(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicEditTitle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicEditAdmin(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicEditAdmin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicEditPhoto(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicEditPhoto", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicEditAbout(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicEditAbout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicUpdatePinnedMessage(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicUpdatePinnedMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicJoinChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicJoinChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicImportChatInvite(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicImportChatInvite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicDeleteChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicDeleteChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicGetAdminLog(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicGetAdminLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicEditBanned(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicEditBanned", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicGetFullChannel(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicGetFullChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) GetFullChannel(ctx context.Context, in *ReqGetFullChannel, opts ...grpc.CallOption) (*ReplyFullChannel, error) {
	out := new(ReplyFullChannel)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/GetFullChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicGetParticipant(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicGetParticipant", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicGetParticipants(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicGetParticipants", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicExportInvite(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicExportInvite", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicToggleInvites(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicToggleInvites", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicGetChannels(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicGetChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicEveryoneQuiet(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicEveryoneQuiet", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicExportMessageLink(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicExportMessageLink", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicPrivateChat(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicPrivateChat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicUpdateUsername(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicUpdateUsername", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicDeleteMessages(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicDeleteMessages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicReadMessageContents(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicReadMessageContents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicGetLeftChannels(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicGetLeftChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SendChannelMessage(ctx context.Context, in *SendChannelMessageReq, opts ...grpc.CallOption) (*SendChannelMessageResp, error) {
	out := new(SendChannelMessageResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/SendChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicSendChannelMessage(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicSendChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SendChannelMedia(ctx context.Context, in *SendChannelMediaReq, opts ...grpc.CallOption) (*SendChannelMessageResp, error) {
	out := new(SendChannelMessageResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/SendChannelMedia", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicSendChannelMedia(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicSendChannelMedia", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) EditChannelMessage(ctx context.Context, in *EditChannelMessageReq, opts ...grpc.CallOption) (*SendChannelMessageResp, error) {
	out := new(SendChannelMessageResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/EditChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicEditChannelMessage(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicEditChannelMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) MessagesMigrateChat(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/MessagesMigrateChat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) GetParticipants(ctx context.Context, in *ReqGetParticipants, opts ...grpc.CallOption) (*ReplyParticipants, error) {
	out := new(ReplyParticipants)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/GetParticipants", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) JoinChannel(ctx context.Context, in *ReqJoinChannel, opts ...grpc.CallOption) (*ReplyJoinChannel, error) {
	out := new(ReplyJoinChannel)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/JoinChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LeaveChannel(ctx context.Context, in *ReqLeaveChannel, opts ...grpc.CallOption) (*ReplyLeaveChannel, error) {
	out := new(ReplyLeaveChannel)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LeaveChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) MigrateChat(ctx context.Context, in *ReqMigrateChat, opts ...grpc.CallOption) (*ReplyMigrateChat, error) {
	out := new(ReplyMigrateChat)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/MigrateChat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) Getchannels(ctx context.Context, in *ReqGetChannels, opts ...grpc.CallOption) (*ReplyGetChannels, error) {
	out := new(ReplyGetChannels)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/Getchannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) GetChannelInactiveUsers(ctx context.Context, in *GetChannelInactiveUsersReq, opts ...grpc.CallOption) (*GetChannelInactiveUsersResult, error) {
	out := new(GetChannelInactiveUsersResult)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/GetChannelInactiveUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) EditBanChannelUser(ctx context.Context, in *ReqEditBanChannelUser, opts ...grpc.CallOption) (*ReplyBanChannelUser, error) {
	out := new(ReplyBanChannelUser)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/EditBanChannelUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicCheckRpm(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicCheckRpm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicCheckRpmV2(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicCheckRpmV2", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicReceiveRpm(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicReceiveRpm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicReceiveRpmV2(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicReceiveRpmV2", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicSendRpm(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicSendRpm", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) LogicSendRpmV2(ctx context.Context, in *HandleLogicChannelReq, opts ...grpc.CallOption) (*HandleLogicChannelResp, error) {
	out := new(HandleLogicChannelResp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/LogicSendRpmV2", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) HandleToggleSlowModel(ctx context.Context, in *HandleToggleSlowModeReq, opts ...grpc.CallOption) (*HandleToggleSlowModeRsq, error) {
	out := new(HandleToggleSlowModeRsq)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/HandleToggleSlowModel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) HandleToggleSignatures(ctx context.Context, in *HandleToggleSignaturesReq, opts ...grpc.CallOption) (*HandleToggleSignaturesRsp, error) {
	out := new(HandleToggleSignaturesRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/HandleToggleSignatures", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SetChannelBanMode(ctx context.Context, in *SetChannelBanModeReq, opts ...grpc.CallOption) (*SetChannelBanModeRsp, error) {
	out := new(SetChannelBanModeRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/SetChannelBanMode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) RestrictChannel(ctx context.Context, in *RestrictChannelReq, opts ...grpc.CallOption) (*RestrictChannelRsp, error) {
	out := new(RestrictChannelRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/RestrictChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) SendGameRdp(ctx context.Context, in *SendGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error) {
	out := new(GameRdpRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/SendGameRdp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) RcvGameRdp(ctx context.Context, in *RcvGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error) {
	out := new(GameRdpRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/RcvGameRdp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) CheckGameRdp(ctx context.Context, in *CheckGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error) {
	out := new(GameRdpRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/CheckGameRdp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) QryGameRdp(ctx context.Context, in *QryGameRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error) {
	out := new(GameRdpRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/QryGameRdp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverServiceClient) QryGameHisRdp(ctx context.Context, in *QryGameHisRdpReq, opts ...grpc.CallOption) (*GameRdpRsp, error) {
	out := new(GameRdpRsp)
	err := grpc.Invoke(ctx, "/imchannelserver.ServerService/QryGameHisRdp", in, out, c.cc, opts...)

	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ServerService service

type ServerServiceServer interface {
	// 检查userName是否可用
	LogicCheckUserName(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 创建频道
	LogicCreateChannel(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 邀请用户进入超级群或者频道
	LogicInviteToChannel(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 踢人出超级群或者频道
	LogicKickFromChannel(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 离开超级群或者频道
	LogicLeaveChannel(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 编辑超级群标题
	LogicEditTitle(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 编辑超级群管理员权限
	LogicEditAdmin(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 修改超级群头像信息
	LogicEditPhoto(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 修改超级群描述信息
	LogicEditAbout(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 置顶超级群消息
	LogicUpdatePinnedMessage(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 通过username加入超级群
	LogicJoinChannel(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 通过邀请链接加入超级群
	LogicImportChatInvite(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 删除超级群或频道
	LogicDeleteChannel(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 获取操作日志
	LogicGetAdminLog(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 超级群踢人或解除该禁止
	LogicEditBanned(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 获取超级群完整信息
	LogicGetFullChannel(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	GetFullChannel(context.Context, *ReqGetFullChannel) (*ReplyFullChannel, error)
	// 获取单个超级群用户信息
	LogicGetParticipant(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 获取多个超级群用户信息（群获取最近成员、管理员、被踢用户、机器人、被禁权用户、群成员搜索、被踢用户搜索）
	LogicGetParticipants(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 创建超级群连接
	LogicExportInvite(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 设置所有人 邀请权限
	LogicToggleInvites(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 获取多个超级群的群信息
	LogicGetChannels(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 修改超级群全体禁言
	LogicEveryoneQuiet(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 获取公开超级群消息链接
	LogicExportMessageLink(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 修改超级群禁止私聊
	LogicPrivateChat(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 更新超级群Username
	LogicUpdateUsername(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 删除超级群消息
	LogicDeleteMessages(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 读取超级群消息内容
	LogicReadMessageContents(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	//
	LogicGetLeftChannels(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 发送消息
	SendChannelMessage(context.Context, *SendChannelMessageReq) (*SendChannelMessageResp, error)
	LogicSendChannelMessage(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 发送媒体
	SendChannelMedia(context.Context, *SendChannelMediaReq) (*SendChannelMessageResp, error)
	LogicSendChannelMedia(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 编辑消息
	EditChannelMessage(context.Context, *EditChannelMessageReq) (*SendChannelMessageResp, error)
	LogicEditChannelMessage(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 升级超级群
	MessagesMigrateChat(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// 获取participants
	GetParticipants(context.Context, *ReqGetParticipants) (*ReplyParticipants, error)
	// 主动加入超级群或者频道
	JoinChannel(context.Context, *ReqJoinChannel) (*ReplyJoinChannel, error)
	// 离开超级群或者频道
	LeaveChannel(context.Context, *ReqLeaveChannel) (*ReplyLeaveChannel, error)
	// 普通群升级超级群
	MigrateChat(context.Context, *ReqMigrateChat) (*ReplyMigrateChat, error)
	// 获取给定channel
	Getchannels(context.Context, *ReqGetChannels) (*ReplyGetChannels, error)
	GetChannelInactiveUsers(context.Context, *GetChannelInactiveUsersReq) (*GetChannelInactiveUsersResult, error)
	// 踢人并进组其再次加入超级群或者频道，或者解除该禁止
	EditBanChannelUser(context.Context, *ReqEditBanChannelUser) (*ReplyBanChannelUser, error)
	// 超级群红包
	LogicCheckRpm(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	LogicCheckRpmV2(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	LogicReceiveRpm(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	LogicReceiveRpmV2(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	LogicSendRpm(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	LogicSendRpmV2(context.Context, *HandleLogicChannelReq) (*HandleLogicChannelResp, error)
	// @ add by Qingsong at 2019-11-06 for call channel server to handler toggle slow model
	HandleToggleSlowModel(context.Context, *HandleToggleSlowModeReq) (*HandleToggleSlowModeRsq, error)
	// @ add by Qingsong at 2019-11-21 for channel toggle signatures
	HandleToggleSignatures(context.Context, *HandleToggleSignaturesReq) (*HandleToggleSignaturesRsp, error)
	// @ add by qingsong at 2019-12-23 for im call channel server to set channel ban mode.
	SetChannelBanMode(context.Context, *SetChannelBanModeReq) (*SetChannelBanModeRsp, error)
	// @ add by qingsong at 2020-04-21 for im call channel server to Restrict channel.
	RestrictChannel(context.Context, *RestrictChannelReq) (*RestrictChannelRsp, error)

	// 发送游戏红包
	SendGameRdp(context.Context, *SendGameRdpReq) (*GameRdpRsp, error)
	// 领取游戏红包
	RcvGameRdp(context.Context, *RcvGameRdpReq) (*GameRdpRsp, error)
	// 查看游戏红包
	CheckGameRdp(context.Context, *CheckGameRdpReq) (*GameRdpRsp, error)
	// 查询游戏红包详情
	QryGameRdp(context.Context, *QryGameRdpReq) (*GameRdpRsp, error)
	// 发送游戏红包历史记录
	QryGameHisRdp(context.Context, *QryGameHisRdpReq) (*GameRdpRsp, error)
}

func RegisterServerServiceServer(s *grpc.Server, srv ServerServiceServer) {
	s.RegisterService(&_ServerService_serviceDesc, srv)
}

func _ServerService_LogicCheckUserName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicCheckUserName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicCheckUserName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicCheckUserName(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicCreateChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicCreateChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicCreateChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicCreateChannel(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicInviteToChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicInviteToChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicInviteToChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicInviteToChannel(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicKickFromChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicKickFromChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicKickFromChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicKickFromChannel(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicLeaveChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicLeaveChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicLeaveChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicLeaveChannel(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicEditTitle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicEditTitle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicEditTitle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicEditTitle(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicEditAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicEditAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicEditAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicEditAdmin(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicEditPhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicEditPhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicEditPhoto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicEditPhoto(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicEditAbout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicEditAbout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicEditAbout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicEditAbout(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicUpdatePinnedMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicUpdatePinnedMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicUpdatePinnedMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicUpdatePinnedMessage(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicJoinChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicJoinChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicJoinChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicJoinChannel(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicImportChatInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicImportChatInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicImportChatInvite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicImportChatInvite(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicDeleteChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicDeleteChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicDeleteChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicDeleteChannel(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicGetAdminLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicGetAdminLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicGetAdminLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicGetAdminLog(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicEditBanned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicEditBanned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicEditBanned",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicEditBanned(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicGetFullChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicGetFullChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicGetFullChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicGetFullChannel(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_GetFullChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetFullChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetFullChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/GetFullChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetFullChannel(ctx, req.(*ReqGetFullChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicGetParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicGetParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicGetParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicGetParticipant(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicGetParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicGetParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicGetParticipants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicGetParticipants(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicExportInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicExportInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicExportInvite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicExportInvite(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicToggleInvites_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicToggleInvites(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicToggleInvites",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicToggleInvites(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicGetChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicGetChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicGetChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicGetChannels(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicEveryoneQuiet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicEveryoneQuiet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicEveryoneQuiet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicEveryoneQuiet(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicExportMessageLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicExportMessageLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicExportMessageLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicExportMessageLink(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicPrivateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicPrivateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicPrivateChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicPrivateChat(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicUpdateUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicUpdateUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicUpdateUsername",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicUpdateUsername(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicDeleteMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicDeleteMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicDeleteMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicDeleteMessages(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicReadMessageContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicReadMessageContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicReadMessageContents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicReadMessageContents(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicGetLeftChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicGetLeftChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicGetLeftChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicGetLeftChannels(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SendChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendChannelMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SendChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/SendChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SendChannelMessage(ctx, req.(*SendChannelMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicSendChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicSendChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicSendChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicSendChannelMessage(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SendChannelMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendChannelMediaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SendChannelMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/SendChannelMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SendChannelMedia(ctx, req.(*SendChannelMediaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicSendChannelMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicSendChannelMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicSendChannelMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicSendChannelMedia(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_EditChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EditChannelMessageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).EditChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/EditChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).EditChannelMessage(ctx, req.(*EditChannelMessageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicEditChannelMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicEditChannelMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicEditChannelMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicEditChannelMessage(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_MessagesMigrateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).MessagesMigrateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/MessagesMigrateChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).MessagesMigrateChat(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_GetParticipants_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetParticipants)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetParticipants(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/GetParticipants",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetParticipants(ctx, req.(*ReqGetParticipants))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_JoinChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqJoinChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).JoinChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/JoinChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).JoinChannel(ctx, req.(*ReqJoinChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LeaveChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqLeaveChannel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LeaveChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LeaveChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LeaveChannel(ctx, req.(*ReqLeaveChannel))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_MigrateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqMigrateChat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).MigrateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/MigrateChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).MigrateChat(ctx, req.(*ReqMigrateChat))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_Getchannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqGetChannels)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).Getchannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/Getchannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).Getchannels(ctx, req.(*ReqGetChannels))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_GetChannelInactiveUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelInactiveUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).GetChannelInactiveUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/GetChannelInactiveUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).GetChannelInactiveUsers(ctx, req.(*GetChannelInactiveUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_EditBanChannelUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqEditBanChannelUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).EditBanChannelUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/EditBanChannelUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).EditBanChannelUser(ctx, req.(*ReqEditBanChannelUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicCheckRpm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicCheckRpm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicCheckRpm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicCheckRpm(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicCheckRpmV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicCheckRpmV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicCheckRpmV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicCheckRpmV2(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicReceiveRpm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicReceiveRpm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicReceiveRpm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicReceiveRpm(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicReceiveRpmV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicReceiveRpmV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicReceiveRpmV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicReceiveRpmV2(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicSendRpm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicSendRpm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicSendRpm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicSendRpm(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_LogicSendRpmV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleLogicChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).LogicSendRpmV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/LogicSendRpmV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).LogicSendRpmV2(ctx, req.(*HandleLogicChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_HandleToggleSlowModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleToggleSlowModeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).HandleToggleSlowModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/HandleToggleSlowModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).HandleToggleSlowModel(ctx, req.(*HandleToggleSlowModeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_HandleToggleSignatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleToggleSignaturesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).HandleToggleSignatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/HandleToggleSignatures",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).HandleToggleSignatures(ctx, req.(*HandleToggleSignaturesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SetChannelBanMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetChannelBanModeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).SetChannelBanMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/SetChannelBanMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SetChannelBanMode(ctx, req.(*SetChannelBanModeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_RestrictChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestrictChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).RestrictChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/RestrictChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).RestrictChannel(ctx, req.(*RestrictChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_SendGameRdp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendGameRdpReq)

	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {

		return srv.(ServerServiceServer).SendGameRdp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/SendGameRdp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).SendGameRdp(ctx, req.(*SendGameRdpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_RcvGameRdp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RcvGameRdpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).RcvGameRdp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/RcvGameRdp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).RcvGameRdp(ctx, req.(*RcvGameRdpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_CheckGameRdp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckGameRdpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).CheckGameRdp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/CheckGameRdp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).CheckGameRdp(ctx, req.(*CheckGameRdpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_QryGameRdp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QryGameRdpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).QryGameRdp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/QryGameRdp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).QryGameRdp(ctx, req.(*QryGameRdpReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerService_QryGameHisRdp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QryGameHisRdpReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServiceServer).QryGameHisRdp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/imchannelserver.ServerService/QryGameHisRdp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServiceServer).QryGameHisRdp(ctx, req.(*QryGameHisRdpReq))

	}
	return interceptor(ctx, in, info, handler)
}

var _ServerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "imchannelserver.ServerService",
	HandlerType: (*ServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LogicCheckUserName",
			Handler:    _ServerService_LogicCheckUserName_Handler,
		},
		{
			MethodName: "LogicCreateChannel",
			Handler:    _ServerService_LogicCreateChannel_Handler,
		},
		{
			MethodName: "LogicInviteToChannel",
			Handler:    _ServerService_LogicInviteToChannel_Handler,
		},
		{
			MethodName: "LogicKickFromChannel",
			Handler:    _ServerService_LogicKickFromChannel_Handler,
		},
		{
			MethodName: "LogicLeaveChannel",
			Handler:    _ServerService_LogicLeaveChannel_Handler,
		},
		{
			MethodName: "LogicEditTitle",
			Handler:    _ServerService_LogicEditTitle_Handler,
		},
		{
			MethodName: "LogicEditAdmin",
			Handler:    _ServerService_LogicEditAdmin_Handler,
		},
		{
			MethodName: "LogicEditPhoto",
			Handler:    _ServerService_LogicEditPhoto_Handler,
		},
		{
			MethodName: "LogicEditAbout",
			Handler:    _ServerService_LogicEditAbout_Handler,
		},
		{
			MethodName: "LogicUpdatePinnedMessage",
			Handler:    _ServerService_LogicUpdatePinnedMessage_Handler,
		},
		{
			MethodName: "LogicJoinChannel",
			Handler:    _ServerService_LogicJoinChannel_Handler,
		},
		{
			MethodName: "LogicImportChatInvite",
			Handler:    _ServerService_LogicImportChatInvite_Handler,
		},
		{
			MethodName: "LogicDeleteChannel",
			Handler:    _ServerService_LogicDeleteChannel_Handler,
		},
		{
			MethodName: "LogicGetAdminLog",
			Handler:    _ServerService_LogicGetAdminLog_Handler,
		},
		{
			MethodName: "LogicEditBanned",
			Handler:    _ServerService_LogicEditBanned_Handler,
		},
		{
			MethodName: "LogicGetFullChannel",
			Handler:    _ServerService_LogicGetFullChannel_Handler,
		},
		{
			MethodName: "GetFullChannel",
			Handler:    _ServerService_GetFullChannel_Handler,
		},
		{
			MethodName: "LogicGetParticipant",
			Handler:    _ServerService_LogicGetParticipant_Handler,
		},
		{
			MethodName: "LogicGetParticipants",
			Handler:    _ServerService_LogicGetParticipants_Handler,
		},
		{
			MethodName: "LogicExportInvite",
			Handler:    _ServerService_LogicExportInvite_Handler,
		},
		{
			MethodName: "LogicToggleInvites",
			Handler:    _ServerService_LogicToggleInvites_Handler,
		},
		{
			MethodName: "LogicGetChannels",
			Handler:    _ServerService_LogicGetChannels_Handler,
		},
		{
			MethodName: "LogicEveryoneQuiet",
			Handler:    _ServerService_LogicEveryoneQuiet_Handler,
		},
		{
			MethodName: "LogicExportMessageLink",
			Handler:    _ServerService_LogicExportMessageLink_Handler,
		},
		{
			MethodName: "LogicPrivateChat",
			Handler:    _ServerService_LogicPrivateChat_Handler,
		},
		{
			MethodName: "LogicUpdateUsername",
			Handler:    _ServerService_LogicUpdateUsername_Handler,
		},
		{
			MethodName: "LogicDeleteMessages",
			Handler:    _ServerService_LogicDeleteMessages_Handler,
		},
		{
			MethodName: "LogicReadMessageContents",
			Handler:    _ServerService_LogicReadMessageContents_Handler,
		},
		{
			MethodName: "LogicGetLeftChannels",
			Handler:    _ServerService_LogicGetLeftChannels_Handler,
		},
		{
			MethodName: "SendChannelMessage",
			Handler:    _ServerService_SendChannelMessage_Handler,
		},
		{
			MethodName: "LogicSendChannelMessage",
			Handler:    _ServerService_LogicSendChannelMessage_Handler,
		},
		{
			MethodName: "SendChannelMedia",
			Handler:    _ServerService_SendChannelMedia_Handler,
		},
		{
			MethodName: "LogicSendChannelMedia",
			Handler:    _ServerService_LogicSendChannelMedia_Handler,
		},
		{
			MethodName: "EditChannelMessage",
			Handler:    _ServerService_EditChannelMessage_Handler,
		},
		{
			MethodName: "LogicEditChannelMessage",
			Handler:    _ServerService_LogicEditChannelMessage_Handler,
		},
		{
			MethodName: "MessagesMigrateChat",
			Handler:    _ServerService_MessagesMigrateChat_Handler,
		},
		{
			MethodName: "GetParticipants",
			Handler:    _ServerService_GetParticipants_Handler,
		},
		{
			MethodName: "JoinChannel",
			Handler:    _ServerService_JoinChannel_Handler,
		},
		{
			MethodName: "LeaveChannel",
			Handler:    _ServerService_LeaveChannel_Handler,
		},
		{
			MethodName: "MigrateChat",
			Handler:    _ServerService_MigrateChat_Handler,
		},
		{
			MethodName: "Getchannels",
			Handler:    _ServerService_Getchannels_Handler,
		},
		{
			MethodName: "GetChannelInactiveUsers",
			Handler:    _ServerService_GetChannelInactiveUsers_Handler,
		},
		{
			MethodName: "EditBanChannelUser",
			Handler:    _ServerService_EditBanChannelUser_Handler,
		},
		{
			MethodName: "LogicCheckRpm",
			Handler:    _ServerService_LogicCheckRpm_Handler,
		},
		{
			MethodName: "LogicCheckRpmV2",
			Handler:    _ServerService_LogicCheckRpmV2_Handler,
		},
		{
			MethodName: "LogicReceiveRpm",
			Handler:    _ServerService_LogicReceiveRpm_Handler,
		},
		{
			MethodName: "LogicReceiveRpmV2",
			Handler:    _ServerService_LogicReceiveRpmV2_Handler,
		},
		{
			MethodName: "LogicSendRpm",
			Handler:    _ServerService_LogicSendRpm_Handler,
		},
		{
			MethodName: "LogicSendRpmV2",
			Handler:    _ServerService_LogicSendRpmV2_Handler,
		},
		{
			MethodName: "HandleToggleSlowModel",
			Handler:    _ServerService_HandleToggleSlowModel_Handler,
		},
		{
			MethodName: "HandleToggleSignatures",
			Handler:    _ServerService_HandleToggleSignatures_Handler,
		},
		{
			MethodName: "SetChannelBanMode",
			Handler:    _ServerService_SetChannelBanMode_Handler,
		},
		{
			MethodName: "RestrictChannel",
			Handler:    _ServerService_RestrictChannel_Handler,
		},
		{

			MethodName: "SendGameRdp",
			Handler:    _ServerService_SendGameRdp_Handler,
		},
		{
			MethodName: "RcvGameRdp",
			Handler:    _ServerService_RcvGameRdp_Handler,
		},
		{
			MethodName: "CheckGameRdp",
			Handler:    _ServerService_CheckGameRdp_Handler,
		},
		{
			MethodName: "QryGameRdp",
			Handler:    _ServerService_QryGameRdp_Handler,
		},
		{
			MethodName: "QryGameHisRdp",
			Handler:    _ServerService_QryGameHisRdp_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/imchannelserver/imchannelserver.proto",
}

func (m *SendGameRdpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendGameRdpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if len(m.RdpRsp) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.RdpRsp)))
		i += copy(dAtA[i:], m.RdpRsp)
	}
	if m.Dbg != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Dbg.Size()))
		n1, err := m.Dbg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *RcvGameRdpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RcvGameRdpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if len(m.RdpRsp) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.RdpRsp)))
		i += copy(dAtA[i:], m.RdpRsp)
	}
	if m.Dbg != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Dbg.Size()))
		n2, err := m.Dbg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *CheckGameRdpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckGameRdpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if len(m.RdpRsp) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.RdpRsp)))
		i += copy(dAtA[i:], m.RdpRsp)
	}
	if m.Dbg != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Dbg.Size()))
		n3, err := m.Dbg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *QryGameRdpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QryGameRdpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if m.Dbg != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Dbg.Size()))
		n4, err := m.Dbg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *QryGameHisRdpReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QryGameHisRdpReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if len(m.Req) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Req)))
		i += copy(dAtA[i:], m.Req)
	}
	if m.Dbg != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Dbg.Size()))
		n5, err := m.Dbg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *ChatMsgsMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatMsgsMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopMsg != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.TopMsg))
	}
	if m.TopPts != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.TopPts))
	}
	if m.ToDate != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ToDate))
	}
	return i, nil
}

func (m *GameRdpRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameRdpRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Code != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Code))
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Meta != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Meta.Size()))
		n6, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *HandleLogicChannelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleLogicChannelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.MessageId))
	}
	if m.KeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.KeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.UserId))
	}
	if m.CrcId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.CrcId))
	}
	if len(m.ObjBin) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ObjBin)))
		i += copy(dAtA[i:], m.ObjBin)
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Layer))
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if len(m.ClientIp) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ClientIp)))
		i += copy(dAtA[i:], m.ClientIp)
	}
	if m.Ostype != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Ostype))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.SessionId))
	}
	if m.API != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.API))
	}
	if len(m.OsTypeStr) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.OsTypeStr)))
		i += copy(dAtA[i:], m.OsTypeStr)
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	return i, nil
}

func (m *HandleLogicChannelResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleLogicChannelResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	return i, nil
}

func (m *SendChannelMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendChannelMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Fromid))
	}
	if m.NoWebpage {
		dAtA[i] = 0x10
		i++
		if m.NoWebpage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Silent {
		dAtA[i] = 0x18
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Background {
		dAtA[i] = 0x20
		i++
		if m.Background {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClearDraft {
		dAtA[i] = 0x28
		i++
		if m.ClearDraft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Peer) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Peer)))
		i += copy(dAtA[i:], m.Peer)
	}
	if m.ReplyToMsgId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ReplyToMsgId))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.RandomId != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.RandomId))
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintImchannelserver(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.FromkeyId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromkeyId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n7, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.IncludeChat {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		if m.IncludeChat {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ViaBotId))
	}
	return i, nil
}

func (m *SendChannelMediaReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendChannelMediaReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Fromid))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Flags))
	}
	if m.Silent {
		dAtA[i] = 0x18
		i++
		if m.Silent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Background {
		dAtA[i] = 0x20
		i++
		if m.Background {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ClearDraft {
		dAtA[i] = 0x28
		i++
		if m.ClearDraft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Peer) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Peer)))
		i += copy(dAtA[i:], m.Peer)
	}
	if m.ReplyToMsgId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ReplyToMsgId))
	}
	if len(m.Media) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Media)))
		i += copy(dAtA[i:], m.Media)
	}
	if len(m.MultiMedia) > 0 {
		for _, b := range m.MultiMedia {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintImchannelserver(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.RandomId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.RandomId))
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if m.Newfileid != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Newfileid))
	}
	if m.FromkeyId != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromkeyId))
	}
	if len(m.Chatmeber) > 0 {
		dAtA9 := make([]byte, len(m.Chatmeber)*10)
		var j8 int
		for _, num1 := range m.Chatmeber {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x72
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if m.Debug != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n10, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ViaBotId))
	}
	return i, nil
}

func (m *SendChannelMessageResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendChannelMessageResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *EditChannelMessageReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EditChannelMessageReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FormId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FormId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Flags != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Flags))
	}
	if m.NoWebpage {
		dAtA[i] = 0x20
		i++
		if m.NoWebpage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StopGeoLive {
		dAtA[i] = 0x28
		i++
		if m.StopGeoLive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Peer) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Peer)))
		i += copy(dAtA[i:], m.Peer)
	}
	if m.Id != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Id))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.ReplyMarkup) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ReplyMarkup)))
		i += copy(dAtA[i:], m.ReplyMarkup)
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			dAtA[i] = 0x52
			i++
			i = encodeVarintImchannelserver(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.GeoPoint) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.GeoPoint)))
		i += copy(dAtA[i:], m.GeoPoint)
	}
	if m.ViaBotId != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ViaBotId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n11, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *ReplyParticipants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyParticipants) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Updates)))
		i += copy(dAtA[i:], m.Updates)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReplyJoinChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyJoinChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReplyLeaveChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyLeaveChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqMigrateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqMigrateChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fromid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Chatid))
	}
	if m.Fromkeyid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Fromkeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n12, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *ReplyMigrateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyMigrateChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.Error != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Error))
	}
	return i, nil
}

func (m *ReplyGetChannels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyGetChannels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Reply) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Reply)))
		i += copy(dAtA[i:], m.Reply)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *GetChannelInactiveUsersReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelInactiveUsersReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Limit))
	}
	if m.Userid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Userid))
	}
	return i, nil
}

func (m *ReplyBanChannelUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyBanChannelUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Updates)))
		i += copy(dAtA[i:], m.Updates)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *ReqGetParticipants) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetParticipants) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OffSet != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.OffSet))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Limit))
	}
	if m.PartiType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.PartiType))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if len(m.Q) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Q)))
		i += copy(dAtA[i:], m.Q)
	}
	if m.Hash != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Hash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n13, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *ReqJoinChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqJoinChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyid))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.AccessHash))
	}
	if m.ByLink {
		dAtA[i] = 0x38
		i++
		if m.ByLink {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Invitor != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Invitor))
	}
	if m.Debug != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n14, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.InviteType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.InviteType))
	}
	return i, nil
}

func (m *ReqKickFromChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqKickFromChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.Kicker != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Kicker))
	}
	if m.Kickee != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Kickee))
	}
	if m.IsBotUser {
		dAtA[i] = 0x20
		i++
		if m.IsBotUser {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsKicked {
		dAtA[i] = 0x28
		i++
		if m.IsKicked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KickedId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.KickedId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n15, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *ReqLeaveChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqLeaveChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n16, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *ReqGetChannels) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetChannels) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelIds) > 0 {
		dAtA18 := make([]byte, len(m.ChannelIds)*10)
		var j17 int
		for _, num1 := range m.ChannelIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if m.FromId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if m.Debug != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n19, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *ReqEditBanChannelUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqEditBanChannelUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.BannedUserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.BannedUserId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.AccessHash))
	}
	if m.UtilDate != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.UtilDate))
	}
	if m.ChannelBannedRights != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelBannedRights.Size()))
		n20, err := m.ChannelBannedRights.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Debug != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n21, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *ChannelBannedRights) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelBannedRights) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flags != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Flags))
	}
	if m.ViewMessages {
		dAtA[i] = 0x10
		i++
		if m.ViewMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendMessages {
		dAtA[i] = 0x18
		i++
		if m.SendMessages {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendMedia {
		dAtA[i] = 0x20
		i++
		if m.SendMedia {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendStickers {
		dAtA[i] = 0x28
		i++
		if m.SendStickers {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendGifs {
		dAtA[i] = 0x30
		i++
		if m.SendGifs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendGames {
		dAtA[i] = 0x38
		i++
		if m.SendGames {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SendInline {
		dAtA[i] = 0x40
		i++
		if m.SendInline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.EmbedLinks {
		dAtA[i] = 0x48
		i++
		if m.EmbedLinks {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UntilDate != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.UntilDate))
	}
	return i, nil
}

func (m *GetChannelInactiveUsersResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetChannelInactiveUsersResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, msg := range m.Users {
			dAtA[i] = 0xa
			i++
			i = encodeVarintImchannelserver(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Count))
	}
	return i, nil
}

func (m *ChannelInactiveUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelInactiveUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Id))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Time != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Time))
	}
	if len(m.TimeStr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.TimeStr)))
		i += copy(dAtA[i:], m.TimeStr)
	}
	return i, nil
}

func (m *ReqGetFullChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetFullChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.AccessHash))
	}
	if m.Debug != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Debug.Size()))
		n22, err := m.Debug.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *ReplyFullChannel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplyFullChannel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Updates) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Updates)))
		i += copy(dAtA[i:], m.Updates)
	}
	if m.ErrorCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrorCode))
	}
	return i, nil
}

func (m *HandleToggleSlowModeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleToggleSlowModeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChnlId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.HashId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.UserId))
	}
	if m.Seconds != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Seconds))
	}
	return i, nil
}

func (m *HandleToggleSlowModeRsq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleToggleSlowModeRsq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Results {
		dAtA[i] = 0x8
		i++
		if m.Results {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HandleToggleSignaturesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleToggleSignaturesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChnlId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.HashId))
	}
	if m.Is_Sign {
		dAtA[i] = 0x18
		i++
		if m.Is_Sign {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HandleToggleSignaturesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleToggleSignaturesRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Results {
		dAtA[i] = 0x8
		i++
		if m.Results {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChannelToggleHistoryHiddenReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelToggleHistoryHiddenReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChnlId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.HashId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.UserId))
	}
	if m.IsHide {
		dAtA[i] = 0x28
		i++
		if m.IsHide {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ChannelToggleHistoryHiddenRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelToggleHistoryHiddenRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Results {
		dAtA[i] = 0x8
		i++
		if m.Results {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ReplyByte) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ReplyByte)))
		i += copy(dAtA[i:], m.ReplyByte)
	}
	return i, nil
}

func (m *SetChannelBanModeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChannelBanModeReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChnlId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.HashId))
	}
	if m.FromId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if m.BanMode {
		dAtA[i] = 0x20
		i++
		if m.BanMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetChannelBanModeRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetChannelBanModeRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ReplyCode))
	}
	if len(m.ReplyBuff) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ReplyBuff)))
		i += copy(dAtA[i:], m.ReplyBuff)
	}
	return i, nil
}

func (m *RestrictChannelReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestrictChannelReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.Platfrom) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Platfrom)))
		i += copy(dAtA[i:], m.Platfrom)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	return i, nil
}

func (m *RestrictChannelRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestrictChannelRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplyCode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ReplyCode))
	}
	if len(m.ReplyInfo) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ReplyInfo)))
		i += copy(dAtA[i:], m.ReplyInfo)
	}
	return i, nil
}

func (m *RecvGameRDPReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvGameRDPReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.AccessHash))
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.MessageId))
	}
	if len(m.DataJson) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.DataJson)))
		i += copy(dAtA[i:], m.DataJson)
	}
	if m.Dbg != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.Dbg.Size()))
		n17, err := m.Dbg.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *RecvGameRDPRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecvGameRDPRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.Result)))
		i += copy(dAtA[i:], m.Result)
	}
	if m.ErrCode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(m.ErrCode))
	}
	if len(m.ErrInfo) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImchannelserver(dAtA, i, uint64(len(m.ErrInfo)))
		i += copy(dAtA[i:], m.ErrInfo)
	}
	return i, nil
}

func encodeVarintImchannelserver(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SendGameRdpReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.RdpRsp)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Dbg != nil {
		l = m.Dbg.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *RcvGameRdpReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.RdpRsp)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Dbg != nil {
		l = m.Dbg.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *CheckGameRdpReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.RdpRsp)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Dbg != nil {
		l = m.Dbg.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *QryGameRdpReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Dbg != nil {
		l = m.Dbg.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *QryGameHisRdpReq) Size() (n int) {
	var l int
	_ = l
	if m.FromKeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	l = len(m.Req)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Dbg != nil {
		l = m.Dbg.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ChatMsgsMeta) Size() (n int) {
	var l int
	_ = l
	if m.TopMsg != 0 {
		n += 1 + sovImchannelserver(uint64(m.TopMsg))
	}
	if m.TopPts != 0 {
		n += 1 + sovImchannelserver(uint64(m.TopPts))
	}
	if m.ToDate != 0 {
		n += 1 + sovImchannelserver(uint64(m.ToDate))
	}
	return n
}

func (m *GameRdpRsp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovImchannelserver(uint64(m.Code))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *HandleLogicChannelReq) Size() (n int) {
	var l int
	_ = l
	if m.MessageId != 0 {
		n += 1 + sovImchannelserver(uint64(m.MessageId))
	}
	if m.KeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.KeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovImchannelserver(uint64(m.UserId))
	}
	if m.CrcId != 0 {
		n += 1 + sovImchannelserver(uint64(m.CrcId))
	}
	l = len(m.ObjBin)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovImchannelserver(uint64(m.Layer))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Ostype != 0 {
		n += 1 + sovImchannelserver(uint64(m.Ostype))
	}
	if m.SessionId != 0 {
		n += 1 + sovImchannelserver(uint64(m.SessionId))
	}
	if m.API != 0 {
		n += 1 + sovImchannelserver(uint64(m.API))
	}
	l = len(m.OsTypeStr)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *HandleLogicChannelResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *SendChannelMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImchannelserver(uint64(m.Fromid))
	}
	if m.NoWebpage {
		n += 2
	}
	if m.Silent {
		n += 2
	}
	if m.Background {
		n += 2
	}
	if m.ClearDraft {
		n += 2
	}
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ReplyToMsgId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ReplyToMsgId))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.RandomId != 0 {
		n += 1 + sovImchannelserver(uint64(m.RandomId))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			l = len(b)
			n += 1 + l + sovImchannelserver(uint64(l))
		}
	}
	if m.FromkeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromkeyId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.IncludeChat {
		n += 3
	}
	if m.ViaBotId != 0 {
		n += 2 + sovImchannelserver(uint64(m.ViaBotId))
	}
	return n
}

func (m *SendChannelMediaReq) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImchannelserver(uint64(m.Fromid))
	}
	if m.Flags != 0 {
		n += 1 + sovImchannelserver(uint64(m.Flags))
	}
	if m.Silent {
		n += 2
	}
	if m.Background {
		n += 2
	}
	if m.ClearDraft {
		n += 2
	}
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ReplyToMsgId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ReplyToMsgId))
	}
	l = len(m.Media)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if len(m.MultiMedia) > 0 {
		for _, b := range m.MultiMedia {
			l = len(b)
			n += 1 + l + sovImchannelserver(uint64(l))
		}
	}
	if m.RandomId != 0 {
		n += 1 + sovImchannelserver(uint64(m.RandomId))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Newfileid != 0 {
		n += 1 + sovImchannelserver(uint64(m.Newfileid))
	}
	if m.FromkeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromkeyId))
	}
	if len(m.Chatmeber) > 0 {
		l = 0
		for _, e := range m.Chatmeber {
			l += sovImchannelserver(uint64(e))
		}
		n += 1 + sovImchannelserver(uint64(l)) + l
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ViaBotId != 0 {
		n += 2 + sovImchannelserver(uint64(m.ViaBotId))
	}
	return n
}

func (m *SendChannelMessageResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *EditChannelMessageReq) Size() (n int) {
	var l int
	_ = l
	if m.FormId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FormId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyid))
	}
	if m.Flags != 0 {
		n += 1 + sovImchannelserver(uint64(m.Flags))
	}
	if m.NoWebpage {
		n += 2
	}
	if m.StopGeoLive {
		n += 2
	}
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovImchannelserver(uint64(m.Id))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.ReplyMarkup)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if len(m.Entities) > 0 {
		for _, b := range m.Entities {
			l = len(b)
			n += 1 + l + sovImchannelserver(uint64(l))
		}
	}
	l = len(m.GeoPoint)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ViaBotId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ViaBotId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReplyParticipants) Size() (n int) {
	var l int
	_ = l
	l = len(m.Updates)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReplyJoinChannel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReplyLeaveChannel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqMigrateChat) Size() (n int) {
	var l int
	_ = l
	if m.Fromid != 0 {
		n += 1 + sovImchannelserver(uint64(m.Fromid))
	}
	if m.Chatid != 0 {
		n += 1 + sovImchannelserver(uint64(m.Chatid))
	}
	if m.Fromkeyid != 0 {
		n += 1 + sovImchannelserver(uint64(m.Fromkeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReplyMigrateChat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Error != 0 {
		n += 1 + sovImchannelserver(uint64(m.Error))
	}
	return n
}

func (m *ReplyGetChannels) Size() (n int) {
	var l int
	_ = l
	l = len(m.Reply)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *GetChannelInactiveUsersReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.Limit != 0 {
		n += 1 + sovImchannelserver(uint64(m.Limit))
	}
	if m.Userid != 0 {
		n += 1 + sovImchannelserver(uint64(m.Userid))
	}
	return n
}

func (m *ReplyBanChannelUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Updates)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *ReqGetParticipants) Size() (n int) {
	var l int
	_ = l
	if m.OffSet != 0 {
		n += 1 + sovImchannelserver(uint64(m.OffSet))
	}
	if m.Limit != 0 {
		n += 1 + sovImchannelserver(uint64(m.Limit))
	}
	if m.PartiType != 0 {
		n += 1 + sovImchannelserver(uint64(m.PartiType))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Hash != 0 {
		n += 1 + sovImchannelserver(uint64(m.Hash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReqJoinChannel) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		n += 1 + sovImchannelserver(uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyid))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImchannelserver(uint64(m.AccessHash))
	}
	if m.ByLink {
		n += 2
	}
	if m.Invitor != 0 {
		n += 1 + sovImchannelserver(uint64(m.Invitor))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.InviteType != 0 {
		n += 1 + sovImchannelserver(uint64(m.InviteType))
	}
	return n
}

func (m *ReqKickFromChannel) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.Kicker != 0 {
		n += 1 + sovImchannelserver(uint64(m.Kicker))
	}
	if m.Kickee != 0 {
		n += 1 + sovImchannelserver(uint64(m.Kickee))
	}
	if m.IsBotUser {
		n += 2
	}
	if m.IsKicked {
		n += 2
	}
	if m.KickedId != 0 {
		n += 1 + sovImchannelserver(uint64(m.KickedId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReqLeaveChannel) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.UserId != 0 {
		n += 1 + sovImchannelserver(uint64(m.UserId))
	}
	if m.FromKeyid != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyid))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReqGetChannels) Size() (n int) {
	var l int
	_ = l
	if len(m.ChannelIds) > 0 {
		l = 0
		for _, e := range m.ChannelIds {
			l += sovImchannelserver(uint64(e))
		}
		n += 1 + sovImchannelserver(uint64(l)) + l
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReqEditBanChannelUser) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.BannedUserId != 0 {
		n += 1 + sovImchannelserver(uint64(m.BannedUserId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImchannelserver(uint64(m.AccessHash))
	}
	if m.UtilDate != 0 {
		n += 1 + sovImchannelserver(uint64(m.UtilDate))
	}
	if m.ChannelBannedRights != nil {
		l = m.ChannelBannedRights.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ChannelBannedRights) Size() (n int) {
	var l int
	_ = l
	if m.Flags != 0 {
		n += 1 + sovImchannelserver(uint64(m.Flags))
	}
	if m.ViewMessages {
		n += 2
	}
	if m.SendMessages {
		n += 2
	}
	if m.SendMedia {
		n += 2
	}
	if m.SendStickers {
		n += 2
	}
	if m.SendGifs {
		n += 2
	}
	if m.SendGames {
		n += 2
	}
	if m.SendInline {
		n += 2
	}
	if m.EmbedLinks {
		n += 2
	}
	if m.UntilDate != 0 {
		n += 1 + sovImchannelserver(uint64(m.UntilDate))
	}
	return n
}

func (m *GetChannelInactiveUsersResult) Size() (n int) {
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovImchannelserver(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovImchannelserver(uint64(m.Count))
	}
	return n
}

func (m *ChannelInactiveUser) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovImchannelserver(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovImchannelserver(uint64(m.Time))
	}
	l = len(m.TimeStr)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReqGetFullChannel) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImchannelserver(uint64(m.AccessHash))
	}
	if m.Debug != nil {
		l = m.Debug.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *ReplyFullChannel) Size() (n int) {
	var l int
	_ = l
	l = len(m.Updates)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrorCode))
	}
	return n
}

func (m *HandleToggleSlowModeReq) Size() (n int) {
	var l int
	_ = l
	if m.ChnlId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		n += 1 + sovImchannelserver(uint64(m.HashId))
	}
	if m.UserId != 0 {
		n += 1 + sovImchannelserver(uint64(m.UserId))
	}
	if m.Seconds != 0 {
		n += 1 + sovImchannelserver(uint64(m.Seconds))
	}
	return n
}

func (m *HandleToggleSlowModeRsq) Size() (n int) {
	var l int
	_ = l
	if m.Results {
		n += 2
	}
	return n
}

func (m *HandleToggleSignaturesReq) Size() (n int) {
	var l int
	_ = l
	if m.ChnlId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		n += 1 + sovImchannelserver(uint64(m.HashId))
	}
	if m.Is_Sign {
		n += 2
	}
	return n
}

func (m *HandleToggleSignaturesRsp) Size() (n int) {
	var l int
	_ = l
	if m.Results {
		n += 2
	}
	return n
}

func (m *ChannelToggleHistoryHiddenReq) Size() (n int) {
	var l int
	_ = l
	if m.ChnlId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		n += 1 + sovImchannelserver(uint64(m.HashId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	if m.UserId != 0 {
		n += 1 + sovImchannelserver(uint64(m.UserId))
	}
	if m.IsHide {
		n += 2
	}
	return n
}

func (m *ChannelToggleHistoryHiddenRsp) Size() (n int) {
	var l int
	_ = l
	if m.Results {
		n += 2
	}
	l = len(m.ReplyByte)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *SetChannelBanModeReq) Size() (n int) {
	var l int
	_ = l
	if m.ChnlId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChnlId))
	}
	if m.HashId != 0 {
		n += 1 + sovImchannelserver(uint64(m.HashId))
	}
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	if m.BanMode {
		n += 2
	}
	return n
}

func (m *SetChannelBanModeRsp) Size() (n int) {
	var l int
	_ = l
	if m.ReplyCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ReplyCode))
	}
	l = len(m.ReplyBuff)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *RestrictChannelReq) Size() (n int) {
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	l = len(m.Platfrom)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *RestrictChannelRsp) Size() (n int) {
	var l int
	_ = l
	if m.ReplyCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ReplyCode))
	}
	l = len(m.ReplyInfo)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *RecvGameRDPReq) Size() (n int) {
	var l int
	_ = l
	if m.FromId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromId))
	}
	if m.FromKeyId != 0 {
		n += 1 + sovImchannelserver(uint64(m.FromKeyId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImchannelserver(uint64(m.ChannelId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovImchannelserver(uint64(m.AccessHash))
	}
	if m.MessageId != 0 {
		n += 1 + sovImchannelserver(uint64(m.MessageId))
	}
	l = len(m.DataJson)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.Dbg != nil {
		l = m.Dbg.Size()
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func (m *RecvGameRDPRsp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	if m.ErrCode != 0 {
		n += 1 + sovImchannelserver(uint64(m.ErrCode))
	}
	l = len(m.ErrInfo)
	if l > 0 {
		n += 1 + l + sovImchannelserver(uint64(l))
	}
	return n
}

func sovImchannelserver(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImchannelserver(x uint64) (n int) {
	return sovImchannelserver(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SendGameRdpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendGameRdpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendGameRdpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdpRsp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RdpRsp = append(m.RdpRsp[:0], dAtA[iNdEx:postIndex]...)
			if m.RdpRsp == nil {
				m.RdpRsp = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbg == nil {
				m.Dbg = &pbcomm.Debug{}
			}
			if err := m.Dbg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RcvGameRdpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RcvGameRdpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RcvGameRdpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdpRsp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RdpRsp = append(m.RdpRsp[:0], dAtA[iNdEx:postIndex]...)
			if m.RdpRsp == nil {
				m.RdpRsp = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbg == nil {
				m.Dbg = &pbcomm.Debug{}
			}
			if err := m.Dbg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckGameRdpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckGameRdpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckGameRdpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RdpRsp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RdpRsp = append(m.RdpRsp[:0], dAtA[iNdEx:postIndex]...)
			if m.RdpRsp == nil {
				m.RdpRsp = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbg == nil {
				m.Dbg = &pbcomm.Debug{}
			}
			if err := m.Dbg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QryGameRdpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QryGameRdpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QryGameRdpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbg == nil {
				m.Dbg = &pbcomm.Debug{}
			}
			if err := m.Dbg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QryGameHisRdpReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QryGameHisRdpReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QryGameHisRdpReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Req = append(m.Req[:0], dAtA[iNdEx:postIndex]...)
			if m.Req == nil {
				m.Req = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbg == nil {
				m.Dbg = &pbcomm.Debug{}
			}
			if err := m.Dbg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatMsgsMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatMsgsMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatMsgsMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMsg", wireType)
			}
			m.TopMsg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMsg |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopPts", wireType)
			}
			m.TopPts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopPts |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToDate", wireType)
			}
			m.ToDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameRdpRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRdpRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRdpRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &ChatMsgsMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleLogicChannelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleLogicChannelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleLogicChannelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrcId", wireType)
			}
			m.CrcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrcId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjBin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ObjBin = append(m.ObjBin[:0], dAtA[iNdEx:postIndex]...)
			if m.ObjBin == nil {
				m.ObjBin = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ostype", wireType)
			}
			m.Ostype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ostype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field API", wireType)
			}
			m.API = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.API |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsTypeStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsTypeStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleLogicChannelResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleLogicChannelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleLogicChannelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendChannelMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendChannelMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendChannelMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWebpage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWebpage = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Background = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDraft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearDraft = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = append(m.Peer[:0], dAtA[iNdEx:postIndex]...)
			if m.Peer == nil {
				m.Peer = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMsgId", wireType)
			}
			m.ReplyToMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, make([]byte, postIndex-iNdEx))
			copy(m.Entities[len(m.Entities)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromkeyId", wireType)
			}
			m.FromkeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromkeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeChat", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeChat = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendChannelMediaReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendChannelMediaReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendChannelMediaReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Silent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Silent = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Background", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Background = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDraft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearDraft = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = append(m.Peer[:0], dAtA[iNdEx:postIndex]...)
			if m.Peer == nil {
				m.Peer = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyToMsgId", wireType)
			}
			m.ReplyToMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyToMsgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Media = append(m.Media[:0], dAtA[iNdEx:postIndex]...)
			if m.Media == nil {
				m.Media = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiMedia", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiMedia = append(m.MultiMedia, make([]byte, postIndex-iNdEx))
			copy(m.MultiMedia[len(m.MultiMedia)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Newfileid", wireType)
			}
			m.Newfileid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Newfileid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromkeyId", wireType)
			}
			m.FromkeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromkeyId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImchannelserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Chatmeber = append(m.Chatmeber, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImchannelserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImchannelserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImchannelserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Chatmeber = append(m.Chatmeber, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatmeber", wireType)
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendChannelMessageResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendChannelMessageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendChannelMessageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EditChannelMessageReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EditChannelMessageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EditChannelMessageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormId", wireType)
			}
			m.FormId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FormId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWebpage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWebpage = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopGeoLive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StopGeoLive = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = append(m.Peer[:0], dAtA[iNdEx:postIndex]...)
			if m.Peer == nil {
				m.Peer = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyMarkup", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyMarkup = append(m.ReplyMarkup[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyMarkup == nil {
				m.ReplyMarkup = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, make([]byte, postIndex-iNdEx))
			copy(m.Entities[len(m.Entities)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoPoint", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeoPoint = append(m.GeoPoint[:0], dAtA[iNdEx:postIndex]...)
			if m.GeoPoint == nil {
				m.GeoPoint = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViaBotId", wireType)
			}
			m.ViaBotId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViaBotId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyParticipants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyParticipants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyParticipants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates[:0], dAtA[iNdEx:postIndex]...)
			if m.Updates == nil {
				m.Updates = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyJoinChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyJoinChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyJoinChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyLeaveChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyLeaveChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyLeaveChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqMigrateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqMigrateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqMigrateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromid", wireType)
			}
			m.Fromid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chatid", wireType)
			}
			m.Chatid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Chatid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fromkeyid", wireType)
			}
			m.Fromkeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fromkeyid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyMigrateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyMigrateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyMigrateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyGetChannels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyGetChannels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyGetChannels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reply", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reply = append(m.Reply[:0], dAtA[iNdEx:postIndex]...)
			if m.Reply == nil {
				m.Reply = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelInactiveUsersReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelInactiveUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelInactiveUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Userid", wireType)
			}
			m.Userid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Userid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyBanChannelUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyBanChannelUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyBanChannelUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates[:0], dAtA[iNdEx:postIndex]...)
			if m.Updates == nil {
				m.Updates = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetParticipants) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetParticipants: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetParticipants: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffSet", wireType)
			}
			m.OffSet = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OffSet |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartiType", wireType)
			}
			m.PartiType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartiType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqJoinChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqJoinChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqJoinChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByLink", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ByLink = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invitor", wireType)
			}
			m.Invitor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invitor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteType", wireType)
			}
			m.InviteType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviteType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqKickFromChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqKickFromChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqKickFromChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kicker", wireType)
			}
			m.Kicker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kicker |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kickee", wireType)
			}
			m.Kickee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kickee |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBotUser", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBotUser = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsKicked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsKicked = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KickedId", wireType)
			}
			m.KickedId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KickedId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqLeaveChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqLeaveChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqLeaveChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyid", wireType)
			}
			m.FromKeyid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetChannels) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetChannels: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetChannels: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImchannelserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChannelIds = append(m.ChannelIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImchannelserver
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImchannelserver
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImchannelserver
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChannelIds = append(m.ChannelIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelIds", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqEditBanChannelUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqEditBanChannelUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqEditBanChannelUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BannedUserId", wireType)
			}
			m.BannedUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BannedUserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UtilDate", wireType)
			}
			m.UtilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UtilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelBannedRights", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelBannedRights == nil {
				m.ChannelBannedRights = &ChannelBannedRights{}
			}
			if err := m.ChannelBannedRights.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelBannedRights) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelBannedRights: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelBannedRights: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			m.Flags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flags |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ViewMessages = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMessages", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendMessages = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendMedia", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendMedia = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendStickers", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendStickers = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendGifs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendGifs = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendGames", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendGames = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendInline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SendInline = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmbedLinks", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmbedLinks = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntilDate", wireType)
			}
			m.UntilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntilDate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelInactiveUsersResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelInactiveUsersResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelInactiveUsersResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &ChannelInactiveUser{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelInactiveUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelInactiveUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelInactiveUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetFullChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetFullChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetFullChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Debug == nil {
				m.Debug = &pbcomm.Debug{}
			}
			if err := m.Debug.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplyFullChannel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplyFullChannel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplyFullChannel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates[:0], dAtA[iNdEx:postIndex]...)
			if m.Updates == nil {
				m.Updates = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleToggleSlowModeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleToggleSlowModeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleToggleSlowModeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChnlId", wireType)
			}
			m.ChnlId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChnlId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
			}
			m.HashId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleToggleSlowModeRsq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleToggleSlowModeRsq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleToggleSlowModeRsq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Results = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleToggleSignaturesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleToggleSignaturesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleToggleSignaturesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChnlId", wireType)
			}
			m.ChnlId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChnlId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
			}
			m.HashId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Is_Sign", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Is_Sign = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleToggleSignaturesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleToggleSignaturesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleToggleSignaturesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Results = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelToggleHistoryHiddenReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelToggleHistoryHiddenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelToggleHistoryHiddenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChnlId", wireType)
			}
			m.ChnlId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChnlId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
			}
			m.HashId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHide", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHide = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelToggleHistoryHiddenRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelToggleHistoryHiddenRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelToggleHistoryHiddenRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Results = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyByte", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyByte = append(m.ReplyByte[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyByte == nil {
				m.ReplyByte = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelBanModeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelBanModeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelBanModeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChnlId", wireType)
			}
			m.ChnlId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChnlId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashId", wireType)
			}
			m.HashId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HashId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BanMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BanMode = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelBanModeRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelBanModeRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelBanModeRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyBuff", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyBuff = append(m.ReplyBuff[:0], dAtA[iNdEx:postIndex]...)
			if m.ReplyBuff == nil {
				m.ReplyBuff = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestrictChannelReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestrictChannelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestrictChannelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platfrom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platfrom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestrictChannelRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestrictChannelRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestrictChannelRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvGameRDPReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvGameRDPReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvGameRDPReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromKeyId", wireType)
			}
			m.FromKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataJson", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataJson = append(m.DataJson[:0], dAtA[iNdEx:postIndex]...)
			if m.DataJson == nil {
				m.DataJson = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbg == nil {
				m.Dbg = &pbcomm.Debug{}
			}
			if err := m.Dbg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecvGameRDPRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecvGameRDPRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecvGameRDPRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCode", wireType)
			}
			m.ErrCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImchannelserver
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImchannelserver(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImchannelserver
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImchannelserver(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImchannelserver
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImchannelserver
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImchannelserver
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImchannelserver
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImchannelserver(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImchannelserver = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImchannelserver   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/imchannelserver/imchannelserver.proto", fileDescriptorImchannelserver)
}

var fileDescriptorImchannelserver = []byte{
	// 2919 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x3b, 0xcd, 0x6f, 0x1b, 0xc7,
	0xf5, 0xa2, 0x28, 0x4a, 0xe4, 0x23, 0x65, 0xc9, 0xeb, 0x2f, 0x86, 0xb6, 0x65, 0x65, 0xf3, 0xf1,
	0x13, 0x7e, 0x45, 0x9d, 0xd6, 0x41, 0x81, 0xa2, 0xa7, 0x46, 0x72, 0x22, 0x31, 0x96, 0x12, 0x65,
	0x65, 0x3b, 0x28, 0xd0, 0x82, 0x58, 0xee, 0x0e, 0xa9, 0x09, 0x77, 0x77, 0x56, 0x3b, 0x43, 0xda,
	0x42, 0xda, 0xa2, 0x40, 0x0e, 0x3d, 0x14, 0x28, 0xda, 0x9e, 0xfb, 0x07, 0xb5, 0xb7, 0x9e, 0x7a,
	0x0b, 0x50, 0xe4, 0xdc, 0x3f, 0xa0, 0x97, 0x02, 0xc5, 0x9b, 0x99, 0xfd, 0x22, 0x97, 0x14, 0xe3,
	0x64, 0x83, 0x5c, 0xac, 0x7d, 0x6f, 0xdf, 0xbe, 0xef, 0xf7, 0xe6, 0xcd, 0x70, 0x0c, 0x1f, 0x0e,
	0xa9, 0xf0, 0xec, 0xfe, 0x43, 0xe7, 0xdc, 0x16, 0x9c, 0x44, 0x13, 0x12, 0x3d, 0xa4, 0xfe, 0x3b,
	0x34, 0x10, 0x24, 0x1a, 0xd8, 0x0e, 0x09, 0x23, 0xd6, 0x1f, 0x0f, 0xde, 0xa1, 0xbe, 0x73, 0x6e,
	0x07, 0x01, 0xf1, 0x14, 0xc9, 0x34, 0xfc, 0x30, 0x8c, 0x98, 0x60, 0xc6, 0xd6, 0x14, 0xba, 0xf3,
	0xd3, 0xa5, 0x98, 0x87, 0x7d, 0x87, 0xf9, 0xbe, 0xfe, 0xa3, 0x58, 0x99, 0x7f, 0xae, 0xc0, 0xb5,
	0x33, 0x12, 0xb8, 0x87, 0xb6, 0x4f, 0x2c, 0x37, 0xb4, 0xc8, 0x85, 0x71, 0x0f, 0x1a, 0x1f, 0x44,
	0xcc, 0x7f, 0x42, 0x2e, 0xbb, 0x6e, 0xbb, 0xb2, 0x5b, 0xd9, 0xab, 0x5a, 0x29, 0xc2, 0xb8, 0x0d,
	0xeb, 0x08, 0x74, 0xdd, 0xf6, 0xea, 0x6e, 0x65, 0xaf, 0x66, 0x69, 0xc8, 0xd8, 0x86, 0xaa, 0x45,
	0x2e, 0xda, 0x6b, 0xbb, 0x95, 0xbd, 0x96, 0x85, 0x8f, 0x48, 0x89, 0x1c, 0x79, 0xd8, 0xae, 0x49,
	0xa4, 0x86, 0x8c, 0x07, 0x50, 0x7d, 0xdc, 0x1f, 0xb6, 0xd7, 0x77, 0x2b, 0x7b, 0xcd, 0x47, 0x9b,
	0x0f, 0xb5, 0x3a, 0x8f, 0x49, 0x7f, 0x3c, 0xb4, 0xf0, 0x8d, 0xf9, 0xa7, 0x0a, 0x6c, 0x5a, 0xce,
	0xe4, 0xfb, 0xa4, 0xd2, 0x5f, 0x2a, 0xb0, 0x75, 0x70, 0x4e, 0x9c, 0xd1, 0xf7, 0x49, 0xa9, 0x97,
	0xb0, 0xf9, 0x49, 0x74, 0x59, 0x82, 0x46, 0x5a, 0x72, 0x6d, 0xae, 0xe4, 0xcf, 0x61, 0x5b, 0x4b,
	0x3e, 0xa2, 0xfc, 0xbb, 0x16, 0xfe, 0x1c, 0x5a, 0x07, 0xe7, 0xb6, 0x38, 0xe1, 0x43, 0x7e, 0x42,
	0x84, 0x8d, 0xac, 0x05, 0x0b, 0x4f, 0xf8, 0x50, 0x4a, 0xad, 0x59, 0x1a, 0xd2, 0xf8, 0x53, 0xc1,
	0x63, 0x91, 0x0a, 0x52, 0xf8, 0xc7, 0xb6, 0x20, 0xed, 0x6a, 0x8c, 0x47, 0xc8, 0xfc, 0x0d, 0x40,
	0xec, 0x4b, 0x1e, 0xca, 0xa8, 0x10, 0x3e, 0xf6, 0x84, 0xe4, 0x8a, 0x51, 0x91, 0x90, 0x61, 0xc0,
	0xda, 0x01, 0x73, 0x89, 0xe6, 0x29, 0x9f, 0xd1, 0x08, 0x14, 0x8f, 0xec, 0x1a, 0x16, 0x3e, 0x1a,
	0x3f, 0x86, 0x35, 0xd4, 0x4d, 0xda, 0xd5, 0x7c, 0x74, 0xff, 0xe1, 0x74, 0x1d, 0x67, 0x0d, 0xb0,
	0x24, 0xa9, 0xf9, 0xfb, 0x2a, 0xdc, 0x3a, 0xb2, 0x03, 0xd7, 0x23, 0xc7, 0x6c, 0x48, 0x9d, 0x03,
	0x45, 0x8f, 0x1e, 0xb9, 0x0f, 0xe0, 0x13, 0xce, 0xed, 0x21, 0xe9, 0x51, 0xe5, 0xda, 0x35, 0xab,
	0xa1, 0x31, 0x5d, 0xd7, 0xb8, 0x05, 0xeb, 0x23, 0x72, 0x89, 0xaf, 0x56, 0xe5, 0xab, 0xda, 0x48,
	0x7a, 0xfc, 0x0e, 0x6c, 0x8c, 0x39, 0x89, 0x10, 0xaf, 0xed, 0x44, 0x50, 0xd1, 0x3b, 0x91, 0x83,
	0x78, 0xd4, 0x6e, 0xd3, 0xaa, 0x39, 0x91, 0xa3, 0xe8, 0x59, 0xff, 0xb3, 0x5e, 0x9f, 0x06, 0x71,
	0x1e, 0xb2, 0xfe, 0x67, 0xfb, 0x34, 0x30, 0x6e, 0x42, 0xed, 0xf4, 0x9c, 0x05, 0x44, 0x66, 0x62,
	0xc3, 0x52, 0x00, 0x62, 0x3d, 0xfb, 0x92, 0x44, 0xed, 0x0d, 0xc9, 0x5c, 0x01, 0xc6, 0x03, 0x68,
	0xda, 0x61, 0xd8, 0x9b, 0x90, 0x88, 0x53, 0x16, 0xb4, 0xeb, 0xf2, 0x0b, 0xb0, 0xc3, 0xf0, 0xb9,
	0xc2, 0x18, 0x1d, 0xa8, 0x1f, 0x78, 0x94, 0x04, 0xa2, 0x1b, 0xb6, 0x1b, 0xf2, 0x6d, 0x02, 0xa3,
	0xcb, 0x19, 0x17, 0x97, 0x21, 0x69, 0x83, 0x54, 0x4c, 0x43, 0x98, 0x59, 0x9c, 0x70, 0xfc, 0xbc,
	0xeb, 0xb6, 0x9b, 0xca, 0xfc, 0x04, 0x81, 0xce, 0x7f, 0xef, 0xb4, 0xdb, 0x6e, 0x49, 0x35, 0xf0,
	0x11, 0xe9, 0x3f, 0xe6, 0x4f, 0x2f, 0x43, 0x72, 0x26, 0xa2, 0xf6, 0xa6, 0x14, 0x92, 0x22, 0x8c,
	0x5d, 0x68, 0x3e, 0x26, 0x13, 0xea, 0x90, 0x13, 0xe6, 0x12, 0xaf, 0x7d, 0x4d, 0xbe, 0xcf, 0xa2,
	0xcc, 0x1f, 0xc1, 0xed, 0xa2, 0x40, 0xa8, 0xa4, 0x88, 0x72, 0x49, 0xa1, 0x20, 0xf3, 0xcb, 0x2a,
	0xdc, 0xc2, 0x2e, 0xaa, 0x69, 0x4f, 0x54, 0x6c, 0x74, 0x71, 0x0f, 0x22, 0xe6, 0xeb, 0xb8, 0xd5,
	0x2c, 0x0d, 0x61, 0x4c, 0x03, 0xd6, 0x7b, 0x41, 0xfa, 0xa1, 0x3d, 0x54, 0xc9, 0x54, 0xb7, 0x1a,
	0x01, 0xfb, 0x54, 0x21, 0xf0, 0x33, 0x4e, 0x3d, 0x12, 0x08, 0x19, 0xbb, 0xba, 0xa5, 0x21, 0x63,
	0x07, 0xa0, 0x6f, 0x3b, 0xa3, 0x61, 0xc4, 0xc6, 0x81, 0x8a, 0x5f, 0xdd, 0xca, 0x60, 0xd0, 0xff,
	0x8e, 0x47, 0xec, 0xa8, 0xe7, 0x46, 0xf6, 0x40, 0xc8, 0x40, 0xd6, 0x2d, 0x90, 0xa8, 0xc7, 0x88,
	0xc1, 0xf4, 0x0d, 0x09, 0x89, 0x64, 0x2c, 0x5b, 0x96, 0x7c, 0x36, 0xde, 0x82, 0xad, 0x88, 0x84,
	0xde, 0x65, 0x4f, 0xb0, 0x9e, 0xcf, 0x87, 0x98, 0x19, 0x2a, 0xa8, 0x2d, 0x89, 0x7e, 0xca, 0x4e,
	0xf8, 0xb0, 0xeb, 0x1a, 0x6d, 0xd8, 0xd0, 0x49, 0xa7, 0xe3, 0x1a, 0x83, 0xc6, 0x5d, 0x68, 0x44,
	0x76, 0xe0, 0x32, 0x1f, 0x3f, 0x6d, 0xc8, 0xd2, 0xaf, 0x2b, 0x44, 0xd7, 0x35, 0x5e, 0x07, 0xc5,
	0xa6, 0xe7, 0xdb, 0xd1, 0x68, 0x1c, 0xca, 0xd8, 0xb6, 0xac, 0xa6, 0xc4, 0x9d, 0x48, 0x14, 0x26,
	0x05, 0x09, 0x04, 0x15, 0x94, 0xf0, 0x76, 0x73, 0xb7, 0xba, 0xd7, 0xb2, 0x12, 0x18, 0x1d, 0x85,
	0x2e, 0xd3, 0x19, 0xbe, 0xa9, 0xa2, 0xaf, 0x31, 0x5d, 0xd7, 0x78, 0x03, 0x6a, 0x2e, 0xb6, 0x86,
	0xf6, 0x56, 0x51, 0xbf, 0x50, 0xef, 0x50, 0x05, 0x1a, 0x38, 0xde, 0xd8, 0x25, 0x3d, 0x5c, 0x21,
	0xdb, 0xdb, 0xd2, 0x2d, 0x4d, 0x8d, 0xc3, 0x5a, 0x34, 0xee, 0x01, 0x4c, 0xa8, 0xdd, 0xeb, 0x33,
	0x81, 0x62, 0xae, 0x4b, 0xf3, 0xeb, 0x13, 0x6a, 0xef, 0x33, 0xd1, 0x75, 0xcd, 0x7f, 0x57, 0xe1,
	0x46, 0x2e, 0xbe, 0x2e, 0xb5, 0x17, 0x45, 0xf7, 0x26, 0xd4, 0x06, 0x9e, 0x3d, 0x8c, 0x3b, 0x8f,
	0x02, 0xbe, 0x97, 0x41, 0xbd, 0x09, 0x35, 0x1f, 0xad, 0x91, 0x21, 0x6d, 0x59, 0x0a, 0x40, 0x89,
	0xfe, 0xd8, 0x13, 0xb4, 0xa7, 0xde, 0x35, 0x64, 0x4c, 0x40, 0xa2, 0xa4, 0xed, 0xf9, 0x88, 0xc3,
	0x15, 0x11, 0x6f, 0xce, 0x46, 0xfc, 0x1e, 0x34, 0x02, 0xf2, 0x62, 0x40, 0x3d, 0x42, 0x5d, 0x59,
	0xba, 0x55, 0x2b, 0x45, 0x5c, 0x15, 0xf3, 0x7b, 0xd0, 0xc0, 0x30, 0xfa, 0xa4, 0x4f, 0xa2, 0xf6,
	0xb5, 0xdd, 0xea, 0x5e, 0xcd, 0x4a, 0x11, 0xcb, 0x65, 0x44, 0x3e, 0xdc, 0xdb, 0x53, 0xe1, 0xfe,
	0x18, 0x6e, 0x17, 0x55, 0xf3, 0xfc, 0x06, 0x80, 0x1a, 0x93, 0x28, 0x62, 0x51, 0xcf, 0x49, 0xd7,
	0x86, 0x86, 0xc4, 0xe0, 0x02, 0x61, 0x7e, 0x51, 0x85, 0x5b, 0xef, 0xbb, 0x54, 0xcc, 0xf6, 0x87,
	0x3b, 0xb0, 0x31, 0x60, 0x91, 0xdf, 0xcb, 0xa4, 0x10, 0x8b, 0xd0, 0x89, 0xda, 0x07, 0xbd, 0x11,
	0xb9, 0x4c, 0x3a, 0xbb, 0xf4, 0xc1, 0x13, 0x44, 0xa4, 0x19, 0x56, 0xcd, 0x66, 0x58, 0xbe, 0xab,
	0xac, 0x4d, 0x77, 0x15, 0x13, 0x36, 0xcf, 0x04, 0x0b, 0x7b, 0x43, 0xc2, 0x7a, 0x1e, 0x9d, 0x10,
	0x9d, 0x4a, 0x4d, 0x44, 0x1e, 0x12, 0x76, 0x4c, 0x27, 0xa4, 0x30, 0x97, 0xae, 0xc1, 0x6a, 0x92,
	0x3e, 0xab, 0x74, 0x51, 0x27, 0x98, 0x0e, 0x7d, 0x63, 0x71, 0xb1, 0xc3, 0x54, 0xb1, 0xdf, 0x85,
	0xc6, 0x21, 0x61, 0xbd, 0x90, 0xd1, 0x40, 0xe8, 0xb4, 0xa9, 0x1f, 0x12, 0x76, 0x8a, 0x30, 0x7e,
	0xf8, 0x5c, 0x47, 0x48, 0x77, 0xfb, 0x04, 0x4e, 0x83, 0xbe, 0x39, 0x3f, 0xe8, 0xe6, 0x31, 0x5c,
	0xb7, 0x50, 0x91, 0x53, 0x3b, 0x12, 0xd4, 0xa1, 0xa1, 0x1d, 0x08, 0x8e, 0xb6, 0x3c, 0x0b, 0x5d,
	0x5b, 0x10, 0xae, 0x43, 0x1a, 0x83, 0x57, 0xc5, 0xf4, 0x10, 0xb6, 0x25, 0xb7, 0x0f, 0x19, 0x0d,
	0x74, 0x5c, 0x31, 0x2a, 0xd2, 0x54, 0xcd, 0x4a, 0x01, 0x57, 0x31, 0x3a, 0xd2, 0x6a, 0x1d, 0x13,
	0x7b, 0x42, 0xbe, 0x11, 0xa7, 0x2f, 0x2a, 0x70, 0xcd, 0x22, 0x17, 0x27, 0x74, 0x18, 0xd9, 0x42,
	0xf5, 0xb5, 0x79, 0x1d, 0xea, 0x36, 0xac, 0x63, 0xc9, 0xd0, 0x64, 0x1e, 0x53, 0x10, 0xd6, 0x96,
	0x2e, 0x34, 0x3d, 0x37, 0xa4, 0x95, 0x47, 0x33, 0x6e, 0x5e, 0x5b, 0xe0, 0xe6, 0x9f, 0x6b, 0xc7,
	0x4c, 0xa9, 0xa1, 0xeb, 0x66, 0x23, 0x57, 0x37, 0x37, 0xa1, 0x26, 0xd5, 0x97, 0x79, 0x54, 0xb3,
	0x14, 0x90, 0xb8, 0xf6, 0x90, 0xc4, 0x15, 0xc3, 0x5f, 0xcd, 0x21, 0xe7, 0xd0, 0x49, 0x79, 0x74,
	0x03, 0xdb, 0x11, 0x74, 0x42, 0x9e, 0x71, 0x12, 0x71, 0x3d, 0xb1, 0xea, 0xa9, 0xac, 0x1b, 0xbb,
	0x27, 0x45, 0xc8, 0x01, 0x87, 0xfa, 0x54, 0xc4, 0x3d, 0x5c, 0x02, 0x68, 0x08, 0x8e, 0x51, 0xf9,
	0xa1, 0x8a, 0xba, 0xe6, 0x47, 0x70, 0x43, 0xaa, 0xbc, 0x6f, 0xc7, 0xc9, 0x80, 0x62, 0x5e, 0x3d,
	0xbb, 0xbe, 0xac, 0x80, 0x61, 0x91, 0x8b, 0x43, 0x22, 0x72, 0xd9, 0x8a, 0x23, 0xd2, 0x60, 0x70,
	0x46, 0x44, 0x1c, 0x4e, 0x05, 0xcd, 0x51, 0xf6, 0x1e, 0x34, 0x42, 0xfc, 0x1a, 0x47, 0x1f, 0xad,
	0x6f, 0x8a, 0xc8, 0x9b, 0xbf, 0x36, 0x6d, 0xbe, 0x4e, 0x9c, 0xae, 0x2b, 0x9b, 0x84, 0x4e, 0x9c,
	0xae, 0x6b, 0xb4, 0xa0, 0x72, 0xa1, 0x27, 0xc1, 0xca, 0x05, 0x76, 0x8b, 0x23, 0x9b, 0x9f, 0xeb,
	0xde, 0x20, 0x9f, 0xd3, 0x24, 0xa9, 0x2f, 0x48, 0x92, 0xff, 0xaa, 0x54, 0xcd, 0x16, 0xcf, 0xe2,
	0x70, 0x68, 0xc7, 0x77, 0xa7, 0xa7, 0xd9, 0x7c, 0x9f, 0xac, 0xa9, 0xa5, 0x24, 0xed, 0x93, 0x3b,
	0x00, 0xb6, 0xe3, 0x10, 0xce, 0xa5, 0x9a, 0xeb, 0xf2, 0x75, 0x06, 0x83, 0x6c, 0xfb, 0x97, 0xc7,
	0x34, 0x18, 0x49, 0x13, 0xea, 0x96, 0x86, 0x30, 0x70, 0x34, 0x98, 0x50, 0x91, 0xa4, 0x66, 0x0c,
	0xa6, 0xe6, 0x35, 0x16, 0xac, 0x2f, 0x0f, 0xa0, 0x29, 0xe9, 0x49, 0x2f, 0x99, 0x67, 0x6b, 0x16,
	0x28, 0x14, 0x3a, 0xdf, 0xfc, 0xdd, 0xaa, 0x8c, 0xef, 0x13, 0xea, 0x8c, 0x70, 0x27, 0xb4, 0xb4,
	0x0f, 0x46, 0xd4, 0x19, 0x91, 0x28, 0x2e, 0x5a, 0x05, 0x25, 0xf8, 0x64, 0x47, 0xa3, 0x20, 0x63,
	0x07, 0x9a, 0x94, 0xcb, 0x45, 0x0e, 0x9d, 0x15, 0xaf, 0x07, 0x94, 0xef, 0x33, 0x21, 0xb3, 0xf3,
	0x2e, 0x34, 0x28, 0xef, 0x49, 0x62, 0x57, 0xaf, 0x05, 0x75, 0xca, 0x9f, 0x48, 0x18, 0x5f, 0xaa,
	0x27, 0x5c, 0x9b, 0xd6, 0x55, 0xbf, 0x55, 0x88, 0x19, 0xaf, 0x6f, 0x4c, 0x7b, 0x7d, 0xa9, 0x14,
	0xf8, 0x43, 0x05, 0xb6, 0x2c, 0x72, 0x91, 0x6b, 0x7b, 0xcb, 0xe6, 0xc0, 0xea, 0x82, 0x1c, 0xa8,
	0xce, 0xd5, 0x66, 0x51, 0xd7, 0xf2, 0x65, 0x3e, 0x66, 0x3b, 0xce, 0x0e, 0x40, 0x22, 0x1a, 0xcb,
	0x17, 0xe7, 0x8c, 0x0c, 0x26, 0x53, 0x21, 0xab, 0xb9, 0x0a, 0x49, 0xc4, 0x55, 0x17, 0x88, 0xfb,
	0xfb, 0x2a, 0xdc, 0xb2, 0xc8, 0x05, 0x0e, 0x05, 0x53, 0x2d, 0x23, 0x65, 0x5b, 0xc9, 0xb1, 0xd5,
	0x9d, 0x59, 0xed, 0xaf, 0x57, 0x73, 0x36, 0x26, 0x33, 0x91, 0x76, 0x5c, 0x75, 0xda, 0x71, 0x26,
	0xb4, 0xfa, 0xf8, 0xec, 0x3e, 0x53, 0xee, 0x53, 0xd5, 0x9e, 0xc3, 0x4d, 0x55, 0x4a, 0x6d, 0xa6,
	0x52, 0xee, 0x42, 0x63, 0x2c, 0xa8, 0xd7, 0xc3, 0xf6, 0x15, 0xe7, 0x03, 0x22, 0x70, 0xef, 0x6c,
	0x3c, 0x87, 0x1b, 0x5a, 0xda, 0xbe, 0xe4, 0x69, 0xd1, 0xe1, 0xb9, 0xe0, 0x32, 0x31, 0x9a, 0x8f,
	0xde, 0x2c, 0xda, 0xfe, 0x4e, 0xd3, 0x5a, 0x45, 0x0c, 0x96, 0x4b, 0xa4, 0x7f, 0xae, 0xc2, 0x8d,
	0x02, 0x8e, 0xe9, 0x8c, 0x54, 0xc9, 0xce, 0x48, 0x6f, 0xc0, 0xe6, 0x84, 0x92, 0x17, 0x3d, 0x3d,
	0xb2, 0x70, 0xbd, 0xf9, 0x6a, 0x21, 0x52, 0x0f, 0x66, 0x92, 0x88, 0x93, 0xc0, 0x4d, 0x89, 0xd4,
	0xc4, 0xde, 0x42, 0x64, 0x42, 0x74, 0x1f, 0x40, 0x13, 0xe1, 0x90, 0xac, 0xab, 0x4b, 0x51, 0xe0,
	0x8c, 0x1c, 0xf3, 0xe0, 0x42, 0x56, 0x29, 0xd7, 0x15, 0x26, 0x79, 0x9c, 0x69, 0x1c, 0x7a, 0x55,
	0x12, 0x0d, 0xe9, 0x80, 0x4b, 0xaf, 0xd6, 0xad, 0x3a, 0x22, 0x0e, 0xe9, 0x20, 0x15, 0x30, 0xb4,
	0x7d, 0xc2, 0x75, 0x83, 0x92, 0xe4, 0x87, 0x88, 0xc0, 0x26, 0x23, 0x5f, 0xd3, 0xc0, 0xa3, 0x81,
	0x1a, 0xc5, 0xea, 0x96, 0xfc, 0xa2, 0x2b, 0x31, 0x48, 0x40, 0xfc, 0x3e, 0x71, 0x7b, 0x1e, 0x0d,
	0x46, 0x5c, 0x36, 0xac, 0xba, 0x05, 0x12, 0x85, 0x4d, 0x4e, 0x0a, 0x18, 0x07, 0x49, 0x50, 0x55,
	0x97, 0x6a, 0x48, 0x8c, 0x3c, 0x11, 0xb9, 0x80, 0xfb, 0x73, 0x97, 0x4f, 0xb9, 0x7c, 0xff, 0x0c,
	0x6a, 0x58, 0x82, 0xaa, 0x3a, 0x16, 0x04, 0x3a, 0xfb, 0xad, 0xa5, 0x3e, 0xc1, 0xe8, 0x38, 0x6c,
	0x1c, 0x24, 0x4b, 0x96, 0x04, 0xcc, 0x61, 0x12, 0xca, 0xec, 0x37, 0x7a, 0x02, 0xad, 0x24, 0x13,
	0xa8, 0x01, 0x6b, 0x81, 0xed, 0xab, 0x75, 0xb3, 0x61, 0xc9, 0x67, 0xc4, 0x09, 0xea, 0xc7, 0x3d,
	0x50, 0x3e, 0x63, 0x1b, 0xc7, 0xbf, 0x67, 0x42, 0x75, 0xbf, 0x86, 0x15, 0x83, 0xe6, 0x1f, 0x2b,
	0x38, 0x76, 0x61, 0xc1, 0x7f, 0x30, 0xf6, 0xbc, 0xb8, 0xff, 0x2c, 0x28, 0xbe, 0xb4, 0xbc, 0x56,
	0xa7, 0xcb, 0x2b, 0x5f, 0x3a, 0xd5, 0x99, 0xd2, 0x59, 0xaa, 0x01, 0x3d, 0xd1, 0x43, 0x4f, 0x56,
	0x9d, 0x57, 0x1e, 0x1f, 0x7e, 0x0b, 0x77, 0xd4, 0x11, 0xc6, 0x53, 0x36, 0x1c, 0x7a, 0xe4, 0xcc,
	0x63, 0x2f, 0x4e, 0x98, 0x1b, 0xef, 0x38, 0x0e, 0xce, 0x03, 0x2f, 0xb3, 0xe3, 0x40, 0x50, 0x1d,
	0x00, 0xa1, 0xb6, 0xf1, 0x41, 0x52, 0xd5, 0x5a, 0x47, 0x50, 0xbd, 0x78, 0x96, 0x3f, 0x49, 0xd2,
	0x2d, 0xa3, 0x0d, 0x1b, 0x67, 0xc4, 0x61, 0x81, 0xcb, 0x75, 0x47, 0x89, 0x41, 0xf3, 0xdd, 0x39,
	0xf2, 0xf9, 0x05, 0x7e, 0xa4, 0xb2, 0x47, 0xd9, 0x54, 0xb7, 0x62, 0xd0, 0x1c, 0xc0, 0x6b, 0xb9,
	0x8f, 0xe8, 0x30, 0xb0, 0xc5, 0x38, 0x22, 0x5c, 0xab, 0xed, 0xe4, 0xd5, 0x76, 0xae, 0x56, 0xbb,
	0xcb, 0x7b, 0xc8, 0x25, 0xde, 0x6f, 0x77, 0x39, 0x42, 0xe6, 0x4f, 0xe6, 0xca, 0xe1, 0xe1, 0x02,
	0xf5, 0xfe, 0x5a, 0x81, 0xfb, 0x3a, 0x30, 0xea, 0xc3, 0x23, 0xca, 0x05, 0x8b, 0x2e, 0x8f, 0xa8,
	0xeb, 0x92, 0xe0, 0x95, 0x5d, 0x8b, 0xcb, 0x7f, 0xc6, 0xb5, 0xfa, 0x5c, 0x34, 0xe3, 0xf3, 0xb5,
	0x9c, 0xcf, 0x95, 0x55, 0xe7, 0xd4, 0x8d, 0x77, 0x6f, 0xeb, 0x5d, 0x7e, 0x44, 0x5d, 0x62, 0x7e,
	0xba, 0x50, 0xbb, 0x45, 0x96, 0x61, 0x76, 0xab, 0xe1, 0xf5, 0x52, 0xa8, 0x5c, 0x6a, 0x59, 0x29,
	0xc2, 0xfc, 0x35, 0xdc, 0x3c, 0x4b, 0xba, 0xc0, 0xbe, 0x1d, 0x7c, 0xa3, 0x44, 0x2a, 0xb6, 0xf6,
	0x35, 0xa8, 0xef, 0xdb, 0x41, 0xcf, 0xc7, 0x5c, 0x56, 0x7d, 0x74, 0x43, 0x0b, 0x32, 0x9f, 0x16,
	0x49, 0xe7, 0x21, 0x16, 0x80, 0x54, 0x51, 0x15, 0x80, 0x1e, 0x15, 0x24, 0x46, 0x1e, 0xc9, 0x26,
	0xaf, 0xfb, 0xe3, 0xc1, 0x20, 0x6f, 0xd3, 0x78, 0x30, 0x30, 0x3f, 0xc7, 0xe9, 0x8b, 0x8b, 0x88,
	0x3a, 0x22, 0x7f, 0xd0, 0xaa, 0xa1, 0xd4, 0xa8, 0xc6, 0x41, 0x52, 0xe6, 0x1d, 0xa8, 0x9f, 0x7a,
	0xb6, 0xc0, 0x96, 0xa0, 0x1b, 0x4f, 0x02, 0xab, 0xe3, 0x62, 0x9b, 0xb3, 0x40, 0x9f, 0x02, 0x6b,
	0x08, 0x9b, 0xd2, 0x53, 0xf2, 0x52, 0xe8, 0xee, 0x23, 0x9f, 0x4d, 0x6b, 0x56, 0xf8, 0xd7, 0x30,
	0x88, 0x06, 0x03, 0xa6, 0xc5, 0xab, 0xd7, 0xdd, 0x60, 0xc0, 0x1e, 0xfd, 0xe7, 0x87, 0xb0, 0x79,
	0x26, 0x7b, 0x2e, 0xfe, 0x4b, 0x1d, 0x62, 0x0c, 0xc1, 0xd0, 0xe7, 0x97, 0xc4, 0x19, 0x61, 0xf2,
	0x7c, 0x84, 0x4d, 0xf2, 0xed, 0x99, 0x16, 0x5d, 0x78, 0xe6, 0xdc, 0xf9, 0xbf, 0xa5, 0xe8, 0x78,
	0x68, 0xae, 0xa4, 0x82, 0x22, 0xa2, 0xb6, 0x7b, 0xb2, 0x75, 0x95, 0x20, 0x88, 0xc2, 0x4d, 0x89,
	0xed, 0xaa, 0x31, 0x9a, 0x7d, 0x07, 0xa2, 0xa6, 0xe7, 0xf3, 0x12, 0x44, 0x0d, 0xe0, 0xba, 0xc4,
	0xe6, 0xe6, 0xe0, 0x12, 0xe4, 0x38, 0x70, 0x4d, 0x62, 0x71, 0xe4, 0x7c, 0x4a, 0x85, 0x47, 0xca,
	0x16, 0xf2, 0x9e, 0xeb, 0xd3, 0xa0, 0x6c, 0x21, 0xa7, 0xe7, 0x4c, 0xb0, 0xd2, 0x2d, 0xe9, 0xb3,
	0xb1, 0x28, 0x43, 0x88, 0x0f, 0x6d, 0x89, 0x55, 0xab, 0xfa, 0x29, 0xc5, 0xe1, 0x55, 0x8f, 0x97,
	0x65, 0x88, 0x23, 0xb0, 0x2d, 0xb1, 0xd9, 0x5d, 0x77, 0x09, 0x62, 0x3e, 0x83, 0x5b, 0xaa, 0x4e,
	0xfd, 0x90, 0x45, 0xd8, 0xe2, 0x84, 0xaa, 0xd8, 0x32, 0x9b, 0xcf, 0x63, 0xe2, 0x91, 0x52, 0x9b,
	0x4f, 0xec, 0xbb, 0x43, 0xa2, 0x12, 0xfb, 0x98, 0x0d, 0xcb, 0x10, 0xe3, 0xc2, 0x56, 0x92, 0x76,
	0x6a, 0x33, 0x53, 0x86, 0x94, 0x73, 0xb8, 0x11, 0x1b, 0x93, 0x1d, 0x37, 0x4b, 0x90, 0xf4, 0x0b,
	0xb8, 0x36, 0x25, 0xc4, 0x9c, 0xf9, 0x78, 0x66, 0x0c, 0xef, 0xbc, 0x5e, 0x40, 0x93, 0x1f, 0x8d,
	0xf3, 0x46, 0x64, 0xce, 0xc8, 0xca, 0x5c, 0x0d, 0xa6, 0x4f, 0xe3, 0x4a, 0x5c, 0x0d, 0xde, 0x7f,
	0x89, 0xb5, 0x53, 0x7e, 0xdd, 0xa8, 0x59, 0x51, 0xc9, 0xe1, 0x25, 0xd7, 0x4d, 0x72, 0xb2, 0x52,
	0xa2, 0x3d, 0xef, 0x4f, 0x48, 0x74, 0xc9, 0x02, 0xf2, 0xc9, 0x98, 0x92, 0x52, 0x72, 0x61, 0x04,
	0xb7, 0x33, 0x01, 0xd2, 0xcd, 0x5a, 0x1e, 0x19, 0x96, 0xe8, 0xbc, 0xd3, 0x88, 0x4e, 0xe2, 0xa3,
	0xf4, 0x12, 0xdb, 0x81, 0x5a, 0x86, 0x70, 0x56, 0x0c, 0x4a, 0x9a, 0x15, 0x63, 0x49, 0xaa, 0x5d,
	0x27, 0x27, 0x29, 0x25, 0x2e, 0xad, 0x16, 0xb1, 0xe3, 0x25, 0xf5, 0x80, 0x05, 0x82, 0x94, 0x54,
	0xb7, 0x99, 0x16, 0x71, 0x4c, 0x06, 0x65, 0xa7, 0xfa, 0xec, 0xaf, 0x93, 0x05, 0x82, 0x0a, 0x2f,
	0x24, 0x14, 0x08, 0x2a, 0xfe, 0xa9, 0xd3, 0x5c, 0x31, 0x3c, 0xb8, 0x23, 0xc5, 0x2f, 0x25, 0xed,
	0x5b, 0x18, 0xb8, 0xb6, 0xa7, 0x7f, 0x62, 0x37, 0xde, 0x5c, 0xac, 0xac, 0xfa, 0x15, 0xfe, 0xeb,
	0x98, 0x14, 0x8f, 0x26, 0x33, 0x92, 0xca, 0x89, 0xd3, 0xec, 0x6f, 0xbe, 0x05, 0x82, 0x0a, 0x7f,
	0x18, 0x7e, 0x95, 0x38, 0x2d, 0x25, 0xed, 0x5b, 0x58, 0xa1, 0x6e, 0xc4, 0x75, 0x9b, 0xfd, 0x85,
	0xef, 0xdb, 0x96, 0x64, 0xfc, 0x12, 0xb6, 0xa6, 0xd7, 0xdb, 0x37, 0xe6, 0x8c, 0x0e, 0x59, 0xa2,
	0x8e, 0x59, 0x3c, 0x3b, 0x64, 0x69, 0xcc, 0x15, 0xe3, 0x0c, 0x9a, 0xd9, 0x29, 0xf8, 0x41, 0x11,
	0xe7, 0x0c, 0xc1, 0xbc, 0x89, 0x24, 0x43, 0x62, 0xae, 0x18, 0xcf, 0xa1, 0x95, 0xdb, 0xc5, 0xed,
	0x16, 0x71, 0xcd, 0x52, 0xcc, 0x53, 0x36, 0x4b, 0xa3, 0x94, 0xcd, 0xba, 0xba, 0x50, 0xd9, 0x0c,
	0xc1, 0x3c, 0x65, 0x33, 0x24, 0x8a, 0xe9, 0x21, 0x11, 0x31, 0x59, 0x31, 0xd3, 0xcc, 0xa2, 0x3d,
	0x8f, 0x69, 0x86, 0xc4, 0x5c, 0x31, 0x5e, 0xc2, 0x9d, 0x39, 0x27, 0xc6, 0xc6, 0x0f, 0x66, 0xbe,
	0x9f, 0xff, 0xd3, 0x6c, 0xe7, 0xe1, 0xf2, 0xc4, 0xf2, 0x02, 0x16, 0x0e, 0xce, 0x46, 0xc1, 0x8f,
	0x29, 0x6f, 0x17, 0x59, 0x35, 0x4b, 0xd7, 0x79, 0xb3, 0xd8, 0xb8, 0x3c, 0x95, 0xb9, 0x62, 0xf4,
	0x61, 0x33, 0x3d, 0x54, 0xb1, 0x42, 0xbf, 0xcc, 0x2d, 0x40, 0x2c, 0xe3, 0xf9, 0xa3, 0x32, 0xa5,
	0x58, 0xc4, 0x21, 0x74, 0x42, 0x4a, 0xb2, 0x25, 0x1e, 0x67, 0x53, 0x29, 0xe5, 0x58, 0x63, 0x43,
	0x2b, 0xe9, 0xeb, 0x25, 0x99, 0x12, 0x1f, 0x08, 0x68, 0x11, 0xe5, 0xd8, 0xe1, 0xc7, 0x77, 0x40,
	0xf3, 0xe7, 0xe6, 0x9e, 0xb1, 0x37, 0x87, 0xc7, 0xcc, 0xf9, 0x7e, 0x67, 0x49, 0x4a, 0x7e, 0x61,
	0xae, 0x18, 0x51, 0x7c, 0xd3, 0x71, 0xfa, 0x24, 0xdc, 0xf8, 0xff, 0xc5, 0x5c, 0xb2, 0x47, 0xf3,
	0x9d, 0xa5, 0x69, 0xb5, 0x1f, 0xaf, 0xcf, 0x1c, 0xe8, 0x1a, 0x6f, 0x15, 0xac, 0x76, 0xb3, 0x47,
	0xce, 0x9d, 0x65, 0xc8, 0xa4, 0x90, 0x5f, 0xc1, 0xd6, 0xd4, 0x11, 0x6b, 0xe1, 0xe2, 0x31, 0x7d,
	0x02, 0xdc, 0xb9, 0x9a, 0x48, 0xb2, 0x3f, 0x81, 0x66, 0xe6, 0xd2, 0x7c, 0x41, 0xef, 0xcc, 0x5f,
	0xa9, 0xef, 0xdc, 0x9d, 0x6d, 0x67, 0xc9, 0x4d, 0x63, 0x73, 0xc5, 0x78, 0x02, 0x90, 0xde, 0x77,
	0x37, 0x76, 0x66, 0x75, 0xc8, 0x5e, 0x86, 0xbf, 0x8a, 0xd9, 0xc7, 0xd0, 0xca, 0xde, 0x54, 0x2f,
	0x58, 0x84, 0xa6, 0x2e, 0xb2, 0x2f, 0xa1, 0x5d, 0x7a, 0xcd, 0xbc, 0x40, 0xbb, 0xdc, 0x1d, 0xf4,
	0xab, 0x98, 0x7d, 0x92, 0xdc, 0x59, 0x57, 0x37, 0xc7, 0x8d, 0xd7, 0xe7, 0xf1, 0x4b, 0x6e, 0x96,
	0x5f, 0xc1, 0x72, 0xbf, 0xf5, 0xb7, 0xaf, 0x76, 0x2a, 0xff, 0xf8, 0x6a, 0xa7, 0xf2, 0xaf, 0xaf,
	0x76, 0x2a, 0xfd, 0x75, 0xf9, 0xff, 0x1a, 0xde, 0xfd, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfc,
	0x2d, 0x78, 0x7f, 0x70, 0x31, 0x00, 0x00,
}
