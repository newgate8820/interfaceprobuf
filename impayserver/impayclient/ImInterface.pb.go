// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gitlab.chatserver.im/interfaceprobuf/impayserver/impayclient/ImInterface.proto

/*
Package impayclient is a generated protocol buffer package.

It is generated from these files:

	gitlab.chatserver.im/interfaceprobuf/impayserver/impayclient/ImInterface.proto

It has these top-level messages:

	SaveIcoReq
	CreateAccount
	GetAccount
	ImCommonReq
	TransListReq
	CommonResp
	UserIdReq
	TransListResp
*/
package impayclient

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// 我的发布 订单处理方式
type HandleType int32

const (
	HandleType_UP   HandleType = 0
	HandleType_DOWN HandleType = 1
	HandleType_DEL  HandleType = 2
)

var HandleType_name = map[int32]string{
	0: "UP",
	1: "DOWN",
	2: "DEL",
}
var HandleType_value = map[string]int32{
	"UP":   0,
	"DOWN": 1,
	"DEL":  2,
}

func (x HandleType) String() string {
	return proto.EnumName(HandleType_name, int32(x))
}
func (HandleType) EnumDescriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{0} }

// 交易类型
type TransType int32

const (
	TransType_BUY  TransType = 0
	TransType_SELL TransType = 1
)

var TransType_name = map[int32]string{
	0: "BUY",
	1: "SELL",
}
var TransType_value = map[string]int32{
	"BUY":  0,
	"SELL": 1,
}

func (x TransType) String() string {
	return proto.EnumName(TransType_name, int32(x))
}
func (TransType) EnumDescriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{1} }

// 发布类型
type ReleaseType int32

const (
	ReleaseType_AGENT ReleaseType = 0
	ReleaseType_USER  ReleaseType = 1
)

var ReleaseType_name = map[int32]string{
	0: "AGENT",
	1: "USER",
}
var ReleaseType_value = map[string]int32{
	"AGENT": 0,
	"USER":  1,
}

func (x ReleaseType) String() string {
	return proto.EnumName(ReleaseType_name, int32(x))
}
func (ReleaseType) EnumDescriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{2} }

// 支付方式
type PayStyle int32

const (
	PayStyle_UNKNOWN PayStyle = 0
	PayStyle_ALIPAY  PayStyle = 1
	PayStyle_WECHAT  PayStyle = 2
	PayStyle_UNION   PayStyle = 3
)

var PayStyle_name = map[int32]string{
	0: "UNKNOWN",
	1: "ALIPAY",
	2: "WECHAT",
	3: "UNION",
}
var PayStyle_value = map[string]int32{
	"UNKNOWN": 0,
	"ALIPAY":  1,
	"WECHAT":  2,
	"UNION":   3,
}

func (x PayStyle) String() string {
	return proto.EnumName(PayStyle_name, int32(x))
}
func (PayStyle) EnumDescriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{3} }

// 排序方式
type OrderStyle int32

const (
	OrderStyle_ASC  OrderStyle = 0
	OrderStyle_DESC OrderStyle = 1
)

var OrderStyle_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var OrderStyle_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x OrderStyle) String() string {
	return proto.EnumName(OrderStyle_name, int32(x))
}
func (OrderStyle) EnumDescriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{4} }

// 交易订单状态
type TransStatus int32

const (
	TransStatus_COMPLETE TransStatus = 0
	TransStatus_CANCEL   TransStatus = 1
	TransStatus_PAID     TransStatus = 2
	TransStatus_UNPAID   TransStatus = 3
)

var TransStatus_name = map[int32]string{
	0: "COMPLETE",
	1: "CANCEL",
	2: "PAID",
	3: "UNPAID",
}
var TransStatus_value = map[string]int32{
	"COMPLETE": 0,
	"CANCEL":   1,
	"PAID":     2,
	"UNPAID":   3,
}

func (x TransStatus) String() string {
	return proto.EnumName(TransStatus_name, int32(x))
}
func (TransStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{5} }

type SaveIcoReq struct {
	UserId   int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FileId   uint64 `protobuf:"varint,2,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FileHash uint64 `protobuf:"varint,3,opt,name=file_hash,json=fileHash,proto3" json:"file_hash,omitempty"`
	FileSize uint64 `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
	Data     string `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *SaveIcoReq) Reset()                    { *m = SaveIcoReq{} }
func (m *SaveIcoReq) String() string            { return proto.CompactTextString(m) }
func (*SaveIcoReq) ProtoMessage()               {}
func (*SaveIcoReq) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{0} }

func (m *SaveIcoReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SaveIcoReq) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *SaveIcoReq) GetFileHash() uint64 {
	if m != nil {
		return m.FileHash
	}
	return 0
}

func (m *SaveIcoReq) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *SaveIcoReq) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// 创建账户
type CreateAccount struct {
	UserId  int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Phone   string `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty"`
	RegTime int32  `protobuf:"varint,3,opt,name=reg_time,json=regTime,proto3" json:"reg_time,omitempty"`
	Data    string `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *CreateAccount) Reset()                    { *m = CreateAccount{} }
func (m *CreateAccount) String() string            { return proto.CompactTextString(m) }
func (*CreateAccount) ProtoMessage()               {}
func (*CreateAccount) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{1} }

func (m *CreateAccount) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CreateAccount) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *CreateAccount) GetRegTime() int32 {
	if m != nil {
		return m.RegTime
	}
	return 0
}

func (m *CreateAccount) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// 获取账户信息
type GetAccount struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *GetAccount) Reset()                    { *m = GetAccount{} }
func (m *GetAccount) String() string            { return proto.CompactTextString(m) }
func (*GetAccount) ProtoMessage()               {}
func (*GetAccount) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{2} }

func (m *GetAccount) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// 公共请求（im负责传发）
type ImCommonReq struct {
	UserId    int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Info      string `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
	MessageId int32  `protobuf:"varint,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	ChannelId int32  `protobuf:"varint,4,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	Phone     string `protobuf:"bytes,5,opt,name=phone,proto3" json:"phone,omitempty"`
}

func (m *ImCommonReq) Reset()                    { *m = ImCommonReq{} }
func (m *ImCommonReq) String() string            { return proto.CompactTextString(m) }
func (*ImCommonReq) ProtoMessage()               {}
func (*ImCommonReq) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{3} }

func (m *ImCommonReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ImCommonReq) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *ImCommonReq) GetMessageId() int32 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

func (m *ImCommonReq) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ImCommonReq) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

type TransListReq struct {
	UserId int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Info   string `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *TransListReq) Reset()                    { *m = TransListReq{} }
func (m *TransListReq) String() string            { return proto.CompactTextString(m) }
func (*TransListReq) ProtoMessage()               {}
func (*TransListReq) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{4} }

func (m *TransListReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TransListReq) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

// 公共响应
type CommonResp struct {
	Code        int32   `protobuf:"varint,1,opt,name=code,proto3" json:"code"`
	Message     string  `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Data        string  `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	UserId      []int32 `protobuf:"varint,4,rep,packed,name=user_id,json=userId" json:"user_id,omitempty"`
	BusinessKey string  `protobuf:"bytes,5,opt,name=business_key,json=businessKey,proto3" json:"business_key,omitempty"`
}

func (m *CommonResp) Reset()                    { *m = CommonResp{} }
func (m *CommonResp) String() string            { return proto.CompactTextString(m) }
func (*CommonResp) ProtoMessage()               {}
func (*CommonResp) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{5} }

func (m *CommonResp) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CommonResp) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CommonResp) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *CommonResp) GetUserId() []int32 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *CommonResp) GetBusinessKey() string {
	if m != nil {
		return m.BusinessKey
	}
	return ""
}

type UserIdReq struct {
	UserId int32  `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	Phone  string `protobuf:"bytes,2,opt,name=phone,proto3" json:"phone,omitempty"`
}

func (m *UserIdReq) Reset()                    { *m = UserIdReq{} }
func (m *UserIdReq) String() string            { return proto.CompactTextString(m) }
func (*UserIdReq) ProtoMessage()               {}
func (*UserIdReq) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{6} }

func (m *UserIdReq) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserIdReq) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

// 购买、出售 列表返回
type TransListResp struct {
	UserId     []int32     `protobuf:"varint,1,rep,packed,name=user_id,json=userId" json:"user_id,omitempty"`
	CommonResp *CommonResp `protobuf:"bytes,2,opt,name=common_resp,json=commonResp" json:"common_resp,omitempty"`
}

func (m *TransListResp) Reset()                    { *m = TransListResp{} }
func (m *TransListResp) String() string            { return proto.CompactTextString(m) }
func (*TransListResp) ProtoMessage()               {}
func (*TransListResp) Descriptor() ([]byte, []int) { return fileDescriptorImInterface, []int{7} }

func (m *TransListResp) GetUserId() []int32 {
	if m != nil {
		return m.UserId
	}
	return nil
}

func (m *TransListResp) GetCommonResp() *CommonResp {
	if m != nil {
		return m.CommonResp
	}
	return nil
}

func init() {
	proto.RegisterType((*SaveIcoReq)(nil), "impayclient.SaveIcoReq")
	proto.RegisterType((*CreateAccount)(nil), "impayclient.CreateAccount")
	proto.RegisterType((*GetAccount)(nil), "impayclient.GetAccount")
	proto.RegisterType((*ImCommonReq)(nil), "impayclient.ImCommonReq")
	proto.RegisterType((*TransListReq)(nil), "impayclient.TransListReq")
	proto.RegisterType((*CommonResp)(nil), "impayclient.CommonResp")
	proto.RegisterType((*UserIdReq)(nil), "impayclient.UserIdReq")
	proto.RegisterType((*TransListResp)(nil), "impayclient.TransListResp")
	proto.RegisterEnum("impayclient.HandleType", HandleType_name, HandleType_value)
	proto.RegisterEnum("impayclient.TransType", TransType_name, TransType_value)
	proto.RegisterEnum("impayclient.ReleaseType", ReleaseType_name, ReleaseType_value)
	proto.RegisterEnum("impayclient.PayStyle", PayStyle_name, PayStyle_value)
	proto.RegisterEnum("impayclient.OrderStyle", OrderStyle_name, OrderStyle_value)
	proto.RegisterEnum("impayclient.TransStatus", TransStatus_name, TransStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ImInterface service

type ImInterfaceClient interface {
	// 创建账户
	CreateAccount(ctx context.Context, in *CreateAccount, opts ...grpc.CallOption) (*CommonResp, error)
	// 获取账户信息
	GetAccount(ctx context.Context, in *UserIdReq, opts ...grpc.CallOption) (*CommonResp, error)
	// 公共请求
	CommonReq(ctx context.Context, in *ImCommonReq, opts ...grpc.CallOption) (*CommonResp, error)
	// 购买出售列表
	TransList(ctx context.Context, in *TransListReq, opts ...grpc.CallOption) (*TransListResp, error)
	// 保存图片文件
	SaveIco(ctx context.Context, in *SaveIcoReq, opts ...grpc.CallOption) (*CommonResp, error)
}

type imInterfaceClient struct {
	cc *grpc.ClientConn
}

func NewImInterfaceClient(cc *grpc.ClientConn) ImInterfaceClient {
	return &imInterfaceClient{cc}
}

func (c *imInterfaceClient) CreateAccount(ctx context.Context, in *CreateAccount, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := grpc.Invoke(ctx, "/impayclient.ImInterface/createAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imInterfaceClient) GetAccount(ctx context.Context, in *UserIdReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := grpc.Invoke(ctx, "/impayclient.ImInterface/getAccount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imInterfaceClient) CommonReq(ctx context.Context, in *ImCommonReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := grpc.Invoke(ctx, "/impayclient.ImInterface/commonReq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imInterfaceClient) TransList(ctx context.Context, in *TransListReq, opts ...grpc.CallOption) (*TransListResp, error) {
	out := new(TransListResp)
	err := grpc.Invoke(ctx, "/impayclient.ImInterface/transList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imInterfaceClient) SaveIco(ctx context.Context, in *SaveIcoReq, opts ...grpc.CallOption) (*CommonResp, error) {
	out := new(CommonResp)
	err := grpc.Invoke(ctx, "/impayclient.ImInterface/saveIco", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ImInterface service

type ImInterfaceServer interface {
	// 创建账户
	CreateAccount(context.Context, *CreateAccount) (*CommonResp, error)
	// 获取账户信息
	GetAccount(context.Context, *UserIdReq) (*CommonResp, error)
	// 公共请求
	CommonReq(context.Context, *ImCommonReq) (*CommonResp, error)
	// 购买出售列表
	TransList(context.Context, *TransListReq) (*TransListResp, error)
	// 保存图片文件
	SaveIco(context.Context, *SaveIcoReq) (*CommonResp, error)
}

func RegisterImInterfaceServer(s *grpc.Server, srv ImInterfaceServer) {
	s.RegisterService(&_ImInterface_serviceDesc, srv)
}

func _ImInterface_CreateAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAccount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImInterfaceServer).CreateAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/impayclient.ImInterface/CreateAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImInterfaceServer).CreateAccount(ctx, req.(*CreateAccount))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImInterface_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImInterfaceServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/impayclient.ImInterface/GetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImInterfaceServer).GetAccount(ctx, req.(*UserIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImInterface_CommonReq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImCommonReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImInterfaceServer).CommonReq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/impayclient.ImInterface/CommonReq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImInterfaceServer).CommonReq(ctx, req.(*ImCommonReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImInterface_TransList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImInterfaceServer).TransList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/impayclient.ImInterface/TransList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImInterfaceServer).TransList(ctx, req.(*TransListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImInterface_SaveIco_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveIcoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImInterfaceServer).SaveIco(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/impayclient.ImInterface/SaveIco",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImInterfaceServer).SaveIco(ctx, req.(*SaveIcoReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _ImInterface_serviceDesc = grpc.ServiceDesc{
	ServiceName: "impayclient.ImInterface",
	HandlerType: (*ImInterfaceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createAccount",
			Handler:    _ImInterface_CreateAccount_Handler,
		},
		{
			MethodName: "getAccount",
			Handler:    _ImInterface_GetAccount_Handler,
		},
		{
			MethodName: "commonReq",
			Handler:    _ImInterface_CommonReq_Handler,
		},
		{
			MethodName: "transList",
			Handler:    _ImInterface_TransList_Handler,
		},
		{
			MethodName: "saveIco",
			Handler:    _ImInterface_SaveIco_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "gitlab.chatserver.im/interfaceprobuf/impayserver/impayclient/ImInterface.proto",
}

func (m *SaveIcoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaveIcoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.UserId))
	}
	if m.FileId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.FileId))
	}
	if m.FileHash != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.FileHash))
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.FileSize))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *CreateAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.UserId))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	if m.RegTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.RegTime))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *GetAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.UserId))
	}
	return i, nil
}

func (m *ImCommonReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImCommonReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.UserId))
	}
	if len(m.Info) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Info)))
		i += copy(dAtA[i:], m.Info)
	}
	if m.MessageId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.MessageId))
	}
	if m.ChannelId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.ChannelId))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	return i, nil
}

func (m *TransListReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransListReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.UserId))
	}
	if len(m.Info) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Info)))
		i += copy(dAtA[i:], m.Info)
	}
	return i, nil
}

func (m *CommonResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Code != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.Code))
	}
	if len(m.Message) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.UserId) > 0 {
		dAtA2 := make([]byte, len(m.UserId)*10)
		var j1 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if len(m.BusinessKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.BusinessKey)))
		i += copy(dAtA[i:], m.BusinessKey)
	}
	return i, nil
}

func (m *UserIdReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserIdReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.UserId))
	}
	if len(m.Phone) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(len(m.Phone)))
		i += copy(dAtA[i:], m.Phone)
	}
	return i, nil
}

func (m *TransListResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransListResp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UserId) > 0 {
		dAtA4 := make([]byte, len(m.UserId)*10)
		var j3 int
		for _, num1 := range m.UserId {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.CommonResp != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImInterface(dAtA, i, uint64(m.CommonResp.Size()))
		n5, err := m.CommonResp.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func encodeVarintImInterface(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SaveIcoReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImInterface(uint64(m.UserId))
	}
	if m.FileId != 0 {
		n += 1 + sovImInterface(uint64(m.FileId))
	}
	if m.FileHash != 0 {
		n += 1 + sovImInterface(uint64(m.FileHash))
	}
	if m.FileSize != 0 {
		n += 1 + sovImInterface(uint64(m.FileSize))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	return n
}

func (m *CreateAccount) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImInterface(uint64(m.UserId))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	if m.RegTime != 0 {
		n += 1 + sovImInterface(uint64(m.RegTime))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	return n
}

func (m *GetAccount) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImInterface(uint64(m.UserId))
	}
	return n
}

func (m *ImCommonReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImInterface(uint64(m.UserId))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	if m.MessageId != 0 {
		n += 1 + sovImInterface(uint64(m.MessageId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovImInterface(uint64(m.ChannelId))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	return n
}

func (m *TransListReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImInterface(uint64(m.UserId))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	return n
}

func (m *CommonResp) Size() (n int) {
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovImInterface(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovImInterface(uint64(e))
		}
		n += 1 + sovImInterface(uint64(l)) + l
	}
	l = len(m.BusinessKey)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	return n
}

func (m *UserIdReq) Size() (n int) {
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovImInterface(uint64(m.UserId))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovImInterface(uint64(l))
	}
	return n
}

func (m *TransListResp) Size() (n int) {
	var l int
	_ = l
	if len(m.UserId) > 0 {
		l = 0
		for _, e := range m.UserId {
			l += sovImInterface(uint64(e))
		}
		n += 1 + sovImInterface(uint64(l)) + l
	}
	if m.CommonResp != nil {
		l = m.CommonResp.Size()
		n += 1 + l + sovImInterface(uint64(l))
	}
	return n
}

func sovImInterface(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImInterface(x uint64) (n int) {
	return sovImInterface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SaveIcoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaveIcoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaveIcoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileHash", wireType)
			}
			m.FileHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileHash |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegTime", wireType)
			}
			m.RegTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImCommonReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImCommonReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImCommonReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransListReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransListReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransListReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImInterface
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImInterface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BusinessKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BusinessKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserIdReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserIdReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserIdReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransListResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransListResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransListResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserId = append(m.UserId, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowImInterface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthImInterface
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowImInterface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserId = append(m.UserId, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImInterface
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommonResp == nil {
				m.CommonResp = &CommonResp{}
			}
			if err := m.CommonResp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImInterface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImInterface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImInterface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImInterface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImInterface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImInterface
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImInterface
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImInterface(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImInterface = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImInterface   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("gitlab.chatserver.im/interfaceprobuf/impayserver/impayclient/ImInterface.proto", fileDescriptorImInterface)
}

var fileDescriptorImInterface = []byte{
	// 766 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xee, 0xc4, 0xf9, 0xf3, 0x71, 0x2b, 0x59, 0x03, 0xda, 0xcd, 0x16, 0x51, 0x8a, 0x25, 0x44,
	0x95, 0x8b, 0x54, 0x5a, 0xb8, 0xe0, 0x47, 0x2b, 0x70, 0x5d, 0xb3, 0xb5, 0x36, 0xb8, 0x91, 0x9d,
	0x68, 0xb5, 0x57, 0xd5, 0xd8, 0x3e, 0x49, 0x46, 0xc4, 0x3f, 0x78, 0x9c, 0x4a, 0xd9, 0x47, 0x40,
	0x88, 0x87, 0xe0, 0x69, 0xb8, 0xe4, 0x05, 0x90, 0x50, 0x9f, 0x04, 0x79, 0xec, 0x24, 0xce, 0x45,
	0x0b, 0xdc, 0x9d, 0x99, 0xef, 0x3b, 0xe7, 0x7c, 0xe7, 0xb3, 0xcf, 0x80, 0xbb, 0xe0, 0xc5, 0x8a,
	0x05, 0xa3, 0x70, 0xc9, 0x0a, 0x81, 0xf9, 0x3d, 0xe6, 0x23, 0x1e, 0x5f, 0xf2, 0xa4, 0xc0, 0x7c,
	0xce, 0x42, 0xcc, 0xf2, 0x34, 0x58, 0xcf, 0x2f, 0x79, 0x9c, 0xb1, 0x4d, 0x05, 0x57, 0x71, 0xb8,
	0xe2, 0x98, 0x14, 0x97, 0x4e, 0xec, 0x6c, 0x99, 0xa3, 0x2c, 0x4f, 0x8b, 0x94, 0x6a, 0x0d, 0xd8,
	0xf8, 0x95, 0x00, 0xf8, 0xec, 0x1e, 0x9d, 0x30, 0xf5, 0xf0, 0x67, 0xfa, 0x1c, 0x7a, 0x6b, 0x81,
	0xf9, 0x1d, 0x8f, 0x06, 0xe4, 0x9c, 0x5c, 0x74, 0xbc, 0x6e, 0x79, 0x74, 0xa2, 0x12, 0x98, 0xf3,
	0x15, 0x96, 0x40, 0xeb, 0x9c, 0x5c, 0xb4, 0xbd, 0x6e, 0x79, 0x74, 0x22, 0xfa, 0x11, 0xa8, 0x12,
	0x58, 0x32, 0xb1, 0x1c, 0x28, 0x12, 0xea, 0x97, 0x17, 0x37, 0x4c, 0x2c, 0x77, 0xa0, 0xe0, 0xef,
	0x71, 0xd0, 0xde, 0x83, 0x3e, 0x7f, 0x8f, 0x94, 0x42, 0x3b, 0x62, 0x05, 0x1b, 0x74, 0xce, 0xc9,
	0x85, 0xea, 0xc9, 0xd8, 0x88, 0xe1, 0xc4, 0xca, 0x91, 0x15, 0x68, 0x86, 0x61, 0xba, 0x4e, 0x8a,
	0xc7, 0x05, 0x7d, 0x08, 0x9d, 0x6c, 0x99, 0x26, 0x28, 0xe5, 0xa8, 0x5e, 0x75, 0xa0, 0x2f, 0xa0,
	0x9f, 0xe3, 0xe2, 0xae, 0xe0, 0x31, 0x4a, 0x31, 0x1d, 0xaf, 0x97, 0xe3, 0x62, 0xca, 0xe3, 0x7d,
	0xbb, 0x76, 0xa3, 0xdd, 0x67, 0x00, 0xaf, 0xb1, 0xf8, 0xb7, 0x5e, 0xc6, 0x6f, 0x04, 0x34, 0x27,
	0xb6, 0xd2, 0x38, 0x4e, 0x93, 0x27, 0x5d, 0xa2, 0xd0, 0xe6, 0xc9, 0x3c, 0xad, 0x35, 0xc9, 0x98,
	0x7e, 0x0c, 0x10, 0xa3, 0x10, 0x6c, 0x21, 0xcd, 0xab, 0x44, 0xa9, 0xf5, 0x8d, 0x13, 0x95, 0x70,
	0xb8, 0x64, 0x49, 0x82, 0xab, 0x12, 0x6e, 0x57, 0x70, 0x7d, 0xd3, 0x1c, 0xb3, 0xd3, 0x18, 0xd3,
	0xf8, 0x16, 0x8e, 0xa7, 0x39, 0x4b, 0xc4, 0x98, 0x8b, 0xe2, 0xff, 0x0a, 0x32, 0x7e, 0x21, 0x00,
	0xdb, 0x59, 0x44, 0x56, 0x52, 0xc2, 0x34, 0xc2, 0x3a, 0x51, 0xc6, 0x74, 0x00, 0xbd, 0x5a, 0x61,
	0x9d, 0xb9, 0x3d, 0xee, 0x5c, 0x54, 0xf6, 0x2e, 0x36, 0xbb, 0xb7, 0xcf, 0x95, 0x46, 0xf7, 0x4f,
	0xe1, 0x38, 0x58, 0x0b, 0x9e, 0xa0, 0x10, 0x77, 0x3f, 0xe1, 0xa6, 0x9e, 0x41, 0xdb, 0xde, 0xbd,
	0xc1, 0x8d, 0xf1, 0x35, 0xa8, 0x33, 0x49, 0x2e, 0xc7, 0x78, 0x06, 0x75, 0xe6, 0x7f, 0xf9, 0xd6,
	0x46, 0x00, 0x27, 0x0d, 0x13, 0x44, 0x76, 0xe8, 0x42, 0x53, 0xc7, 0x57, 0xa0, 0x85, 0x72, 0xe0,
	0xbb, 0x1c, 0x45, 0x26, 0xab, 0x68, 0x2f, 0x9f, 0x8f, 0x1a, 0x7b, 0x30, 0xda, 0x1b, 0xe2, 0x41,
	0xb8, 0x8b, 0x87, 0x9f, 0x03, 0xdc, 0xb0, 0x24, 0x5a, 0xe1, 0x74, 0x93, 0x21, 0xed, 0x42, 0x6b,
	0x36, 0xd1, 0x8f, 0x68, 0x1f, 0xda, 0xd7, 0xb7, 0x6f, 0x5d, 0x9d, 0xd0, 0x1e, 0x28, 0xd7, 0xf6,
	0x58, 0x6f, 0x0d, 0xcf, 0x40, 0x95, 0x62, 0x24, 0xaf, 0x07, 0xca, 0xd5, 0xec, 0x5d, 0x45, 0xf4,
	0xed, 0xf1, 0x58, 0x27, 0x43, 0x03, 0x34, 0x0f, 0x57, 0xc8, 0x44, 0x55, 0x49, 0x85, 0x8e, 0xf9,
	0xda, 0x76, 0xa7, 0x15, 0x67, 0xe6, 0xdb, 0x9e, 0x4e, 0x86, 0xdf, 0x40, 0x7f, 0xc2, 0x36, 0x7e,
	0xb1, 0x59, 0x21, 0xd5, 0xa0, 0x37, 0x73, 0xdf, 0xb8, 0x65, 0x97, 0x23, 0x0a, 0xd0, 0x35, 0xc7,
	0xce, 0xc4, 0x7c, 0xa7, 0x93, 0x32, 0x7e, 0x6b, 0x5b, 0x37, 0xe6, 0x54, 0x6f, 0x95, 0x55, 0x66,
	0xae, 0x73, 0xeb, 0xea, 0xca, 0xf0, 0x13, 0x80, 0xdb, 0x3c, 0xc2, 0xbc, 0xca, 0xee, 0x81, 0x62,
	0xfa, 0x56, 0xad, 0xd4, 0xf6, 0x2d, 0x9d, 0x0c, 0x5f, 0x81, 0x26, 0x05, 0xfa, 0x05, 0x2b, 0xd6,
	0x82, 0x1e, 0x43, 0xdf, 0xba, 0xfd, 0x71, 0x32, 0xb6, 0xa7, 0x76, 0xd5, 0xc0, 0x32, 0x5d, 0xcb,
	0x1e, 0xeb, 0xa4, 0x4c, 0x99, 0x98, 0xce, 0xb5, 0xde, 0x2a, 0x6f, 0x67, 0xae, 0x8c, 0x95, 0x97,
	0x7f, 0xb5, 0xca, 0x15, 0xd8, 0x3d, 0x25, 0xf4, 0x07, 0x38, 0x09, 0x0f, 0x16, 0xf5, 0xf4, 0xd0,
	0xce, 0x26, 0x76, 0xfa, 0x98, 0xd5, 0xc6, 0x11, 0xfd, 0x0e, 0x60, 0xb1, 0xdf, 0xc0, 0x67, 0x07,
	0xc4, 0xdd, 0x8f, 0xf1, 0x54, 0x81, 0xef, 0x41, 0x0d, 0x77, 0x8b, 0x39, 0x38, 0xe0, 0x35, 0x56,
	0xf6, 0xa9, 0x0a, 0xd7, 0xa0, 0x16, 0xdb, 0xff, 0x88, 0xbe, 0x38, 0xe0, 0x35, 0x97, 0xec, 0xf4,
	0xf4, 0x31, 0x48, 0x56, 0x79, 0x05, 0x3d, 0x51, 0xbd, 0xa3, 0xf4, 0xb0, 0xd7, 0xfe, 0x75, 0x7d,
	0x42, 0xc4, 0xd5, 0x97, 0x7f, 0x3c, 0x9c, 0x91, 0x3f, 0x1f, 0xce, 0xc8, 0xdf, 0x0f, 0x67, 0x04,
	0x3e, 0xe0, 0xf1, 0x88, 0x07, 0xbc, 0x7a, 0xb0, 0x83, 0xf5, 0x5c, 0x8c, 0x78, 0x7c, 0xa5, 0x3a,
	0xb1, 0x8f, 0xf9, 0x3d, 0x0f, 0x71, 0x42, 0x7e, 0x6f, 0x29, 0x3c, 0xe0, 0x41, 0x57, 0x12, 0xbe,
	0xf8, 0x27, 0x00, 0x00, 0xff, 0xff, 0x46, 0x24, 0x23, 0x81, 0x23, 0x06, 0x00, 0x00,
}
